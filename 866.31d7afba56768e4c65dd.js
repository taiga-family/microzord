(self["webpackChunkdemo"] = self["webpackChunkdemo"] || []).push([[866],{

/***/ 6099:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ HostChildWarningModule)
/* harmony export */ });
/* harmony import */ var _taiga_ui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(885);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);


let HostChildWarningModule = /*#__PURE__*/(() => {
  class HostChildWarningModule {}
  HostChildWarningModule.ɵfac = function HostChildWarningModule_Factory(t) {
    return new (t || HostChildWarningModule)();
  };
  HostChildWarningModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
    type: HostChildWarningModule
  });
  HostChildWarningModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
    imports: [[_taiga_ui_core__WEBPACK_IMPORTED_MODULE_1__/* .TuiNotificationModule */ .Hi]]
  });
  return HostChildWarningModule;
})();

/***/ }),

/***/ 8866:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/@angular/platform-browser/fesm2015/platform-browser.js
var platform_browser = __webpack_require__(1211);
// EXTERNAL MODULE: consume shared module (default) @angular/core@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/core/fesm2015/core.js)
var core_js_ = __webpack_require__(8312);
// EXTERNAL MODULE: ./node_modules/@angular/animations/fesm2015/animations.js
var animations = __webpack_require__(6083);
// EXTERNAL MODULE: ./node_modules/@angular/animations/fesm2015/browser.js
var browser = __webpack_require__(9221);
// EXTERNAL MODULE: consume shared module (default) @angular/common@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/common/fesm2015/common.js)
var common_js_ = __webpack_require__(3008);
;// CONCATENATED MODULE: ./node_modules/@angular/platform-browser/fesm2015/animations.js
/**
 * @license Angular v12.2.17
 * (c) 2010-2021 Google LLC. https://angular.io/
 * License: MIT
 */







/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


let BrowserAnimationBuilder = /*#__PURE__*/(() => {
  class BrowserAnimationBuilder extends animations/* AnimationBuilder */._j {
    constructor(rootRenderer, doc) {
      super();
      this._nextAnimationId = 0;
      const typeData = {
        id: '0',
        encapsulation: core_js_.ViewEncapsulation.None,
        styles: [],
        data: {
          animation: []
        }
      };
      this._renderer = rootRenderer.createRenderer(doc.body, typeData);
    }
    build(animation) {
      const id = this._nextAnimationId.toString();
      this._nextAnimationId++;
      const entry = Array.isArray(animation) ? (0,animations/* sequence */.vP)(animation) : animation;
      issueAnimationCommand(this._renderer, null, id, 'register', [entry]);
      return new BrowserAnimationFactory(id, this._renderer);
    }
  }
  BrowserAnimationBuilder.ɵfac = function BrowserAnimationBuilder_Factory(t) {
    return new (t || BrowserAnimationBuilder)(core_js_["ɵɵinject"](core_js_.RendererFactory2), core_js_["ɵɵinject"](common_js_.DOCUMENT));
  };
  BrowserAnimationBuilder.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: BrowserAnimationBuilder,
    factory: BrowserAnimationBuilder.ɵfac
  });
  return BrowserAnimationBuilder;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
class BrowserAnimationFactory extends animations/* AnimationFactory */.LC {
  constructor(_id, _renderer) {
    super();
    this._id = _id;
    this._renderer = _renderer;
  }
  create(element, options) {
    return new RendererAnimationPlayer(this._id, element, options || {}, this._renderer);
  }
}
class RendererAnimationPlayer {
  constructor(id, element, options, _renderer) {
    this.id = id;
    this.element = element;
    this._renderer = _renderer;
    this.parentPlayer = null;
    this._started = false;
    this.totalTime = 0;
    this._command('create', options);
  }
  _listen(eventName, callback) {
    return this._renderer.listen(this.element, `@@${this.id}:${eventName}`, callback);
  }
  _command(command, ...args) {
    return issueAnimationCommand(this._renderer, this.element, this.id, command, args);
  }
  onDone(fn) {
    this._listen('done', fn);
  }
  onStart(fn) {
    this._listen('start', fn);
  }
  onDestroy(fn) {
    this._listen('destroy', fn);
  }
  init() {
    this._command('init');
  }
  hasStarted() {
    return this._started;
  }
  play() {
    this._command('play');
    this._started = true;
  }
  pause() {
    this._command('pause');
  }
  restart() {
    this._command('restart');
  }
  finish() {
    this._command('finish');
  }
  destroy() {
    this._command('destroy');
  }
  reset() {
    this._command('reset');
    this._started = false;
  }
  setPosition(p) {
    this._command('setPosition', p);
  }
  getPosition() {
    var _a, _b;
    return (_b = (_a = this._renderer.engine.players[+this.id]) === null || _a === void 0 ? void 0 : _a.getPosition()) !== null && _b !== void 0 ? _b : 0;
  }
}
function issueAnimationCommand(renderer, element, id, command, args) {
  return renderer.setProperty(element, `@@${id}:${command}`, args);
}
const ANIMATION_PREFIX = '@';
const DISABLE_ANIMATIONS_FLAG = '@.disabled';
let AnimationRendererFactory = /*#__PURE__*/(() => {
  class AnimationRendererFactory {
    constructor(delegate, engine, _zone) {
      this.delegate = delegate;
      this.engine = engine;
      this._zone = _zone;
      this._currentId = 0;
      this._microtaskId = 1;
      this._animationCallbacksBuffer = [];
      this._rendererCache = new Map();
      this._cdRecurDepth = 0;
      this.promise = Promise.resolve(0);
      engine.onRemovalComplete = (element, delegate) => {
        // Note: if an component element has a leave animation, and the component
        // a host leave animation, the view engine will call `removeChild` for the parent
        // component renderer as well as for the child component renderer.
        // Therefore, we need to check if we already removed the element.
        if (delegate && delegate.parentNode(element)) {
          delegate.removeChild(element.parentNode, element);
        }
      };
    }
    createRenderer(hostElement, type) {
      const EMPTY_NAMESPACE_ID = '';
      // cache the delegates to find out which cached delegate can
      // be used by which cached renderer
      const delegate = this.delegate.createRenderer(hostElement, type);
      if (!hostElement || !type || !type.data || !type.data['animation']) {
        let renderer = this._rendererCache.get(delegate);
        if (!renderer) {
          renderer = new BaseAnimationRenderer(EMPTY_NAMESPACE_ID, delegate, this.engine);
          // only cache this result when the base renderer is used
          this._rendererCache.set(delegate, renderer);
        }
        return renderer;
      }
      const componentId = type.id;
      const namespaceId = type.id + '-' + this._currentId;
      this._currentId++;
      this.engine.register(namespaceId, hostElement);
      const registerTrigger = trigger => {
        if (Array.isArray(trigger)) {
          trigger.forEach(registerTrigger);
        } else {
          this.engine.registerTrigger(componentId, namespaceId, hostElement, trigger.name, trigger);
        }
      };
      const animationTriggers = type.data['animation'];
      animationTriggers.forEach(registerTrigger);
      return new AnimationRenderer(this, namespaceId, delegate, this.engine);
    }
    begin() {
      this._cdRecurDepth++;
      if (this.delegate.begin) {
        this.delegate.begin();
      }
    }
    _scheduleCountTask() {
      // always use promise to schedule microtask instead of use Zone
      this.promise.then(() => {
        this._microtaskId++;
      });
    }
    /** @internal */
    scheduleListenerCallback(count, fn, data) {
      if (count >= 0 && count < this._microtaskId) {
        this._zone.run(() => fn(data));
        return;
      }
      if (this._animationCallbacksBuffer.length == 0) {
        Promise.resolve(null).then(() => {
          this._zone.run(() => {
            this._animationCallbacksBuffer.forEach(tuple => {
              const [fn, data] = tuple;
              fn(data);
            });
            this._animationCallbacksBuffer = [];
          });
        });
      }
      this._animationCallbacksBuffer.push([fn, data]);
    }
    end() {
      this._cdRecurDepth--;
      // this is to prevent animations from running twice when an inner
      // component does CD when a parent component instead has inserted it
      if (this._cdRecurDepth == 0) {
        this._zone.runOutsideAngular(() => {
          this._scheduleCountTask();
          this.engine.flush(this._microtaskId);
        });
      }
      if (this.delegate.end) {
        this.delegate.end();
      }
    }
    whenRenderingDone() {
      return this.engine.whenRenderingDone();
    }
  }
  AnimationRendererFactory.ɵfac = function AnimationRendererFactory_Factory(t) {
    return new (t || AnimationRendererFactory)(core_js_["ɵɵinject"](core_js_.RendererFactory2), core_js_["ɵɵinject"](browser/* ɵAnimationEngine */.Th), core_js_["ɵɵinject"](core_js_.NgZone));
  };
  AnimationRendererFactory.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: AnimationRendererFactory,
    factory: AnimationRendererFactory.ɵfac
  });
  return AnimationRendererFactory;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
class BaseAnimationRenderer {
  constructor(namespaceId, delegate, engine) {
    this.namespaceId = namespaceId;
    this.delegate = delegate;
    this.engine = engine;
    this.destroyNode = this.delegate.destroyNode ? n => delegate.destroyNode(n) : null;
  }
  get data() {
    return this.delegate.data;
  }
  destroy() {
    this.engine.destroy(this.namespaceId, this.delegate);
    this.delegate.destroy();
  }
  createElement(name, namespace) {
    return this.delegate.createElement(name, namespace);
  }
  createComment(value) {
    return this.delegate.createComment(value);
  }
  createText(value) {
    return this.delegate.createText(value);
  }
  appendChild(parent, newChild) {
    this.delegate.appendChild(parent, newChild);
    this.engine.onInsert(this.namespaceId, newChild, parent, false);
  }
  insertBefore(parent, newChild, refChild, isMove = true) {
    this.delegate.insertBefore(parent, newChild, refChild);
    // If `isMove` true than we should animate this insert.
    this.engine.onInsert(this.namespaceId, newChild, parent, isMove);
  }
  removeChild(parent, oldChild, isHostElement) {
    this.engine.onRemove(this.namespaceId, oldChild, this.delegate, isHostElement);
  }
  selectRootElement(selectorOrNode, preserveContent) {
    return this.delegate.selectRootElement(selectorOrNode, preserveContent);
  }
  parentNode(node) {
    return this.delegate.parentNode(node);
  }
  nextSibling(node) {
    return this.delegate.nextSibling(node);
  }
  setAttribute(el, name, value, namespace) {
    this.delegate.setAttribute(el, name, value, namespace);
  }
  removeAttribute(el, name, namespace) {
    this.delegate.removeAttribute(el, name, namespace);
  }
  addClass(el, name) {
    this.delegate.addClass(el, name);
  }
  removeClass(el, name) {
    this.delegate.removeClass(el, name);
  }
  setStyle(el, style, value, flags) {
    this.delegate.setStyle(el, style, value, flags);
  }
  removeStyle(el, style, flags) {
    this.delegate.removeStyle(el, style, flags);
  }
  setProperty(el, name, value) {
    if (name.charAt(0) == ANIMATION_PREFIX && name == DISABLE_ANIMATIONS_FLAG) {
      this.disableAnimations(el, !!value);
    } else {
      this.delegate.setProperty(el, name, value);
    }
  }
  setValue(node, value) {
    this.delegate.setValue(node, value);
  }
  listen(target, eventName, callback) {
    return this.delegate.listen(target, eventName, callback);
  }
  disableAnimations(element, value) {
    this.engine.disableAnimations(element, value);
  }
}
class AnimationRenderer extends BaseAnimationRenderer {
  constructor(factory, namespaceId, delegate, engine) {
    super(namespaceId, delegate, engine);
    this.factory = factory;
    this.namespaceId = namespaceId;
  }
  setProperty(el, name, value) {
    if (name.charAt(0) == ANIMATION_PREFIX) {
      if (name.charAt(1) == '.' && name == DISABLE_ANIMATIONS_FLAG) {
        value = value === undefined ? true : !!value;
        this.disableAnimations(el, value);
      } else {
        this.engine.process(this.namespaceId, el, name.substr(1), value);
      }
    } else {
      this.delegate.setProperty(el, name, value);
    }
  }
  listen(target, eventName, callback) {
    if (eventName.charAt(0) == ANIMATION_PREFIX) {
      const element = resolveElementFromTarget(target);
      let name = eventName.substr(1);
      let phase = '';
      // @listener.phase is for trigger animation callbacks
      // @@listener is for animation builder callbacks
      if (name.charAt(0) != ANIMATION_PREFIX) {
        [name, phase] = parseTriggerCallbackName(name);
      }
      return this.engine.listen(this.namespaceId, element, name, phase, event => {
        const countId = event['_data'] || -1;
        this.factory.scheduleListenerCallback(countId, callback, event);
      });
    }
    return this.delegate.listen(target, eventName, callback);
  }
}
function resolveElementFromTarget(target) {
  switch (target) {
    case 'body':
      return document.body;
    case 'document':
      return document;
    case 'window':
      return window;
    default:
      return target;
  }
}
function parseTriggerCallbackName(triggerName) {
  const dotIndex = triggerName.indexOf('.');
  const trigger = triggerName.substring(0, dotIndex);
  const phase = triggerName.substr(dotIndex + 1);
  return [trigger, phase];
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
let InjectableAnimationEngine = /*#__PURE__*/(() => {
  class InjectableAnimationEngine extends browser/* ɵAnimationEngine */.Th {
    constructor(doc, driver, normalizer) {
      super(doc.body, driver, normalizer);
    }
    ngOnDestroy() {
      this.flush();
    }
  }
  InjectableAnimationEngine.ɵfac = function InjectableAnimationEngine_Factory(t) {
    return new (t || InjectableAnimationEngine)(core_js_["ɵɵinject"](common_js_.DOCUMENT), core_js_["ɵɵinject"](browser/* AnimationDriver */.Vi), core_js_["ɵɵinject"](browser/* ɵAnimationStyleNormalizer */.NH));
  };
  InjectableAnimationEngine.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: InjectableAnimationEngine,
    factory: InjectableAnimationEngine.ɵfac
  });
  return InjectableAnimationEngine;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
function instantiateSupportedAnimationDriver() {
  return (0,browser/* ɵsupportsWebAnimations */.QN)() ? new browser/* ɵWebAnimationsDriver */.DT() : new browser/* ɵCssKeyframesDriver */.uL();
}
function instantiateDefaultStyleNormalizer() {
  return new browser/* ɵWebAnimationsStyleNormalizer */.Ar();
}
function instantiateRendererFactory(renderer, engine, zone) {
  return new AnimationRendererFactory(renderer, engine, zone);
}
/**
 * @publicApi
 */
const ANIMATION_MODULE_TYPE = /*#__PURE__*/new core_js_.InjectionToken('AnimationModuleType');
const SHARED_ANIMATION_PROVIDERS = [{
  provide: animations/* AnimationBuilder */._j,
  useClass: BrowserAnimationBuilder
}, {
  provide: browser/* ɵAnimationStyleNormalizer */.NH,
  useFactory: instantiateDefaultStyleNormalizer
}, {
  provide: browser/* ɵAnimationEngine */.Th,
  useClass: InjectableAnimationEngine
}, {
  provide: core_js_.RendererFactory2,
  useFactory: instantiateRendererFactory,
  deps: [platform_browser["ɵDomRendererFactory2"], browser/* ɵAnimationEngine */.Th, core_js_.NgZone]
}];
/**
 * Separate providers from the actual module so that we can do a local modification in Google3 to
 * include them in the BrowserModule.
 */
const BROWSER_ANIMATIONS_PROVIDERS = [{
  provide: browser/* AnimationDriver */.Vi,
  useFactory: instantiateSupportedAnimationDriver
}, {
  provide: ANIMATION_MODULE_TYPE,
  useValue: 'BrowserAnimations'
}, ...SHARED_ANIMATION_PROVIDERS];
/**
 * Separate providers from the actual module so that we can do a local modification in Google3 to
 * include them in the BrowserTestingModule.
 */
const BROWSER_NOOP_ANIMATIONS_PROVIDERS = [{
  provide: browser/* AnimationDriver */.Vi,
  useClass: browser/* ɵNoopAnimationDriver */.nV
}, {
  provide: ANIMATION_MODULE_TYPE,
  useValue: 'NoopAnimations'
}, ...SHARED_ANIMATION_PROVIDERS];

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Exports `BrowserModule` with additional [dependency-injection providers](guide/glossary#provider)
 * for use with animations. See [Animations](guide/animations).
 * @publicApi
 */
let BrowserAnimationsModule = /*#__PURE__*/(() => {
  class BrowserAnimationsModule {
    /**
     * Configures the module based on the specified object.
     *
     * @param config Object used to configure the behavior of the `BrowserAnimationsModule`.
     * @see `BrowserAnimationsModuleConfig`
     *
     * @usageNotes
     * When registering the `BrowserAnimationsModule`, you can use the `withConfig`
     * function as follows:
     * ```
     * @NgModule({
     *   imports: [BrowserAnimationsModule.withConfig(config)]
     * })
     * class MyNgModule {}
     * ```
     */
    static withConfig(config) {
      return {
        ngModule: BrowserAnimationsModule,
        providers: config.disableAnimations ? BROWSER_NOOP_ANIMATIONS_PROVIDERS : BROWSER_ANIMATIONS_PROVIDERS
      };
    }
  }
  BrowserAnimationsModule.ɵfac = function BrowserAnimationsModule_Factory(t) {
    return new (t || BrowserAnimationsModule)();
  };
  BrowserAnimationsModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: BrowserAnimationsModule
  });
  BrowserAnimationsModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    providers: BROWSER_ANIMATIONS_PROVIDERS,
    imports: [platform_browser.BrowserModule]
  });
  return BrowserAnimationsModule;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/*#__PURE__*/(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](BrowserAnimationsModule, {
    exports: function () {
      return [platform_browser.BrowserModule];
    }
  });
})();
/**
 * A null player that must be imported to allow disabling of animations.
 * @publicApi
 */
let NoopAnimationsModule = /*#__PURE__*/(() => {
  class NoopAnimationsModule {}
  NoopAnimationsModule.ɵfac = function NoopAnimationsModule_Factory(t) {
    return new (t || NoopAnimationsModule)();
  };
  NoopAnimationsModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: NoopAnimationsModule
  });
  NoopAnimationsModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    providers: BROWSER_NOOP_ANIMATIONS_PROVIDERS,
    imports: [platform_browser.BrowserModule]
  });
  return NoopAnimationsModule;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/*#__PURE__*/(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](NoopAnimationsModule, {
    exports: function () {
      return [platform_browser.BrowserModule];
    }
  });
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=animations.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/addon-doc/fesm2015/taiga-ui-addon-doc.js + 73 modules
var taiga_ui_addon_doc = __webpack_require__(9052);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-link.js
var taiga_ui_core_components_link = __webpack_require__(2847);
;// CONCATENATED MODULE: ./apps/demo/src/app/app.component.ts



let AppComponent = /*#__PURE__*/(() => {
  class AppComponent {}
  AppComponent.ɵfac = function AppComponent_Factory(t) {
    return new (t || AppComponent)();
  };
  AppComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: AppComponent,
    selectors: [["microzord-root"]],
    decls: 5,
    vars: 0,
    consts: [["ngProjectAs", "tuiDocHeader", 5, ["tuiDocHeader"]], ["tuiLink", "", "tuiMode", "onLight", "href", "https://github.com/TinkoffCreditSystems/microzord", "target", "_blank", 1, "link"], ["src", "assets/images/github.svg", "alt", "", 1, "github"]],
    template: function AppComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵelementStart"](0, "tui-doc-main");
        core_js_["ɵɵelementContainerStart"](1, 0);
        core_js_["ɵɵelementStart"](2, "a", 1);
        core_js_["ɵɵelement"](3, "img", 2);
        core_js_["ɵɵtext"](4, " GitHub ");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementContainerEnd"]();
        core_js_["ɵɵelementEnd"]();
      }
    },
    directives: [taiga_ui_addon_doc/* TuiDocMainComponent */.$5, taiga_ui_core_components_link/* TuiLinkComponent */.V],
    styles: ["[_nghost-%COMP%] {\n  font: var(--tui-font-text-m);\n}\n.link[_ngcontent-%COMP%] {\n  font-weight: bold;\n  height: 24px;\n}\n.github[_ngcontent-%COMP%] {\n  width: 24px;\n  height: 24px;\n  margin: 0 4px 0 16px;\n  vertical-align: -6px;\n}"],
    changeDetection: 0
  });
  return AppComponent;
})();
// EXTERNAL MODULE: consume shared module (default) @angular/router@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/router/fesm2015/router.js)
var router_js_ = __webpack_require__(2541);
// EXTERNAL MODULE: ./node_modules/@tinkoff/ng-polymorpheus/fesm2015/tinkoff-ng-polymorpheus.js
var tinkoff_ng_polymorpheus = __webpack_require__(9570);
;// CONCATENATED MODULE: ./apps/demo/src/app/logo/logo.component.ts


let LogoComponent = /*#__PURE__*/(() => {
  class LogoComponent {}
  LogoComponent.ɵfac = function LogoComponent_Factory(t) {
    return new (t || LogoComponent)();
  };
  LogoComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: LogoComponent,
    selectors: [["logo"]],
    decls: 3,
    vars: 0,
    consts: [["src", "assets/images/microzord.png", "alt", "logo", 1, "logo"], ["src", "assets/images/by.svg", "alt", "by Tinkoff", 1, "by"]],
    template: function LogoComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵelement"](0, "img", 0);
        core_js_["ɵɵtext"](1, "\nmicrozord\n");
        core_js_["ɵɵelement"](2, "img", 1);
      }
    },
    styles: ["[_nghost-%COMP%] {\n  display: flex;\n  align-items: center;\n}\n@media screen and (max-width: 599px) {\n  [_nghost-%COMP%] {\n    font-size: 0;\n  }\n}\n.logo[_ngcontent-%COMP%] {\n  width: 30px;\n  margin-right: 10px;\n}\n.by[_ngcontent-%COMP%] {\n  margin-left: 14px;\n}\n@media screen and (max-width: 599px) {\n  .by[_ngcontent-%COMP%] {\n    display: none;\n  }\n}"],
    changeDetection: 0
  });
  return LogoComponent;
})();
const LOGO_CONTENT = new tinkoff_ng_polymorpheus/* PolymorpheusComponent */.Al(LogoComponent);
;// CONCATENATED MODULE: ./apps/demo/src/app/pages.ts
const pages = [{
  section: `Starting`,
  title: `Getting started`,
  keywords: 'intro, how to, guide, main, главная, начало, инструкция',
  route: 'getting-started'
}, {
  section: `Starting`,
  title: `What is an asset map`,
  keywords: 'intro, how to, guide, main, source, child, host, главная, начало, инструкция, карта',
  route: 'asset-map'
}, {
  section: `Starting`,
  title: `Application entity`,
  keywords: 'intro, how to, guide, main, source, child, host, zord, приложение',
  route: 'application'
}, {
  section: `Native JS`,
  title: `Native JS — Installation`,
  keywords: 'javascript, vanilla, spa',
  route: 'native-installation'
}, {
  section: `Angular`,
  title: `Angular — Installation`,
  keywords: 'angular, spa',
  route: 'angular-installation'
}, {
  section: `Angular`,
  title: `Angular — Host`,
  keywords: 'angular, spa, host',
  route: 'angular-host'
}, {
  section: `Angular`,
  title: `Angular — Child`,
  keywords: 'angular, spa, child',
  route: 'angular-child'
}, {
  section: `React`,
  title: `React — Installation`,
  keywords: 'react, spa',
  route: 'react-installation'
}, {
  section: `React`,
  title: `React — Child`,
  keywords: 'react, spa, child',
  route: 'react-child'
}];
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-notification.js
var taiga_ui_core_components_notification = __webpack_require__(885);
// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.mjs
var tslib_es6 = __webpack_require__(7582);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-decorators.js
var taiga_ui_cdk_decorators = __webpack_require__(4358);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-island.js





const _c0 = ["*"];
let TuiIslandComponent = /*#__PURE__*/(() => {
  let TuiIslandComponent = class TuiIslandComponent {
    constructor() {
      this.size = 'm';
      this.textAlign = "left" /* Left */;
      this.hoverable = false;
      this.transparent = false;
    }
    get sizeS() {
      return this.size === 's';
    }
    get sizeM() {
      return this.size === 'm';
    }
    get sizeL() {
      return this.size === 'l';
    }
    get textAlignLeft() {
      return this.textAlign === 'left';
    }
    get textAlignCenter() {
      return this.textAlign === 'center';
    }
    get textAlignRight() {
      return this.textAlign === 'right';
    }
  };
  TuiIslandComponent.ɵfac = function TuiIslandComponent_Factory(t) {
    return new (t || TuiIslandComponent)();
  };
  TuiIslandComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiIslandComponent,
    selectors: [["tui-island"], ["a", "tuiIsland", ""]],
    hostAttrs: [1, "tui-island"],
    hostVars: 16,
    hostBindings: function TuiIslandComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("tui-island_hoverable", ctx.hoverable)("tui-island_transparent", ctx.transparent)("tui-island_size_s", ctx.sizeS)("tui-island_size_m", ctx.sizeM)("tui-island_size_l", ctx.sizeL)("tui-island_text-align_left", ctx.textAlignLeft)("tui-island_text-align_center", ctx.textAlignCenter)("tui-island_text-align_right", ctx.textAlignRight);
      }
    },
    inputs: {
      size: "size",
      textAlign: "textAlign",
      hoverable: "hoverable",
      transparent: "transparent"
    },
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function TuiIslandComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵprojection"](0);
      }
    },
    styles: ["[_nghost-%COMP%]{display:block}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiIslandComponent.prototype, "size", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiIslandComponent.prototype, "textAlign", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class.tui-island_hoverable'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiIslandComponent.prototype, "hoverable", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class.tui-island_transparent'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiIslandComponent.prototype, "transparent", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class.tui-island_size_s')], TuiIslandComponent.prototype, "sizeS", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class.tui-island_size_m')], TuiIslandComponent.prototype, "sizeM", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class.tui-island_size_l')], TuiIslandComponent.prototype, "sizeL", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class.tui-island_text-align_left')], TuiIslandComponent.prototype, "textAlignLeft", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class.tui-island_text-align_center')], TuiIslandComponent.prototype, "textAlignCenter", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class.tui-island_text-align_right')], TuiIslandComponent.prototype, "textAlignRight", null);
  return TuiIslandComponent;
})();
let TuiIslandModule = /*#__PURE__*/(() => {
  let TuiIslandModule = class TuiIslandModule {};
  TuiIslandModule.ɵfac = function TuiIslandModule_Factory(t) {
    return new (t || TuiIslandModule)();
  };
  TuiIslandModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiIslandModule
  });
  TuiIslandModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule]]
  });
  return TuiIslandModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiIslandModule, {
    declarations: function () {
      return [TuiIslandComponent];
    },
    imports: function () {
      return [common_js_.CommonModule];
    },
    exports: function () {
      return [TuiIslandComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-island.js.map
// EXTERNAL MODULE: ./apps/demo/src/app/shared/host-child-warning/host-child-warning.module.ts
var host_child_warning_module = __webpack_require__(6099);
;// CONCATENATED MODULE: ./apps/demo/src/app/getting-started/getting-started.module.ts







let GettingStartedModule = /*#__PURE__*/(() => {
  class GettingStartedModule {}
  GettingStartedModule.ɵfac = function GettingStartedModule_Factory(t) {
    return new (t || GettingStartedModule)();
  };
  GettingStartedModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: GettingStartedModule
  });
  GettingStartedModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, taiga_ui_addon_doc/* TuiDocPageModule */.Lq, taiga_ui_core_components_link/* TuiLinkModule */.j, taiga_ui_addon_doc/* TuiDocCodeModule */.JF, router_js_.RouterModule, taiga_ui_core_components_notification/* TuiNotificationModule */.Hi, TuiIslandModule, host_child_warning_module/* HostChildWarningModule */.$]]
  });
  return GettingStartedModule;
})();
;// CONCATENATED MODULE: ./apps/demo/src/app/getting-started/getting-started.component.ts





let GettingStartedComponent = /*#__PURE__*/(() => {
  class GettingStartedComponent {}
  GettingStartedComponent.ɵfac = function GettingStartedComponent_Factory(t) {
    return new (t || GettingStartedComponent)();
  };
  GettingStartedComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: GettingStartedComponent,
    selectors: [["getting-started"]],
    decls: 60,
    vars: 0,
    consts: [["header", "Getting started"], [1, "about"], [1, "about__benefit"], [1, "tui-island__title"], [1, "tui-island__paragraph"], [1, "tui-space_top-4"], ["tuiLink", "", "routerLink", "/asset-map"], ["tuiLink", "", "routerLink", "/application"], ["tuiLink", "", "routerLink", "/todo"], ["tuiLink", "", "routerLink", "/angular-installation"]],
    template: function GettingStartedComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵelementStart"](0, "tui-doc-page", 0);
        core_js_["ɵɵelementStart"](1, "p");
        core_js_["ɵɵelementStart"](2, "strong");
        core_js_["ɵɵtext"](3, "microzord");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtext"](4, " is a small tool that allows you to add and render multiple apps on one page. It has simple ideomatic APIs for some modern frameworks (Vue and Svelte come soon) and builds bridges between them. ");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](5, "section", 1);
        core_js_["ɵɵelementStart"](6, "tui-island", 2);
        core_js_["ɵɵelementStart"](7, "h3", 3);
        core_js_["ɵɵtext"](8, "\uD83E\uDDD9 Framework agnostic");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](9, "p", 4);
        core_js_["ɵɵtext"](10, " You can have an Angular application with a React app header and a Vue app footer. Each app can have endless amount of nested apps inside. There are also wrappers for every modern framework with simple API. ");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](11, "tui-island", 2);
        core_js_["ɵɵelementStart"](12, "h3", 3);
        core_js_["ɵɵtext"](13, "\uD83E\uDDE9 Modular");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](14, "p", 4);
        core_js_["ɵɵtext"](15, " You can insert another app in your app in any place as an ordinary component. Use the same methods to bind data and to handle its events. ");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](16, "section");
        core_js_["ɵɵelementStart"](17, "h2");
        core_js_["ɵɵtext"](18, "What it is about");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](19, "p");
        core_js_["ɵɵtext"](20, "There are two terms that we want to declare first:");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](21, "ul");
        core_js_["ɵɵelementStart"](22, "li");
        core_js_["ɵɵelementStart"](23, "strong");
        core_js_["ɵɵtext"](24, "Child app");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtext"](25, " is any application that is built with microzord and can be inserted into the host app. ");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](26, "li");
        core_js_["ɵɵelementStart"](27, "strong");
        core_js_["ɵɵtext"](28, "Host app");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtext"](29, " is any application that uses microzord to render child apps inside. ");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](30, "tui-notification", 5);
        core_js_["ɵɵtext"](31, " Some application can host any amount of child apps and be a child for other app at the same time ");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](32, "p");
        core_js_["ɵɵtext"](33, " Microzord does not impose any restrictions but just gives more opportunities for your app. All your apps can be still used as separated apps and can be integrated with others with no additional code in application bundle. ");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](34, "p");
        core_js_["ɵɵtext"](35, " It renders your apps right in DOM without any additional elements or iframes and provides some ideomatic ways to control apps and get data from them. ");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](36, "section");
        core_js_["ɵɵelementStart"](37, "h2");
        core_js_["ɵɵtext"](38, "How to start");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](39, "p");
        core_js_["ɵɵtext"](40, "You can read about main concepts of microzord:");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](41, "ul");
        core_js_["ɵɵelementStart"](42, "li");
        core_js_["ɵɵelementStart"](43, "a", 6);
        core_js_["ɵɵtext"](44, "What is an asset map");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](45, "li");
        core_js_["ɵɵelementStart"](46, "a", 7);
        core_js_["ɵɵtext"](47, "Application entity");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](48, "p");
        core_js_["ɵɵtext"](49, "Or you can just choose your framework and figure it out in the process:");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](50, "ul");
        core_js_["ɵɵelementStart"](51, "li");
        core_js_["ɵɵelementStart"](52, "a", 8);
        core_js_["ɵɵtext"](53, "Native JS installation");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](54, "li");
        core_js_["ɵɵelementStart"](55, "a", 8);
        core_js_["ɵɵtext"](56, "React installation");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](57, "li");
        core_js_["ɵɵelementStart"](58, "a", 9);
        core_js_["ɵɵtext"](59, "Angular installation");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
      }
    },
    directives: [taiga_ui_addon_doc/* TuiDocPageComponent */.qo, TuiIslandComponent, taiga_ui_core_components_notification/* TuiNotificationComponent */.Ls, taiga_ui_core_components_link/* TuiLinkComponent */.V, router_js_.RouterLinkWithHref],
    styles: [".about[_ngcontent-%COMP%] {\n  display: flex;\n  margin-top: 20px;\n  margin-bottom: 20px;\n}\n.about__benefit[_ngcontent-%COMP%] {\n  flex: 1;\n  margin-right: 32px;\n}"],
    changeDetection: 0
  });
  return GettingStartedComponent;
})();
;// CONCATENATED MODULE: ./apps/demo/src/app/routes.ts

const ROUTES = [{
  path: 'getting-started',
  component: GettingStartedComponent,
  data: {
    title: `Getting started`
  }
}, {
  path: 'asset-map',
  loadChildren: () => Promise.all(/* import() */[__webpack_require__.e(592), __webpack_require__.e(199)]).then(__webpack_require__.bind(__webpack_require__, 5199)).then(m => m.AssetMapModule),
  data: {
    title: `What is an asset map`
  }
}, {
  path: 'application',
  loadChildren: () => __webpack_require__.e(/* import() */ 442).then(__webpack_require__.bind(__webpack_require__, 1442)).then(m => m.ApplicationModule),
  data: {
    title: `Application entity`
  }
}, {
  path: 'native-installation',
  loadChildren: () => __webpack_require__.e(/* import() */ 597).then(__webpack_require__.bind(__webpack_require__, 9597)).then(m => m.NativeInstallationModule),
  data: {
    title: `Native Installation`
  }
}, {
  path: 'react-installation',
  loadChildren: () => __webpack_require__.e(/* import() */ 768).then(__webpack_require__.bind(__webpack_require__, 5768)).then(m => m.ReactInstallationModule),
  data: {
    title: `React Installation`
  }
}, {
  path: 'react-child',
  loadChildren: () => __webpack_require__.e(/* import() */ 543).then(__webpack_require__.bind(__webpack_require__, 6543)).then(m => m.ReactChildModule),
  data: {
    title: `React Child`
  }
}, {
  path: 'angular-installation',
  loadChildren: () => Promise.all(/* import() */[__webpack_require__.e(592), __webpack_require__.e(738)]).then(__webpack_require__.bind(__webpack_require__, 9738)).then(m => m.AngularInstallationModule),
  data: {
    title: `Angular Installation`
  }
}, {
  path: 'angular-host',
  loadChildren: () => __webpack_require__.e(/* import() */ 871).then(__webpack_require__.bind(__webpack_require__, 4871)).then(m => m.AngularHostModule),
  data: {
    title: `Angular Host`
  }
}, {
  path: 'angular-child',
  loadChildren: () => __webpack_require__.e(/* import() */ 400).then(__webpack_require__.bind(__webpack_require__, 4400)).then(m => m.AngularChildModule),
  data: {
    title: `Angular Child`
  }
}, {
  path: '**',
  redirectTo: 'getting-started'
}];
// EXTERNAL MODULE: ./node_modules/ngx-highlightjs/fesm2015/ngx-highlightjs.js + 1 modules
var ngx_highlightjs = __webpack_require__(7841);
;// CONCATENATED MODULE: ./apps/demo/src/app/app.module.ts













const HIGHLIGHT_OPTIONS_VALUE = {
  coreLibraryLoader: () => __webpack_require__.e(/* import() */ 856).then(__webpack_require__.t.bind(__webpack_require__, 7856, 23)),
  lineNumbersLoader: () => __webpack_require__.e(/* import() */ 22).then(__webpack_require__.t.bind(__webpack_require__, 9022, 23)),
  languages: {
    typescript: () => __webpack_require__.e(/* import() */ 433).then(__webpack_require__.t.bind(__webpack_require__, 2433, 23)),
    less: () => __webpack_require__.e(/* import() */ 257).then(__webpack_require__.t.bind(__webpack_require__, 6257, 23)),
    xml: () => __webpack_require__.e(/* import() */ 546).then(__webpack_require__.t.bind(__webpack_require__, 3546, 23))
  }
};
let AppModule = /*#__PURE__*/(() => {
  class AppModule {
    getEntryPoint() {
      return AppComponent;
    }
  }
  AppModule.ɵfac = function AppModule_Factory(t) {
    return new (t || AppModule)();
  };
  AppModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: AppModule,
    bootstrap: [AppComponent]
  });
  AppModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    providers: [{
      provide: taiga_ui_addon_doc/* TUI_DOC_LOGO */.Or,
      useValue: LOGO_CONTENT
    }, {
      provide: taiga_ui_addon_doc/* TUI_DOC_PAGES */.V5,
      useValue: pages
    }, {
      provide: ngx_highlightjs/* HIGHLIGHT_OPTIONS */.rN,
      useValue: HIGHLIGHT_OPTIONS_VALUE
    }],
    imports: [[platform_browser.BrowserModule, BrowserAnimationsModule, taiga_ui_addon_doc/* TuiDocMainModule */.qn, taiga_ui_core_components_link/* TuiLinkModule */.j, GettingStartedModule, router_js_.RouterModule.forRoot(ROUTES, {
      initialNavigation: 'enabled'
    })]]
  });
  return AppModule;
})();
;// CONCATENATED MODULE: ./apps/demo/src/environments/environment.ts
const environment = {
  production: true
};
;// CONCATENATED MODULE: ./apps/demo/src/bootstrap.ts




if (environment.production) {
  (0,core_js_.enableProdMode)();
}
platform_browser.platformBrowser().bootstrapModule(AppModule).catch(err => console.error(err));

/***/ }),

/***/ 6083:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EY: () => (/* binding */ stagger),
/* harmony export */   IO: () => (/* binding */ query),
/* harmony export */   LC: () => (/* binding */ AnimationFactory),
/* harmony export */   X$: () => (/* binding */ trigger),
/* harmony export */   ZE: () => (/* binding */ AnimationGroupPlayer),
/* harmony export */   ZN: () => (/* binding */ NoopAnimationPlayer),
/* harmony export */   _j: () => (/* binding */ AnimationBuilder),
/* harmony export */   eR: () => (/* binding */ transition),
/* harmony export */   jt: () => (/* binding */ animate),
/* harmony export */   k1: () => (/* binding */ ɵPRE_STYLE),
/* harmony export */   l3: () => (/* binding */ AUTO_STYLE),
/* harmony export */   oB: () => (/* binding */ style),
/* harmony export */   pV: () => (/* binding */ animateChild),
/* harmony export */   vP: () => (/* binding */ sequence)
/* harmony export */ });
/* unused harmony exports animation, group, keyframes, state, useAnimation */
/**
 * @license Angular v12.2.17
 * (c) 2010-2021 Google LLC. https://angular.io/
 * License: MIT
 */

/**
 * An injectable service that produces an animation sequence programmatically within an
 * Angular component or directive.
 * Provided by the `BrowserAnimationsModule` or `NoopAnimationsModule`.
 *
 * @usageNotes
 *
 * To use this service, add it to your component or directive as a dependency.
 * The service is instantiated along with your component.
 *
 * Apps do not typically need to create their own animation players, but if you
 * do need to, follow these steps:
 *
 * 1. Use the `build()` method to create a programmatic animation using the
 * `animate()` function. The method returns an `AnimationFactory` instance.
 *
 * 2. Use the factory object to create an `AnimationPlayer` and attach it to a DOM element.
 *
 * 3. Use the player object to control the animation programmatically.
 *
 * For example:
 *
 * ```ts
 * // import the service from BrowserAnimationsModule
 * import {AnimationBuilder} from '@angular/animations';
 * // require the service as a dependency
 * class MyCmp {
 *   constructor(private _builder: AnimationBuilder) {}
 *
 *   makeAnimation(element: any) {
 *     // first define a reusable animation
 *     const myAnimation = this._builder.build([
 *       style({ width: 0 }),
 *       animate(1000, style({ width: '100px' }))
 *     ]);
 *
 *     // use the returned factory object to create a player
 *     const player = myAnimation.create(element);
 *
 *     player.play();
 *   }
 * }
 * ```
 *
 * @publicApi
 */
class AnimationBuilder {}
/**
 * A factory object returned from the `AnimationBuilder`.`build()` method.
 *
 * @publicApi
 */
class AnimationFactory {}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Specifies automatic styling.
 *
 * @publicApi
 */
const AUTO_STYLE = '*';
/**
 * Creates a named animation trigger, containing a  list of `state()`
 * and `transition()` entries to be evaluated when the expression
 * bound to the trigger changes.
 *
 * @param name An identifying string.
 * @param definitions  An animation definition object, containing an array of `state()`
 * and `transition()` declarations.
 *
 * @return An object that encapsulates the trigger data.
 *
 * @usageNotes
 * Define an animation trigger in the `animations` section of `@Component` metadata.
 * In the template, reference the trigger by name and bind it to a trigger expression that
 * evaluates to a defined animation state, using the following format:
 *
 * `[@triggerName]="expression"`
 *
 * Animation trigger bindings convert all values to strings, and then match the
 * previous and current values against any linked transitions.
 * Booleans can be specified as `1` or `true` and `0` or `false`.
 *
 * ### Usage Example
 *
 * The following example creates an animation trigger reference based on the provided
 * name value.
 * The provided animation value is expected to be an array consisting of state and
 * transition declarations.
 *
 * ```typescript
 * @Component({
 *   selector: "my-component",
 *   templateUrl: "my-component-tpl.html",
 *   animations: [
 *     trigger("myAnimationTrigger", [
 *       state(...),
 *       state(...),
 *       transition(...),
 *       transition(...)
 *     ])
 *   ]
 * })
 * class MyComponent {
 *   myStatusExp = "something";
 * }
 * ```
 *
 * The template associated with this component makes use of the defined trigger
 * by binding to an element within its template code.
 *
 * ```html
 * <!-- somewhere inside of my-component-tpl.html -->
 * <div [@myAnimationTrigger]="myStatusExp">...</div>
 * ```
 *
 * ### Using an inline function
 * The `transition` animation method also supports reading an inline function which can decide
 * if its associated animation should be run.
 *
 * ```typescript
 * // this method is run each time the `myAnimationTrigger` trigger value changes.
 * function myInlineMatcherFn(fromState: string, toState: string, element: any, params: {[key:
 string]: any}): boolean {
 *   // notice that `element` and `params` are also available here
 *   return toState == 'yes-please-animate';
 * }
 *
 * @Component({
 *   selector: 'my-component',
 *   templateUrl: 'my-component-tpl.html',
 *   animations: [
 *     trigger('myAnimationTrigger', [
 *       transition(myInlineMatcherFn, [
 *         // the animation sequence code
 *       ]),
 *     ])
 *   ]
 * })
 * class MyComponent {
 *   myStatusExp = "yes-please-animate";
 * }
 * ```
 *
 * ### Disabling Animations
 * When true, the special animation control binding `@.disabled` binding prevents
 * all animations from rendering.
 * Place the  `@.disabled` binding on an element to disable
 * animations on the element itself, as well as any inner animation triggers
 * within the element.
 *
 * The following example shows how to use this feature:
 *
 * ```typescript
 * @Component({
 *   selector: 'my-component',
 *   template: `
 *     <div [@.disabled]="isDisabled">
 *       <div [@childAnimation]="exp"></div>
 *     </div>
 *   `,
 *   animations: [
 *     trigger("childAnimation", [
 *       // ...
 *     ])
 *   ]
 * })
 * class MyComponent {
 *   isDisabled = true;
 *   exp = '...';
 * }
 * ```
 *
 * When `@.disabled` is true, it prevents the `@childAnimation` trigger from animating,
 * along with any inner animations.
 *
 * ### Disable animations application-wide
 * When an area of the template is set to have animations disabled,
 * **all** inner components have their animations disabled as well.
 * This means that you can disable all animations for an app
 * by placing a host binding set on `@.disabled` on the topmost Angular component.
 *
 * ```typescript
 * import {Component, HostBinding} from '@angular/core';
 *
 * @Component({
 *   selector: 'app-component',
 *   templateUrl: 'app.component.html',
 * })
 * class AppComponent {
 *   @HostBinding('@.disabled')
 *   public animationsDisabled = true;
 * }
 * ```
 *
 * ### Overriding disablement of inner animations
 * Despite inner animations being disabled, a parent animation can `query()`
 * for inner elements located in disabled areas of the template and still animate
 * them if needed. This is also the case for when a sub animation is
 * queried by a parent and then later animated using `animateChild()`.
 *
 * ### Detecting when an animation is disabled
 * If a region of the DOM (or the entire application) has its animations disabled, the animation
 * trigger callbacks still fire, but for zero seconds. When the callback fires, it provides
 * an instance of an `AnimationEvent`. If animations are disabled,
 * the `.disabled` flag on the event is true.
 *
 * @publicApi
 */
function trigger(name, definitions) {
  return {
    type: 7 /* Trigger */,
    name,
    definitions,
    options: {}
  };
}
/**
 * Defines an animation step that combines styling information with timing information.
 *
 * @param timings Sets `AnimateTimings` for the parent animation.
 * A string in the format "duration [delay] [easing]".
 *  - Duration and delay are expressed as a number and optional time unit,
 * such as "1s" or "10ms" for one second and 10 milliseconds, respectively.
 * The default unit is milliseconds.
 *  - The easing value controls how the animation accelerates and decelerates
 * during its runtime. Value is one of  `ease`, `ease-in`, `ease-out`,
 * `ease-in-out`, or a `cubic-bezier()` function call.
 * If not supplied, no easing is applied.
 *
 * For example, the string "1s 100ms ease-out" specifies a duration of
 * 1000 milliseconds, and delay of 100 ms, and the "ease-out" easing style,
 * which decelerates near the end of the duration.
 * @param styles Sets AnimationStyles for the parent animation.
 * A function call to either `style()` or `keyframes()`
 * that returns a collection of CSS style entries to be applied to the parent animation.
 * When null, uses the styles from the destination state.
 * This is useful when describing an animation step that will complete an animation;
 * see "Animating to the final state" in `transitions()`.
 * @returns An object that encapsulates the animation step.
 *
 * @usageNotes
 * Call within an animation `sequence()`, `{@link animations/group group()}`, or
 * `transition()` call to specify an animation step
 * that applies given style data to the parent animation for a given amount of time.
 *
 * ### Syntax Examples
 * **Timing examples**
 *
 * The following examples show various `timings` specifications.
 * - `animate(500)` : Duration is 500 milliseconds.
 * - `animate("1s")` : Duration is 1000 milliseconds.
 * - `animate("100ms 0.5s")` : Duration is 100 milliseconds, delay is 500 milliseconds.
 * - `animate("5s ease-in")` : Duration is 5000 milliseconds, easing in.
 * - `animate("5s 10ms cubic-bezier(.17,.67,.88,.1)")` : Duration is 5000 milliseconds, delay is 10
 * milliseconds, easing according to a bezier curve.
 *
 * **Style examples**
 *
 * The following example calls `style()` to set a single CSS style.
 * ```typescript
 * animate(500, style({ background: "red" }))
 * ```
 * The following example calls `keyframes()` to set a CSS style
 * to different values for successive keyframes.
 * ```typescript
 * animate(500, keyframes(
 *  [
 *   style({ background: "blue" }),
 *   style({ background: "red" })
 *  ])
 * ```
 *
 * @publicApi
 */
function animate(timings, styles = null) {
  return {
    type: 4 /* Animate */,
    styles,
    timings
  };
}
/**
 * @description Defines a list of animation steps to be run in parallel.
 *
 * @param steps An array of animation step objects.
 * - When steps are defined by `style()` or `animate()`
 * function calls, each call within the group is executed instantly.
 * - To specify offset styles to be applied at a later time, define steps with
 * `keyframes()`, or use `animate()` calls with a delay value.
 * For example:
 *
 * ```typescript
 * group([
 *   animate("1s", style({ background: "black" })),
 *   animate("2s", style({ color: "white" }))
 * ])
 * ```
 *
 * @param options An options object containing a delay and
 * developer-defined parameters that provide styling defaults and
 * can be overridden on invocation.
 *
 * @return An object that encapsulates the group data.
 *
 * @usageNotes
 * Grouped animations are useful when a series of styles must be
 * animated at different starting times and closed off at different ending times.
 *
 * When called within a `sequence()` or a
 * `transition()` call, does not continue to the next
 * instruction until all of the inner animation steps have completed.
 *
 * @publicApi
 */
function group(steps, options = null) {
  return {
    type: 3 /* Group */,
    steps,
    options
  };
}
/**
 * Defines a list of animation steps to be run sequentially, one by one.
 *
 * @param steps An array of animation step objects.
 * - Steps defined by `style()` calls apply the styling data immediately.
 * - Steps defined by `animate()` calls apply the styling data over time
 *   as specified by the timing data.
 *
 * ```typescript
 * sequence([
 *   style({ opacity: 0 }),
 *   animate("1s", style({ opacity: 1 }))
 * ])
 * ```
 *
 * @param options An options object containing a delay and
 * developer-defined parameters that provide styling defaults and
 * can be overridden on invocation.
 *
 * @return An object that encapsulates the sequence data.
 *
 * @usageNotes
 * When you pass an array of steps to a
 * `transition()` call, the steps run sequentially by default.
 * Compare this to the `{@link animations/group group()}` call, which runs animation steps in
 *parallel.
 *
 * When a sequence is used within a `{@link animations/group group()}` or a `transition()` call,
 * execution continues to the next instruction only after each of the inner animation
 * steps have completed.
 *
 * @publicApi
 **/
function sequence(steps, options = null) {
  return {
    type: 2 /* Sequence */,
    steps,
    options
  };
}
/**
 * Declares a key/value object containing CSS properties/styles that
 * can then be used for an animation `state`, within an animation `sequence`,
 * or as styling data for calls to `animate()` and `keyframes()`.
 *
 * @param tokens A set of CSS styles or HTML styles associated with an animation state.
 * The value can be any of the following:
 * - A key-value style pair associating a CSS property with a value.
 * - An array of key-value style pairs.
 * - An asterisk (*), to use auto-styling, where styles are derived from the element
 * being animated and applied to the animation when it starts.
 *
 * Auto-styling can be used to define a state that depends on layout or other
 * environmental factors.
 *
 * @return An object that encapsulates the style data.
 *
 * @usageNotes
 * The following examples create animation styles that collect a set of
 * CSS property values:
 *
 * ```typescript
 * // string values for CSS properties
 * style({ background: "red", color: "blue" })
 *
 * // numerical pixel values
 * style({ width: 100, height: 0 })
 * ```
 *
 * The following example uses auto-styling to allow a component to animate from
 * a height of 0 up to the height of the parent element:
 *
 * ```
 * style({ height: 0 }),
 * animate("1s", style({ height: "*" }))
 * ```
 *
 * @publicApi
 **/
function style(tokens) {
  return {
    type: 6 /* Style */,
    styles: tokens,
    offset: null
  };
}
/**
 * Declares an animation state within a trigger attached to an element.
 *
 * @param name One or more names for the defined state in a comma-separated string.
 * The following reserved state names can be supplied to define a style for specific use
 * cases:
 *
 * - `void` You can associate styles with this name to be used when
 * the element is detached from the application. For example, when an `ngIf` evaluates
 * to false, the state of the associated element is void.
 *  - `*` (asterisk) Indicates the default state. You can associate styles with this name
 * to be used as the fallback when the state that is being animated is not declared
 * within the trigger.
 *
 * @param styles A set of CSS styles associated with this state, created using the
 * `style()` function.
 * This set of styles persists on the element once the state has been reached.
 * @param options Parameters that can be passed to the state when it is invoked.
 * 0 or more key-value pairs.
 * @return An object that encapsulates the new state data.
 *
 * @usageNotes
 * Use the `trigger()` function to register states to an animation trigger.
 * Use the `transition()` function to animate between states.
 * When a state is active within a component, its associated styles persist on the element,
 * even when the animation ends.
 *
 * @publicApi
 **/
function state(name, styles, options) {
  return {
    type: 0 /* State */,
    name,
    styles,
    options
  };
}
/**
 * Defines a set of animation styles, associating each style with an optional `offset` value.
 *
 * @param steps A set of animation styles with optional offset data.
 * The optional `offset` value for a style specifies a percentage of the total animation
 * time at which that style is applied.
 * @returns An object that encapsulates the keyframes data.
 *
 * @usageNotes
 * Use with the `animate()` call. Instead of applying animations
 * from the current state
 * to the destination state, keyframes describe how each style entry is applied and at what point
 * within the animation arc.
 * Compare [CSS Keyframe Animations](https://www.w3schools.com/css/css3_animations.asp).
 *
 * ### Usage
 *
 * In the following example, the offset values describe
 * when each `backgroundColor` value is applied. The color is red at the start, and changes to
 * blue when 20% of the total time has elapsed.
 *
 * ```typescript
 * // the provided offset values
 * animate("5s", keyframes([
 *   style({ backgroundColor: "red", offset: 0 }),
 *   style({ backgroundColor: "blue", offset: 0.2 }),
 *   style({ backgroundColor: "orange", offset: 0.3 }),
 *   style({ backgroundColor: "black", offset: 1 })
 * ]))
 * ```
 *
 * If there are no `offset` values specified in the style entries, the offsets
 * are calculated automatically.
 *
 * ```typescript
 * animate("5s", keyframes([
 *   style({ backgroundColor: "red" }) // offset = 0
 *   style({ backgroundColor: "blue" }) // offset = 0.33
 *   style({ backgroundColor: "orange" }) // offset = 0.66
 *   style({ backgroundColor: "black" }) // offset = 1
 * ]))
 *```

 * @publicApi
 */
function keyframes(steps) {
  return {
    type: 5 /* Keyframes */,
    steps
  };
}
/**
 * Declares an animation transition as a sequence of animation steps to run when a given
 * condition is satisfied. The condition is a Boolean expression or function that compares
 * the previous and current animation states, and returns true if this transition should occur.
 * When the state criteria of a defined transition are met, the associated animation is
 * triggered.
 *
 * @param stateChangeExpr A Boolean expression or function that compares the previous and current
 * animation states, and returns true if this transition should occur. Note that  "true" and "false"
 * match 1 and 0, respectively. An expression is evaluated each time a state change occurs in the
 * animation trigger element.
 * The animation steps run when the expression evaluates to true.
 *
 * - A state-change string takes the form "state1 => state2", where each side is a defined animation
 * state, or an asterix (*) to refer to a dynamic start or end state.
 *   - The expression string can contain multiple comma-separated statements;
 * for example "state1 => state2, state3 => state4".
 *   - Special values `:enter` and `:leave` initiate a transition on the entry and exit states,
 * equivalent to  "void => *"  and "* => void".
 *   - Special values `:increment` and `:decrement` initiate a transition when a numeric value has
 * increased or decreased in value.
 * - A function is executed each time a state change occurs in the animation trigger element.
 * The animation steps run when the function returns true.
 *
 * @param steps One or more animation objects, as returned by the `animate()` or
 * `sequence()` function, that form a transformation from one state to another.
 * A sequence is used by default when you pass an array.
 * @param options An options object that can contain a delay value for the start of the animation,
 * and additional developer-defined parameters. Provided values for additional parameters are used
 * as defaults, and override values can be passed to the caller on invocation.
 * @returns An object that encapsulates the transition data.
 *
 * @usageNotes
 * The template associated with a component binds an animation trigger to an element.
 *
 * ```HTML
 * <!-- somewhere inside of my-component-tpl.html -->
 * <div [@myAnimationTrigger]="myStatusExp">...</div>
 * ```
 *
 * All transitions are defined within an animation trigger,
 * along with named states that the transitions change to and from.
 *
 * ```typescript
 * trigger("myAnimationTrigger", [
 *  // define states
 *  state("on", style({ background: "green" })),
 *  state("off", style({ background: "grey" })),
 *  ...]
 * ```
 *
 * Note that when you call the `sequence()` function within a `{@link animations/group group()}`
 * or a `transition()` call, execution does not continue to the next instruction
 * until each of the inner animation steps have completed.
 *
 * ### Syntax examples
 *
 * The following examples define transitions between the two defined states (and default states),
 * using various options:
 *
 * ```typescript
 * // Transition occurs when the state value
 * // bound to "myAnimationTrigger" changes from "on" to "off"
 * transition("on => off", animate(500))
 * // Run the same animation for both directions
 * transition("on <=> off", animate(500))
 * // Define multiple state-change pairs separated by commas
 * transition("on => off, off => void", animate(500))
 * ```
 *
 * ### Special values for state-change expressions
 *
 * - Catch-all state change for when an element is inserted into the page and the
 * destination state is unknown:
 *
 * ```typescript
 * transition("void => *", [
 *  style({ opacity: 0 }),
 *  animate(500)
 *  ])
 * ```
 *
 * - Capture a state change between any states:
 *
 *  `transition("* => *", animate("1s 0s"))`
 *
 * - Entry and exit transitions:
 *
 * ```typescript
 * transition(":enter", [
 *   style({ opacity: 0 }),
 *   animate(500, style({ opacity: 1 }))
 *   ]),
 * transition(":leave", [
 *   animate(500, style({ opacity: 0 }))
 *   ])
 * ```
 *
 * - Use `:increment` and `:decrement` to initiate transitions:
 *
 * ```typescript
 * transition(":increment", group([
 *  query(':enter', [
 *     style({ left: '100%' }),
 *     animate('0.5s ease-out', style('*'))
 *   ]),
 *  query(':leave', [
 *     animate('0.5s ease-out', style({ left: '-100%' }))
 *  ])
 * ]))
 *
 * transition(":decrement", group([
 *  query(':enter', [
 *     style({ left: '100%' }),
 *     animate('0.5s ease-out', style('*'))
 *   ]),
 *  query(':leave', [
 *     animate('0.5s ease-out', style({ left: '-100%' }))
 *  ])
 * ]))
 * ```
 *
 * ### State-change functions
 *
 * Here is an example of a `fromState` specified as a state-change function that invokes an
 * animation when true:
 *
 * ```typescript
 * transition((fromState, toState) =>
 *  {
 *   return fromState == "off" && toState == "on";
 *  },
 *  animate("1s 0s"))
 * ```
 *
 * ### Animating to the final state
 *
 * If the final step in a transition is a call to `animate()` that uses a timing value
 * with no style data, that step is automatically considered the final animation arc,
 * for the element to reach the final state. Angular automatically adds or removes
 * CSS styles to ensure that the element is in the correct final state.
 *
 * The following example defines a transition that starts by hiding the element,
 * then makes sure that it animates properly to whatever state is currently active for trigger:
 *
 * ```typescript
 * transition("void => *", [
 *   style({ opacity: 0 }),
 *   animate(500)
 *  ])
 * ```
 * ### Boolean value matching
 * If a trigger binding value is a Boolean, it can be matched using a transition expression
 * that compares true and false or 1 and 0. For example:
 *
 * ```
 * // in the template
 * <div [@openClose]="open ? true : false">...</div>
 * // in the component metadata
 * trigger('openClose', [
 *   state('true', style({ height: '*' })),
 *   state('false', style({ height: '0px' })),
 *   transition('false <=> true', animate(500))
 * ])
 * ```
 *
 * @publicApi
 **/
function transition(stateChangeExpr, steps, options = null) {
  return {
    type: 1 /* Transition */,
    expr: stateChangeExpr,
    animation: steps,
    options
  };
}
/**
 * Produces a reusable animation that can be invoked in another animation or sequence,
 * by calling the `useAnimation()` function.
 *
 * @param steps One or more animation objects, as returned by the `animate()`
 * or `sequence()` function, that form a transformation from one state to another.
 * A sequence is used by default when you pass an array.
 * @param options An options object that can contain a delay value for the start of the
 * animation, and additional developer-defined parameters.
 * Provided values for additional parameters are used as defaults,
 * and override values can be passed to the caller on invocation.
 * @returns An object that encapsulates the animation data.
 *
 * @usageNotes
 * The following example defines a reusable animation, providing some default parameter
 * values.
 *
 * ```typescript
 * var fadeAnimation = animation([
 *   style({ opacity: '{{ start }}' }),
 *   animate('{{ time }}',
 *   style({ opacity: '{{ end }}'}))
 *   ],
 *   { params: { time: '1000ms', start: 0, end: 1 }});
 * ```
 *
 * The following invokes the defined animation with a call to `useAnimation()`,
 * passing in override parameter values.
 *
 * ```js
 * useAnimation(fadeAnimation, {
 *   params: {
 *     time: '2s',
 *     start: 1,
 *     end: 0
 *   }
 * })
 * ```
 *
 * If any of the passed-in parameter values are missing from this call,
 * the default values are used. If one or more parameter values are missing before a step is
 * animated, `useAnimation()` throws an error.
 *
 * @publicApi
 */
function animation(steps, options = null) {
  return {
    type: 8 /* Reference */,
    animation: steps,
    options
  };
}
/**
 * Executes a queried inner animation element within an animation sequence.
 *
 * @param options An options object that can contain a delay value for the start of the
 * animation, and additional override values for developer-defined parameters.
 * @return An object that encapsulates the child animation data.
 *
 * @usageNotes
 * Each time an animation is triggered in Angular, the parent animation
 * has priority and any child animations are blocked. In order
 * for a child animation to run, the parent animation must query each of the elements
 * containing child animations, and run them using this function.
 *
 * Note that this feature is designed to be used with `query()` and it will only work
 * with animations that are assigned using the Angular animation library. CSS keyframes
 * and transitions are not handled by this API.
 *
 * @publicApi
 */
function animateChild(options = null) {
  return {
    type: 9 /* AnimateChild */,
    options
  };
}
/**
 * Starts a reusable animation that is created using the `animation()` function.
 *
 * @param animation The reusable animation to start.
 * @param options An options object that can contain a delay value for the start of
 * the animation, and additional override values for developer-defined parameters.
 * @return An object that contains the animation parameters.
 *
 * @publicApi
 */
function useAnimation(animation, options = null) {
  return {
    type: 10 /* AnimateRef */,
    animation,
    options
  };
}
/**
 * Finds one or more inner elements within the current element that is
 * being animated within a sequence. Use with `animate()`.
 *
 * @param selector The element to query, or a set of elements that contain Angular-specific
 * characteristics, specified with one or more of the following tokens.
 *  - `query(":enter")` or `query(":leave")` : Query for newly inserted/removed elements.
 *  - `query(":animating")` : Query all currently animating elements.
 *  - `query("@triggerName")` : Query elements that contain an animation trigger.
 *  - `query("@*")` : Query all elements that contain an animation triggers.
 *  - `query(":self")` : Include the current element into the animation sequence.
 *
 * @param animation One or more animation steps to apply to the queried element or elements.
 * An array is treated as an animation sequence.
 * @param options An options object. Use the 'limit' field to limit the total number of
 * items to collect.
 * @return An object that encapsulates the query data.
 *
 * @usageNotes
 * Tokens can be merged into a combined query selector string. For example:
 *
 * ```typescript
 *  query(':self, .record:enter, .record:leave, @subTrigger', [...])
 * ```
 *
 * The `query()` function collects multiple elements and works internally by using
 * `element.querySelectorAll`. Use the `limit` field of an options object to limit
 * the total number of items to be collected. For example:
 *
 * ```js
 * query('div', [
 *   animate(...),
 *   animate(...)
 * ], { limit: 1 })
 * ```
 *
 * By default, throws an error when zero items are found. Set the
 * `optional` flag to ignore this error. For example:
 *
 * ```js
 * query('.some-element-that-may-not-be-there', [
 *   animate(...),
 *   animate(...)
 * ], { optional: true })
 * ```
 *
 * ### Usage Example
 *
 * The following example queries for inner elements and animates them
 * individually using `animate()`.
 *
 * ```typescript
 * @Component({
 *   selector: 'inner',
 *   template: `
 *     <div [@queryAnimation]="exp">
 *       <h1>Title</h1>
 *       <div class="content">
 *         Blah blah blah
 *       </div>
 *     </div>
 *   `,
 *   animations: [
 *    trigger('queryAnimation', [
 *      transition('* => goAnimate', [
 *        // hide the inner elements
 *        query('h1', style({ opacity: 0 })),
 *        query('.content', style({ opacity: 0 })),
 *
 *        // animate the inner elements in, one by one
 *        query('h1', animate(1000, style({ opacity: 1 }))),
 *        query('.content', animate(1000, style({ opacity: 1 }))),
 *      ])
 *    ])
 *  ]
 * })
 * class Cmp {
 *   exp = '';
 *
 *   goAnimate() {
 *     this.exp = 'goAnimate';
 *   }
 * }
 * ```
 *
 * @publicApi
 */
function query(selector, animation, options = null) {
  return {
    type: 11 /* Query */,
    selector,
    animation,
    options
  };
}
/**
 * Use within an animation `query()` call to issue a timing gap after
 * each queried item is animated.
 *
 * @param timings A delay value.
 * @param animation One ore more animation steps.
 * @returns An object that encapsulates the stagger data.
 *
 * @usageNotes
 * In the following example, a container element wraps a list of items stamped out
 * by an `ngFor`. The container element contains an animation trigger that will later be set
 * to query for each of the inner items.
 *
 * Each time items are added, the opacity fade-in animation runs,
 * and each removed item is faded out.
 * When either of these animations occur, the stagger effect is
 * applied after each item's animation is started.
 *
 * ```html
 * <!-- list.component.html -->
 * <button (click)="toggle()">Show / Hide Items</button>
 * <hr />
 * <div [@listAnimation]="items.length">
 *   <div *ngFor="let item of items">
 *     {{ item }}
 *   </div>
 * </div>
 * ```
 *
 * Here is the component code:
 *
 * ```typescript
 * import {trigger, transition, style, animate, query, stagger} from '@angular/animations';
 * @Component({
 *   templateUrl: 'list.component.html',
 *   animations: [
 *     trigger('listAnimation', [
 *     ...
 *     ])
 *   ]
 * })
 * class ListComponent {
 *   items = [];
 *
 *   showItems() {
 *     this.items = [0,1,2,3,4];
 *   }
 *
 *   hideItems() {
 *     this.items = [];
 *   }
 *
 *   toggle() {
 *     this.items.length ? this.hideItems() : this.showItems();
 *    }
 *  }
 * ```
 *
 * Here is the animation trigger code:
 *
 * ```typescript
 * trigger('listAnimation', [
 *   transition('* => *', [ // each time the binding value changes
 *     query(':leave', [
 *       stagger(100, [
 *         animate('0.5s', style({ opacity: 0 }))
 *       ])
 *     ]),
 *     query(':enter', [
 *       style({ opacity: 0 }),
 *       stagger(100, [
 *         animate('0.5s', style({ opacity: 1 }))
 *       ])
 *     ])
 *   ])
 * ])
 * ```
 *
 * @publicApi
 */
function stagger(timings, animation) {
  return {
    type: 12 /* Stagger */,
    timings,
    animation
  };
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function scheduleMicroTask(cb) {
  Promise.resolve(null).then(cb);
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * An empty programmatic controller for reusable animations.
 * Used internally when animations are disabled, to avoid
 * checking for the null case when an animation player is expected.
 *
 * @see `animate()`
 * @see `AnimationPlayer`
 * @see `GroupPlayer`
 *
 * @publicApi
 */
class NoopAnimationPlayer {
  constructor(duration = 0, delay = 0) {
    this._onDoneFns = [];
    this._onStartFns = [];
    this._onDestroyFns = [];
    this._started = false;
    this._destroyed = false;
    this._finished = false;
    this._position = 0;
    this.parentPlayer = null;
    this.totalTime = duration + delay;
  }
  _onFinish() {
    if (!this._finished) {
      this._finished = true;
      this._onDoneFns.forEach(fn => fn());
      this._onDoneFns = [];
    }
  }
  onStart(fn) {
    this._onStartFns.push(fn);
  }
  onDone(fn) {
    this._onDoneFns.push(fn);
  }
  onDestroy(fn) {
    this._onDestroyFns.push(fn);
  }
  hasStarted() {
    return this._started;
  }
  init() {}
  play() {
    if (!this.hasStarted()) {
      this._onStart();
      this.triggerMicrotask();
    }
    this._started = true;
  }
  /** @internal */
  triggerMicrotask() {
    scheduleMicroTask(() => this._onFinish());
  }
  _onStart() {
    this._onStartFns.forEach(fn => fn());
    this._onStartFns = [];
  }
  pause() {}
  restart() {}
  finish() {
    this._onFinish();
  }
  destroy() {
    if (!this._destroyed) {
      this._destroyed = true;
      if (!this.hasStarted()) {
        this._onStart();
      }
      this.finish();
      this._onDestroyFns.forEach(fn => fn());
      this._onDestroyFns = [];
    }
  }
  reset() {
    this._started = false;
  }
  setPosition(position) {
    this._position = this.totalTime ? position * this.totalTime : 1;
  }
  getPosition() {
    return this.totalTime ? this._position / this.totalTime : 1;
  }
  /** @internal */
  triggerCallback(phaseName) {
    const methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;
    methods.forEach(fn => fn());
    methods.length = 0;
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A programmatic controller for a group of reusable animations.
 * Used internally to control animations.
 *
 * @see `AnimationPlayer`
 * @see `{@link animations/group group()}`
 *
 */
class AnimationGroupPlayer {
  constructor(_players) {
    this._onDoneFns = [];
    this._onStartFns = [];
    this._finished = false;
    this._started = false;
    this._destroyed = false;
    this._onDestroyFns = [];
    this.parentPlayer = null;
    this.totalTime = 0;
    this.players = _players;
    let doneCount = 0;
    let destroyCount = 0;
    let startCount = 0;
    const total = this.players.length;
    if (total == 0) {
      scheduleMicroTask(() => this._onFinish());
    } else {
      this.players.forEach(player => {
        player.onDone(() => {
          if (++doneCount == total) {
            this._onFinish();
          }
        });
        player.onDestroy(() => {
          if (++destroyCount == total) {
            this._onDestroy();
          }
        });
        player.onStart(() => {
          if (++startCount == total) {
            this._onStart();
          }
        });
      });
    }
    this.totalTime = this.players.reduce((time, player) => Math.max(time, player.totalTime), 0);
  }
  _onFinish() {
    if (!this._finished) {
      this._finished = true;
      this._onDoneFns.forEach(fn => fn());
      this._onDoneFns = [];
    }
  }
  init() {
    this.players.forEach(player => player.init());
  }
  onStart(fn) {
    this._onStartFns.push(fn);
  }
  _onStart() {
    if (!this.hasStarted()) {
      this._started = true;
      this._onStartFns.forEach(fn => fn());
      this._onStartFns = [];
    }
  }
  onDone(fn) {
    this._onDoneFns.push(fn);
  }
  onDestroy(fn) {
    this._onDestroyFns.push(fn);
  }
  hasStarted() {
    return this._started;
  }
  play() {
    if (!this.parentPlayer) {
      this.init();
    }
    this._onStart();
    this.players.forEach(player => player.play());
  }
  pause() {
    this.players.forEach(player => player.pause());
  }
  restart() {
    this.players.forEach(player => player.restart());
  }
  finish() {
    this._onFinish();
    this.players.forEach(player => player.finish());
  }
  destroy() {
    this._onDestroy();
  }
  _onDestroy() {
    if (!this._destroyed) {
      this._destroyed = true;
      this._onFinish();
      this.players.forEach(player => player.destroy());
      this._onDestroyFns.forEach(fn => fn());
      this._onDestroyFns = [];
    }
  }
  reset() {
    this.players.forEach(player => player.reset());
    this._destroyed = false;
    this._finished = false;
    this._started = false;
  }
  setPosition(p) {
    const timeAtPosition = p * this.totalTime;
    this.players.forEach(player => {
      const position = player.totalTime ? Math.min(1, timeAtPosition / player.totalTime) : 1;
      player.setPosition(position);
    });
  }
  getPosition() {
    const longestPlayer = this.players.reduce((longestSoFar, player) => {
      const newPlayerIsLongest = longestSoFar === null || player.totalTime > longestSoFar.totalTime;
      return newPlayerIsLongest ? player : longestSoFar;
    }, null);
    return longestPlayer != null ? longestPlayer.getPosition() : 0;
  }
  beforeDestroy() {
    this.players.forEach(player => {
      if (player.beforeDestroy) {
        player.beforeDestroy();
      }
    });
  }
  /** @internal */
  triggerCallback(phaseName) {
    const methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;
    methods.forEach(fn => fn());
    methods.length = 0;
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const ɵPRE_STYLE = '!';

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=animations.js.map

/***/ }),

/***/ 9221:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ar: () => (/* binding */ WebAnimationsStyleNormalizer),
/* harmony export */   DT: () => (/* binding */ WebAnimationsDriver),
/* harmony export */   NH: () => (/* binding */ AnimationStyleNormalizer),
/* harmony export */   QN: () => (/* binding */ supportsWebAnimations),
/* harmony export */   Th: () => (/* binding */ AnimationEngine),
/* harmony export */   Vi: () => (/* binding */ AnimationDriver),
/* harmony export */   nV: () => (/* binding */ NoopAnimationDriver),
/* harmony export */   uL: () => (/* binding */ CssKeyframesDriver)
/* harmony export */ });
/* unused harmony exports ɵAnimation, ɵCssKeyframesPlayer, ɵNoopAnimationStyleNormalizer, ɵWebAnimationsPlayer, ɵallowPreviousPlayerStylesMerge, ɵangular_packages_animations_browser_browser_a, ɵcontainsElement, ɵinvokeQuery, ɵmatchesElement, ɵvalidateStyleProperty */
/* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6083);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @license Angular v12.2.17
 * (c) 2010-2021 Google LLC. https://angular.io/
 * License: MIT
 */




/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

function isBrowser() {
  return typeof window !== 'undefined' && typeof window.document !== 'undefined';
}
function isNode() {
  // Checking only for `process` isn't enough to identify whether or not we're in a Node
  // environment, because Webpack by default will polyfill the `process`. While we can discern
  // that Webpack polyfilled it by looking at `process.browser`, it's very Webpack-specific and
  // might not be future-proof. Instead we look at the stringified version of `process` which
  // is `[object process]` in Node and `[object Object]` when polyfilled.
  return typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
}
function optimizeGroupPlayer(players) {
  switch (players.length) {
    case 0:
      return new _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .NoopAnimationPlayer */ .ZN();
    case 1:
      return players[0];
    default:
      return new _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* ["ɵAnimationGroupPlayer"] */ .ZE(players);
  }
}
function normalizeKeyframes(driver, normalizer, element, keyframes, preStyles = {}, postStyles = {}) {
  const errors = [];
  const normalizedKeyframes = [];
  let previousOffset = -1;
  let previousKeyframe = null;
  keyframes.forEach(kf => {
    const offset = kf['offset'];
    const isSameOffset = offset == previousOffset;
    const normalizedKeyframe = isSameOffset && previousKeyframe || {};
    Object.keys(kf).forEach(prop => {
      let normalizedProp = prop;
      let normalizedValue = kf[prop];
      if (prop !== 'offset') {
        normalizedProp = normalizer.normalizePropertyName(normalizedProp, errors);
        switch (normalizedValue) {
          case _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* ["ɵPRE_STYLE"] */ .k1:
            normalizedValue = preStyles[prop];
            break;
          case _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .AUTO_STYLE */ .l3:
            normalizedValue = postStyles[prop];
            break;
          default:
            normalizedValue = normalizer.normalizeStyleValue(prop, normalizedProp, normalizedValue, errors);
            break;
        }
      }
      normalizedKeyframe[normalizedProp] = normalizedValue;
    });
    if (!isSameOffset) {
      normalizedKeyframes.push(normalizedKeyframe);
    }
    previousKeyframe = normalizedKeyframe;
    previousOffset = offset;
  });
  if (errors.length) {
    const LINE_START = '\n - ';
    throw new Error(`Unable to animate due to the following errors:${LINE_START}${errors.join(LINE_START)}`);
  }
  return normalizedKeyframes;
}
function listenOnPlayer(player, eventName, event, callback) {
  switch (eventName) {
    case 'start':
      player.onStart(() => callback(event && copyAnimationEvent(event, 'start', player)));
      break;
    case 'done':
      player.onDone(() => callback(event && copyAnimationEvent(event, 'done', player)));
      break;
    case 'destroy':
      player.onDestroy(() => callback(event && copyAnimationEvent(event, 'destroy', player)));
      break;
  }
}
function copyAnimationEvent(e, phaseName, player) {
  const totalTime = player.totalTime;
  const disabled = player.disabled ? true : false;
  const event = makeAnimationEvent(e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName, totalTime == undefined ? e.totalTime : totalTime, disabled);
  const data = e['_data'];
  if (data != null) {
    event['_data'] = data;
  }
  return event;
}
function makeAnimationEvent(element, triggerName, fromState, toState, phaseName = '', totalTime = 0, disabled) {
  return {
    element,
    triggerName,
    fromState,
    toState,
    phaseName,
    totalTime,
    disabled: !!disabled
  };
}
function getOrSetAsInMap(map, key, defaultValue) {
  let value;
  if (map instanceof Map) {
    value = map.get(key);
    if (!value) {
      map.set(key, value = defaultValue);
    }
  } else {
    value = map[key];
    if (!value) {
      value = map[key] = defaultValue;
    }
  }
  return value;
}
function parseTimelineCommand(command) {
  const separatorPos = command.indexOf(':');
  const id = command.substring(1, separatorPos);
  const action = command.substr(separatorPos + 1);
  return [id, action];
}
let _contains = (elm1, elm2) => false;
const ɵ0 = (/* unused pure expression or super */ null && (_contains));
let _matches = (element, selector) => false;
const ɵ1 = (/* unused pure expression or super */ null && (_matches));
let _query = (element, selector, multi) => {
  return [];
};
const ɵ2 = (/* unused pure expression or super */ null && (_query));
// Define utility methods for browsers and platform-server(domino) where Element
// and utility methods exist.
const _isNode = /*#__PURE__*/isNode();
if (_isNode || typeof Element !== 'undefined') {
  if (! /*#__PURE__*/isBrowser()) {
    _contains = (elm1, elm2) => elm1.contains(elm2);
  } else {
    _contains = (elm1, elm2) => {
      while (elm2 && elm2 !== document.documentElement) {
        if (elm2 === elm1) {
          return true;
        }
        elm2 = elm2.parentNode || elm2.host; // consider host to support shadow DOM
      }

      return false;
    };
  }
  _matches = /*#__PURE__*/(() => {
    if (_isNode || Element.prototype.matches) {
      return (element, selector) => element.matches(selector);
    } else {
      const proto = Element.prototype;
      const fn = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
      if (fn) {
        return (element, selector) => fn.apply(element, [selector]);
      } else {
        return _matches;
      }
    }
  })();
  _query = (element, selector, multi) => {
    let results = [];
    if (multi) {
      // DO NOT REFACTOR TO USE SPREAD SYNTAX.
      // For element queries that return sufficiently large NodeList objects,
      // using spread syntax to populate the results array causes a RangeError
      // due to the call stack limit being reached. `Array.from` can not be used
      // as well, since NodeList is not iterable in IE 11, see
      // https://developer.mozilla.org/en-US/docs/Web/API/NodeList
      // More info is available in #38551.
      const elems = element.querySelectorAll(selector);
      for (let i = 0; i < elems.length; i++) {
        results.push(elems[i]);
      }
    } else {
      const elm = element.querySelector(selector);
      if (elm) {
        results.push(elm);
      }
    }
    return results;
  };
}
function containsVendorPrefix(prop) {
  // Webkit is the only real popular vendor prefix nowadays
  // cc: http://shouldiprefix.com/
  return prop.substring(1, 6) == 'ebkit'; // webkit or Webkit
}

let _CACHED_BODY = null;
let _IS_WEBKIT = false;
function validateStyleProperty(prop) {
  if (!_CACHED_BODY) {
    _CACHED_BODY = getBodyNode() || {};
    _IS_WEBKIT = _CACHED_BODY.style ? 'WebkitAppearance' in _CACHED_BODY.style : false;
  }
  let result = true;
  if (_CACHED_BODY.style && !containsVendorPrefix(prop)) {
    result = prop in _CACHED_BODY.style;
    if (!result && _IS_WEBKIT) {
      const camelProp = 'Webkit' + prop.charAt(0).toUpperCase() + prop.substr(1);
      result = camelProp in _CACHED_BODY.style;
    }
  }
  return result;
}
function getBodyNode() {
  if (typeof document != 'undefined') {
    return document.body;
  }
  return null;
}
const matchesElement = _matches;
const containsElement = _contains;
const invokeQuery = _query;
function hypenatePropsObject(object) {
  const newObj = {};
  Object.keys(object).forEach(prop => {
    const newProp = prop.replace(/([a-z])([A-Z])/g, '$1-$2');
    newObj[newProp] = object[prop];
  });
  return newObj;
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @publicApi
 */
let NoopAnimationDriver = /*#__PURE__*/(() => {
  class NoopAnimationDriver {
    validateStyleProperty(prop) {
      return validateStyleProperty(prop);
    }
    matchesElement(element, selector) {
      return matchesElement(element, selector);
    }
    containsElement(elm1, elm2) {
      return containsElement(elm1, elm2);
    }
    query(element, selector, multi) {
      return invokeQuery(element, selector, multi);
    }
    computeStyle(element, prop, defaultValue) {
      return defaultValue || '';
    }
    animate(element, keyframes, duration, delay, easing, previousPlayers = [], scrubberAccessRequested) {
      return new _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .NoopAnimationPlayer */ .ZN(duration, delay);
    }
  }
  NoopAnimationDriver.ɵfac = function NoopAnimationDriver_Factory(t) {
    return new (t || NoopAnimationDriver)();
  };
  NoopAnimationDriver.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: NoopAnimationDriver,
    factory: NoopAnimationDriver.ɵfac
  });
  return NoopAnimationDriver;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @publicApi
 */
let AnimationDriver = /*#__PURE__*/(() => {
  class AnimationDriver {}
  AnimationDriver.NOOP = /* @__PURE__ */new NoopAnimationDriver();

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  return AnimationDriver;
})();
const ONE_SECOND = 1000;
const SUBSTITUTION_EXPR_START = '{{';
const SUBSTITUTION_EXPR_END = '}}';
const ENTER_CLASSNAME = 'ng-enter';
const LEAVE_CLASSNAME = 'ng-leave';
const ENTER_SELECTOR = '.ng-enter';
const LEAVE_SELECTOR = '.ng-leave';
const NG_TRIGGER_CLASSNAME = 'ng-trigger';
const NG_TRIGGER_SELECTOR = '.ng-trigger';
const NG_ANIMATING_CLASSNAME = 'ng-animating';
const NG_ANIMATING_SELECTOR = '.ng-animating';
function resolveTimingValue(value) {
  if (typeof value == 'number') return value;
  const matches = value.match(/^(-?[\.\d]+)(m?s)/);
  if (!matches || matches.length < 2) return 0;
  return _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
}
function _convertTimeValueToMS(value, unit) {
  switch (unit) {
    case 's':
      return value * ONE_SECOND;
    default:
      // ms or something else
      return value;
  }
}
function resolveTiming(timings, errors, allowNegativeValues) {
  return timings.hasOwnProperty('duration') ? timings : parseTimeExpression(timings, errors, allowNegativeValues);
}
function parseTimeExpression(exp, errors, allowNegativeValues) {
  const regex = /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i;
  let duration;
  let delay = 0;
  let easing = '';
  if (typeof exp === 'string') {
    const matches = exp.match(regex);
    if (matches === null) {
      errors.push(`The provided timing value "${exp}" is invalid.`);
      return {
        duration: 0,
        delay: 0,
        easing: ''
      };
    }
    duration = _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
    const delayMatch = matches[3];
    if (delayMatch != null) {
      delay = _convertTimeValueToMS(parseFloat(delayMatch), matches[4]);
    }
    const easingVal = matches[5];
    if (easingVal) {
      easing = easingVal;
    }
  } else {
    duration = exp;
  }
  if (!allowNegativeValues) {
    let containsErrors = false;
    let startIndex = errors.length;
    if (duration < 0) {
      errors.push(`Duration values below 0 are not allowed for this animation step.`);
      containsErrors = true;
    }
    if (delay < 0) {
      errors.push(`Delay values below 0 are not allowed for this animation step.`);
      containsErrors = true;
    }
    if (containsErrors) {
      errors.splice(startIndex, 0, `The provided timing value "${exp}" is invalid.`);
    }
  }
  return {
    duration,
    delay,
    easing
  };
}
function copyObj(obj, destination = {}) {
  Object.keys(obj).forEach(prop => {
    destination[prop] = obj[prop];
  });
  return destination;
}
function normalizeStyles(styles) {
  const normalizedStyles = {};
  if (Array.isArray(styles)) {
    styles.forEach(data => copyStyles(data, false, normalizedStyles));
  } else {
    copyStyles(styles, false, normalizedStyles);
  }
  return normalizedStyles;
}
function copyStyles(styles, readPrototype, destination = {}) {
  if (readPrototype) {
    // we make use of a for-in loop so that the
    // prototypically inherited properties are
    // revealed from the backFill map
    for (let prop in styles) {
      destination[prop] = styles[prop];
    }
  } else {
    copyObj(styles, destination);
  }
  return destination;
}
function getStyleAttributeString(element, key, value) {
  // Return the key-value pair string to be added to the style attribute for the
  // given CSS style key.
  if (value) {
    return key + ':' + value + ';';
  } else {
    return '';
  }
}
function writeStyleAttribute(element) {
  // Read the style property of the element and manually reflect it to the
  // style attribute. This is needed because Domino on platform-server doesn't
  // understand the full set of allowed CSS properties and doesn't reflect some
  // of them automatically.
  let styleAttrValue = '';
  for (let i = 0; i < element.style.length; i++) {
    const key = element.style.item(i);
    styleAttrValue += getStyleAttributeString(element, key, element.style.getPropertyValue(key));
  }
  for (const key in element.style) {
    // Skip internal Domino properties that don't need to be reflected.
    if (!element.style.hasOwnProperty(key) || key.startsWith('_')) {
      continue;
    }
    const dashKey = camelCaseToDashCase(key);
    styleAttrValue += getStyleAttributeString(element, dashKey, element.style[key]);
  }
  element.setAttribute('style', styleAttrValue);
}
function setStyles(element, styles, formerStyles) {
  if (element['style']) {
    Object.keys(styles).forEach(prop => {
      const camelProp = dashCaseToCamelCase(prop);
      if (formerStyles && !formerStyles.hasOwnProperty(prop)) {
        formerStyles[prop] = element.style[camelProp];
      }
      element.style[camelProp] = styles[prop];
    });
    // On the server set the 'style' attribute since it's not automatically reflected.
    if (isNode()) {
      writeStyleAttribute(element);
    }
  }
}
function eraseStyles(element, styles) {
  if (element['style']) {
    Object.keys(styles).forEach(prop => {
      const camelProp = dashCaseToCamelCase(prop);
      element.style[camelProp] = '';
    });
    // On the server set the 'style' attribute since it's not automatically reflected.
    if (isNode()) {
      writeStyleAttribute(element);
    }
  }
}
function normalizeAnimationEntry(steps) {
  if (Array.isArray(steps)) {
    if (steps.length == 1) return steps[0];
    return (0,_angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .sequence */ .vP)(steps);
  }
  return steps;
}
function validateStyleParams(value, options, errors) {
  const params = options.params || {};
  const matches = extractStyleParams(value);
  if (matches.length) {
    matches.forEach(varName => {
      if (!params.hasOwnProperty(varName)) {
        errors.push(`Unable to resolve the local animation param ${varName} in the given list of values`);
      }
    });
  }
}
const PARAM_REGEX = /*#__PURE__*/new RegExp(`${SUBSTITUTION_EXPR_START}\\s*(.+?)\\s*${SUBSTITUTION_EXPR_END}`, 'g');
function extractStyleParams(value) {
  let params = [];
  if (typeof value === 'string') {
    let match;
    while (match = PARAM_REGEX.exec(value)) {
      params.push(match[1]);
    }
    PARAM_REGEX.lastIndex = 0;
  }
  return params;
}
function interpolateParams(value, params, errors) {
  const original = value.toString();
  const str = original.replace(PARAM_REGEX, (_, varName) => {
    let localVal = params[varName];
    // this means that the value was never overridden by the data passed in by the user
    if (!params.hasOwnProperty(varName)) {
      errors.push(`Please provide a value for the animation param ${varName}`);
      localVal = '';
    }
    return localVal.toString();
  });
  // we do this to assert that numeric values stay as they are
  return str == original ? value : str;
}
function iteratorToArray(iterator) {
  const arr = [];
  let item = iterator.next();
  while (!item.done) {
    arr.push(item.value);
    item = iterator.next();
  }
  return arr;
}
const DASH_CASE_REGEXP = /-+([a-z0-9])/g;
function dashCaseToCamelCase(input) {
  return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());
}
function camelCaseToDashCase(input) {
  return input.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function allowPreviousPlayerStylesMerge(duration, delay) {
  return duration === 0 || delay === 0;
}
function balancePreviousStylesIntoKeyframes(element, keyframes, previousStyles) {
  const previousStyleProps = Object.keys(previousStyles);
  if (previousStyleProps.length && keyframes.length) {
    let startingKeyframe = keyframes[0];
    let missingStyleProps = [];
    previousStyleProps.forEach(prop => {
      if (!startingKeyframe.hasOwnProperty(prop)) {
        missingStyleProps.push(prop);
      }
      startingKeyframe[prop] = previousStyles[prop];
    });
    if (missingStyleProps.length) {
      // tslint:disable-next-line
      for (var i = 1; i < keyframes.length; i++) {
        let kf = keyframes[i];
        missingStyleProps.forEach(function (prop) {
          kf[prop] = computeStyle(element, prop);
        });
      }
    }
  }
  return keyframes;
}
function visitDslNode(visitor, node, context) {
  switch (node.type) {
    case 7 /* Trigger */:
      return visitor.visitTrigger(node, context);
    case 0 /* State */:
      return visitor.visitState(node, context);
    case 1 /* Transition */:
      return visitor.visitTransition(node, context);
    case 2 /* Sequence */:
      return visitor.visitSequence(node, context);
    case 3 /* Group */:
      return visitor.visitGroup(node, context);
    case 4 /* Animate */:
      return visitor.visitAnimate(node, context);
    case 5 /* Keyframes */:
      return visitor.visitKeyframes(node, context);
    case 6 /* Style */:
      return visitor.visitStyle(node, context);
    case 8 /* Reference */:
      return visitor.visitReference(node, context);
    case 9 /* AnimateChild */:
      return visitor.visitAnimateChild(node, context);
    case 10 /* AnimateRef */:
      return visitor.visitAnimateRef(node, context);
    case 11 /* Query */:
      return visitor.visitQuery(node, context);
    case 12 /* Stagger */:
      return visitor.visitStagger(node, context);
    default:
      throw new Error(`Unable to resolve animation metadata node #${node.type}`);
  }
}
function computeStyle(element, prop) {
  return window.getComputedStyle(element)[prop];
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const ANY_STATE = '*';
function parseTransitionExpr(transitionValue, errors) {
  const expressions = [];
  if (typeof transitionValue == 'string') {
    transitionValue.split(/\s*,\s*/).forEach(str => parseInnerTransitionStr(str, expressions, errors));
  } else {
    expressions.push(transitionValue);
  }
  return expressions;
}
function parseInnerTransitionStr(eventStr, expressions, errors) {
  if (eventStr[0] == ':') {
    const result = parseAnimationAlias(eventStr, errors);
    if (typeof result == 'function') {
      expressions.push(result);
      return;
    }
    eventStr = result;
  }
  const match = eventStr.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
  if (match == null || match.length < 4) {
    errors.push(`The provided transition expression "${eventStr}" is not supported`);
    return expressions;
  }
  const fromState = match[1];
  const separator = match[2];
  const toState = match[3];
  expressions.push(makeLambdaFromStates(fromState, toState));
  const isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;
  if (separator[0] == '<' && !isFullAnyStateExpr) {
    expressions.push(makeLambdaFromStates(toState, fromState));
  }
}
function parseAnimationAlias(alias, errors) {
  switch (alias) {
    case ':enter':
      return 'void => *';
    case ':leave':
      return '* => void';
    case ':increment':
      return (fromState, toState) => parseFloat(toState) > parseFloat(fromState);
    case ':decrement':
      return (fromState, toState) => parseFloat(toState) < parseFloat(fromState);
    default:
      errors.push(`The transition alias value "${alias}" is not supported`);
      return '* => *';
  }
}
// DO NOT REFACTOR ... keep the follow set instantiations
// with the values intact (closure compiler for some reason
// removes follow-up lines that add the values outside of
// the constructor...
const TRUE_BOOLEAN_VALUES = /*#__PURE__*/new Set(['true', '1']);
const FALSE_BOOLEAN_VALUES = /*#__PURE__*/new Set(['false', '0']);
function makeLambdaFromStates(lhs, rhs) {
  const LHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(lhs) || FALSE_BOOLEAN_VALUES.has(lhs);
  const RHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(rhs) || FALSE_BOOLEAN_VALUES.has(rhs);
  return (fromState, toState) => {
    let lhsMatch = lhs == ANY_STATE || lhs == fromState;
    let rhsMatch = rhs == ANY_STATE || rhs == toState;
    if (!lhsMatch && LHS_MATCH_BOOLEAN && typeof fromState === 'boolean') {
      lhsMatch = fromState ? TRUE_BOOLEAN_VALUES.has(lhs) : FALSE_BOOLEAN_VALUES.has(lhs);
    }
    if (!rhsMatch && RHS_MATCH_BOOLEAN && typeof toState === 'boolean') {
      rhsMatch = toState ? TRUE_BOOLEAN_VALUES.has(rhs) : FALSE_BOOLEAN_VALUES.has(rhs);
    }
    return lhsMatch && rhsMatch;
  };
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const SELF_TOKEN = ':self';
const SELF_TOKEN_REGEX = /*#__PURE__*/new RegExp(`\s*${SELF_TOKEN}\s*,?`, 'g');
/*
 * [Validation]
 * The visitor code below will traverse the animation AST generated by the animation verb functions
 * (the output is a tree of objects) and attempt to perform a series of validations on the data. The
 * following corner-cases will be validated:
 *
 * 1. Overlap of animations
 * Given that a CSS property cannot be animated in more than one place at the same time, it's
 * important that this behavior is detected and validated. The way in which this occurs is that
 * each time a style property is examined, a string-map containing the property will be updated with
 * the start and end times for when the property is used within an animation step.
 *
 * If there are two or more parallel animations that are currently running (these are invoked by the
 * group()) on the same element then the validator will throw an error. Since the start/end timing
 * values are collected for each property then if the current animation step is animating the same
 * property and its timing values fall anywhere into the window of time that the property is
 * currently being animated within then this is what causes an error.
 *
 * 2. Timing values
 * The validator will validate to see if a timing value of `duration delay easing` or
 * `durationNumber` is valid or not.
 *
 * (note that upon validation the code below will replace the timing data with an object containing
 * {duration,delay,easing}.
 *
 * 3. Offset Validation
 * Each of the style() calls are allowed to have an offset value when placed inside of keyframes().
 * Offsets within keyframes() are considered valid when:
 *
 *   - No offsets are used at all
 *   - Each style() entry contains an offset value
 *   - Each offset is between 0 and 1
 *   - Each offset is greater to or equal than the previous one
 *
 * Otherwise an error will be thrown.
 */
function buildAnimationAst(driver, metadata, errors) {
  return new AnimationAstBuilderVisitor(driver).build(metadata, errors);
}
const ROOT_SELECTOR = '';
class AnimationAstBuilderVisitor {
  constructor(_driver) {
    this._driver = _driver;
  }
  build(metadata, errors) {
    const context = new AnimationAstBuilderContext(errors);
    this._resetContextStyleTimingState(context);
    return visitDslNode(this, normalizeAnimationEntry(metadata), context);
  }
  _resetContextStyleTimingState(context) {
    context.currentQuerySelector = ROOT_SELECTOR;
    context.collectedStyles = {};
    context.collectedStyles[ROOT_SELECTOR] = {};
    context.currentTime = 0;
  }
  visitTrigger(metadata, context) {
    let queryCount = context.queryCount = 0;
    let depCount = context.depCount = 0;
    const states = [];
    const transitions = [];
    if (metadata.name.charAt(0) == '@') {
      context.errors.push('animation triggers cannot be prefixed with an `@` sign (e.g. trigger(\'@foo\', [...]))');
    }
    metadata.definitions.forEach(def => {
      this._resetContextStyleTimingState(context);
      if (def.type == 0 /* State */) {
        const stateDef = def;
        const name = stateDef.name;
        name.toString().split(/\s*,\s*/).forEach(n => {
          stateDef.name = n;
          states.push(this.visitState(stateDef, context));
        });
        stateDef.name = name;
      } else if (def.type == 1 /* Transition */) {
        const transition = this.visitTransition(def, context);
        queryCount += transition.queryCount;
        depCount += transition.depCount;
        transitions.push(transition);
      } else {
        context.errors.push('only state() and transition() definitions can sit inside of a trigger()');
      }
    });
    return {
      type: 7 /* Trigger */,
      name: metadata.name,
      states,
      transitions,
      queryCount,
      depCount,
      options: null
    };
  }
  visitState(metadata, context) {
    const styleAst = this.visitStyle(metadata.styles, context);
    const astParams = metadata.options && metadata.options.params || null;
    if (styleAst.containsDynamicStyles) {
      const missingSubs = new Set();
      const params = astParams || {};
      styleAst.styles.forEach(value => {
        if (isObject(value)) {
          const stylesObj = value;
          Object.keys(stylesObj).forEach(prop => {
            extractStyleParams(stylesObj[prop]).forEach(sub => {
              if (!params.hasOwnProperty(sub)) {
                missingSubs.add(sub);
              }
            });
          });
        }
      });
      if (missingSubs.size) {
        const missingSubsArr = iteratorToArray(missingSubs.values());
        context.errors.push(`state("${metadata.name}", ...) must define default values for all the following style substitutions: ${missingSubsArr.join(', ')}`);
      }
    }
    return {
      type: 0 /* State */,
      name: metadata.name,
      style: styleAst,
      options: astParams ? {
        params: astParams
      } : null
    };
  }
  visitTransition(metadata, context) {
    context.queryCount = 0;
    context.depCount = 0;
    const animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);
    const matchers = parseTransitionExpr(metadata.expr, context.errors);
    return {
      type: 1 /* Transition */,
      matchers,
      animation,
      queryCount: context.queryCount,
      depCount: context.depCount,
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitSequence(metadata, context) {
    return {
      type: 2 /* Sequence */,
      steps: metadata.steps.map(s => visitDslNode(this, s, context)),
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitGroup(metadata, context) {
    const currentTime = context.currentTime;
    let furthestTime = 0;
    const steps = metadata.steps.map(step => {
      context.currentTime = currentTime;
      const innerAst = visitDslNode(this, step, context);
      furthestTime = Math.max(furthestTime, context.currentTime);
      return innerAst;
    });
    context.currentTime = furthestTime;
    return {
      type: 3 /* Group */,
      steps,
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitAnimate(metadata, context) {
    const timingAst = constructTimingAst(metadata.timings, context.errors);
    context.currentAnimateTimings = timingAst;
    let styleAst;
    let styleMetadata = metadata.styles ? metadata.styles : (0,_angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .style */ .oB)({});
    if (styleMetadata.type == 5 /* Keyframes */) {
      styleAst = this.visitKeyframes(styleMetadata, context);
    } else {
      let styleMetadata = metadata.styles;
      let isEmpty = false;
      if (!styleMetadata) {
        isEmpty = true;
        const newStyleData = {};
        if (timingAst.easing) {
          newStyleData['easing'] = timingAst.easing;
        }
        styleMetadata = (0,_angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .style */ .oB)(newStyleData);
      }
      context.currentTime += timingAst.duration + timingAst.delay;
      const _styleAst = this.visitStyle(styleMetadata, context);
      _styleAst.isEmptyStep = isEmpty;
      styleAst = _styleAst;
    }
    context.currentAnimateTimings = null;
    return {
      type: 4 /* Animate */,
      timings: timingAst,
      style: styleAst,
      options: null
    };
  }
  visitStyle(metadata, context) {
    const ast = this._makeStyleAst(metadata, context);
    this._validateStyleAst(ast, context);
    return ast;
  }
  _makeStyleAst(metadata, context) {
    const styles = [];
    if (Array.isArray(metadata.styles)) {
      metadata.styles.forEach(styleTuple => {
        if (typeof styleTuple == 'string') {
          if (styleTuple == _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .AUTO_STYLE */ .l3) {
            styles.push(styleTuple);
          } else {
            context.errors.push(`The provided style string value ${styleTuple} is not allowed.`);
          }
        } else {
          styles.push(styleTuple);
        }
      });
    } else {
      styles.push(metadata.styles);
    }
    let containsDynamicStyles = false;
    let collectedEasing = null;
    styles.forEach(styleData => {
      if (isObject(styleData)) {
        const styleMap = styleData;
        const easing = styleMap['easing'];
        if (easing) {
          collectedEasing = easing;
          delete styleMap['easing'];
        }
        if (!containsDynamicStyles) {
          for (let prop in styleMap) {
            const value = styleMap[prop];
            if (value.toString().indexOf(SUBSTITUTION_EXPR_START) >= 0) {
              containsDynamicStyles = true;
              break;
            }
          }
        }
      }
    });
    return {
      type: 6 /* Style */,
      styles,
      easing: collectedEasing,
      offset: metadata.offset,
      containsDynamicStyles,
      options: null
    };
  }
  _validateStyleAst(ast, context) {
    const timings = context.currentAnimateTimings;
    let endTime = context.currentTime;
    let startTime = context.currentTime;
    if (timings && startTime > 0) {
      startTime -= timings.duration + timings.delay;
    }
    ast.styles.forEach(tuple => {
      if (typeof tuple == 'string') return;
      Object.keys(tuple).forEach(prop => {
        if (!this._driver.validateStyleProperty(prop)) {
          context.errors.push(`The provided animation property "${prop}" is not a supported CSS property for animations`);
          return;
        }
        const collectedStyles = context.collectedStyles[context.currentQuerySelector];
        const collectedEntry = collectedStyles[prop];
        let updateCollectedStyle = true;
        if (collectedEntry) {
          if (startTime != endTime && startTime >= collectedEntry.startTime && endTime <= collectedEntry.endTime) {
            context.errors.push(`The CSS property "${prop}" that exists between the times of "${collectedEntry.startTime}ms" and "${collectedEntry.endTime}ms" is also being animated in a parallel animation between the times of "${startTime}ms" and "${endTime}ms"`);
            updateCollectedStyle = false;
          }
          // we always choose the smaller start time value since we
          // want to have a record of the entire animation window where
          // the style property is being animated in between
          startTime = collectedEntry.startTime;
        }
        if (updateCollectedStyle) {
          collectedStyles[prop] = {
            startTime,
            endTime
          };
        }
        if (context.options) {
          validateStyleParams(tuple[prop], context.options, context.errors);
        }
      });
    });
  }
  visitKeyframes(metadata, context) {
    const ast = {
      type: 5 /* Keyframes */,
      styles: [],
      options: null
    };
    if (!context.currentAnimateTimings) {
      context.errors.push(`keyframes() must be placed inside of a call to animate()`);
      return ast;
    }
    const MAX_KEYFRAME_OFFSET = 1;
    let totalKeyframesWithOffsets = 0;
    const offsets = [];
    let offsetsOutOfOrder = false;
    let keyframesOutOfRange = false;
    let previousOffset = 0;
    const keyframes = metadata.steps.map(styles => {
      const style = this._makeStyleAst(styles, context);
      let offsetVal = style.offset != null ? style.offset : consumeOffset(style.styles);
      let offset = 0;
      if (offsetVal != null) {
        totalKeyframesWithOffsets++;
        offset = style.offset = offsetVal;
      }
      keyframesOutOfRange = keyframesOutOfRange || offset < 0 || offset > 1;
      offsetsOutOfOrder = offsetsOutOfOrder || offset < previousOffset;
      previousOffset = offset;
      offsets.push(offset);
      return style;
    });
    if (keyframesOutOfRange) {
      context.errors.push(`Please ensure that all keyframe offsets are between 0 and 1`);
    }
    if (offsetsOutOfOrder) {
      context.errors.push(`Please ensure that all keyframe offsets are in order`);
    }
    const length = metadata.steps.length;
    let generatedOffset = 0;
    if (totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length) {
      context.errors.push(`Not all style() steps within the declared keyframes() contain offsets`);
    } else if (totalKeyframesWithOffsets == 0) {
      generatedOffset = MAX_KEYFRAME_OFFSET / (length - 1);
    }
    const limit = length - 1;
    const currentTime = context.currentTime;
    const currentAnimateTimings = context.currentAnimateTimings;
    const animateDuration = currentAnimateTimings.duration;
    keyframes.forEach((kf, i) => {
      const offset = generatedOffset > 0 ? i == limit ? 1 : generatedOffset * i : offsets[i];
      const durationUpToThisFrame = offset * animateDuration;
      context.currentTime = currentTime + currentAnimateTimings.delay + durationUpToThisFrame;
      currentAnimateTimings.duration = durationUpToThisFrame;
      this._validateStyleAst(kf, context);
      kf.offset = offset;
      ast.styles.push(kf);
    });
    return ast;
  }
  visitReference(metadata, context) {
    return {
      type: 8 /* Reference */,
      animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitAnimateChild(metadata, context) {
    context.depCount++;
    return {
      type: 9 /* AnimateChild */,
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitAnimateRef(metadata, context) {
    return {
      type: 10 /* AnimateRef */,
      animation: this.visitReference(metadata.animation, context),
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitQuery(metadata, context) {
    const parentSelector = context.currentQuerySelector;
    const options = metadata.options || {};
    context.queryCount++;
    context.currentQuery = metadata;
    const [selector, includeSelf] = normalizeSelector(metadata.selector);
    context.currentQuerySelector = parentSelector.length ? parentSelector + ' ' + selector : selector;
    getOrSetAsInMap(context.collectedStyles, context.currentQuerySelector, {});
    const animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);
    context.currentQuery = null;
    context.currentQuerySelector = parentSelector;
    return {
      type: 11 /* Query */,
      selector,
      limit: options.limit || 0,
      optional: !!options.optional,
      includeSelf,
      animation,
      originalSelector: metadata.selector,
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitStagger(metadata, context) {
    if (!context.currentQuery) {
      context.errors.push(`stagger() can only be used inside of query()`);
    }
    const timings = metadata.timings === 'full' ? {
      duration: 0,
      delay: 0,
      easing: 'full'
    } : resolveTiming(metadata.timings, context.errors, true);
    return {
      type: 12 /* Stagger */,
      animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),
      timings,
      options: null
    };
  }
}
function normalizeSelector(selector) {
  const hasAmpersand = selector.split(/\s*,\s*/).find(token => token == SELF_TOKEN) ? true : false;
  if (hasAmpersand) {
    selector = selector.replace(SELF_TOKEN_REGEX, '');
  }
  // the :enter and :leave selectors are filled in at runtime during timeline building
  selector = selector.replace(/@\*/g, NG_TRIGGER_SELECTOR).replace(/@\w+/g, match => NG_TRIGGER_SELECTOR + '-' + match.substr(1)).replace(/:animating/g, NG_ANIMATING_SELECTOR);
  return [selector, hasAmpersand];
}
function normalizeParams(obj) {
  return obj ? copyObj(obj) : null;
}
class AnimationAstBuilderContext {
  constructor(errors) {
    this.errors = errors;
    this.queryCount = 0;
    this.depCount = 0;
    this.currentTransition = null;
    this.currentQuery = null;
    this.currentQuerySelector = null;
    this.currentAnimateTimings = null;
    this.currentTime = 0;
    this.collectedStyles = {};
    this.options = null;
  }
}
function consumeOffset(styles) {
  if (typeof styles == 'string') return null;
  let offset = null;
  if (Array.isArray(styles)) {
    styles.forEach(styleTuple => {
      if (isObject(styleTuple) && styleTuple.hasOwnProperty('offset')) {
        const obj = styleTuple;
        offset = parseFloat(obj['offset']);
        delete obj['offset'];
      }
    });
  } else if (isObject(styles) && styles.hasOwnProperty('offset')) {
    const obj = styles;
    offset = parseFloat(obj['offset']);
    delete obj['offset'];
  }
  return offset;
}
function isObject(value) {
  return !Array.isArray(value) && typeof value == 'object';
}
function constructTimingAst(value, errors) {
  let timings = null;
  if (value.hasOwnProperty('duration')) {
    timings = value;
  } else if (typeof value == 'number') {
    const duration = resolveTiming(value, errors).duration;
    return makeTimingAst(duration, 0, '');
  }
  const strValue = value;
  const isDynamic = strValue.split(/\s+/).some(v => v.charAt(0) == '{' && v.charAt(1) == '{');
  if (isDynamic) {
    const ast = makeTimingAst(0, 0, '');
    ast.dynamic = true;
    ast.strValue = strValue;
    return ast;
  }
  timings = timings || resolveTiming(strValue, errors);
  return makeTimingAst(timings.duration, timings.delay, timings.easing);
}
function normalizeAnimationOptions(options) {
  if (options) {
    options = copyObj(options);
    if (options['params']) {
      options['params'] = normalizeParams(options['params']);
    }
  } else {
    options = {};
  }
  return options;
}
function makeTimingAst(duration, delay, easing) {
  return {
    duration,
    delay,
    easing
  };
}
function createTimelineInstruction(element, keyframes, preStyleProps, postStyleProps, duration, delay, easing = null, subTimeline = false) {
  return {
    type: 1 /* TimelineAnimation */,
    element,
    keyframes,
    preStyleProps,
    postStyleProps,
    duration,
    delay,
    totalTime: duration + delay,
    easing,
    subTimeline
  };
}
class ElementInstructionMap {
  constructor() {
    this._map = new Map();
  }
  consume(element) {
    let instructions = this._map.get(element);
    if (instructions) {
      this._map.delete(element);
    } else {
      instructions = [];
    }
    return instructions;
  }
  append(element, instructions) {
    let existingInstructions = this._map.get(element);
    if (!existingInstructions) {
      this._map.set(element, existingInstructions = []);
    }
    existingInstructions.push(...instructions);
  }
  has(element) {
    return this._map.has(element);
  }
  clear() {
    this._map.clear();
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const ONE_FRAME_IN_MILLISECONDS = 1;
const ENTER_TOKEN = ':enter';
const ENTER_TOKEN_REGEX = /*#__PURE__*/new RegExp(ENTER_TOKEN, 'g');
const LEAVE_TOKEN = ':leave';
const LEAVE_TOKEN_REGEX = /*#__PURE__*/new RegExp(LEAVE_TOKEN, 'g');
/*
 * The code within this file aims to generate web-animations-compatible keyframes from Angular's
 * animation DSL code.
 *
 * The code below will be converted from:
 *
 * ```
 * sequence([
 *   style({ opacity: 0 }),
 *   animate(1000, style({ opacity: 0 }))
 * ])
 * ```
 *
 * To:
 * ```
 * keyframes = [{ opacity: 0, offset: 0 }, { opacity: 1, offset: 1 }]
 * duration = 1000
 * delay = 0
 * easing = ''
 * ```
 *
 * For this operation to cover the combination of animation verbs (style, animate, group, etc...) a
 * combination of prototypical inheritance, AST traversal and merge-sort-like algorithms are used.
 *
 * [AST Traversal]
 * Each of the animation verbs, when executed, will return an string-map object representing what
 * type of action it is (style, animate, group, etc...) and the data associated with it. This means
 * that when functional composition mix of these functions is evaluated (like in the example above)
 * then it will end up producing a tree of objects representing the animation itself.
 *
 * When this animation object tree is processed by the visitor code below it will visit each of the
 * verb statements within the visitor. And during each visit it will build the context of the
 * animation keyframes by interacting with the `TimelineBuilder`.
 *
 * [TimelineBuilder]
 * This class is responsible for tracking the styles and building a series of keyframe objects for a
 * timeline between a start and end time. The builder starts off with an initial timeline and each
 * time the AST comes across a `group()`, `keyframes()` or a combination of the two wihtin a
 * `sequence()` then it will generate a sub timeline for each step as well as a new one after
 * they are complete.
 *
 * As the AST is traversed, the timing state on each of the timelines will be incremented. If a sub
 * timeline was created (based on one of the cases above) then the parent timeline will attempt to
 * merge the styles used within the sub timelines into itself (only with group() this will happen).
 * This happens with a merge operation (much like how the merge works in mergesort) and it will only
 * copy the most recently used styles from the sub timelines into the parent timeline. This ensures
 * that if the styles are used later on in another phase of the animation then they will be the most
 * up-to-date values.
 *
 * [How Missing Styles Are Updated]
 * Each timeline has a `backFill` property which is responsible for filling in new styles into
 * already processed keyframes if a new style shows up later within the animation sequence.
 *
 * ```
 * sequence([
 *   style({ width: 0 }),
 *   animate(1000, style({ width: 100 })),
 *   animate(1000, style({ width: 200 })),
 *   animate(1000, style({ width: 300 }))
 *   animate(1000, style({ width: 400, height: 400 })) // notice how `height` doesn't exist anywhere
 * else
 * ])
 * ```
 *
 * What is happening here is that the `height` value is added later in the sequence, but is missing
 * from all previous animation steps. Therefore when a keyframe is created it would also be missing
 * from all previous keyframes up until where it is first used. For the timeline keyframe generation
 * to properly fill in the style it will place the previous value (the value from the parent
 * timeline) or a default value of `*` into the backFill object. Given that each of the keyframe
 * styles are objects that prototypically inhert from the backFill object, this means that if a
 * value is added into the backFill then it will automatically propagate any missing values to all
 * keyframes. Therefore the missing `height` value will be properly filled into the already
 * processed keyframes.
 *
 * When a sub-timeline is created it will have its own backFill property. This is done so that
 * styles present within the sub-timeline do not accidentally seep into the previous/future timeline
 * keyframes
 *
 * (For prototypically-inherited contents to be detected a `for(i in obj)` loop must be used.)
 *
 * [Validation]
 * The code in this file is not responsible for validation. That functionality happens with within
 * the `AnimationValidatorVisitor` code.
 */
function buildAnimationTimelines(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles = {}, finalStyles = {}, options, subInstructions, errors = []) {
  return new AnimationTimelineBuilderVisitor().buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors);
}
class AnimationTimelineBuilderVisitor {
  buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors = []) {
    subInstructions = subInstructions || new ElementInstructionMap();
    const context = new AnimationTimelineContext(driver, rootElement, subInstructions, enterClassName, leaveClassName, errors, []);
    context.options = options;
    context.currentTimeline.setStyles([startingStyles], null, context.errors, options);
    visitDslNode(this, ast, context);
    // this checks to see if an actual animation happened
    const timelines = context.timelines.filter(timeline => timeline.containsAnimation());
    if (timelines.length && Object.keys(finalStyles).length) {
      const tl = timelines[timelines.length - 1];
      if (!tl.allowOnlyTimelineStyles()) {
        tl.setStyles([finalStyles], null, context.errors, options);
      }
    }
    return timelines.length ? timelines.map(timeline => timeline.buildKeyframes()) : [createTimelineInstruction(rootElement, [], [], [], 0, 0, '', false)];
  }
  visitTrigger(ast, context) {
    // these values are not visited in this AST
  }
  visitState(ast, context) {
    // these values are not visited in this AST
  }
  visitTransition(ast, context) {
    // these values are not visited in this AST
  }
  visitAnimateChild(ast, context) {
    const elementInstructions = context.subInstructions.consume(context.element);
    if (elementInstructions) {
      const innerContext = context.createSubContext(ast.options);
      const startTime = context.currentTimeline.currentTime;
      const endTime = this._visitSubInstructions(elementInstructions, innerContext, innerContext.options);
      if (startTime != endTime) {
        // we do this on the upper context because we created a sub context for
        // the sub child animations
        context.transformIntoNewTimeline(endTime);
      }
    }
    context.previousNode = ast;
  }
  visitAnimateRef(ast, context) {
    const innerContext = context.createSubContext(ast.options);
    innerContext.transformIntoNewTimeline();
    this.visitReference(ast.animation, innerContext);
    context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime);
    context.previousNode = ast;
  }
  _visitSubInstructions(instructions, context, options) {
    const startTime = context.currentTimeline.currentTime;
    let furthestTime = startTime;
    // this is a special-case for when a user wants to skip a sub
    // animation from being fired entirely.
    const duration = options.duration != null ? resolveTimingValue(options.duration) : null;
    const delay = options.delay != null ? resolveTimingValue(options.delay) : null;
    if (duration !== 0) {
      instructions.forEach(instruction => {
        const instructionTimings = context.appendInstructionToTimeline(instruction, duration, delay);
        furthestTime = Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);
      });
    }
    return furthestTime;
  }
  visitReference(ast, context) {
    context.updateOptions(ast.options, true);
    visitDslNode(this, ast.animation, context);
    context.previousNode = ast;
  }
  visitSequence(ast, context) {
    const subContextCount = context.subContextCount;
    let ctx = context;
    const options = ast.options;
    if (options && (options.params || options.delay)) {
      ctx = context.createSubContext(options);
      ctx.transformIntoNewTimeline();
      if (options.delay != null) {
        if (ctx.previousNode.type == 6 /* Style */) {
          ctx.currentTimeline.snapshotCurrentStyles();
          ctx.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
        }
        const delay = resolveTimingValue(options.delay);
        ctx.delayNextStep(delay);
      }
    }
    if (ast.steps.length) {
      ast.steps.forEach(s => visitDslNode(this, s, ctx));
      // this is here just incase the inner steps only contain or end with a style() call
      ctx.currentTimeline.applyStylesToKeyframe();
      // this means that some animation function within the sequence
      // ended up creating a sub timeline (which means the current
      // timeline cannot overlap with the contents of the sequence)
      if (ctx.subContextCount > subContextCount) {
        ctx.transformIntoNewTimeline();
      }
    }
    context.previousNode = ast;
  }
  visitGroup(ast, context) {
    const innerTimelines = [];
    let furthestTime = context.currentTimeline.currentTime;
    const delay = ast.options && ast.options.delay ? resolveTimingValue(ast.options.delay) : 0;
    ast.steps.forEach(s => {
      const innerContext = context.createSubContext(ast.options);
      if (delay) {
        innerContext.delayNextStep(delay);
      }
      visitDslNode(this, s, innerContext);
      furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);
      innerTimelines.push(innerContext.currentTimeline);
    });
    // this operation is run after the AST loop because otherwise
    // if the parent timeline's collected styles were updated then
    // it would pass in invalid data into the new-to-be forked items
    innerTimelines.forEach(timeline => context.currentTimeline.mergeTimelineCollectedStyles(timeline));
    context.transformIntoNewTimeline(furthestTime);
    context.previousNode = ast;
  }
  _visitTiming(ast, context) {
    if (ast.dynamic) {
      const strValue = ast.strValue;
      const timingValue = context.params ? interpolateParams(strValue, context.params, context.errors) : strValue;
      return resolveTiming(timingValue, context.errors);
    } else {
      return {
        duration: ast.duration,
        delay: ast.delay,
        easing: ast.easing
      };
    }
  }
  visitAnimate(ast, context) {
    const timings = context.currentAnimateTimings = this._visitTiming(ast.timings, context);
    const timeline = context.currentTimeline;
    if (timings.delay) {
      context.incrementTime(timings.delay);
      timeline.snapshotCurrentStyles();
    }
    const style = ast.style;
    if (style.type == 5 /* Keyframes */) {
      this.visitKeyframes(style, context);
    } else {
      context.incrementTime(timings.duration);
      this.visitStyle(style, context);
      timeline.applyStylesToKeyframe();
    }
    context.currentAnimateTimings = null;
    context.previousNode = ast;
  }
  visitStyle(ast, context) {
    const timeline = context.currentTimeline;
    const timings = context.currentAnimateTimings;
    // this is a special case for when a style() call
    // directly follows  an animate() call (but not inside of an animate() call)
    if (!timings && timeline.getCurrentStyleProperties().length) {
      timeline.forwardFrame();
    }
    const easing = timings && timings.easing || ast.easing;
    if (ast.isEmptyStep) {
      timeline.applyEmptyStep(easing);
    } else {
      timeline.setStyles(ast.styles, easing, context.errors, context.options);
    }
    context.previousNode = ast;
  }
  visitKeyframes(ast, context) {
    const currentAnimateTimings = context.currentAnimateTimings;
    const startTime = context.currentTimeline.duration;
    const duration = currentAnimateTimings.duration;
    const innerContext = context.createSubContext();
    const innerTimeline = innerContext.currentTimeline;
    innerTimeline.easing = currentAnimateTimings.easing;
    ast.styles.forEach(step => {
      const offset = step.offset || 0;
      innerTimeline.forwardTime(offset * duration);
      innerTimeline.setStyles(step.styles, step.easing, context.errors, context.options);
      innerTimeline.applyStylesToKeyframe();
    });
    // this will ensure that the parent timeline gets all the styles from
    // the child even if the new timeline below is not used
    context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline);
    // we do this because the window between this timeline and the sub timeline
    // should ensure that the styles within are exactly the same as they were before
    context.transformIntoNewTimeline(startTime + duration);
    context.previousNode = ast;
  }
  visitQuery(ast, context) {
    // in the event that the first step before this is a style step we need
    // to ensure the styles are applied before the children are animated
    const startTime = context.currentTimeline.currentTime;
    const options = ast.options || {};
    const delay = options.delay ? resolveTimingValue(options.delay) : 0;
    if (delay && (context.previousNode.type === 6 /* Style */ || startTime == 0 && context.currentTimeline.getCurrentStyleProperties().length)) {
      context.currentTimeline.snapshotCurrentStyles();
      context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
    }
    let furthestTime = startTime;
    const elms = context.invokeQuery(ast.selector, ast.originalSelector, ast.limit, ast.includeSelf, options.optional ? true : false, context.errors);
    context.currentQueryTotal = elms.length;
    let sameElementTimeline = null;
    elms.forEach((element, i) => {
      context.currentQueryIndex = i;
      const innerContext = context.createSubContext(ast.options, element);
      if (delay) {
        innerContext.delayNextStep(delay);
      }
      if (element === context.element) {
        sameElementTimeline = innerContext.currentTimeline;
      }
      visitDslNode(this, ast.animation, innerContext);
      // this is here just incase the inner steps only contain or end
      // with a style() call (which is here to signal that this is a preparatory
      // call to style an element before it is animated again)
      innerContext.currentTimeline.applyStylesToKeyframe();
      const endTime = innerContext.currentTimeline.currentTime;
      furthestTime = Math.max(furthestTime, endTime);
    });
    context.currentQueryIndex = 0;
    context.currentQueryTotal = 0;
    context.transformIntoNewTimeline(furthestTime);
    if (sameElementTimeline) {
      context.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline);
      context.currentTimeline.snapshotCurrentStyles();
    }
    context.previousNode = ast;
  }
  visitStagger(ast, context) {
    const parentContext = context.parentContext;
    const tl = context.currentTimeline;
    const timings = ast.timings;
    const duration = Math.abs(timings.duration);
    const maxTime = duration * (context.currentQueryTotal - 1);
    let delay = duration * context.currentQueryIndex;
    let staggerTransformer = timings.duration < 0 ? 'reverse' : timings.easing;
    switch (staggerTransformer) {
      case 'reverse':
        delay = maxTime - delay;
        break;
      case 'full':
        delay = parentContext.currentStaggerTime;
        break;
    }
    const timeline = context.currentTimeline;
    if (delay) {
      timeline.delayNextStep(delay);
    }
    const startingTime = timeline.currentTime;
    visitDslNode(this, ast.animation, context);
    context.previousNode = ast;
    // time = duration + delay
    // the reason why this computation is so complex is because
    // the inner timeline may either have a delay value or a stretched
    // keyframe depending on if a subtimeline is not used or is used.
    parentContext.currentStaggerTime = tl.currentTime - startingTime + (tl.startTime - parentContext.currentTimeline.startTime);
  }
}
const DEFAULT_NOOP_PREVIOUS_NODE = {};
class AnimationTimelineContext {
  constructor(_driver, element, subInstructions, _enterClassName, _leaveClassName, errors, timelines, initialTimeline) {
    this._driver = _driver;
    this.element = element;
    this.subInstructions = subInstructions;
    this._enterClassName = _enterClassName;
    this._leaveClassName = _leaveClassName;
    this.errors = errors;
    this.timelines = timelines;
    this.parentContext = null;
    this.currentAnimateTimings = null;
    this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
    this.subContextCount = 0;
    this.options = {};
    this.currentQueryIndex = 0;
    this.currentQueryTotal = 0;
    this.currentStaggerTime = 0;
    this.currentTimeline = initialTimeline || new TimelineBuilder(this._driver, element, 0);
    timelines.push(this.currentTimeline);
  }
  get params() {
    return this.options.params;
  }
  updateOptions(options, skipIfExists) {
    if (!options) return;
    const newOptions = options;
    let optionsToUpdate = this.options;
    // NOTE: this will get patched up when other animation methods support duration overrides
    if (newOptions.duration != null) {
      optionsToUpdate.duration = resolveTimingValue(newOptions.duration);
    }
    if (newOptions.delay != null) {
      optionsToUpdate.delay = resolveTimingValue(newOptions.delay);
    }
    const newParams = newOptions.params;
    if (newParams) {
      let paramsToUpdate = optionsToUpdate.params;
      if (!paramsToUpdate) {
        paramsToUpdate = this.options.params = {};
      }
      Object.keys(newParams).forEach(name => {
        if (!skipIfExists || !paramsToUpdate.hasOwnProperty(name)) {
          paramsToUpdate[name] = interpolateParams(newParams[name], paramsToUpdate, this.errors);
        }
      });
    }
  }
  _copyOptions() {
    const options = {};
    if (this.options) {
      const oldParams = this.options.params;
      if (oldParams) {
        const params = options['params'] = {};
        Object.keys(oldParams).forEach(name => {
          params[name] = oldParams[name];
        });
      }
    }
    return options;
  }
  createSubContext(options = null, element, newTime) {
    const target = element || this.element;
    const context = new AnimationTimelineContext(this._driver, target, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(target, newTime || 0));
    context.previousNode = this.previousNode;
    context.currentAnimateTimings = this.currentAnimateTimings;
    context.options = this._copyOptions();
    context.updateOptions(options);
    context.currentQueryIndex = this.currentQueryIndex;
    context.currentQueryTotal = this.currentQueryTotal;
    context.parentContext = this;
    this.subContextCount++;
    return context;
  }
  transformIntoNewTimeline(newTime) {
    this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
    this.currentTimeline = this.currentTimeline.fork(this.element, newTime);
    this.timelines.push(this.currentTimeline);
    return this.currentTimeline;
  }
  appendInstructionToTimeline(instruction, duration, delay) {
    const updatedTimings = {
      duration: duration != null ? duration : instruction.duration,
      delay: this.currentTimeline.currentTime + (delay != null ? delay : 0) + instruction.delay,
      easing: ''
    };
    const builder = new SubTimelineBuilder(this._driver, instruction.element, instruction.keyframes, instruction.preStyleProps, instruction.postStyleProps, updatedTimings, instruction.stretchStartingKeyframe);
    this.timelines.push(builder);
    return updatedTimings;
  }
  incrementTime(time) {
    this.currentTimeline.forwardTime(this.currentTimeline.duration + time);
  }
  delayNextStep(delay) {
    // negative delays are not yet supported
    if (delay > 0) {
      this.currentTimeline.delayNextStep(delay);
    }
  }
  invokeQuery(selector, originalSelector, limit, includeSelf, optional, errors) {
    let results = [];
    if (includeSelf) {
      results.push(this.element);
    }
    if (selector.length > 0) {
      // if :self is only used then the selector is empty
      selector = selector.replace(ENTER_TOKEN_REGEX, '.' + this._enterClassName);
      selector = selector.replace(LEAVE_TOKEN_REGEX, '.' + this._leaveClassName);
      const multi = limit != 1;
      let elements = this._driver.query(this.element, selector, multi);
      if (limit !== 0) {
        elements = limit < 0 ? elements.slice(elements.length + limit, elements.length) : elements.slice(0, limit);
      }
      results.push(...elements);
    }
    if (!optional && results.length == 0) {
      errors.push(`\`query("${originalSelector}")\` returned zero elements. (Use \`query("${originalSelector}", { optional: true })\` if you wish to allow this.)`);
    }
    return results;
  }
}
class TimelineBuilder {
  constructor(_driver, element, startTime, _elementTimelineStylesLookup) {
    this._driver = _driver;
    this.element = element;
    this.startTime = startTime;
    this._elementTimelineStylesLookup = _elementTimelineStylesLookup;
    this.duration = 0;
    this._previousKeyframe = {};
    this._currentKeyframe = {};
    this._keyframes = new Map();
    this._styleSummary = {};
    this._pendingStyles = {};
    this._backFill = {};
    this._currentEmptyStepKeyframe = null;
    if (!this._elementTimelineStylesLookup) {
      this._elementTimelineStylesLookup = new Map();
    }
    this._localTimelineStyles = Object.create(this._backFill, {});
    this._globalTimelineStyles = this._elementTimelineStylesLookup.get(element);
    if (!this._globalTimelineStyles) {
      this._globalTimelineStyles = this._localTimelineStyles;
      this._elementTimelineStylesLookup.set(element, this._localTimelineStyles);
    }
    this._loadKeyframe();
  }
  containsAnimation() {
    switch (this._keyframes.size) {
      case 0:
        return false;
      case 1:
        return this.getCurrentStyleProperties().length > 0;
      default:
        return true;
    }
  }
  getCurrentStyleProperties() {
    return Object.keys(this._currentKeyframe);
  }
  get currentTime() {
    return this.startTime + this.duration;
  }
  delayNextStep(delay) {
    // in the event that a style() step is placed right before a stagger()
    // and that style() step is the very first style() value in the animation
    // then we need to make a copy of the keyframe [0, copy, 1] so that the delay
    // properly applies the style() values to work with the stagger...
    const hasPreStyleStep = this._keyframes.size == 1 && Object.keys(this._pendingStyles).length;
    if (this.duration || hasPreStyleStep) {
      this.forwardTime(this.currentTime + delay);
      if (hasPreStyleStep) {
        this.snapshotCurrentStyles();
      }
    } else {
      this.startTime += delay;
    }
  }
  fork(element, currentTime) {
    this.applyStylesToKeyframe();
    return new TimelineBuilder(this._driver, element, currentTime || this.currentTime, this._elementTimelineStylesLookup);
  }
  _loadKeyframe() {
    if (this._currentKeyframe) {
      this._previousKeyframe = this._currentKeyframe;
    }
    this._currentKeyframe = this._keyframes.get(this.duration);
    if (!this._currentKeyframe) {
      this._currentKeyframe = Object.create(this._backFill, {});
      this._keyframes.set(this.duration, this._currentKeyframe);
    }
  }
  forwardFrame() {
    this.duration += ONE_FRAME_IN_MILLISECONDS;
    this._loadKeyframe();
  }
  forwardTime(time) {
    this.applyStylesToKeyframe();
    this.duration = time;
    this._loadKeyframe();
  }
  _updateStyle(prop, value) {
    this._localTimelineStyles[prop] = value;
    this._globalTimelineStyles[prop] = value;
    this._styleSummary[prop] = {
      time: this.currentTime,
      value
    };
  }
  allowOnlyTimelineStyles() {
    return this._currentEmptyStepKeyframe !== this._currentKeyframe;
  }
  applyEmptyStep(easing) {
    if (easing) {
      this._previousKeyframe['easing'] = easing;
    }
    // special case for animate(duration):
    // all missing styles are filled with a `*` value then
    // if any destination styles are filled in later on the same
    // keyframe then they will override the overridden styles
    // We use `_globalTimelineStyles` here because there may be
    // styles in previous keyframes that are not present in this timeline
    Object.keys(this._globalTimelineStyles).forEach(prop => {
      this._backFill[prop] = this._globalTimelineStyles[prop] || _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .AUTO_STYLE */ .l3;
      this._currentKeyframe[prop] = _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .AUTO_STYLE */ .l3;
    });
    this._currentEmptyStepKeyframe = this._currentKeyframe;
  }
  setStyles(input, easing, errors, options) {
    if (easing) {
      this._previousKeyframe['easing'] = easing;
    }
    const params = options && options.params || {};
    const styles = flattenStyles(input, this._globalTimelineStyles);
    Object.keys(styles).forEach(prop => {
      const val = interpolateParams(styles[prop], params, errors);
      this._pendingStyles[prop] = val;
      if (!this._localTimelineStyles.hasOwnProperty(prop)) {
        this._backFill[prop] = this._globalTimelineStyles.hasOwnProperty(prop) ? this._globalTimelineStyles[prop] : _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .AUTO_STYLE */ .l3;
      }
      this._updateStyle(prop, val);
    });
  }
  applyStylesToKeyframe() {
    const styles = this._pendingStyles;
    const props = Object.keys(styles);
    if (props.length == 0) return;
    this._pendingStyles = {};
    props.forEach(prop => {
      const val = styles[prop];
      this._currentKeyframe[prop] = val;
    });
    Object.keys(this._localTimelineStyles).forEach(prop => {
      if (!this._currentKeyframe.hasOwnProperty(prop)) {
        this._currentKeyframe[prop] = this._localTimelineStyles[prop];
      }
    });
  }
  snapshotCurrentStyles() {
    Object.keys(this._localTimelineStyles).forEach(prop => {
      const val = this._localTimelineStyles[prop];
      this._pendingStyles[prop] = val;
      this._updateStyle(prop, val);
    });
  }
  getFinalKeyframe() {
    return this._keyframes.get(this.duration);
  }
  get properties() {
    const properties = [];
    for (let prop in this._currentKeyframe) {
      properties.push(prop);
    }
    return properties;
  }
  mergeTimelineCollectedStyles(timeline) {
    Object.keys(timeline._styleSummary).forEach(prop => {
      const details0 = this._styleSummary[prop];
      const details1 = timeline._styleSummary[prop];
      if (!details0 || details1.time > details0.time) {
        this._updateStyle(prop, details1.value);
      }
    });
  }
  buildKeyframes() {
    this.applyStylesToKeyframe();
    const preStyleProps = new Set();
    const postStyleProps = new Set();
    const isEmpty = this._keyframes.size === 1 && this.duration === 0;
    let finalKeyframes = [];
    this._keyframes.forEach((keyframe, time) => {
      const finalKeyframe = copyStyles(keyframe, true);
      Object.keys(finalKeyframe).forEach(prop => {
        const value = finalKeyframe[prop];
        if (value == _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* ["ɵPRE_STYLE"] */ .k1) {
          preStyleProps.add(prop);
        } else if (value == _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .AUTO_STYLE */ .l3) {
          postStyleProps.add(prop);
        }
      });
      if (!isEmpty) {
        finalKeyframe['offset'] = time / this.duration;
      }
      finalKeyframes.push(finalKeyframe);
    });
    const preProps = preStyleProps.size ? iteratorToArray(preStyleProps.values()) : [];
    const postProps = postStyleProps.size ? iteratorToArray(postStyleProps.values()) : [];
    // special case for a 0-second animation (which is designed just to place styles onscreen)
    if (isEmpty) {
      const kf0 = finalKeyframes[0];
      const kf1 = copyObj(kf0);
      kf0['offset'] = 0;
      kf1['offset'] = 1;
      finalKeyframes = [kf0, kf1];
    }
    return createTimelineInstruction(this.element, finalKeyframes, preProps, postProps, this.duration, this.startTime, this.easing, false);
  }
}
class SubTimelineBuilder extends TimelineBuilder {
  constructor(driver, element, keyframes, preStyleProps, postStyleProps, timings, _stretchStartingKeyframe = false) {
    super(driver, element, timings.delay);
    this.keyframes = keyframes;
    this.preStyleProps = preStyleProps;
    this.postStyleProps = postStyleProps;
    this._stretchStartingKeyframe = _stretchStartingKeyframe;
    this.timings = {
      duration: timings.duration,
      delay: timings.delay,
      easing: timings.easing
    };
  }
  containsAnimation() {
    return this.keyframes.length > 1;
  }
  buildKeyframes() {
    let keyframes = this.keyframes;
    let {
      delay,
      duration,
      easing
    } = this.timings;
    if (this._stretchStartingKeyframe && delay) {
      const newKeyframes = [];
      const totalTime = duration + delay;
      const startingGap = delay / totalTime;
      // the original starting keyframe now starts once the delay is done
      const newFirstKeyframe = copyStyles(keyframes[0], false);
      newFirstKeyframe['offset'] = 0;
      newKeyframes.push(newFirstKeyframe);
      const oldFirstKeyframe = copyStyles(keyframes[0], false);
      oldFirstKeyframe['offset'] = roundOffset(startingGap);
      newKeyframes.push(oldFirstKeyframe);
      /*
        When the keyframe is stretched then it means that the delay before the animation
        starts is gone. Instead the first keyframe is placed at the start of the animation
        and it is then copied to where it starts when the original delay is over. This basically
        means nothing animates during that delay, but the styles are still renderered. For this
        to work the original offset values that exist in the original keyframes must be "warped"
        so that they can take the new keyframe + delay into account.
               delay=1000, duration=1000, keyframes = 0 .5 1
               turns into
               delay=0, duration=2000, keyframes = 0 .33 .66 1
       */
      // offsets between 1 ... n -1 are all warped by the keyframe stretch
      const limit = keyframes.length - 1;
      for (let i = 1; i <= limit; i++) {
        let kf = copyStyles(keyframes[i], false);
        const oldOffset = kf['offset'];
        const timeAtKeyframe = delay + oldOffset * duration;
        kf['offset'] = roundOffset(timeAtKeyframe / totalTime);
        newKeyframes.push(kf);
      }
      // the new starting keyframe should be added at the start
      duration = totalTime;
      delay = 0;
      easing = '';
      keyframes = newKeyframes;
    }
    return createTimelineInstruction(this.element, keyframes, this.preStyleProps, this.postStyleProps, duration, delay, easing, true);
  }
}
function roundOffset(offset, decimalPoints = 3) {
  const mult = Math.pow(10, decimalPoints - 1);
  return Math.round(offset * mult) / mult;
}
function flattenStyles(input, allStyles) {
  const styles = {};
  let allProperties;
  input.forEach(token => {
    if (token === '*') {
      allProperties = allProperties || Object.keys(allStyles);
      allProperties.forEach(prop => {
        styles[prop] = _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .AUTO_STYLE */ .l3;
      });
    } else {
      copyStyles(token, false, styles);
    }
  });
  return styles;
}
class Animation {
  constructor(_driver, input) {
    this._driver = _driver;
    const errors = [];
    const ast = buildAnimationAst(_driver, input, errors);
    if (errors.length) {
      const errorMessage = `animation validation failed:\n${errors.join('\n')}`;
      throw new Error(errorMessage);
    }
    this._animationAst = ast;
  }
  buildTimelines(element, startingStyles, destinationStyles, options, subInstructions) {
    const start = Array.isArray(startingStyles) ? normalizeStyles(startingStyles) : startingStyles;
    const dest = Array.isArray(destinationStyles) ? normalizeStyles(destinationStyles) : destinationStyles;
    const errors = [];
    subInstructions = subInstructions || new ElementInstructionMap();
    const result = buildAnimationTimelines(this._driver, element, this._animationAst, ENTER_CLASSNAME, LEAVE_CLASSNAME, start, dest, options, subInstructions, errors);
    if (errors.length) {
      const errorMessage = `animation building failed:\n${errors.join('\n')}`;
      throw new Error(errorMessage);
    }
    return result;
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @publicApi
 */
class AnimationStyleNormalizer {}
/**
 * @publicApi
 */
class NoopAnimationStyleNormalizer {
  normalizePropertyName(propertyName, errors) {
    return propertyName;
  }
  normalizeStyleValue(userProvidedProperty, normalizedProperty, value, errors) {
    return value;
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class WebAnimationsStyleNormalizer extends AnimationStyleNormalizer {
  normalizePropertyName(propertyName, errors) {
    return dashCaseToCamelCase(propertyName);
  }
  normalizeStyleValue(userProvidedProperty, normalizedProperty, value, errors) {
    let unit = '';
    const strVal = value.toString().trim();
    if (DIMENSIONAL_PROP_MAP[normalizedProperty] && value !== 0 && value !== '0') {
      if (typeof value === 'number') {
        unit = 'px';
      } else {
        const valAndSuffixMatch = value.match(/^[+-]?[\d\.]+([a-z]*)$/);
        if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
          errors.push(`Please provide a CSS unit value for ${userProvidedProperty}:${value}`);
        }
      }
    }
    return strVal + unit;
  }
}
const ɵ0$1 = () => makeBooleanMap('width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective'.split(','));
const DIMENSIONAL_PROP_MAP = /*#__PURE__*/ɵ0$1();
function makeBooleanMap(keys) {
  const map = {};
  keys.forEach(key => map[key] = true);
  return map;
}
function createTransitionInstruction(element, triggerName, fromState, toState, isRemovalTransition, fromStyles, toStyles, timelines, queriedElements, preStyleProps, postStyleProps, totalTime, errors) {
  return {
    type: 0 /* TransitionAnimation */,
    element,
    triggerName,
    isRemovalTransition,
    fromState,
    fromStyles,
    toState,
    toStyles,
    timelines,
    queriedElements,
    preStyleProps,
    postStyleProps,
    totalTime,
    errors
  };
}
const EMPTY_OBJECT = {};
class AnimationTransitionFactory {
  constructor(_triggerName, ast, _stateStyles) {
    this._triggerName = _triggerName;
    this.ast = ast;
    this._stateStyles = _stateStyles;
  }
  match(currentState, nextState, element, params) {
    return oneOrMoreTransitionsMatch(this.ast.matchers, currentState, nextState, element, params);
  }
  buildStyles(stateName, params, errors) {
    const backupStateStyler = this._stateStyles['*'];
    const stateStyler = this._stateStyles[stateName];
    const backupStyles = backupStateStyler ? backupStateStyler.buildStyles(params, errors) : {};
    return stateStyler ? stateStyler.buildStyles(params, errors) : backupStyles;
  }
  build(driver, element, currentState, nextState, enterClassName, leaveClassName, currentOptions, nextOptions, subInstructions, skipAstBuild) {
    const errors = [];
    const transitionAnimationParams = this.ast.options && this.ast.options.params || EMPTY_OBJECT;
    const currentAnimationParams = currentOptions && currentOptions.params || EMPTY_OBJECT;
    const currentStateStyles = this.buildStyles(currentState, currentAnimationParams, errors);
    const nextAnimationParams = nextOptions && nextOptions.params || EMPTY_OBJECT;
    const nextStateStyles = this.buildStyles(nextState, nextAnimationParams, errors);
    const queriedElements = new Set();
    const preStyleMap = new Map();
    const postStyleMap = new Map();
    const isRemoval = nextState === 'void';
    const animationOptions = {
      params: Object.assign(Object.assign({}, transitionAnimationParams), nextAnimationParams)
    };
    const timelines = skipAstBuild ? [] : buildAnimationTimelines(driver, element, this.ast.animation, enterClassName, leaveClassName, currentStateStyles, nextStateStyles, animationOptions, subInstructions, errors);
    let totalTime = 0;
    timelines.forEach(tl => {
      totalTime = Math.max(tl.duration + tl.delay, totalTime);
    });
    if (errors.length) {
      return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, [], [], preStyleMap, postStyleMap, totalTime, errors);
    }
    timelines.forEach(tl => {
      const elm = tl.element;
      const preProps = getOrSetAsInMap(preStyleMap, elm, {});
      tl.preStyleProps.forEach(prop => preProps[prop] = true);
      const postProps = getOrSetAsInMap(postStyleMap, elm, {});
      tl.postStyleProps.forEach(prop => postProps[prop] = true);
      if (elm !== element) {
        queriedElements.add(elm);
      }
    });
    const queriedElementsList = iteratorToArray(queriedElements.values());
    return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, timelines, queriedElementsList, preStyleMap, postStyleMap, totalTime);
  }
}
function oneOrMoreTransitionsMatch(matchFns, currentState, nextState, element, params) {
  return matchFns.some(fn => fn(currentState, nextState, element, params));
}
class AnimationStateStyles {
  constructor(styles, defaultParams, normalizer) {
    this.styles = styles;
    this.defaultParams = defaultParams;
    this.normalizer = normalizer;
  }
  buildStyles(params, errors) {
    const finalStyles = {};
    const combinedParams = copyObj(this.defaultParams);
    Object.keys(params).forEach(key => {
      const value = params[key];
      if (value != null) {
        combinedParams[key] = value;
      }
    });
    this.styles.styles.forEach(value => {
      if (typeof value !== 'string') {
        const styleObj = value;
        Object.keys(styleObj).forEach(prop => {
          let val = styleObj[prop];
          if (val.length > 1) {
            val = interpolateParams(val, combinedParams, errors);
          }
          const normalizedProp = this.normalizer.normalizePropertyName(prop, errors);
          val = this.normalizer.normalizeStyleValue(prop, normalizedProp, val, errors);
          finalStyles[normalizedProp] = val;
        });
      }
    });
    return finalStyles;
  }
}
function buildTrigger(name, ast, normalizer) {
  return new AnimationTrigger(name, ast, normalizer);
}
class AnimationTrigger {
  constructor(name, ast, _normalizer) {
    this.name = name;
    this.ast = ast;
    this._normalizer = _normalizer;
    this.transitionFactories = [];
    this.states = {};
    ast.states.forEach(ast => {
      const defaultParams = ast.options && ast.options.params || {};
      this.states[ast.name] = new AnimationStateStyles(ast.style, defaultParams, _normalizer);
    });
    balanceProperties(this.states, 'true', '1');
    balanceProperties(this.states, 'false', '0');
    ast.transitions.forEach(ast => {
      this.transitionFactories.push(new AnimationTransitionFactory(name, ast, this.states));
    });
    this.fallbackTransition = createFallbackTransition(name, this.states, this._normalizer);
  }
  get containsQueries() {
    return this.ast.queryCount > 0;
  }
  matchTransition(currentState, nextState, element, params) {
    const entry = this.transitionFactories.find(f => f.match(currentState, nextState, element, params));
    return entry || null;
  }
  matchStyles(currentState, params, errors) {
    return this.fallbackTransition.buildStyles(currentState, params, errors);
  }
}
function createFallbackTransition(triggerName, states, normalizer) {
  const matchers = [(fromState, toState) => true];
  const animation = {
    type: 2 /* Sequence */,
    steps: [],
    options: null
  };
  const transition = {
    type: 1 /* Transition */,
    animation,
    matchers,
    options: null,
    queryCount: 0,
    depCount: 0
  };
  return new AnimationTransitionFactory(triggerName, transition, states);
}
function balanceProperties(obj, key1, key2) {
  if (obj.hasOwnProperty(key1)) {
    if (!obj.hasOwnProperty(key2)) {
      obj[key2] = obj[key1];
    }
  } else if (obj.hasOwnProperty(key2)) {
    obj[key1] = obj[key2];
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const EMPTY_INSTRUCTION_MAP = /*#__PURE__*/new ElementInstructionMap();
class TimelineAnimationEngine {
  constructor(bodyNode, _driver, _normalizer) {
    this.bodyNode = bodyNode;
    this._driver = _driver;
    this._normalizer = _normalizer;
    this._animations = {};
    this._playersById = {};
    this.players = [];
  }
  register(id, metadata) {
    const errors = [];
    const ast = buildAnimationAst(this._driver, metadata, errors);
    if (errors.length) {
      throw new Error(`Unable to build the animation due to the following errors: ${errors.join('\n')}`);
    } else {
      this._animations[id] = ast;
    }
  }
  _buildPlayer(i, preStyles, postStyles) {
    const element = i.element;
    const keyframes = normalizeKeyframes(this._driver, this._normalizer, element, i.keyframes, preStyles, postStyles);
    return this._driver.animate(element, keyframes, i.duration, i.delay, i.easing, [], true);
  }
  create(id, element, options = {}) {
    const errors = [];
    const ast = this._animations[id];
    let instructions;
    const autoStylesMap = new Map();
    if (ast) {
      instructions = buildAnimationTimelines(this._driver, element, ast, ENTER_CLASSNAME, LEAVE_CLASSNAME, {}, {}, options, EMPTY_INSTRUCTION_MAP, errors);
      instructions.forEach(inst => {
        const styles = getOrSetAsInMap(autoStylesMap, inst.element, {});
        inst.postStyleProps.forEach(prop => styles[prop] = null);
      });
    } else {
      errors.push('The requested animation doesn\'t exist or has already been destroyed');
      instructions = [];
    }
    if (errors.length) {
      throw new Error(`Unable to create the animation due to the following errors: ${errors.join('\n')}`);
    }
    autoStylesMap.forEach((styles, element) => {
      Object.keys(styles).forEach(prop => {
        styles[prop] = this._driver.computeStyle(element, prop, _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .AUTO_STYLE */ .l3);
      });
    });
    const players = instructions.map(i => {
      const styles = autoStylesMap.get(i.element);
      return this._buildPlayer(i, {}, styles);
    });
    const player = optimizeGroupPlayer(players);
    this._playersById[id] = player;
    player.onDestroy(() => this.destroy(id));
    this.players.push(player);
    return player;
  }
  destroy(id) {
    const player = this._getPlayer(id);
    player.destroy();
    delete this._playersById[id];
    const index = this.players.indexOf(player);
    if (index >= 0) {
      this.players.splice(index, 1);
    }
  }
  _getPlayer(id) {
    const player = this._playersById[id];
    if (!player) {
      throw new Error(`Unable to find the timeline player referenced by ${id}`);
    }
    return player;
  }
  listen(id, element, eventName, callback) {
    // triggerName, fromState, toState are all ignored for timeline animations
    const baseEvent = makeAnimationEvent(element, '', '', '');
    listenOnPlayer(this._getPlayer(id), eventName, baseEvent, callback);
    return () => {};
  }
  command(id, element, command, args) {
    if (command == 'register') {
      this.register(id, args[0]);
      return;
    }
    if (command == 'create') {
      const options = args[0] || {};
      this.create(id, element, options);
      return;
    }
    const player = this._getPlayer(id);
    switch (command) {
      case 'play':
        player.play();
        break;
      case 'pause':
        player.pause();
        break;
      case 'reset':
        player.reset();
        break;
      case 'restart':
        player.restart();
        break;
      case 'finish':
        player.finish();
        break;
      case 'init':
        player.init();
        break;
      case 'setPosition':
        player.setPosition(parseFloat(args[0]));
        break;
      case 'destroy':
        this.destroy(id);
        break;
    }
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const QUEUED_CLASSNAME = 'ng-animate-queued';
const QUEUED_SELECTOR = '.ng-animate-queued';
const DISABLED_CLASSNAME = 'ng-animate-disabled';
const DISABLED_SELECTOR = '.ng-animate-disabled';
const STAR_CLASSNAME = 'ng-star-inserted';
const STAR_SELECTOR = '.ng-star-inserted';
const EMPTY_PLAYER_ARRAY = [];
const NULL_REMOVAL_STATE = {
  namespaceId: '',
  setForRemoval: false,
  setForMove: false,
  hasAnimation: false,
  removedBeforeQueried: false
};
const NULL_REMOVED_QUERIED_STATE = {
  namespaceId: '',
  setForMove: false,
  setForRemoval: false,
  hasAnimation: false,
  removedBeforeQueried: true
};
const REMOVAL_FLAG = '__ng_removed';
class StateValue {
  constructor(input, namespaceId = '') {
    this.namespaceId = namespaceId;
    const isObj = input && input.hasOwnProperty('value');
    const value = isObj ? input['value'] : input;
    this.value = normalizeTriggerValue(value);
    if (isObj) {
      const options = copyObj(input);
      delete options['value'];
      this.options = options;
    } else {
      this.options = {};
    }
    if (!this.options.params) {
      this.options.params = {};
    }
  }
  get params() {
    return this.options.params;
  }
  absorbOptions(options) {
    const newParams = options.params;
    if (newParams) {
      const oldParams = this.options.params;
      Object.keys(newParams).forEach(prop => {
        if (oldParams[prop] == null) {
          oldParams[prop] = newParams[prop];
        }
      });
    }
  }
}
const VOID_VALUE = 'void';
const DEFAULT_STATE_VALUE = /*#__PURE__*/new StateValue(VOID_VALUE);
class AnimationTransitionNamespace {
  constructor(id, hostElement, _engine) {
    this.id = id;
    this.hostElement = hostElement;
    this._engine = _engine;
    this.players = [];
    this._triggers = {};
    this._queue = [];
    this._elementListeners = new Map();
    this._hostClassName = 'ng-tns-' + id;
    addClass(hostElement, this._hostClassName);
  }
  listen(element, name, phase, callback) {
    if (!this._triggers.hasOwnProperty(name)) {
      throw new Error(`Unable to listen on the animation trigger event "${phase}" because the animation trigger "${name}" doesn\'t exist!`);
    }
    if (phase == null || phase.length == 0) {
      throw new Error(`Unable to listen on the animation trigger "${name}" because the provided event is undefined!`);
    }
    if (!isTriggerEventValid(phase)) {
      throw new Error(`The provided animation trigger event "${phase}" for the animation trigger "${name}" is not supported!`);
    }
    const listeners = getOrSetAsInMap(this._elementListeners, element, []);
    const data = {
      name,
      phase,
      callback
    };
    listeners.push(data);
    const triggersWithStates = getOrSetAsInMap(this._engine.statesByElement, element, {});
    if (!triggersWithStates.hasOwnProperty(name)) {
      addClass(element, NG_TRIGGER_CLASSNAME);
      addClass(element, NG_TRIGGER_CLASSNAME + '-' + name);
      triggersWithStates[name] = DEFAULT_STATE_VALUE;
    }
    return () => {
      // the event listener is removed AFTER the flush has occurred such
      // that leave animations callbacks can fire (otherwise if the node
      // is removed in between then the listeners would be deregistered)
      this._engine.afterFlush(() => {
        const index = listeners.indexOf(data);
        if (index >= 0) {
          listeners.splice(index, 1);
        }
        if (!this._triggers[name]) {
          delete triggersWithStates[name];
        }
      });
    };
  }
  register(name, ast) {
    if (this._triggers[name]) {
      // throw
      return false;
    } else {
      this._triggers[name] = ast;
      return true;
    }
  }
  _getTrigger(name) {
    const trigger = this._triggers[name];
    if (!trigger) {
      throw new Error(`The provided animation trigger "${name}" has not been registered!`);
    }
    return trigger;
  }
  trigger(element, triggerName, value, defaultToFallback = true) {
    const trigger = this._getTrigger(triggerName);
    const player = new TransitionAnimationPlayer(this.id, triggerName, element);
    let triggersWithStates = this._engine.statesByElement.get(element);
    if (!triggersWithStates) {
      addClass(element, NG_TRIGGER_CLASSNAME);
      addClass(element, NG_TRIGGER_CLASSNAME + '-' + triggerName);
      this._engine.statesByElement.set(element, triggersWithStates = {});
    }
    let fromState = triggersWithStates[triggerName];
    const toState = new StateValue(value, this.id);
    const isObj = value && value.hasOwnProperty('value');
    if (!isObj && fromState) {
      toState.absorbOptions(fromState.options);
    }
    triggersWithStates[triggerName] = toState;
    if (!fromState) {
      fromState = DEFAULT_STATE_VALUE;
    }
    const isRemoval = toState.value === VOID_VALUE;
    // normally this isn't reached by here, however, if an object expression
    // is passed in then it may be a new object each time. Comparing the value
    // is important since that will stay the same despite there being a new object.
    // The removal arc here is special cased because the same element is triggered
    // twice in the event that it contains animations on the outer/inner portions
    // of the host container
    if (!isRemoval && fromState.value === toState.value) {
      // this means that despite the value not changing, some inner params
      // have changed which means that the animation final styles need to be applied
      if (!objEquals(fromState.params, toState.params)) {
        const errors = [];
        const fromStyles = trigger.matchStyles(fromState.value, fromState.params, errors);
        const toStyles = trigger.matchStyles(toState.value, toState.params, errors);
        if (errors.length) {
          this._engine.reportError(errors);
        } else {
          this._engine.afterFlush(() => {
            eraseStyles(element, fromStyles);
            setStyles(element, toStyles);
          });
        }
      }
      return;
    }
    const playersOnElement = getOrSetAsInMap(this._engine.playersByElement, element, []);
    playersOnElement.forEach(player => {
      // only remove the player if it is queued on the EXACT same trigger/namespace
      // we only also deal with queued players here because if the animation has
      // started then we want to keep the player alive until the flush happens
      // (which is where the previousPlayers are passed into the new palyer)
      if (player.namespaceId == this.id && player.triggerName == triggerName && player.queued) {
        player.destroy();
      }
    });
    let transition = trigger.matchTransition(fromState.value, toState.value, element, toState.params);
    let isFallbackTransition = false;
    if (!transition) {
      if (!defaultToFallback) return;
      transition = trigger.fallbackTransition;
      isFallbackTransition = true;
    }
    this._engine.totalQueuedPlayers++;
    this._queue.push({
      element,
      triggerName,
      transition,
      fromState,
      toState,
      player,
      isFallbackTransition
    });
    if (!isFallbackTransition) {
      addClass(element, QUEUED_CLASSNAME);
      player.onStart(() => {
        removeClass(element, QUEUED_CLASSNAME);
      });
    }
    player.onDone(() => {
      let index = this.players.indexOf(player);
      if (index >= 0) {
        this.players.splice(index, 1);
      }
      const players = this._engine.playersByElement.get(element);
      if (players) {
        let index = players.indexOf(player);
        if (index >= 0) {
          players.splice(index, 1);
        }
      }
    });
    this.players.push(player);
    playersOnElement.push(player);
    return player;
  }
  deregister(name) {
    delete this._triggers[name];
    this._engine.statesByElement.forEach((stateMap, element) => {
      delete stateMap[name];
    });
    this._elementListeners.forEach((listeners, element) => {
      this._elementListeners.set(element, listeners.filter(entry => {
        return entry.name != name;
      }));
    });
  }
  clearElementCache(element) {
    this._engine.statesByElement.delete(element);
    this._elementListeners.delete(element);
    const elementPlayers = this._engine.playersByElement.get(element);
    if (elementPlayers) {
      elementPlayers.forEach(player => player.destroy());
      this._engine.playersByElement.delete(element);
    }
  }
  _signalRemovalForInnerTriggers(rootElement, context) {
    const elements = this._engine.driver.query(rootElement, NG_TRIGGER_SELECTOR, true);
    // emulate a leave animation for all inner nodes within this node.
    // If there are no animations found for any of the nodes then clear the cache
    // for the element.
    elements.forEach(elm => {
      // this means that an inner remove() operation has already kicked off
      // the animation on this element...
      if (elm[REMOVAL_FLAG]) return;
      const namespaces = this._engine.fetchNamespacesByElement(elm);
      if (namespaces.size) {
        namespaces.forEach(ns => ns.triggerLeaveAnimation(elm, context, false, true));
      } else {
        this.clearElementCache(elm);
      }
    });
    // If the child elements were removed along with the parent, their animations might not
    // have completed. Clear all the elements from the cache so we don't end up with a memory leak.
    this._engine.afterFlushAnimationsDone(() => elements.forEach(elm => this.clearElementCache(elm)));
  }
  triggerLeaveAnimation(element, context, destroyAfterComplete, defaultToFallback) {
    const triggerStates = this._engine.statesByElement.get(element);
    if (triggerStates) {
      const players = [];
      Object.keys(triggerStates).forEach(triggerName => {
        // this check is here in the event that an element is removed
        // twice (both on the host level and the component level)
        if (this._triggers[triggerName]) {
          const player = this.trigger(element, triggerName, VOID_VALUE, defaultToFallback);
          if (player) {
            players.push(player);
          }
        }
      });
      if (players.length) {
        this._engine.markElementAsRemoved(this.id, element, true, context);
        if (destroyAfterComplete) {
          optimizeGroupPlayer(players).onDone(() => this._engine.processLeaveNode(element));
        }
        return true;
      }
    }
    return false;
  }
  prepareLeaveAnimationListeners(element) {
    const listeners = this._elementListeners.get(element);
    const elementStates = this._engine.statesByElement.get(element);
    // if this statement fails then it means that the element was picked up
    // by an earlier flush (or there are no listeners at all to track the leave).
    if (listeners && elementStates) {
      const visitedTriggers = new Set();
      listeners.forEach(listener => {
        const triggerName = listener.name;
        if (visitedTriggers.has(triggerName)) return;
        visitedTriggers.add(triggerName);
        const trigger = this._triggers[triggerName];
        const transition = trigger.fallbackTransition;
        const fromState = elementStates[triggerName] || DEFAULT_STATE_VALUE;
        const toState = new StateValue(VOID_VALUE);
        const player = new TransitionAnimationPlayer(this.id, triggerName, element);
        this._engine.totalQueuedPlayers++;
        this._queue.push({
          element,
          triggerName,
          transition,
          fromState,
          toState,
          player,
          isFallbackTransition: true
        });
      });
    }
  }
  removeNode(element, context) {
    const engine = this._engine;
    if (element.childElementCount) {
      this._signalRemovalForInnerTriggers(element, context);
    }
    // this means that a * => VOID animation was detected and kicked off
    if (this.triggerLeaveAnimation(element, context, true)) return;
    // find the player that is animating and make sure that the
    // removal is delayed until that player has completed
    let containsPotentialParentTransition = false;
    if (engine.totalAnimations) {
      const currentPlayers = engine.players.length ? engine.playersByQueriedElement.get(element) : [];
      // when this `if statement` does not continue forward it means that
      // a previous animation query has selected the current element and
      // is animating it. In this situation want to continue forwards and
      // allow the element to be queued up for animation later.
      if (currentPlayers && currentPlayers.length) {
        containsPotentialParentTransition = true;
      } else {
        let parent = element;
        while (parent = parent.parentNode) {
          const triggers = engine.statesByElement.get(parent);
          if (triggers) {
            containsPotentialParentTransition = true;
            break;
          }
        }
      }
    }
    // at this stage we know that the element will either get removed
    // during flush or will be picked up by a parent query. Either way
    // we need to fire the listeners for this element when it DOES get
    // removed (once the query parent animation is done or after flush)
    this.prepareLeaveAnimationListeners(element);
    // whether or not a parent has an animation we need to delay the deferral of the leave
    // operation until we have more information (which we do after flush() has been called)
    if (containsPotentialParentTransition) {
      engine.markElementAsRemoved(this.id, element, false, context);
    } else {
      const removalFlag = element[REMOVAL_FLAG];
      if (!removalFlag || removalFlag === NULL_REMOVAL_STATE) {
        // we do this after the flush has occurred such
        // that the callbacks can be fired
        engine.afterFlush(() => this.clearElementCache(element));
        engine.destroyInnerAnimations(element);
        engine._onRemovalComplete(element, context);
      }
    }
  }
  insertNode(element, parent) {
    addClass(element, this._hostClassName);
  }
  drainQueuedTransitions(microtaskId) {
    const instructions = [];
    this._queue.forEach(entry => {
      const player = entry.player;
      if (player.destroyed) return;
      const element = entry.element;
      const listeners = this._elementListeners.get(element);
      if (listeners) {
        listeners.forEach(listener => {
          if (listener.name == entry.triggerName) {
            const baseEvent = makeAnimationEvent(element, entry.triggerName, entry.fromState.value, entry.toState.value);
            baseEvent['_data'] = microtaskId;
            listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);
          }
        });
      }
      if (player.markedForDestroy) {
        this._engine.afterFlush(() => {
          // now we can destroy the element properly since the event listeners have
          // been bound to the player
          player.destroy();
        });
      } else {
        instructions.push(entry);
      }
    });
    this._queue = [];
    return instructions.sort((a, b) => {
      // if depCount == 0 them move to front
      // otherwise if a contains b then move back
      const d0 = a.transition.ast.depCount;
      const d1 = b.transition.ast.depCount;
      if (d0 == 0 || d1 == 0) {
        return d0 - d1;
      }
      return this._engine.driver.containsElement(a.element, b.element) ? 1 : -1;
    });
  }
  destroy(context) {
    this.players.forEach(p => p.destroy());
    this._signalRemovalForInnerTriggers(this.hostElement, context);
  }
  elementContainsData(element) {
    let containsData = false;
    if (this._elementListeners.has(element)) containsData = true;
    containsData = (this._queue.find(entry => entry.element === element) ? true : false) || containsData;
    return containsData;
  }
}
class TransitionAnimationEngine {
  constructor(bodyNode, driver, _normalizer) {
    this.bodyNode = bodyNode;
    this.driver = driver;
    this._normalizer = _normalizer;
    this.players = [];
    this.newHostElements = new Map();
    this.playersByElement = new Map();
    this.playersByQueriedElement = new Map();
    this.statesByElement = new Map();
    this.disabledNodes = new Set();
    this.totalAnimations = 0;
    this.totalQueuedPlayers = 0;
    this._namespaceLookup = {};
    this._namespaceList = [];
    this._flushFns = [];
    this._whenQuietFns = [];
    this.namespacesByHostElement = new Map();
    this.collectedEnterElements = [];
    this.collectedLeaveElements = [];
    // this method is designed to be overridden by the code that uses this engine
    this.onRemovalComplete = (element, context) => {};
  }
  /** @internal */
  _onRemovalComplete(element, context) {
    this.onRemovalComplete(element, context);
  }
  get queuedPlayers() {
    const players = [];
    this._namespaceList.forEach(ns => {
      ns.players.forEach(player => {
        if (player.queued) {
          players.push(player);
        }
      });
    });
    return players;
  }
  createNamespace(namespaceId, hostElement) {
    const ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);
    if (this.bodyNode && this.driver.containsElement(this.bodyNode, hostElement)) {
      this._balanceNamespaceList(ns, hostElement);
    } else {
      // defer this later until flush during when the host element has
      // been inserted so that we know exactly where to place it in
      // the namespace list
      this.newHostElements.set(hostElement, ns);
      // given that this host element is apart of the animation code, it
      // may or may not be inserted by a parent node that is of an
      // animation renderer type. If this happens then we can still have
      // access to this item when we query for :enter nodes. If the parent
      // is a renderer then the set data-structure will normalize the entry
      this.collectEnterElement(hostElement);
    }
    return this._namespaceLookup[namespaceId] = ns;
  }
  _balanceNamespaceList(ns, hostElement) {
    const limit = this._namespaceList.length - 1;
    if (limit >= 0) {
      let found = false;
      for (let i = limit; i >= 0; i--) {
        const nextNamespace = this._namespaceList[i];
        if (this.driver.containsElement(nextNamespace.hostElement, hostElement)) {
          this._namespaceList.splice(i + 1, 0, ns);
          found = true;
          break;
        }
      }
      if (!found) {
        this._namespaceList.splice(0, 0, ns);
      }
    } else {
      this._namespaceList.push(ns);
    }
    this.namespacesByHostElement.set(hostElement, ns);
    return ns;
  }
  register(namespaceId, hostElement) {
    let ns = this._namespaceLookup[namespaceId];
    if (!ns) {
      ns = this.createNamespace(namespaceId, hostElement);
    }
    return ns;
  }
  registerTrigger(namespaceId, name, trigger) {
    let ns = this._namespaceLookup[namespaceId];
    if (ns && ns.register(name, trigger)) {
      this.totalAnimations++;
    }
  }
  destroy(namespaceId, context) {
    if (!namespaceId) return;
    const ns = this._fetchNamespace(namespaceId);
    this.afterFlush(() => {
      this.namespacesByHostElement.delete(ns.hostElement);
      delete this._namespaceLookup[namespaceId];
      const index = this._namespaceList.indexOf(ns);
      if (index >= 0) {
        this._namespaceList.splice(index, 1);
      }
    });
    this.afterFlushAnimationsDone(() => ns.destroy(context));
  }
  _fetchNamespace(id) {
    return this._namespaceLookup[id];
  }
  fetchNamespacesByElement(element) {
    // normally there should only be one namespace per element, however
    // if @triggers are placed on both the component element and then
    // its host element (within the component code) then there will be
    // two namespaces returned. We use a set here to simply the dedupe
    // of namespaces incase there are multiple triggers both the elm and host
    const namespaces = new Set();
    const elementStates = this.statesByElement.get(element);
    if (elementStates) {
      const keys = Object.keys(elementStates);
      for (let i = 0; i < keys.length; i++) {
        const nsId = elementStates[keys[i]].namespaceId;
        if (nsId) {
          const ns = this._fetchNamespace(nsId);
          if (ns) {
            namespaces.add(ns);
          }
        }
      }
    }
    return namespaces;
  }
  trigger(namespaceId, element, name, value) {
    if (isElementNode(element)) {
      const ns = this._fetchNamespace(namespaceId);
      if (ns) {
        ns.trigger(element, name, value);
        return true;
      }
    }
    return false;
  }
  insertNode(namespaceId, element, parent, insertBefore) {
    if (!isElementNode(element)) return;
    // special case for when an element is removed and reinserted (move operation)
    // when this occurs we do not want to use the element for deletion later
    const details = element[REMOVAL_FLAG];
    if (details && details.setForRemoval) {
      details.setForRemoval = false;
      details.setForMove = true;
      const index = this.collectedLeaveElements.indexOf(element);
      if (index >= 0) {
        this.collectedLeaveElements.splice(index, 1);
      }
    }
    // in the event that the namespaceId is blank then the caller
    // code does not contain any animation code in it, but it is
    // just being called so that the node is marked as being inserted
    if (namespaceId) {
      const ns = this._fetchNamespace(namespaceId);
      // This if-statement is a workaround for router issue #21947.
      // The router sometimes hits a race condition where while a route
      // is being instantiated a new navigation arrives, triggering leave
      // animation of DOM that has not been fully initialized, until this
      // is resolved, we need to handle the scenario when DOM is not in a
      // consistent state during the animation.
      if (ns) {
        ns.insertNode(element, parent);
      }
    }
    // only *directives and host elements are inserted before
    if (insertBefore) {
      this.collectEnterElement(element);
    }
  }
  collectEnterElement(element) {
    this.collectedEnterElements.push(element);
  }
  markElementAsDisabled(element, value) {
    if (value) {
      if (!this.disabledNodes.has(element)) {
        this.disabledNodes.add(element);
        addClass(element, DISABLED_CLASSNAME);
      }
    } else if (this.disabledNodes.has(element)) {
      this.disabledNodes.delete(element);
      removeClass(element, DISABLED_CLASSNAME);
    }
  }
  removeNode(namespaceId, element, isHostElement, context) {
    if (isElementNode(element)) {
      const ns = namespaceId ? this._fetchNamespace(namespaceId) : null;
      if (ns) {
        ns.removeNode(element, context);
      } else {
        this.markElementAsRemoved(namespaceId, element, false, context);
      }
      if (isHostElement) {
        const hostNS = this.namespacesByHostElement.get(element);
        if (hostNS && hostNS.id !== namespaceId) {
          hostNS.removeNode(element, context);
        }
      }
    } else {
      this._onRemovalComplete(element, context);
    }
  }
  markElementAsRemoved(namespaceId, element, hasAnimation, context) {
    this.collectedLeaveElements.push(element);
    element[REMOVAL_FLAG] = {
      namespaceId,
      setForRemoval: context,
      hasAnimation,
      removedBeforeQueried: false
    };
  }
  listen(namespaceId, element, name, phase, callback) {
    if (isElementNode(element)) {
      return this._fetchNamespace(namespaceId).listen(element, name, phase, callback);
    }
    return () => {};
  }
  _buildInstruction(entry, subTimelines, enterClassName, leaveClassName, skipBuildAst) {
    return entry.transition.build(this.driver, entry.element, entry.fromState.value, entry.toState.value, enterClassName, leaveClassName, entry.fromState.options, entry.toState.options, subTimelines, skipBuildAst);
  }
  destroyInnerAnimations(containerElement) {
    let elements = this.driver.query(containerElement, NG_TRIGGER_SELECTOR, true);
    elements.forEach(element => this.destroyActiveAnimationsForElement(element));
    if (this.playersByQueriedElement.size == 0) return;
    elements = this.driver.query(containerElement, NG_ANIMATING_SELECTOR, true);
    elements.forEach(element => this.finishActiveQueriedAnimationOnElement(element));
  }
  destroyActiveAnimationsForElement(element) {
    const players = this.playersByElement.get(element);
    if (players) {
      players.forEach(player => {
        // special case for when an element is set for destruction, but hasn't started.
        // in this situation we want to delay the destruction until the flush occurs
        // so that any event listeners attached to the player are triggered.
        if (player.queued) {
          player.markedForDestroy = true;
        } else {
          player.destroy();
        }
      });
    }
  }
  finishActiveQueriedAnimationOnElement(element) {
    const players = this.playersByQueriedElement.get(element);
    if (players) {
      players.forEach(player => player.finish());
    }
  }
  whenRenderingDone() {
    return new Promise(resolve => {
      if (this.players.length) {
        return optimizeGroupPlayer(this.players).onDone(() => resolve());
      } else {
        resolve();
      }
    });
  }
  processLeaveNode(element) {
    const details = element[REMOVAL_FLAG];
    if (details && details.setForRemoval) {
      // this will prevent it from removing it twice
      element[REMOVAL_FLAG] = NULL_REMOVAL_STATE;
      if (details.namespaceId) {
        this.destroyInnerAnimations(element);
        const ns = this._fetchNamespace(details.namespaceId);
        if (ns) {
          ns.clearElementCache(element);
        }
      }
      this._onRemovalComplete(element, details.setForRemoval);
    }
    if (this.driver.matchesElement(element, DISABLED_SELECTOR)) {
      this.markElementAsDisabled(element, false);
    }
    this.driver.query(element, DISABLED_SELECTOR, true).forEach(node => {
      this.markElementAsDisabled(node, false);
    });
  }
  flush(microtaskId = -1) {
    let players = [];
    if (this.newHostElements.size) {
      this.newHostElements.forEach((ns, element) => this._balanceNamespaceList(ns, element));
      this.newHostElements.clear();
    }
    if (this.totalAnimations && this.collectedEnterElements.length) {
      for (let i = 0; i < this.collectedEnterElements.length; i++) {
        const elm = this.collectedEnterElements[i];
        addClass(elm, STAR_CLASSNAME);
      }
    }
    if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {
      const cleanupFns = [];
      try {
        players = this._flushAnimations(cleanupFns, microtaskId);
      } finally {
        for (let i = 0; i < cleanupFns.length; i++) {
          cleanupFns[i]();
        }
      }
    } else {
      for (let i = 0; i < this.collectedLeaveElements.length; i++) {
        const element = this.collectedLeaveElements[i];
        this.processLeaveNode(element);
      }
    }
    this.totalQueuedPlayers = 0;
    this.collectedEnterElements.length = 0;
    this.collectedLeaveElements.length = 0;
    this._flushFns.forEach(fn => fn());
    this._flushFns = [];
    if (this._whenQuietFns.length) {
      // we move these over to a variable so that
      // if any new callbacks are registered in another
      // flush they do not populate the existing set
      const quietFns = this._whenQuietFns;
      this._whenQuietFns = [];
      if (players.length) {
        optimizeGroupPlayer(players).onDone(() => {
          quietFns.forEach(fn => fn());
        });
      } else {
        quietFns.forEach(fn => fn());
      }
    }
  }
  reportError(errors) {
    throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${errors.join('\n')}`);
  }
  _flushAnimations(cleanupFns, microtaskId) {
    const subTimelines = new ElementInstructionMap();
    const skippedPlayers = [];
    const skippedPlayersMap = new Map();
    const queuedInstructions = [];
    const queriedElements = new Map();
    const allPreStyleElements = new Map();
    const allPostStyleElements = new Map();
    const disabledElementsSet = new Set();
    this.disabledNodes.forEach(node => {
      disabledElementsSet.add(node);
      const nodesThatAreDisabled = this.driver.query(node, QUEUED_SELECTOR, true);
      for (let i = 0; i < nodesThatAreDisabled.length; i++) {
        disabledElementsSet.add(nodesThatAreDisabled[i]);
      }
    });
    const bodyNode = this.bodyNode;
    const allTriggerElements = Array.from(this.statesByElement.keys());
    const enterNodeMap = buildRootMap(allTriggerElements, this.collectedEnterElements);
    // this must occur before the instructions are built below such that
    // the :enter queries match the elements (since the timeline queries
    // are fired during instruction building).
    const enterNodeMapIds = new Map();
    let i = 0;
    enterNodeMap.forEach((nodes, root) => {
      const className = ENTER_CLASSNAME + i++;
      enterNodeMapIds.set(root, className);
      nodes.forEach(node => addClass(node, className));
    });
    const allLeaveNodes = [];
    const mergedLeaveNodes = new Set();
    const leaveNodesWithoutAnimations = new Set();
    for (let i = 0; i < this.collectedLeaveElements.length; i++) {
      const element = this.collectedLeaveElements[i];
      const details = element[REMOVAL_FLAG];
      if (details && details.setForRemoval) {
        allLeaveNodes.push(element);
        mergedLeaveNodes.add(element);
        if (details.hasAnimation) {
          this.driver.query(element, STAR_SELECTOR, true).forEach(elm => mergedLeaveNodes.add(elm));
        } else {
          leaveNodesWithoutAnimations.add(element);
        }
      }
    }
    const leaveNodeMapIds = new Map();
    const leaveNodeMap = buildRootMap(allTriggerElements, Array.from(mergedLeaveNodes));
    leaveNodeMap.forEach((nodes, root) => {
      const className = LEAVE_CLASSNAME + i++;
      leaveNodeMapIds.set(root, className);
      nodes.forEach(node => addClass(node, className));
    });
    cleanupFns.push(() => {
      enterNodeMap.forEach((nodes, root) => {
        const className = enterNodeMapIds.get(root);
        nodes.forEach(node => removeClass(node, className));
      });
      leaveNodeMap.forEach((nodes, root) => {
        const className = leaveNodeMapIds.get(root);
        nodes.forEach(node => removeClass(node, className));
      });
      allLeaveNodes.forEach(element => {
        this.processLeaveNode(element);
      });
    });
    const allPlayers = [];
    const erroneousTransitions = [];
    for (let i = this._namespaceList.length - 1; i >= 0; i--) {
      const ns = this._namespaceList[i];
      ns.drainQueuedTransitions(microtaskId).forEach(entry => {
        const player = entry.player;
        const element = entry.element;
        allPlayers.push(player);
        if (this.collectedEnterElements.length) {
          const details = element[REMOVAL_FLAG];
          // move animations are currently not supported...
          if (details && details.setForMove) {
            player.destroy();
            return;
          }
        }
        const nodeIsOrphaned = !bodyNode || !this.driver.containsElement(bodyNode, element);
        const leaveClassName = leaveNodeMapIds.get(element);
        const enterClassName = enterNodeMapIds.get(element);
        const instruction = this._buildInstruction(entry, subTimelines, enterClassName, leaveClassName, nodeIsOrphaned);
        if (instruction.errors && instruction.errors.length) {
          erroneousTransitions.push(instruction);
          return;
        }
        // even though the element may not be apart of the DOM, it may
        // still be added at a later point (due to the mechanics of content
        // projection and/or dynamic component insertion) therefore it's
        // important we still style the element.
        if (nodeIsOrphaned) {
          player.onStart(() => eraseStyles(element, instruction.fromStyles));
          player.onDestroy(() => setStyles(element, instruction.toStyles));
          skippedPlayers.push(player);
          return;
        }
        // if a unmatched transition is queued to go then it SHOULD NOT render
        // an animation and cancel the previously running animations.
        if (entry.isFallbackTransition) {
          player.onStart(() => eraseStyles(element, instruction.fromStyles));
          player.onDestroy(() => setStyles(element, instruction.toStyles));
          skippedPlayers.push(player);
          return;
        }
        // this means that if a parent animation uses this animation as a sub trigger
        // then it will instruct the timeline builder to not add a player delay, but
        // instead stretch the first keyframe gap up until the animation starts. The
        // reason this is important is to prevent extra initialization styles from being
        // required by the user in the animation.
        instruction.timelines.forEach(tl => tl.stretchStartingKeyframe = true);
        subTimelines.append(element, instruction.timelines);
        const tuple = {
          instruction,
          player,
          element
        };
        queuedInstructions.push(tuple);
        instruction.queriedElements.forEach(element => getOrSetAsInMap(queriedElements, element, []).push(player));
        instruction.preStyleProps.forEach((stringMap, element) => {
          const props = Object.keys(stringMap);
          if (props.length) {
            let setVal = allPreStyleElements.get(element);
            if (!setVal) {
              allPreStyleElements.set(element, setVal = new Set());
            }
            props.forEach(prop => setVal.add(prop));
          }
        });
        instruction.postStyleProps.forEach((stringMap, element) => {
          const props = Object.keys(stringMap);
          let setVal = allPostStyleElements.get(element);
          if (!setVal) {
            allPostStyleElements.set(element, setVal = new Set());
          }
          props.forEach(prop => setVal.add(prop));
        });
      });
    }
    if (erroneousTransitions.length) {
      const errors = [];
      erroneousTransitions.forEach(instruction => {
        errors.push(`@${instruction.triggerName} has failed due to:\n`);
        instruction.errors.forEach(error => errors.push(`- ${error}\n`));
      });
      allPlayers.forEach(player => player.destroy());
      this.reportError(errors);
    }
    const allPreviousPlayersMap = new Map();
    // this map works to tell which element in the DOM tree is contained by
    // which animation. Further down below this map will get populated once
    // the players are built and in doing so it can efficiently figure out
    // if a sub player is skipped due to a parent player having priority.
    const animationElementMap = new Map();
    queuedInstructions.forEach(entry => {
      const element = entry.element;
      if (subTimelines.has(element)) {
        animationElementMap.set(element, element);
        this._beforeAnimationBuild(entry.player.namespaceId, entry.instruction, allPreviousPlayersMap);
      }
    });
    skippedPlayers.forEach(player => {
      const element = player.element;
      const previousPlayers = this._getPreviousPlayers(element, false, player.namespaceId, player.triggerName, null);
      previousPlayers.forEach(prevPlayer => {
        getOrSetAsInMap(allPreviousPlayersMap, element, []).push(prevPlayer);
        prevPlayer.destroy();
      });
    });
    // this is a special case for nodes that will be removed (either by)
    // having their own leave animations or by being queried in a container
    // that will be removed once a parent animation is complete. The idea
    // here is that * styles must be identical to ! styles because of
    // backwards compatibility (* is also filled in by default in many places).
    // Otherwise * styles will return an empty value or auto since the element
    // that is being getComputedStyle'd will not be visible (since * = destination)
    const replaceNodes = allLeaveNodes.filter(node => {
      return replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements);
    });
    // POST STAGE: fill the * styles
    const postStylesMap = new Map();
    const allLeaveQueriedNodes = cloakAndComputeStyles(postStylesMap, this.driver, leaveNodesWithoutAnimations, allPostStyleElements, _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .AUTO_STYLE */ .l3);
    allLeaveQueriedNodes.forEach(node => {
      if (replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements)) {
        replaceNodes.push(node);
      }
    });
    // PRE STAGE: fill the ! styles
    const preStylesMap = new Map();
    enterNodeMap.forEach((nodes, root) => {
      cloakAndComputeStyles(preStylesMap, this.driver, new Set(nodes), allPreStyleElements, _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* ["ɵPRE_STYLE"] */ .k1);
    });
    replaceNodes.forEach(node => {
      const post = postStylesMap.get(node);
      const pre = preStylesMap.get(node);
      postStylesMap.set(node, Object.assign(Object.assign({}, post), pre));
    });
    const rootPlayers = [];
    const subPlayers = [];
    const NO_PARENT_ANIMATION_ELEMENT_DETECTED = {};
    queuedInstructions.forEach(entry => {
      const {
        element,
        player,
        instruction
      } = entry;
      // this means that it was never consumed by a parent animation which
      // means that it is independent and therefore should be set for animation
      if (subTimelines.has(element)) {
        if (disabledElementsSet.has(element)) {
          player.onDestroy(() => setStyles(element, instruction.toStyles));
          player.disabled = true;
          player.overrideTotalTime(instruction.totalTime);
          skippedPlayers.push(player);
          return;
        }
        // this will flow up the DOM and query the map to figure out
        // if a parent animation has priority over it. In the situation
        // that a parent is detected then it will cancel the loop. If
        // nothing is detected, or it takes a few hops to find a parent,
        // then it will fill in the missing nodes and signal them as having
        // a detected parent (or a NO_PARENT value via a special constant).
        let parentWithAnimation = NO_PARENT_ANIMATION_ELEMENT_DETECTED;
        if (animationElementMap.size > 1) {
          let elm = element;
          const parentsToAdd = [];
          while (elm = elm.parentNode) {
            const detectedParent = animationElementMap.get(elm);
            if (detectedParent) {
              parentWithAnimation = detectedParent;
              break;
            }
            parentsToAdd.push(elm);
          }
          parentsToAdd.forEach(parent => animationElementMap.set(parent, parentWithAnimation));
        }
        const innerPlayer = this._buildAnimation(player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap);
        player.setRealPlayer(innerPlayer);
        if (parentWithAnimation === NO_PARENT_ANIMATION_ELEMENT_DETECTED) {
          rootPlayers.push(player);
        } else {
          const parentPlayers = this.playersByElement.get(parentWithAnimation);
          if (parentPlayers && parentPlayers.length) {
            player.parentPlayer = optimizeGroupPlayer(parentPlayers);
          }
          skippedPlayers.push(player);
        }
      } else {
        eraseStyles(element, instruction.fromStyles);
        player.onDestroy(() => setStyles(element, instruction.toStyles));
        // there still might be a ancestor player animating this
        // element therefore we will still add it as a sub player
        // even if its animation may be disabled
        subPlayers.push(player);
        if (disabledElementsSet.has(element)) {
          skippedPlayers.push(player);
        }
      }
    });
    // find all of the sub players' corresponding inner animation player
    subPlayers.forEach(player => {
      // even if any players are not found for a sub animation then it
      // will still complete itself after the next tick since it's Noop
      const playersForElement = skippedPlayersMap.get(player.element);
      if (playersForElement && playersForElement.length) {
        const innerPlayer = optimizeGroupPlayer(playersForElement);
        player.setRealPlayer(innerPlayer);
      }
    });
    // the reason why we don't actually play the animation is
    // because all that a skipped player is designed to do is to
    // fire the start/done transition callback events
    skippedPlayers.forEach(player => {
      if (player.parentPlayer) {
        player.syncPlayerEvents(player.parentPlayer);
      } else {
        player.destroy();
      }
    });
    // run through all of the queued removals and see if they
    // were picked up by a query. If not then perform the removal
    // operation right away unless a parent animation is ongoing.
    for (let i = 0; i < allLeaveNodes.length; i++) {
      const element = allLeaveNodes[i];
      const details = element[REMOVAL_FLAG];
      removeClass(element, LEAVE_CLASSNAME);
      // this means the element has a removal animation that is being
      // taken care of and therefore the inner elements will hang around
      // until that animation is over (or the parent queried animation)
      if (details && details.hasAnimation) continue;
      let players = [];
      // if this element is queried or if it contains queried children
      // then we want for the element not to be removed from the page
      // until the queried animations have finished
      if (queriedElements.size) {
        let queriedPlayerResults = queriedElements.get(element);
        if (queriedPlayerResults && queriedPlayerResults.length) {
          players.push(...queriedPlayerResults);
        }
        let queriedInnerElements = this.driver.query(element, NG_ANIMATING_SELECTOR, true);
        for (let j = 0; j < queriedInnerElements.length; j++) {
          let queriedPlayers = queriedElements.get(queriedInnerElements[j]);
          if (queriedPlayers && queriedPlayers.length) {
            players.push(...queriedPlayers);
          }
        }
      }
      const activePlayers = players.filter(p => !p.destroyed);
      if (activePlayers.length) {
        removeNodesAfterAnimationDone(this, element, activePlayers);
      } else {
        this.processLeaveNode(element);
      }
    }
    // this is required so the cleanup method doesn't remove them
    allLeaveNodes.length = 0;
    rootPlayers.forEach(player => {
      this.players.push(player);
      player.onDone(() => {
        player.destroy();
        const index = this.players.indexOf(player);
        this.players.splice(index, 1);
      });
      player.play();
    });
    return rootPlayers;
  }
  elementContainsData(namespaceId, element) {
    let containsData = false;
    const details = element[REMOVAL_FLAG];
    if (details && details.setForRemoval) containsData = true;
    if (this.playersByElement.has(element)) containsData = true;
    if (this.playersByQueriedElement.has(element)) containsData = true;
    if (this.statesByElement.has(element)) containsData = true;
    return this._fetchNamespace(namespaceId).elementContainsData(element) || containsData;
  }
  afterFlush(callback) {
    this._flushFns.push(callback);
  }
  afterFlushAnimationsDone(callback) {
    this._whenQuietFns.push(callback);
  }
  _getPreviousPlayers(element, isQueriedElement, namespaceId, triggerName, toStateValue) {
    let players = [];
    if (isQueriedElement) {
      const queriedElementPlayers = this.playersByQueriedElement.get(element);
      if (queriedElementPlayers) {
        players = queriedElementPlayers;
      }
    } else {
      const elementPlayers = this.playersByElement.get(element);
      if (elementPlayers) {
        const isRemovalAnimation = !toStateValue || toStateValue == VOID_VALUE;
        elementPlayers.forEach(player => {
          if (player.queued) return;
          if (!isRemovalAnimation && player.triggerName != triggerName) return;
          players.push(player);
        });
      }
    }
    if (namespaceId || triggerName) {
      players = players.filter(player => {
        if (namespaceId && namespaceId != player.namespaceId) return false;
        if (triggerName && triggerName != player.triggerName) return false;
        return true;
      });
    }
    return players;
  }
  _beforeAnimationBuild(namespaceId, instruction, allPreviousPlayersMap) {
    const triggerName = instruction.triggerName;
    const rootElement = instruction.element;
    // when a removal animation occurs, ALL previous players are collected
    // and destroyed (even if they are outside of the current namespace)
    const targetNameSpaceId = instruction.isRemovalTransition ? undefined : namespaceId;
    const targetTriggerName = instruction.isRemovalTransition ? undefined : triggerName;
    for (const timelineInstruction of instruction.timelines) {
      const element = timelineInstruction.element;
      const isQueriedElement = element !== rootElement;
      const players = getOrSetAsInMap(allPreviousPlayersMap, element, []);
      const previousPlayers = this._getPreviousPlayers(element, isQueriedElement, targetNameSpaceId, targetTriggerName, instruction.toState);
      previousPlayers.forEach(player => {
        const realPlayer = player.getRealPlayer();
        if (realPlayer.beforeDestroy) {
          realPlayer.beforeDestroy();
        }
        player.destroy();
        players.push(player);
      });
    }
    // this needs to be done so that the PRE/POST styles can be
    // computed properly without interfering with the previous animation
    eraseStyles(rootElement, instruction.fromStyles);
  }
  _buildAnimation(namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap) {
    const triggerName = instruction.triggerName;
    const rootElement = instruction.element;
    // we first run this so that the previous animation player
    // data can be passed into the successive animation players
    const allQueriedPlayers = [];
    const allConsumedElements = new Set();
    const allSubElements = new Set();
    const allNewPlayers = instruction.timelines.map(timelineInstruction => {
      const element = timelineInstruction.element;
      allConsumedElements.add(element);
      // FIXME (matsko): make sure to-be-removed animations are removed properly
      const details = element[REMOVAL_FLAG];
      if (details && details.removedBeforeQueried) return new _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .NoopAnimationPlayer */ .ZN(timelineInstruction.duration, timelineInstruction.delay);
      const isQueriedElement = element !== rootElement;
      const previousPlayers = flattenGroupPlayers((allPreviousPlayersMap.get(element) || EMPTY_PLAYER_ARRAY).map(p => p.getRealPlayer())).filter(p => {
        // the `element` is not apart of the AnimationPlayer definition, but
        // Mock/WebAnimations
        // use the element within their implementation. This will be added in Angular5 to
        // AnimationPlayer
        const pp = p;
        return pp.element ? pp.element === element : false;
      });
      const preStyles = preStylesMap.get(element);
      const postStyles = postStylesMap.get(element);
      const keyframes = normalizeKeyframes(this.driver, this._normalizer, element, timelineInstruction.keyframes, preStyles, postStyles);
      const player = this._buildPlayer(timelineInstruction, keyframes, previousPlayers);
      // this means that this particular player belongs to a sub trigger. It is
      // important that we match this player up with the corresponding (@trigger.listener)
      if (timelineInstruction.subTimeline && skippedPlayersMap) {
        allSubElements.add(element);
      }
      if (isQueriedElement) {
        const wrappedPlayer = new TransitionAnimationPlayer(namespaceId, triggerName, element);
        wrappedPlayer.setRealPlayer(player);
        allQueriedPlayers.push(wrappedPlayer);
      }
      return player;
    });
    allQueriedPlayers.forEach(player => {
      getOrSetAsInMap(this.playersByQueriedElement, player.element, []).push(player);
      player.onDone(() => deleteOrUnsetInMap(this.playersByQueriedElement, player.element, player));
    });
    allConsumedElements.forEach(element => addClass(element, NG_ANIMATING_CLASSNAME));
    const player = optimizeGroupPlayer(allNewPlayers);
    player.onDestroy(() => {
      allConsumedElements.forEach(element => removeClass(element, NG_ANIMATING_CLASSNAME));
      setStyles(rootElement, instruction.toStyles);
    });
    // this basically makes all of the callbacks for sub element animations
    // be dependent on the upper players for when they finish
    allSubElements.forEach(element => {
      getOrSetAsInMap(skippedPlayersMap, element, []).push(player);
    });
    return player;
  }
  _buildPlayer(instruction, keyframes, previousPlayers) {
    if (keyframes.length > 0) {
      return this.driver.animate(instruction.element, keyframes, instruction.duration, instruction.delay, instruction.easing, previousPlayers);
    }
    // special case for when an empty transition|definition is provided
    // ... there is no point in rendering an empty animation
    return new _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .NoopAnimationPlayer */ .ZN(instruction.duration, instruction.delay);
  }
}
class TransitionAnimationPlayer {
  constructor(namespaceId, triggerName, element) {
    this.namespaceId = namespaceId;
    this.triggerName = triggerName;
    this.element = element;
    this._player = new _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .NoopAnimationPlayer */ .ZN();
    this._containsRealPlayer = false;
    this._queuedCallbacks = {};
    this.destroyed = false;
    this.markedForDestroy = false;
    this.disabled = false;
    this.queued = true;
    this.totalTime = 0;
  }
  setRealPlayer(player) {
    if (this._containsRealPlayer) return;
    this._player = player;
    Object.keys(this._queuedCallbacks).forEach(phase => {
      this._queuedCallbacks[phase].forEach(callback => listenOnPlayer(player, phase, undefined, callback));
    });
    this._queuedCallbacks = {};
    this._containsRealPlayer = true;
    this.overrideTotalTime(player.totalTime);
    this.queued = false;
  }
  getRealPlayer() {
    return this._player;
  }
  overrideTotalTime(totalTime) {
    this.totalTime = totalTime;
  }
  syncPlayerEvents(player) {
    const p = this._player;
    if (p.triggerCallback) {
      player.onStart(() => p.triggerCallback('start'));
    }
    player.onDone(() => this.finish());
    player.onDestroy(() => this.destroy());
  }
  _queueEvent(name, callback) {
    getOrSetAsInMap(this._queuedCallbacks, name, []).push(callback);
  }
  onDone(fn) {
    if (this.queued) {
      this._queueEvent('done', fn);
    }
    this._player.onDone(fn);
  }
  onStart(fn) {
    if (this.queued) {
      this._queueEvent('start', fn);
    }
    this._player.onStart(fn);
  }
  onDestroy(fn) {
    if (this.queued) {
      this._queueEvent('destroy', fn);
    }
    this._player.onDestroy(fn);
  }
  init() {
    this._player.init();
  }
  hasStarted() {
    return this.queued ? false : this._player.hasStarted();
  }
  play() {
    !this.queued && this._player.play();
  }
  pause() {
    !this.queued && this._player.pause();
  }
  restart() {
    !this.queued && this._player.restart();
  }
  finish() {
    this._player.finish();
  }
  destroy() {
    this.destroyed = true;
    this._player.destroy();
  }
  reset() {
    !this.queued && this._player.reset();
  }
  setPosition(p) {
    if (!this.queued) {
      this._player.setPosition(p);
    }
  }
  getPosition() {
    return this.queued ? 0 : this._player.getPosition();
  }
  /** @internal */
  triggerCallback(phaseName) {
    const p = this._player;
    if (p.triggerCallback) {
      p.triggerCallback(phaseName);
    }
  }
}
function deleteOrUnsetInMap(map, key, value) {
  let currentValues;
  if (map instanceof Map) {
    currentValues = map.get(key);
    if (currentValues) {
      if (currentValues.length) {
        const index = currentValues.indexOf(value);
        currentValues.splice(index, 1);
      }
      if (currentValues.length == 0) {
        map.delete(key);
      }
    }
  } else {
    currentValues = map[key];
    if (currentValues) {
      if (currentValues.length) {
        const index = currentValues.indexOf(value);
        currentValues.splice(index, 1);
      }
      if (currentValues.length == 0) {
        delete map[key];
      }
    }
  }
  return currentValues;
}
function normalizeTriggerValue(value) {
  // we use `!= null` here because it's the most simple
  // way to test against a "falsy" value without mixing
  // in empty strings or a zero value. DO NOT OPTIMIZE.
  return value != null ? value : null;
}
function isElementNode(node) {
  return node && node['nodeType'] === 1;
}
function isTriggerEventValid(eventName) {
  return eventName == 'start' || eventName == 'done';
}
function cloakElement(element, value) {
  const oldValue = element.style.display;
  element.style.display = value != null ? value : 'none';
  return oldValue;
}
function cloakAndComputeStyles(valuesMap, driver, elements, elementPropsMap, defaultStyle) {
  const cloakVals = [];
  elements.forEach(element => cloakVals.push(cloakElement(element)));
  const failedElements = [];
  elementPropsMap.forEach((props, element) => {
    const styles = {};
    props.forEach(prop => {
      const value = styles[prop] = driver.computeStyle(element, prop, defaultStyle);
      // there is no easy way to detect this because a sub element could be removed
      // by a parent animation element being detached.
      if (!value || value.length == 0) {
        element[REMOVAL_FLAG] = NULL_REMOVED_QUERIED_STATE;
        failedElements.push(element);
      }
    });
    valuesMap.set(element, styles);
  });
  // we use a index variable here since Set.forEach(a, i) does not return
  // an index value for the closure (but instead just the value)
  let i = 0;
  elements.forEach(element => cloakElement(element, cloakVals[i++]));
  return failedElements;
}
/*
Since the Angular renderer code will return a collection of inserted
nodes in all areas of a DOM tree, it's up to this algorithm to figure
out which nodes are roots for each animation @trigger.

By placing each inserted node into a Set and traversing upwards, it
is possible to find the @trigger elements and well any direct *star
insertion nodes, if a @trigger root is found then the enter element
is placed into the Map[@trigger] spot.
 */
function buildRootMap(roots, nodes) {
  const rootMap = new Map();
  roots.forEach(root => rootMap.set(root, []));
  if (nodes.length == 0) return rootMap;
  const NULL_NODE = 1;
  const nodeSet = new Set(nodes);
  const localRootMap = new Map();
  function getRoot(node) {
    if (!node) return NULL_NODE;
    let root = localRootMap.get(node);
    if (root) return root;
    const parent = node.parentNode;
    if (rootMap.has(parent)) {
      // ngIf inside @trigger
      root = parent;
    } else if (nodeSet.has(parent)) {
      // ngIf inside ngIf
      root = NULL_NODE;
    } else {
      // recurse upwards
      root = getRoot(parent);
    }
    localRootMap.set(node, root);
    return root;
  }
  nodes.forEach(node => {
    const root = getRoot(node);
    if (root !== NULL_NODE) {
      rootMap.get(root).push(node);
    }
  });
  return rootMap;
}
const CLASSES_CACHE_KEY = '$$classes';
function containsClass(element, className) {
  if (element.classList) {
    return element.classList.contains(className);
  } else {
    const classes = element[CLASSES_CACHE_KEY];
    return classes && classes[className];
  }
}
function addClass(element, className) {
  if (element.classList) {
    element.classList.add(className);
  } else {
    let classes = element[CLASSES_CACHE_KEY];
    if (!classes) {
      classes = element[CLASSES_CACHE_KEY] = {};
    }
    classes[className] = true;
  }
}
function removeClass(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else {
    let classes = element[CLASSES_CACHE_KEY];
    if (classes) {
      delete classes[className];
    }
  }
}
function removeNodesAfterAnimationDone(engine, element, players) {
  optimizeGroupPlayer(players).onDone(() => engine.processLeaveNode(element));
}
function flattenGroupPlayers(players) {
  const finalPlayers = [];
  _flattenGroupPlayersRecur(players, finalPlayers);
  return finalPlayers;
}
function _flattenGroupPlayersRecur(players, finalPlayers) {
  for (let i = 0; i < players.length; i++) {
    const player = players[i];
    if (player instanceof _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* ["ɵAnimationGroupPlayer"] */ .ZE) {
      _flattenGroupPlayersRecur(player.players, finalPlayers);
    } else {
      finalPlayers.push(player);
    }
  }
}
function objEquals(a, b) {
  const k1 = Object.keys(a);
  const k2 = Object.keys(b);
  if (k1.length != k2.length) return false;
  for (let i = 0; i < k1.length; i++) {
    const prop = k1[i];
    if (!b.hasOwnProperty(prop) || a[prop] !== b[prop]) return false;
  }
  return true;
}
function replacePostStylesAsPre(element, allPreStyleElements, allPostStyleElements) {
  const postEntry = allPostStyleElements.get(element);
  if (!postEntry) return false;
  let preEntry = allPreStyleElements.get(element);
  if (preEntry) {
    postEntry.forEach(data => preEntry.add(data));
  } else {
    allPreStyleElements.set(element, postEntry);
  }
  allPostStyleElements.delete(element);
  return true;
}
class AnimationEngine {
  constructor(bodyNode, _driver, _normalizer) {
    this.bodyNode = bodyNode;
    this._driver = _driver;
    this._normalizer = _normalizer;
    this._triggerCache = {};
    // this method is designed to be overridden by the code that uses this engine
    this.onRemovalComplete = (element, context) => {};
    this._transitionEngine = new TransitionAnimationEngine(bodyNode, _driver, _normalizer);
    this._timelineEngine = new TimelineAnimationEngine(bodyNode, _driver, _normalizer);
    this._transitionEngine.onRemovalComplete = (element, context) => this.onRemovalComplete(element, context);
  }
  registerTrigger(componentId, namespaceId, hostElement, name, metadata) {
    const cacheKey = componentId + '-' + name;
    let trigger = this._triggerCache[cacheKey];
    if (!trigger) {
      const errors = [];
      const ast = buildAnimationAst(this._driver, metadata, errors);
      if (errors.length) {
        throw new Error(`The animation trigger "${name}" has failed to build due to the following errors:\n - ${errors.join('\n - ')}`);
      }
      trigger = buildTrigger(name, ast, this._normalizer);
      this._triggerCache[cacheKey] = trigger;
    }
    this._transitionEngine.registerTrigger(namespaceId, name, trigger);
  }
  register(namespaceId, hostElement) {
    this._transitionEngine.register(namespaceId, hostElement);
  }
  destroy(namespaceId, context) {
    this._transitionEngine.destroy(namespaceId, context);
  }
  onInsert(namespaceId, element, parent, insertBefore) {
    this._transitionEngine.insertNode(namespaceId, element, parent, insertBefore);
  }
  onRemove(namespaceId, element, context, isHostElement) {
    this._transitionEngine.removeNode(namespaceId, element, isHostElement || false, context);
  }
  disableAnimations(element, disable) {
    this._transitionEngine.markElementAsDisabled(element, disable);
  }
  process(namespaceId, element, property, value) {
    if (property.charAt(0) == '@') {
      const [id, action] = parseTimelineCommand(property);
      const args = value;
      this._timelineEngine.command(id, element, action, args);
    } else {
      this._transitionEngine.trigger(namespaceId, element, property, value);
    }
  }
  listen(namespaceId, element, eventName, eventPhase, callback) {
    // @@listen
    if (eventName.charAt(0) == '@') {
      const [id, action] = parseTimelineCommand(eventName);
      return this._timelineEngine.listen(id, element, action, callback);
    }
    return this._transitionEngine.listen(namespaceId, element, eventName, eventPhase, callback);
  }
  flush(microtaskId = -1) {
    this._transitionEngine.flush(microtaskId);
  }
  get players() {
    return this._transitionEngine.players.concat(this._timelineEngine.players);
  }
  whenRenderingDone() {
    return this._transitionEngine.whenRenderingDone();
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Returns an instance of `SpecialCasedStyles` if and when any special (non animateable) styles are
 * detected.
 *
 * In CSS there exist properties that cannot be animated within a keyframe animation
 * (whether it be via CSS keyframes or web-animations) and the animation implementation
 * will ignore them. This function is designed to detect those special cased styles and
 * return a container that will be executed at the start and end of the animation.
 *
 * @returns an instance of `SpecialCasedStyles` if any special styles are detected otherwise `null`
 */
function packageNonAnimatableStyles(element, styles) {
  let startStyles = null;
  let endStyles = null;
  if (Array.isArray(styles) && styles.length) {
    startStyles = filterNonAnimatableStyles(styles[0]);
    if (styles.length > 1) {
      endStyles = filterNonAnimatableStyles(styles[styles.length - 1]);
    }
  } else if (styles) {
    startStyles = filterNonAnimatableStyles(styles);
  }
  return startStyles || endStyles ? new SpecialCasedStyles(element, startStyles, endStyles) : null;
}
/**
 * Designed to be executed during a keyframe-based animation to apply any special-cased styles.
 *
 * When started (when the `start()` method is run) then the provided `startStyles`
 * will be applied. When finished (when the `finish()` method is called) the
 * `endStyles` will be applied as well any any starting styles. Finally when
 * `destroy()` is called then all styles will be removed.
 */
let SpecialCasedStyles = /*#__PURE__*/(() => {
  class SpecialCasedStyles {
    constructor(_element, _startStyles, _endStyles) {
      this._element = _element;
      this._startStyles = _startStyles;
      this._endStyles = _endStyles;
      this._state = 0 /* Pending */;
      let initialStyles = SpecialCasedStyles.initialStylesByElement.get(_element);
      if (!initialStyles) {
        SpecialCasedStyles.initialStylesByElement.set(_element, initialStyles = {});
      }
      this._initialStyles = initialStyles;
    }
    start() {
      if (this._state < 1 /* Started */) {
        if (this._startStyles) {
          setStyles(this._element, this._startStyles, this._initialStyles);
        }
        this._state = 1 /* Started */;
      }
    }

    finish() {
      this.start();
      if (this._state < 2 /* Finished */) {
        setStyles(this._element, this._initialStyles);
        if (this._endStyles) {
          setStyles(this._element, this._endStyles);
          this._endStyles = null;
        }
        this._state = 1 /* Started */;
      }
    }

    destroy() {
      this.finish();
      if (this._state < 3 /* Destroyed */) {
        SpecialCasedStyles.initialStylesByElement.delete(this._element);
        if (this._startStyles) {
          eraseStyles(this._element, this._startStyles);
          this._endStyles = null;
        }
        if (this._endStyles) {
          eraseStyles(this._element, this._endStyles);
          this._endStyles = null;
        }
        setStyles(this._element, this._initialStyles);
        this._state = 3 /* Destroyed */;
      }
    }
  }

  SpecialCasedStyles.initialStylesByElement = /* @__PURE__ */new WeakMap();
  return SpecialCasedStyles;
})();
function filterNonAnimatableStyles(styles) {
  let result = null;
  const props = Object.keys(styles);
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (isNonAnimatableStyle(prop)) {
      result = result || {};
      result[prop] = styles[prop];
    }
  }
  return result;
}
function isNonAnimatableStyle(prop) {
  return prop === 'display' || prop === 'position';
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
const ANIMATION_PROP = 'animation';
const ANIMATIONEND_EVENT = 'animationend';
const ONE_SECOND$1 = 1000;
class ElementAnimationStyleHandler {
  constructor(_element, _name, _duration, _delay, _easing, _fillMode, _onDoneFn) {
    this._element = _element;
    this._name = _name;
    this._duration = _duration;
    this._delay = _delay;
    this._easing = _easing;
    this._fillMode = _fillMode;
    this._onDoneFn = _onDoneFn;
    this._finished = false;
    this._destroyed = false;
    this._startTime = 0;
    this._position = 0;
    this._eventFn = e => this._handleCallback(e);
  }
  apply() {
    applyKeyframeAnimation(this._element, `${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`);
    addRemoveAnimationEvent(this._element, this._eventFn, false);
    this._startTime = Date.now();
  }
  pause() {
    playPauseAnimation(this._element, this._name, 'paused');
  }
  resume() {
    playPauseAnimation(this._element, this._name, 'running');
  }
  setPosition(position) {
    const index = findIndexForAnimation(this._element, this._name);
    this._position = position * this._duration;
    setAnimationStyle(this._element, 'Delay', `-${this._position}ms`, index);
  }
  getPosition() {
    return this._position;
  }
  _handleCallback(event) {
    const timestamp = event._ngTestManualTimestamp || Date.now();
    const elapsedTime = parseFloat(event.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES)) * ONE_SECOND$1;
    if (event.animationName == this._name && Math.max(timestamp - this._startTime, 0) >= this._delay && elapsedTime >= this._duration) {
      this.finish();
    }
  }
  finish() {
    if (this._finished) return;
    this._finished = true;
    this._onDoneFn();
    addRemoveAnimationEvent(this._element, this._eventFn, true);
  }
  destroy() {
    if (this._destroyed) return;
    this._destroyed = true;
    this.finish();
    removeKeyframeAnimation(this._element, this._name);
  }
}
function playPauseAnimation(element, name, status) {
  const index = findIndexForAnimation(element, name);
  setAnimationStyle(element, 'PlayState', status, index);
}
function applyKeyframeAnimation(element, value) {
  const anim = getAnimationStyle(element, '').trim();
  let index = 0;
  if (anim.length) {
    index = countChars(anim, ',') + 1;
    value = `${anim}, ${value}`;
  }
  setAnimationStyle(element, '', value);
  return index;
}
function removeKeyframeAnimation(element, name) {
  const anim = getAnimationStyle(element, '');
  const tokens = anim.split(',');
  const index = findMatchingTokenIndex(tokens, name);
  if (index >= 0) {
    tokens.splice(index, 1);
    const newValue = tokens.join(',');
    setAnimationStyle(element, '', newValue);
  }
}
function findIndexForAnimation(element, value) {
  const anim = getAnimationStyle(element, '');
  if (anim.indexOf(',') > 0) {
    const tokens = anim.split(',');
    return findMatchingTokenIndex(tokens, value);
  }
  return findMatchingTokenIndex([anim], value);
}
function findMatchingTokenIndex(tokens, searchToken) {
  for (let i = 0; i < tokens.length; i++) {
    if (tokens[i].indexOf(searchToken) >= 0) {
      return i;
    }
  }
  return -1;
}
function addRemoveAnimationEvent(element, fn, doRemove) {
  doRemove ? element.removeEventListener(ANIMATIONEND_EVENT, fn) : element.addEventListener(ANIMATIONEND_EVENT, fn);
}
function setAnimationStyle(element, name, value, index) {
  const prop = ANIMATION_PROP + name;
  if (index != null) {
    const oldValue = element.style[prop];
    if (oldValue.length) {
      const tokens = oldValue.split(',');
      tokens[index] = value;
      value = tokens.join(',');
    }
  }
  element.style[prop] = value;
}
function getAnimationStyle(element, name) {
  return element.style[ANIMATION_PROP + name] || '';
}
function countChars(value, char) {
  let count = 0;
  for (let i = 0; i < value.length; i++) {
    const c = value.charAt(i);
    if (c === char) count++;
  }
  return count;
}
const DEFAULT_FILL_MODE = 'forwards';
const DEFAULT_EASING = 'linear';
class CssKeyframesPlayer {
  constructor(element, keyframes, animationName, _duration, _delay, easing, _finalStyles, _specialStyles) {
    this.element = element;
    this.keyframes = keyframes;
    this.animationName = animationName;
    this._duration = _duration;
    this._delay = _delay;
    this._finalStyles = _finalStyles;
    this._specialStyles = _specialStyles;
    this._onDoneFns = [];
    this._onStartFns = [];
    this._onDestroyFns = [];
    this.currentSnapshot = {};
    this._state = 0;
    this.easing = easing || DEFAULT_EASING;
    this.totalTime = _duration + _delay;
    this._buildStyler();
  }
  onStart(fn) {
    this._onStartFns.push(fn);
  }
  onDone(fn) {
    this._onDoneFns.push(fn);
  }
  onDestroy(fn) {
    this._onDestroyFns.push(fn);
  }
  destroy() {
    this.init();
    if (this._state >= 4 /* DESTROYED */) return;
    this._state = 4 /* DESTROYED */;
    this._styler.destroy();
    this._flushStartFns();
    this._flushDoneFns();
    if (this._specialStyles) {
      this._specialStyles.destroy();
    }
    this._onDestroyFns.forEach(fn => fn());
    this._onDestroyFns = [];
  }
  _flushDoneFns() {
    this._onDoneFns.forEach(fn => fn());
    this._onDoneFns = [];
  }
  _flushStartFns() {
    this._onStartFns.forEach(fn => fn());
    this._onStartFns = [];
  }
  finish() {
    this.init();
    if (this._state >= 3 /* FINISHED */) return;
    this._state = 3 /* FINISHED */;
    this._styler.finish();
    this._flushStartFns();
    if (this._specialStyles) {
      this._specialStyles.finish();
    }
    this._flushDoneFns();
  }
  setPosition(value) {
    this._styler.setPosition(value);
  }
  getPosition() {
    return this._styler.getPosition();
  }
  hasStarted() {
    return this._state >= 2 /* STARTED */;
  }

  init() {
    if (this._state >= 1 /* INITIALIZED */) return;
    this._state = 1 /* INITIALIZED */;
    const elm = this.element;
    this._styler.apply();
    if (this._delay) {
      this._styler.pause();
    }
  }
  play() {
    this.init();
    if (!this.hasStarted()) {
      this._flushStartFns();
      this._state = 2 /* STARTED */;
      if (this._specialStyles) {
        this._specialStyles.start();
      }
    }
    this._styler.resume();
  }
  pause() {
    this.init();
    this._styler.pause();
  }
  restart() {
    this.reset();
    this.play();
  }
  reset() {
    this._state = 0 /* RESET */;
    this._styler.destroy();
    this._buildStyler();
    this._styler.apply();
  }
  _buildStyler() {
    this._styler = new ElementAnimationStyleHandler(this.element, this.animationName, this._duration, this._delay, this.easing, DEFAULT_FILL_MODE, () => this.finish());
  }
  /** @internal */
  triggerCallback(phaseName) {
    const methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;
    methods.forEach(fn => fn());
    methods.length = 0;
  }
  beforeDestroy() {
    this.init();
    const styles = {};
    if (this.hasStarted()) {
      const finished = this._state >= 3 /* FINISHED */;
      Object.keys(this._finalStyles).forEach(prop => {
        if (prop != 'offset') {
          styles[prop] = finished ? this._finalStyles[prop] : computeStyle(this.element, prop);
        }
      });
    }
    this.currentSnapshot = styles;
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class DirectStylePlayer extends _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .NoopAnimationPlayer */ .ZN {
  constructor(element, styles) {
    super();
    this.element = element;
    this._startingStyles = {};
    this.__initialized = false;
    this._styles = hypenatePropsObject(styles);
  }
  init() {
    if (this.__initialized || !this._startingStyles) return;
    this.__initialized = true;
    Object.keys(this._styles).forEach(prop => {
      this._startingStyles[prop] = this.element.style[prop];
    });
    super.init();
  }
  play() {
    if (!this._startingStyles) return;
    this.init();
    Object.keys(this._styles).forEach(prop => this.element.style.setProperty(prop, this._styles[prop]));
    super.play();
  }
  destroy() {
    if (!this._startingStyles) return;
    Object.keys(this._startingStyles).forEach(prop => {
      const value = this._startingStyles[prop];
      if (value) {
        this.element.style.setProperty(prop, value);
      } else {
        this.element.style.removeProperty(prop);
      }
    });
    this._startingStyles = null;
    super.destroy();
  }
}
const KEYFRAMES_NAME_PREFIX = 'gen_css_kf_';
const TAB_SPACE = ' ';
class CssKeyframesDriver {
  constructor() {
    this._count = 0;
  }
  validateStyleProperty(prop) {
    return validateStyleProperty(prop);
  }
  matchesElement(element, selector) {
    return matchesElement(element, selector);
  }
  containsElement(elm1, elm2) {
    return containsElement(elm1, elm2);
  }
  query(element, selector, multi) {
    return invokeQuery(element, selector, multi);
  }
  computeStyle(element, prop, defaultValue) {
    return window.getComputedStyle(element)[prop];
  }
  buildKeyframeElement(element, name, keyframes) {
    keyframes = keyframes.map(kf => hypenatePropsObject(kf));
    let keyframeStr = `@keyframes ${name} {\n`;
    let tab = '';
    keyframes.forEach(kf => {
      tab = TAB_SPACE;
      const offset = parseFloat(kf['offset']);
      keyframeStr += `${tab}${offset * 100}% {\n`;
      tab += TAB_SPACE;
      Object.keys(kf).forEach(prop => {
        const value = kf[prop];
        switch (prop) {
          case 'offset':
            return;
          case 'easing':
            if (value) {
              keyframeStr += `${tab}animation-timing-function: ${value};\n`;
            }
            return;
          default:
            keyframeStr += `${tab}${prop}: ${value};\n`;
            return;
        }
      });
      keyframeStr += `${tab}}\n`;
    });
    keyframeStr += `}\n`;
    const kfElm = document.createElement('style');
    kfElm.textContent = keyframeStr;
    return kfElm;
  }
  animate(element, keyframes, duration, delay, easing, previousPlayers = [], scrubberAccessRequested) {
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && scrubberAccessRequested) {
      notifyFaultyScrubber();
    }
    const previousCssKeyframePlayers = previousPlayers.filter(player => player instanceof CssKeyframesPlayer);
    const previousStyles = {};
    if (allowPreviousPlayerStylesMerge(duration, delay)) {
      previousCssKeyframePlayers.forEach(player => {
        let styles = player.currentSnapshot;
        Object.keys(styles).forEach(prop => previousStyles[prop] = styles[prop]);
      });
    }
    keyframes = balancePreviousStylesIntoKeyframes(element, keyframes, previousStyles);
    const finalStyles = flattenKeyframesIntoStyles(keyframes);
    // if there is no animation then there is no point in applying
    // styles and waiting for an event to get fired. This causes lag.
    // It's better to just directly apply the styles to the element
    // via the direct styling animation player.
    if (duration == 0) {
      return new DirectStylePlayer(element, finalStyles);
    }
    const animationName = `${KEYFRAMES_NAME_PREFIX}${this._count++}`;
    const kfElm = this.buildKeyframeElement(element, animationName, keyframes);
    const nodeToAppendKfElm = findNodeToAppendKeyframeElement(element);
    nodeToAppendKfElm.appendChild(kfElm);
    const specialStyles = packageNonAnimatableStyles(element, keyframes);
    const player = new CssKeyframesPlayer(element, keyframes, animationName, duration, delay, easing, finalStyles, specialStyles);
    player.onDestroy(() => removeElement(kfElm));
    return player;
  }
}
function findNodeToAppendKeyframeElement(element) {
  var _a;
  const rootNode = (_a = element.getRootNode) === null || _a === void 0 ? void 0 : _a.call(element);
  if (typeof ShadowRoot !== 'undefined' && rootNode instanceof ShadowRoot) {
    return rootNode;
  }
  return document.head;
}
function flattenKeyframesIntoStyles(keyframes) {
  let flatKeyframes = {};
  if (keyframes) {
    const kfs = Array.isArray(keyframes) ? keyframes : [keyframes];
    kfs.forEach(kf => {
      Object.keys(kf).forEach(prop => {
        if (prop == 'offset' || prop == 'easing') return;
        flatKeyframes[prop] = kf[prop];
      });
    });
  }
  return flatKeyframes;
}
function removeElement(node) {
  node.parentNode.removeChild(node);
}
let warningIssued = false;
function notifyFaultyScrubber() {
  if (warningIssued) return;
  console.warn('@angular/animations: please load the web-animations.js polyfill to allow programmatic access...\n', '  visit https://bit.ly/IWukam to learn more about using the web-animation-js polyfill.');
  warningIssued = true;
}
class WebAnimationsPlayer {
  constructor(element, keyframes, options, _specialStyles) {
    this.element = element;
    this.keyframes = keyframes;
    this.options = options;
    this._specialStyles = _specialStyles;
    this._onDoneFns = [];
    this._onStartFns = [];
    this._onDestroyFns = [];
    this._initialized = false;
    this._finished = false;
    this._started = false;
    this._destroyed = false;
    this.time = 0;
    this.parentPlayer = null;
    this.currentSnapshot = {};
    this._duration = options['duration'];
    this._delay = options['delay'] || 0;
    this.time = this._duration + this._delay;
  }
  _onFinish() {
    if (!this._finished) {
      this._finished = true;
      this._onDoneFns.forEach(fn => fn());
      this._onDoneFns = [];
    }
  }
  init() {
    this._buildPlayer();
    this._preparePlayerBeforeStart();
  }
  _buildPlayer() {
    if (this._initialized) return;
    this._initialized = true;
    const keyframes = this.keyframes;
    this.domPlayer = this._triggerWebAnimation(this.element, keyframes, this.options);
    this._finalKeyframe = keyframes.length ? keyframes[keyframes.length - 1] : {};
    this.domPlayer.addEventListener('finish', () => this._onFinish());
  }
  _preparePlayerBeforeStart() {
    // this is required so that the player doesn't start to animate right away
    if (this._delay) {
      this._resetDomPlayerState();
    } else {
      this.domPlayer.pause();
    }
  }
  /** @internal */
  _triggerWebAnimation(element, keyframes, options) {
    // jscompiler doesn't seem to know animate is a native property because it's not fully
    // supported yet across common browsers (we polyfill it for Edge/Safari) [CL #143630929]
    return element['animate'](keyframes, options);
  }
  onStart(fn) {
    this._onStartFns.push(fn);
  }
  onDone(fn) {
    this._onDoneFns.push(fn);
  }
  onDestroy(fn) {
    this._onDestroyFns.push(fn);
  }
  play() {
    this._buildPlayer();
    if (!this.hasStarted()) {
      this._onStartFns.forEach(fn => fn());
      this._onStartFns = [];
      this._started = true;
      if (this._specialStyles) {
        this._specialStyles.start();
      }
    }
    this.domPlayer.play();
  }
  pause() {
    this.init();
    this.domPlayer.pause();
  }
  finish() {
    this.init();
    if (this._specialStyles) {
      this._specialStyles.finish();
    }
    this._onFinish();
    this.domPlayer.finish();
  }
  reset() {
    this._resetDomPlayerState();
    this._destroyed = false;
    this._finished = false;
    this._started = false;
  }
  _resetDomPlayerState() {
    if (this.domPlayer) {
      this.domPlayer.cancel();
    }
  }
  restart() {
    this.reset();
    this.play();
  }
  hasStarted() {
    return this._started;
  }
  destroy() {
    if (!this._destroyed) {
      this._destroyed = true;
      this._resetDomPlayerState();
      this._onFinish();
      if (this._specialStyles) {
        this._specialStyles.destroy();
      }
      this._onDestroyFns.forEach(fn => fn());
      this._onDestroyFns = [];
    }
  }
  setPosition(p) {
    if (this.domPlayer === undefined) {
      this.init();
    }
    this.domPlayer.currentTime = p * this.time;
  }
  getPosition() {
    return this.domPlayer.currentTime / this.time;
  }
  get totalTime() {
    return this._delay + this._duration;
  }
  beforeDestroy() {
    const styles = {};
    if (this.hasStarted()) {
      Object.keys(this._finalKeyframe).forEach(prop => {
        if (prop != 'offset') {
          styles[prop] = this._finished ? this._finalKeyframe[prop] : computeStyle(this.element, prop);
        }
      });
    }
    this.currentSnapshot = styles;
  }
  /** @internal */
  triggerCallback(phaseName) {
    const methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;
    methods.forEach(fn => fn());
    methods.length = 0;
  }
}
class WebAnimationsDriver {
  constructor() {
    this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(getElementAnimateFn().toString());
    this._cssKeyframesDriver = new CssKeyframesDriver();
  }
  validateStyleProperty(prop) {
    return validateStyleProperty(prop);
  }
  matchesElement(element, selector) {
    return matchesElement(element, selector);
  }
  containsElement(elm1, elm2) {
    return containsElement(elm1, elm2);
  }
  query(element, selector, multi) {
    return invokeQuery(element, selector, multi);
  }
  computeStyle(element, prop, defaultValue) {
    return window.getComputedStyle(element)[prop];
  }
  overrideWebAnimationsSupport(supported) {
    this._isNativeImpl = supported;
  }
  animate(element, keyframes, duration, delay, easing, previousPlayers = [], scrubberAccessRequested) {
    const useKeyframes = !scrubberAccessRequested && !this._isNativeImpl;
    if (useKeyframes) {
      return this._cssKeyframesDriver.animate(element, keyframes, duration, delay, easing, previousPlayers);
    }
    const fill = delay == 0 ? 'both' : 'forwards';
    const playerOptions = {
      duration,
      delay,
      fill
    };
    // we check for this to avoid having a null|undefined value be present
    // for the easing (which results in an error for certain browsers #9752)
    if (easing) {
      playerOptions['easing'] = easing;
    }
    const previousStyles = {};
    const previousWebAnimationPlayers = previousPlayers.filter(player => player instanceof WebAnimationsPlayer);
    if (allowPreviousPlayerStylesMerge(duration, delay)) {
      previousWebAnimationPlayers.forEach(player => {
        let styles = player.currentSnapshot;
        Object.keys(styles).forEach(prop => previousStyles[prop] = styles[prop]);
      });
    }
    keyframes = keyframes.map(styles => copyStyles(styles, false));
    keyframes = balancePreviousStylesIntoKeyframes(element, keyframes, previousStyles);
    const specialStyles = packageNonAnimatableStyles(element, keyframes);
    return new WebAnimationsPlayer(element, keyframes, playerOptions, specialStyles);
  }
}
function supportsWebAnimations() {
  return typeof getElementAnimateFn() === 'function';
}
function getElementAnimateFn() {
  return isBrowser() && Element.prototype['animate'] || {};
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=browser.js.map

/***/ }),

/***/ 3738:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AbstractControl: () => (/* binding */ AbstractControl),
  AbstractControlDirective: () => (/* binding */ AbstractControlDirective),
  AbstractFormGroupDirective: () => (/* binding */ AbstractFormGroupDirective),
  COMPOSITION_BUFFER_MODE: () => (/* binding */ COMPOSITION_BUFFER_MODE),
  CheckboxControlValueAccessor: () => (/* binding */ CheckboxControlValueAccessor),
  CheckboxRequiredValidator: () => (/* binding */ CheckboxRequiredValidator),
  ControlContainer: () => (/* binding */ ControlContainer),
  DefaultValueAccessor: () => (/* binding */ DefaultValueAccessor),
  EmailValidator: () => (/* binding */ EmailValidator),
  FormArray: () => (/* binding */ FormArray),
  FormArrayName: () => (/* binding */ FormArrayName),
  FormBuilder: () => (/* binding */ FormBuilder),
  FormControl: () => (/* binding */ FormControl),
  FormControlDirective: () => (/* binding */ FormControlDirective),
  FormControlName: () => (/* binding */ FormControlName),
  FormGroup: () => (/* binding */ FormGroup),
  FormGroupDirective: () => (/* binding */ FormGroupDirective),
  FormGroupName: () => (/* binding */ FormGroupName),
  FormsModule: () => (/* binding */ FormsModule),
  MaxLengthValidator: () => (/* binding */ MaxLengthValidator),
  MaxValidator: () => (/* binding */ MaxValidator),
  MinLengthValidator: () => (/* binding */ MinLengthValidator),
  MinValidator: () => (/* binding */ MinValidator),
  NG_ASYNC_VALIDATORS: () => (/* binding */ NG_ASYNC_VALIDATORS),
  NG_VALIDATORS: () => (/* binding */ NG_VALIDATORS),
  NG_VALUE_ACCESSOR: () => (/* binding */ NG_VALUE_ACCESSOR),
  NgControl: () => (/* binding */ NgControl),
  NgControlStatus: () => (/* binding */ NgControlStatus),
  NgControlStatusGroup: () => (/* binding */ NgControlStatusGroup),
  NgForm: () => (/* binding */ NgForm),
  NgModel: () => (/* binding */ NgModel),
  NgModelGroup: () => (/* binding */ NgModelGroup),
  NgSelectOption: () => (/* binding */ NgSelectOption),
  NumberValueAccessor: () => (/* binding */ NumberValueAccessor),
  PatternValidator: () => (/* binding */ PatternValidator),
  RadioControlValueAccessor: () => (/* binding */ RadioControlValueAccessor),
  RangeValueAccessor: () => (/* binding */ RangeValueAccessor),
  ReactiveFormsModule: () => (/* binding */ ReactiveFormsModule),
  RequiredValidator: () => (/* binding */ RequiredValidator),
  SelectControlValueAccessor: () => (/* binding */ SelectControlValueAccessor),
  SelectMultipleControlValueAccessor: () => (/* binding */ SelectMultipleControlValueAccessor),
  VERSION: () => (/* binding */ VERSION),
  Validators: () => (/* binding */ Validators),
  "ɵInternalFormsSharedModule": () => (/* binding */ ɵInternalFormsSharedModule),
  "ɵNgNoValidate": () => (/* binding */ ɵNgNoValidate),
  "ɵNgSelectMultipleOption": () => (/* binding */ ɵNgSelectMultipleOption),
  "ɵangular_packages_forms_forms_a": () => (/* binding */ SHARED_FORM_DIRECTIVES),
  "ɵangular_packages_forms_forms_b": () => (/* binding */ TEMPLATE_DRIVEN_DIRECTIVES),
  "ɵangular_packages_forms_forms_ba": () => (/* binding */ SELECT_MULTIPLE_VALUE_ACCESSOR),
  "ɵangular_packages_forms_forms_bb": () => (/* binding */ ɵNgSelectMultipleOption),
  "ɵangular_packages_forms_forms_bc": () => (/* binding */ ɵNgNoValidate),
  "ɵangular_packages_forms_forms_bd": () => (/* binding */ MAX_VALIDATOR),
  "ɵangular_packages_forms_forms_be": () => (/* binding */ MIN_VALIDATOR),
  "ɵangular_packages_forms_forms_bf": () => (/* binding */ REQUIRED_VALIDATOR),
  "ɵangular_packages_forms_forms_bg": () => (/* binding */ CHECKBOX_REQUIRED_VALIDATOR),
  "ɵangular_packages_forms_forms_bh": () => (/* binding */ EMAIL_VALIDATOR),
  "ɵangular_packages_forms_forms_bi": () => (/* binding */ MIN_LENGTH_VALIDATOR),
  "ɵangular_packages_forms_forms_bj": () => (/* binding */ MAX_LENGTH_VALIDATOR),
  "ɵangular_packages_forms_forms_bk": () => (/* binding */ PATTERN_VALIDATOR),
  "ɵangular_packages_forms_forms_bl": () => (/* binding */ minValidator),
  "ɵangular_packages_forms_forms_bm": () => (/* binding */ maxValidator),
  "ɵangular_packages_forms_forms_bn": () => (/* binding */ requiredValidator),
  "ɵangular_packages_forms_forms_bo": () => (/* binding */ requiredTrueValidator),
  "ɵangular_packages_forms_forms_bp": () => (/* binding */ emailValidator),
  "ɵangular_packages_forms_forms_bq": () => (/* binding */ minLengthValidator),
  "ɵangular_packages_forms_forms_br": () => (/* binding */ maxLengthValidator),
  "ɵangular_packages_forms_forms_bs": () => (/* binding */ patternValidator),
  "ɵangular_packages_forms_forms_bt": () => (/* binding */ nullValidator),
  "ɵangular_packages_forms_forms_c": () => (/* binding */ REACTIVE_DRIVEN_DIRECTIVES),
  "ɵangular_packages_forms_forms_d": () => (/* binding */ ɵInternalFormsSharedModule),
  "ɵangular_packages_forms_forms_e": () => (/* binding */ CHECKBOX_VALUE_ACCESSOR),
  "ɵangular_packages_forms_forms_f": () => (/* binding */ BaseControlValueAccessor),
  "ɵangular_packages_forms_forms_g": () => (/* binding */ BuiltInControlValueAccessor),
  "ɵangular_packages_forms_forms_h": () => (/* binding */ DEFAULT_VALUE_ACCESSOR),
  "ɵangular_packages_forms_forms_i": () => (/* binding */ AbstractControlStatus),
  "ɵangular_packages_forms_forms_j": () => (/* binding */ ngControlStatusHost),
  "ɵangular_packages_forms_forms_k": () => (/* binding */ ngGroupStatusHost),
  "ɵangular_packages_forms_forms_l": () => (/* binding */ formDirectiveProvider),
  "ɵangular_packages_forms_forms_m": () => (/* binding */ formControlBinding),
  "ɵangular_packages_forms_forms_n": () => (/* binding */ modelGroupProvider),
  "ɵangular_packages_forms_forms_o": () => (/* binding */ NUMBER_VALUE_ACCESSOR),
  "ɵangular_packages_forms_forms_p": () => (/* binding */ RADIO_VALUE_ACCESSOR),
  "ɵangular_packages_forms_forms_q": () => (/* binding */ RadioControlRegistryModule),
  "ɵangular_packages_forms_forms_r": () => (/* binding */ RadioControlRegistry),
  "ɵangular_packages_forms_forms_s": () => (/* binding */ RANGE_VALUE_ACCESSOR),
  "ɵangular_packages_forms_forms_t": () => (/* binding */ NG_MODEL_WITH_FORM_CONTROL_WARNING),
  "ɵangular_packages_forms_forms_u": () => (/* binding */ formControlBinding$1),
  "ɵangular_packages_forms_forms_v": () => (/* binding */ controlNameBinding),
  "ɵangular_packages_forms_forms_w": () => (/* binding */ formDirectiveProvider$1),
  "ɵangular_packages_forms_forms_x": () => (/* binding */ formGroupNameProvider),
  "ɵangular_packages_forms_forms_y": () => (/* binding */ formArrayNameProvider),
  "ɵangular_packages_forms_forms_z": () => (/* binding */ SELECT_VALUE_ACCESSOR)
});

// EXTERNAL MODULE: consume shared module (default) @angular/core@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/core/fesm2015/core.js)
var core_js_ = __webpack_require__(8312);
// EXTERNAL MODULE: consume shared module (default) @angular/common@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/common/fesm2015/common.js)
var common_js_ = __webpack_require__(3008);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/from.js + 6 modules
var from = __webpack_require__(4402);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Observable.js + 2 modules
var Observable = __webpack_require__(8891);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isArray.js
var isArray = __webpack_require__(9796);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js
var map = __webpack_require__(8002);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isObject.js
var isObject = __webpack_require__(1555);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/observable/forkJoin.js





function forkJoin(...sources) {
  if (sources.length === 1) {
    const first = sources[0];
    if ((0,isArray/* isArray */.k)(first)) {
      return forkJoinInternal(first, null);
    }
    if ((0,isObject/* isObject */.K)(first) && Object.getPrototypeOf(first) === Object.prototype) {
      const keys = Object.keys(first);
      return forkJoinInternal(keys.map(key => first[key]), keys);
    }
  }
  if (typeof sources[sources.length - 1] === 'function') {
    const resultSelector = sources.pop();
    sources = sources.length === 1 && (0,isArray/* isArray */.k)(sources[0]) ? sources[0] : sources;
    return forkJoinInternal(sources, null).pipe((0,map/* map */.U)(args => resultSelector(...args)));
  }
  return forkJoinInternal(sources, null);
}
function forkJoinInternal(sources, keys) {
  return new Observable/* Observable */.y(subscriber => {
    const len = sources.length;
    if (len === 0) {
      subscriber.complete();
      return;
    }
    const values = new Array(len);
    let completed = 0;
    let emitted = 0;
    for (let i = 0; i < len; i++) {
      const source = (0,from/* from */.D)(sources[i]);
      let hasValue = false;
      subscriber.add(source.subscribe({
        next: value => {
          if (!hasValue) {
            hasValue = true;
            emitted++;
          }
          values[i] = value;
        },
        error: err => subscriber.error(err),
        complete: () => {
          completed++;
          if (completed === len || !hasValue) {
            if (emitted === len) {
              subscriber.next(keys ? keys.reduce((result, key, i) => (result[key] = values[i], result), {}) : values);
            }
            subscriber.complete();
          }
        }
      }));
    }
  });
}
//# sourceMappingURL=forkJoin.js.map
;// CONCATENATED MODULE: ./node_modules/@angular/forms/fesm2015/forms.js
/**
 * @license Angular v12.2.17
 * (c) 2010-2021 Google LLC. https://angular.io/
 * License: MIT
 */






/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Base class for all ControlValueAccessor classes defined in Forms package.
 * Contains common logic and utility functions.
 *
 * Note: this is an *internal-only* class and should not be extended or used directly in
 * applications code.
 */

let BaseControlValueAccessor = /*#__PURE__*/(() => {
  class BaseControlValueAccessor {
    constructor(_renderer, _elementRef) {
      this._renderer = _renderer;
      this._elementRef = _elementRef;
      /**
       * The registered callback function called when a change or input event occurs on the input
       * element.
       * @nodoc
       */
      this.onChange = _ => {};
      /**
       * The registered callback function called when a blur event occurs on the input element.
       * @nodoc
       */
      this.onTouched = () => {};
    }
    /**
     * Helper method that sets a property on a target element using the current Renderer
     * implementation.
     * @nodoc
     */
    setProperty(key, value) {
      this._renderer.setProperty(this._elementRef.nativeElement, key, value);
    }
    /**
     * Registers a function called when the control is touched.
     * @nodoc
     */
    registerOnTouched(fn) {
      this.onTouched = fn;
    }
    /**
     * Registers a function called when the control value changes.
     * @nodoc
     */
    registerOnChange(fn) {
      this.onChange = fn;
    }
    /**
     * Sets the "disabled" property on the range input element.
     * @nodoc
     */
    setDisabledState(isDisabled) {
      this.setProperty('disabled', isDisabled);
    }
  }
  BaseControlValueAccessor.ɵfac = function BaseControlValueAccessor_Factory(t) {
    return new (t || BaseControlValueAccessor)(core_js_["ɵɵdirectiveInject"](core_js_.Renderer2), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef));
  };
  BaseControlValueAccessor.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: BaseControlValueAccessor
  });
  return BaseControlValueAccessor;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * Base class for all built-in ControlValueAccessor classes (except DefaultValueAccessor, which is
 * used in case no other CVAs can be found). We use this class to distinguish between default CVA,
 * built-in CVAs and custom CVAs, so that Forms logic can recognize built-in CVAs and treat custom
 * ones with higher priority (when both built-in and custom CVAs are present).
 *
 * Note: this is an *internal-only* class and should not be extended or used directly in
 * applications code.
 */
let BuiltInControlValueAccessor = /*#__PURE__*/(() => {
  class BuiltInControlValueAccessor extends BaseControlValueAccessor {}
  BuiltInControlValueAccessor.ɵfac = /*@__PURE__*/function () {
    let ɵBuiltInControlValueAccessor_BaseFactory;
    return function BuiltInControlValueAccessor_Factory(t) {
      return (ɵBuiltInControlValueAccessor_BaseFactory || (ɵBuiltInControlValueAccessor_BaseFactory = core_js_["ɵɵgetInheritedFactory"](BuiltInControlValueAccessor)))(t || BuiltInControlValueAccessor);
    };
  }();
  BuiltInControlValueAccessor.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: BuiltInControlValueAccessor,
    features: [core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return BuiltInControlValueAccessor;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * Used to provide a `ControlValueAccessor` for form controls.
 *
 * See `DefaultValueAccessor` for how to implement one.
 *
 * @publicApi
 */
const NG_VALUE_ACCESSOR = /*#__PURE__*/new core_js_.InjectionToken('NgValueAccessor');

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const CHECKBOX_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => CheckboxControlValueAccessor),
  multi: true
};
/**
 * @description
 * A `ControlValueAccessor` for writing a value and listening to changes on a checkbox input
 * element.
 *
 * @usageNotes
 *
 * ### Using a checkbox with a reactive form.
 *
 * The following example shows how to use a checkbox with a reactive form.
 *
 * ```ts
 * const rememberLoginControl = new FormControl();
 * ```
 *
 * ```
 * <input type="checkbox" [formControl]="rememberLoginControl">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let CheckboxControlValueAccessor = /*#__PURE__*/(() => {
  class CheckboxControlValueAccessor extends BuiltInControlValueAccessor {
    /**
     * Sets the "checked" property on the input element.
     * @nodoc
     */
    writeValue(value) {
      this.setProperty('checked', value);
    }
  }
  CheckboxControlValueAccessor.ɵfac = /*@__PURE__*/function () {
    let ɵCheckboxControlValueAccessor_BaseFactory;
    return function CheckboxControlValueAccessor_Factory(t) {
      return (ɵCheckboxControlValueAccessor_BaseFactory || (ɵCheckboxControlValueAccessor_BaseFactory = core_js_["ɵɵgetInheritedFactory"](CheckboxControlValueAccessor)))(t || CheckboxControlValueAccessor);
    };
  }();
  CheckboxControlValueAccessor.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: CheckboxControlValueAccessor,
    selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]],
    hostBindings: function CheckboxControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("change", function CheckboxControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.checked);
        })("blur", function CheckboxControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    features: [core_js_["ɵɵProvidersFeature"]([CHECKBOX_VALUE_ACCESSOR]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return CheckboxControlValueAccessor;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const DEFAULT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => DefaultValueAccessor),
  multi: true
};
/**
 * We must check whether the agent is Android because composition events
 * behave differently between iOS and Android.
 */
function _isAndroid() {
  const userAgent = (0,common_js_["ɵgetDOM"])() ? (0,common_js_["ɵgetDOM"])().getUserAgent() : '';
  return /android (\d+)/.test(userAgent.toLowerCase());
}
/**
 * @description
 * Provide this token to control if form directives buffer IME input until
 * the "compositionend" event occurs.
 * @publicApi
 */
const COMPOSITION_BUFFER_MODE = /*#__PURE__*/new core_js_.InjectionToken('CompositionEventMode');
/**
 * The default `ControlValueAccessor` for writing a value and listening to changes on input
 * elements. The accessor is used by the `FormControlDirective`, `FormControlName`, and
 * `NgModel` directives.
 *
 * {@searchKeywords ngDefaultControl}
 *
 * @usageNotes
 *
 * ### Using the default value accessor
 *
 * The following example shows how to use an input element that activates the default value accessor
 * (in this case, a text field).
 *
 * ```ts
 * const firstNameControl = new FormControl();
 * ```
 *
 * ```
 * <input type="text" [formControl]="firstNameControl">
 * ```
 *
 * This value accessor is used by default for `<input type="text">` and `<textarea>` elements, but
 * you could also use it for custom components that have similar behavior and do not require special
 * processing. In order to attach the default value accessor to a custom element, add the
 * `ngDefaultControl` attribute as shown below.
 *
 * ```
 * <custom-input-component ngDefaultControl [(ngModel)]="value"></custom-input-component>
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let DefaultValueAccessor = /*#__PURE__*/(() => {
  class DefaultValueAccessor extends BaseControlValueAccessor {
    constructor(renderer, elementRef, _compositionMode) {
      super(renderer, elementRef);
      this._compositionMode = _compositionMode;
      /** Whether the user is creating a composition string (IME events). */
      this._composing = false;
      if (this._compositionMode == null) {
        this._compositionMode = !_isAndroid();
      }
    }
    /**
     * Sets the "value" property on the input element.
     * @nodoc
     */
    writeValue(value) {
      const normalizedValue = value == null ? '' : value;
      this.setProperty('value', normalizedValue);
    }
    /** @internal */
    _handleInput(value) {
      if (!this._compositionMode || this._compositionMode && !this._composing) {
        this.onChange(value);
      }
    }
    /** @internal */
    _compositionStart() {
      this._composing = true;
    }
    /** @internal */
    _compositionEnd(value) {
      this._composing = false;
      this._compositionMode && this.onChange(value);
    }
  }
  DefaultValueAccessor.ɵfac = function DefaultValueAccessor_Factory(t) {
    return new (t || DefaultValueAccessor)(core_js_["ɵɵdirectiveInject"](core_js_.Renderer2), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](COMPOSITION_BUFFER_MODE, 8));
  };
  DefaultValueAccessor.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: DefaultValueAccessor,
    selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]],
    hostBindings: function DefaultValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("input", function DefaultValueAccessor_input_HostBindingHandler($event) {
          return ctx._handleInput($event.target.value);
        })("blur", function DefaultValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        })("compositionstart", function DefaultValueAccessor_compositionstart_HostBindingHandler() {
          return ctx._compositionStart();
        })("compositionend", function DefaultValueAccessor_compositionend_HostBindingHandler($event) {
          return ctx._compositionEnd($event.target.value);
        });
      }
    },
    features: [core_js_["ɵɵProvidersFeature"]([DEFAULT_VALUE_ACCESSOR]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return DefaultValueAccessor;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function isEmptyInputValue(value) {
  // we don't check for string here so it also works with arrays
  return value == null || value.length === 0;
}
function hasValidLength(value) {
  // non-strict comparison is intentional, to check for both `null` and `undefined` values
  return value != null && typeof value.length === 'number';
}
/**
 * @description
 * An `InjectionToken` for registering additional synchronous validators used with
 * `AbstractControl`s.
 *
 * @see `NG_ASYNC_VALIDATORS`
 *
 * @usageNotes
 *
 * ### Providing a custom validator
 *
 * The following example registers a custom validator directive. Adding the validator to the
 * existing collection of validators requires the `multi: true` option.
 *
 * ```typescript
 * @Directive({
 *   selector: '[customValidator]',
 *   providers: [{provide: NG_VALIDATORS, useExisting: CustomValidatorDirective, multi: true}]
 * })
 * class CustomValidatorDirective implements Validator {
 *   validate(control: AbstractControl): ValidationErrors | null {
 *     return { 'custom': true };
 *   }
 * }
 * ```
 *
 * @publicApi
 */
const NG_VALIDATORS = /*#__PURE__*/new core_js_.InjectionToken('NgValidators');
/**
 * @description
 * An `InjectionToken` for registering additional asynchronous validators used with
 * `AbstractControl`s.
 *
 * @see `NG_VALIDATORS`
 *
 * @publicApi
 */
const NG_ASYNC_VALIDATORS = /*#__PURE__*/new core_js_.InjectionToken('NgAsyncValidators');
/**
 * A regular expression that matches valid e-mail addresses.
 *
 * At a high level, this regexp matches e-mail addresses of the format `local-part@tld`, where:
 * - `local-part` consists of one or more of the allowed characters (alphanumeric and some
 *   punctuation symbols).
 * - `local-part` cannot begin or end with a period (`.`).
 * - `local-part` cannot be longer than 64 characters.
 * - `tld` consists of one or more `labels` separated by periods (`.`). For example `localhost` or
 *   `foo.com`.
 * - A `label` consists of one or more of the allowed characters (alphanumeric, dashes (`-`) and
 *   periods (`.`)).
 * - A `label` cannot begin or end with a dash (`-`) or a period (`.`).
 * - A `label` cannot be longer than 63 characters.
 * - The whole address cannot be longer than 254 characters.
 *
 * ## Implementation background
 *
 * This regexp was ported over from AngularJS (see there for git history):
 * https://github.com/angular/angular.js/blob/c133ef836/src/ng/directive/input.js#L27
 * It is based on the
 * [WHATWG version](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with
 * some enhancements to incorporate more RFC rules (such as rules related to domain names and the
 * lengths of different parts of the address). The main differences from the WHATWG version are:
 *   - Disallow `local-part` to begin or end with a period (`.`).
 *   - Disallow `local-part` length to exceed 64 characters.
 *   - Disallow total address length to exceed 254 characters.
 *
 * See [this commit](https://github.com/angular/angular.js/commit/f3f5cf72e) for more details.
 */
const EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
/**
 * @description
 * Provides a set of built-in validators that can be used by form controls.
 *
 * A validator is a function that processes a `FormControl` or collection of
 * controls and returns an error map or null. A null map means that validation has passed.
 *
 * @see [Form Validation](/guide/form-validation)
 *
 * @publicApi
 */
class Validators {
  /**
   * @description
   * Validator that requires the control's value to be greater than or equal to the provided number.
   *
   * @usageNotes
   *
   * ### Validate against a minimum of 3
   *
   * ```typescript
   * const control = new FormControl(2, Validators.min(3));
   *
   * console.log(control.errors); // {min: {min: 3, actual: 2}}
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `min` property if the validation check fails, otherwise `null`.
   *
   * @see `updateValueAndValidity()`
   *
   */
  static min(min) {
    return minValidator(min);
  }
  /**
   * @description
   * Validator that requires the control's value to be less than or equal to the provided number.
   *
   * @usageNotes
   *
   * ### Validate against a maximum of 15
   *
   * ```typescript
   * const control = new FormControl(16, Validators.max(15));
   *
   * console.log(control.errors); // {max: {max: 15, actual: 16}}
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `max` property if the validation check fails, otherwise `null`.
   *
   * @see `updateValueAndValidity()`
   *
   */
  static max(max) {
    return maxValidator(max);
  }
  /**
   * @description
   * Validator that requires the control have a non-empty value.
   *
   * @usageNotes
   *
   * ### Validate that the field is non-empty
   *
   * ```typescript
   * const control = new FormControl('', Validators.required);
   *
   * console.log(control.errors); // {required: true}
   * ```
   *
   * @returns An error map with the `required` property
   * if the validation check fails, otherwise `null`.
   *
   * @see `updateValueAndValidity()`
   *
   */
  static required(control) {
    return requiredValidator(control);
  }
  /**
   * @description
   * Validator that requires the control's value be true. This validator is commonly
   * used for required checkboxes.
   *
   * @usageNotes
   *
   * ### Validate that the field value is true
   *
   * ```typescript
   * const control = new FormControl('', Validators.requiredTrue);
   *
   * console.log(control.errors); // {required: true}
   * ```
   *
   * @returns An error map that contains the `required` property
   * set to `true` if the validation check fails, otherwise `null`.
   *
   * @see `updateValueAndValidity()`
   *
   */
  static requiredTrue(control) {
    return requiredTrueValidator(control);
  }
  /**
   * @description
   * Validator that requires the control's value pass an email validation test.
   *
   * Tests the value using a [regular
   * expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
   * pattern suitable for common usecases. The pattern is based on the definition of a valid email
   * address in the [WHATWG HTML
   * specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with
   * some enhancements to incorporate more RFC rules (such as rules related to domain names and the
   * lengths of different parts of the address).
   *
   * The differences from the WHATWG version include:
   * - Disallow `local-part` (the part before the `@` symbol) to begin or end with a period (`.`).
   * - Disallow `local-part` to be longer than 64 characters.
   * - Disallow the whole address to be longer than 254 characters.
   *
   * If this pattern does not satisfy your business needs, you can use `Validators.pattern()` to
   * validate the value against a different pattern.
   *
   * @usageNotes
   *
   * ### Validate that the field matches a valid email pattern
   *
   * ```typescript
   * const control = new FormControl('bad@', Validators.email);
   *
   * console.log(control.errors); // {email: true}
   * ```
   *
   * @returns An error map with the `email` property
   * if the validation check fails, otherwise `null`.
   *
   * @see `updateValueAndValidity()`
   *
   */
  static email(control) {
    return emailValidator(control);
  }
  /**
   * @description
   * Validator that requires the length of the control's value to be greater than or equal
   * to the provided minimum length. This validator is also provided by default if you use the
   * the HTML5 `minlength` attribute. Note that the `minLength` validator is intended to be used
   * only for types that have a numeric `length` property, such as strings or arrays. The
   * `minLength` validator logic is also not invoked for values when their `length` property is 0
   * (for example in case of an empty string or an empty array), to support optional controls. You
   * can use the standard `required` validator if empty values should not be considered valid.
   *
   * @usageNotes
   *
   * ### Validate that the field has a minimum of 3 characters
   *
   * ```typescript
   * const control = new FormControl('ng', Validators.minLength(3));
   *
   * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}
   * ```
   *
   * ```html
   * <input minlength="5">
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `minlength` property if the validation check fails, otherwise `null`.
   *
   * @see `updateValueAndValidity()`
   *
   */
  static minLength(minLength) {
    return minLengthValidator(minLength);
  }
  /**
   * @description
   * Validator that requires the length of the control's value to be less than or equal
   * to the provided maximum length. This validator is also provided by default if you use the
   * the HTML5 `maxlength` attribute. Note that the `maxLength` validator is intended to be used
   * only for types that have a numeric `length` property, such as strings or arrays.
   *
   * @usageNotes
   *
   * ### Validate that the field has maximum of 5 characters
   *
   * ```typescript
   * const control = new FormControl('Angular', Validators.maxLength(5));
   *
   * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}
   * ```
   *
   * ```html
   * <input maxlength="5">
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `maxlength` property if the validation check fails, otherwise `null`.
   *
   * @see `updateValueAndValidity()`
   *
   */
  static maxLength(maxLength) {
    return maxLengthValidator(maxLength);
  }
  /**
   * @description
   * Validator that requires the control's value to match a regex pattern. This validator is also
   * provided by default if you use the HTML5 `pattern` attribute.
   *
   * @usageNotes
   *
   * ### Validate that the field only contains letters or spaces
   *
   * ```typescript
   * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));
   *
   * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}
   * ```
   *
   * ```html
   * <input pattern="[a-zA-Z ]*">
   * ```
   *
   * ### Pattern matching with the global or sticky flag
   *
   * `RegExp` objects created with the `g` or `y` flags that are passed into `Validators.pattern`
   * can produce different results on the same input when validations are run consecutively. This is
   * due to how the behavior of `RegExp.prototype.test` is
   * specified in [ECMA-262](https://tc39.es/ecma262/#sec-regexpbuiltinexec)
   * (`RegExp` preserves the index of the last match when the global or sticky flag is used).
   * Due to this behavior, it is recommended that when using
   * `Validators.pattern` you **do not** pass in a `RegExp` object with either the global or sticky
   * flag enabled.
   *
   * ```typescript
   * // Not recommended (since the `g` flag is used)
   * const controlOne = new FormControl('1', Validators.pattern(/foo/g));
   *
   * // Good
   * const controlTwo = new FormControl('1', Validators.pattern(/foo/));
   * ```
   *
   * @param pattern A regular expression to be used as is to test the values, or a string.
   * If a string is passed, the `^` character is prepended and the `$` character is
   * appended to the provided string (if not already present), and the resulting regular
   * expression is used to test the values.
   *
   * @returns A validator function that returns an error map with the
   * `pattern` property if the validation check fails, otherwise `null`.
   *
   * @see `updateValueAndValidity()`
   *
   */
  static pattern(pattern) {
    return patternValidator(pattern);
  }
  /**
   * @description
   * Validator that performs no operation.
   *
   * @see `updateValueAndValidity()`
   *
   */
  static nullValidator(control) {
    return nullValidator(control);
  }
  static compose(validators) {
    return compose(validators);
  }
  /**
   * @description
   * Compose multiple async validators into a single function that returns the union
   * of the individual error objects for the provided control.
   *
   * @returns A validator function that returns an error map with the
   * merged error objects of the async validators if the validation check fails, otherwise `null`.
   *
   * @see `updateValueAndValidity()`
   *
   */
  static composeAsync(validators) {
    return composeAsync(validators);
  }
}
/**
 * Validator that requires the control's value to be greater than or equal to the provided number.
 * See `Validators.min` for additional information.
 */
function minValidator(min) {
  return control => {
    if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {
      return null; // don't validate empty values to allow optional controls
    }

    const value = parseFloat(control.value);
    // Controls with NaN values after parsing should be treated as not having a
    // minimum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-min
    return !isNaN(value) && value < min ? {
      'min': {
        'min': min,
        'actual': control.value
      }
    } : null;
  };
}
/**
 * Validator that requires the control's value to be less than or equal to the provided number.
 * See `Validators.max` for additional information.
 */
function maxValidator(max) {
  return control => {
    if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) {
      return null; // don't validate empty values to allow optional controls
    }

    const value = parseFloat(control.value);
    // Controls with NaN values after parsing should be treated as not having a
    // maximum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-max
    return !isNaN(value) && value > max ? {
      'max': {
        'max': max,
        'actual': control.value
      }
    } : null;
  };
}
/**
 * Validator that requires the control have a non-empty value.
 * See `Validators.required` for additional information.
 */
function requiredValidator(control) {
  return isEmptyInputValue(control.value) ? {
    'required': true
  } : null;
}
/**
 * Validator that requires the control's value be true. This validator is commonly
 * used for required checkboxes.
 * See `Validators.requiredTrue` for additional information.
 */
function requiredTrueValidator(control) {
  return control.value === true ? null : {
    'required': true
  };
}
/**
 * Validator that requires the control's value pass an email validation test.
 * See `Validators.email` for additional information.
 */
function emailValidator(control) {
  if (isEmptyInputValue(control.value)) {
    return null; // don't validate empty values to allow optional controls
  }

  return EMAIL_REGEXP.test(control.value) ? null : {
    'email': true
  };
}
/**
 * Validator that requires the length of the control's value to be greater than or equal
 * to the provided minimum length. See `Validators.minLength` for additional information.
 */
function minLengthValidator(minLength) {
  return control => {
    if (isEmptyInputValue(control.value) || !hasValidLength(control.value)) {
      // don't validate empty values to allow optional controls
      // don't validate values without `length` property
      return null;
    }
    return control.value.length < minLength ? {
      'minlength': {
        'requiredLength': minLength,
        'actualLength': control.value.length
      }
    } : null;
  };
}
/**
 * Validator that requires the length of the control's value to be less than or equal
 * to the provided maximum length. See `Validators.maxLength` for additional information.
 */
function maxLengthValidator(maxLength) {
  return control => {
    return hasValidLength(control.value) && control.value.length > maxLength ? {
      'maxlength': {
        'requiredLength': maxLength,
        'actualLength': control.value.length
      }
    } : null;
  };
}
/**
 * Validator that requires the control's value to match a regex pattern.
 * See `Validators.pattern` for additional information.
 */
function patternValidator(pattern) {
  if (!pattern) return nullValidator;
  let regex;
  let regexStr;
  if (typeof pattern === 'string') {
    regexStr = '';
    if (pattern.charAt(0) !== '^') regexStr += '^';
    regexStr += pattern;
    if (pattern.charAt(pattern.length - 1) !== '$') regexStr += '$';
    regex = new RegExp(regexStr);
  } else {
    regexStr = pattern.toString();
    regex = pattern;
  }
  return control => {
    if (isEmptyInputValue(control.value)) {
      return null; // don't validate empty values to allow optional controls
    }

    const value = control.value;
    return regex.test(value) ? null : {
      'pattern': {
        'requiredPattern': regexStr,
        'actualValue': value
      }
    };
  };
}
/**
 * Function that has `ValidatorFn` shape, but performs no operation.
 */
function nullValidator(control) {
  return null;
}
function isPresent(o) {
  return o != null;
}
function toObservable(r) {
  const obs = (0,core_js_["ɵisPromise"])(r) ? (0,from/* from */.D)(r) : r;
  if (!(0,core_js_["ɵisObservable"])(obs) && (typeof ngDevMode === 'undefined' || ngDevMode)) {
    throw new Error(`Expected validator to return Promise or Observable.`);
  }
  return obs;
}
function mergeErrors(arrayOfErrors) {
  let res = {};
  // Not using Array.reduce here due to a Chrome 80 bug
  // https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
  arrayOfErrors.forEach(errors => {
    res = errors != null ? Object.assign(Object.assign({}, res), errors) : res;
  });
  return Object.keys(res).length === 0 ? null : res;
}
function executeValidators(control, validators) {
  return validators.map(validator => validator(control));
}
function isValidatorFn(validator) {
  return !validator.validate;
}
/**
 * Given the list of validators that may contain both functions as well as classes, return the list
 * of validator functions (convert validator classes into validator functions). This is needed to
 * have consistent structure in validators list before composing them.
 *
 * @param validators The set of validators that may contain validators both in plain function form
 *     as well as represented as a validator class.
 */
function normalizeValidators(validators) {
  return validators.map(validator => {
    return isValidatorFn(validator) ? validator : c => validator.validate(c);
  });
}
/**
 * Merges synchronous validators into a single validator function.
 * See `Validators.compose` for additional information.
 */
function compose(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function (control) {
    return mergeErrors(executeValidators(control, presentValidators));
  };
}
/**
 * Accepts a list of validators of different possible shapes (`Validator` and `ValidatorFn`),
 * normalizes the list (converts everything to `ValidatorFn`) and merges them into a single
 * validator function.
 */
function composeValidators(validators) {
  return validators != null ? compose(normalizeValidators(validators)) : null;
}
/**
 * Merges asynchronous validators into a single validator function.
 * See `Validators.composeAsync` for additional information.
 */
function composeAsync(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function (control) {
    const observables = executeValidators(control, presentValidators).map(toObservable);
    return forkJoin(observables).pipe((0,map/* map */.U)(mergeErrors));
  };
}
/**
 * Accepts a list of async validators of different possible shapes (`AsyncValidator` and
 * `AsyncValidatorFn`), normalizes the list (converts everything to `AsyncValidatorFn`) and merges
 * them into a single validator function.
 */
function composeAsyncValidators(validators) {
  return validators != null ? composeAsync(normalizeValidators(validators)) : null;
}
/**
 * Merges raw control validators with a given directive validator and returns the combined list of
 * validators as an array.
 */
function mergeValidators(controlValidators, dirValidator) {
  if (controlValidators === null) return [dirValidator];
  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] : [controlValidators, dirValidator];
}
/**
 * Retrieves the list of raw synchronous validators attached to a given control.
 */
function getControlValidators(control) {
  return control._rawValidators;
}
/**
 * Retrieves the list of raw asynchronous validators attached to a given control.
 */
function getControlAsyncValidators(control) {
  return control._rawAsyncValidators;
}
/**
 * Accepts a singleton validator, an array, or null, and returns an array type with the provided
 * validators.
 *
 * @param validators A validator, validators, or null.
 * @returns A validators array.
 */
function makeValidatorsArray(validators) {
  if (!validators) return [];
  return Array.isArray(validators) ? validators : [validators];
}
/**
 * Determines whether a validator or validators array has a given validator.
 *
 * @param validators The validator or validators to compare against.
 * @param validator The validator to check.
 * @returns Whether the validator is present.
 */
function hasValidator(validators, validator) {
  return Array.isArray(validators) ? validators.includes(validator) : validators === validator;
}
/**
 * Combines two arrays of validators into one. If duplicates are provided, only one will be added.
 *
 * @param validators The new validators.
 * @param currentValidators The base array of currrent validators.
 * @returns An array of validators.
 */
function addValidators(validators, currentValidators) {
  const current = makeValidatorsArray(currentValidators);
  const validatorsToAdd = makeValidatorsArray(validators);
  validatorsToAdd.forEach(v => {
    // Note: if there are duplicate entries in the new validators array,
    // only the first one would be added to the current list of validarors.
    // Duplicate ones would be ignored since `hasValidator` would detect
    // the presence of a validator function and we update the current list in place.
    if (!hasValidator(current, v)) {
      current.push(v);
    }
  });
  return current;
}
function removeValidators(validators, currentValidators) {
  return makeValidatorsArray(currentValidators).filter(v => !hasValidator(validators, v));
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @description
 * Base class for control directives.
 *
 * This class is only used internally in the `ReactiveFormsModule` and the `FormsModule`.
 *
 * @publicApi
 */
let AbstractControlDirective = /*#__PURE__*/(() => {
  class AbstractControlDirective {
    constructor() {
      /**
       * Set of synchronous validators as they were provided while calling `setValidators` function.
       * @internal
       */
      this._rawValidators = [];
      /**
       * Set of asynchronous validators as they were provided while calling `setAsyncValidators`
       * function.
       * @internal
       */
      this._rawAsyncValidators = [];
      /*
       * The set of callbacks to be invoked when directive instance is being destroyed.
       */
      this._onDestroyCallbacks = [];
    }
    /**
     * @description
     * Reports the value of the control if it is present, otherwise null.
     */
    get value() {
      return this.control ? this.control.value : null;
    }
    /**
     * @description
     * Reports whether the control is valid. A control is considered valid if no
     * validation errors exist with the current value.
     * If the control is not present, null is returned.
     */
    get valid() {
      return this.control ? this.control.valid : null;
    }
    /**
     * @description
     * Reports whether the control is invalid, meaning that an error exists in the input value.
     * If the control is not present, null is returned.
     */
    get invalid() {
      return this.control ? this.control.invalid : null;
    }
    /**
     * @description
     * Reports whether a control is pending, meaning that that async validation is occurring and
     * errors are not yet available for the input value. If the control is not present, null is
     * returned.
     */
    get pending() {
      return this.control ? this.control.pending : null;
    }
    /**
     * @description
     * Reports whether the control is disabled, meaning that the control is disabled
     * in the UI and is exempt from validation checks and excluded from aggregate
     * values of ancestor controls. If the control is not present, null is returned.
     */
    get disabled() {
      return this.control ? this.control.disabled : null;
    }
    /**
     * @description
     * Reports whether the control is enabled, meaning that the control is included in ancestor
     * calculations of validity or value. If the control is not present, null is returned.
     */
    get enabled() {
      return this.control ? this.control.enabled : null;
    }
    /**
     * @description
     * Reports the control's validation errors. If the control is not present, null is returned.
     */
    get errors() {
      return this.control ? this.control.errors : null;
    }
    /**
     * @description
     * Reports whether the control is pristine, meaning that the user has not yet changed
     * the value in the UI. If the control is not present, null is returned.
     */
    get pristine() {
      return this.control ? this.control.pristine : null;
    }
    /**
     * @description
     * Reports whether the control is dirty, meaning that the user has changed
     * the value in the UI. If the control is not present, null is returned.
     */
    get dirty() {
      return this.control ? this.control.dirty : null;
    }
    /**
     * @description
     * Reports whether the control is touched, meaning that the user has triggered
     * a `blur` event on it. If the control is not present, null is returned.
     */
    get touched() {
      return this.control ? this.control.touched : null;
    }
    /**
     * @description
     * Reports the validation status of the control. Possible values include:
     * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.
     * If the control is not present, null is returned.
     */
    get status() {
      return this.control ? this.control.status : null;
    }
    /**
     * @description
     * Reports whether the control is untouched, meaning that the user has not yet triggered
     * a `blur` event on it. If the control is not present, null is returned.
     */
    get untouched() {
      return this.control ? this.control.untouched : null;
    }
    /**
     * @description
     * Returns a multicasting observable that emits a validation status whenever it is
     * calculated for the control. If the control is not present, null is returned.
     */
    get statusChanges() {
      return this.control ? this.control.statusChanges : null;
    }
    /**
     * @description
     * Returns a multicasting observable of value changes for the control that emits every time the
     * value of the control changes in the UI or programmatically.
     * If the control is not present, null is returned.
     */
    get valueChanges() {
      return this.control ? this.control.valueChanges : null;
    }
    /**
     * @description
     * Returns an array that represents the path from the top-level form to this control.
     * Each index is the string name of the control on that level.
     */
    get path() {
      return null;
    }
    /**
     * Sets synchronous validators for this directive.
     * @internal
     */
    _setValidators(validators) {
      this._rawValidators = validators || [];
      this._composedValidatorFn = composeValidators(this._rawValidators);
    }
    /**
     * Sets asynchronous validators for this directive.
     * @internal
     */
    _setAsyncValidators(validators) {
      this._rawAsyncValidators = validators || [];
      this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);
    }
    /**
     * @description
     * Synchronous validator function composed of all the synchronous validators registered with this
     * directive.
     */
    get validator() {
      return this._composedValidatorFn || null;
    }
    /**
     * @description
     * Asynchronous validator function composed of all the asynchronous validators registered with
     * this directive.
     */
    get asyncValidator() {
      return this._composedAsyncValidatorFn || null;
    }
    /**
     * Internal function to register callbacks that should be invoked
     * when directive instance is being destroyed.
     * @internal
     */
    _registerOnDestroy(fn) {
      this._onDestroyCallbacks.push(fn);
    }
    /**
     * Internal function to invoke all registered "on destroy" callbacks.
     * Note: calling this function also clears the list of callbacks.
     * @internal
     */
    _invokeOnDestroyCallbacks() {
      this._onDestroyCallbacks.forEach(fn => fn());
      this._onDestroyCallbacks = [];
    }
    /**
     * @description
     * Resets the control with the provided value if the control is present.
     */
    reset(value = undefined) {
      if (this.control) this.control.reset(value);
    }
    /**
     * @description
     * Reports whether the control with the given path has the error specified.
     *
     * @param errorCode The code of the error to check
     * @param path A list of control names that designates how to move from the current control
     * to the control that should be queried for errors.
     *
     * @usageNotes
     * For example, for the following `FormGroup`:
     *
     * ```
     * form = new FormGroup({
     *   address: new FormGroup({ street: new FormControl() })
     * });
     * ```
     *
     * The path to the 'street' control from the root form would be 'address' -> 'street'.
     *
     * It can be provided to this method in one of two formats:
     *
     * 1. An array of string control names, e.g. `['address', 'street']`
     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
     *
     * If no path is given, this method checks for the error on the current control.
     *
     * @returns whether the given error is present in the control at the given path.
     *
     * If the control is not present, false is returned.
     */
    hasError(errorCode, path) {
      return this.control ? this.control.hasError(errorCode, path) : false;
    }
    /**
     * @description
     * Reports error data for the control with the given path.
     *
     * @param errorCode The code of the error to check
     * @param path A list of control names that designates how to move from the current control
     * to the control that should be queried for errors.
     *
     * @usageNotes
     * For example, for the following `FormGroup`:
     *
     * ```
     * form = new FormGroup({
     *   address: new FormGroup({ street: new FormControl() })
     * });
     * ```
     *
     * The path to the 'street' control from the root form would be 'address' -> 'street'.
     *
     * It can be provided to this method in one of two formats:
     *
     * 1. An array of string control names, e.g. `['address', 'street']`
     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
     *
     * @returns error data for that particular error. If the control or error is not present,
     * null is returned.
     */
    getError(errorCode, path) {
      return this.control ? this.control.getError(errorCode, path) : null;
    }
  }
  AbstractControlDirective.ɵfac = function AbstractControlDirective_Factory(t) {
    return new (t || AbstractControlDirective)();
  };
  AbstractControlDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: AbstractControlDirective
  });

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @description
   * A base class for directives that contain multiple registered instances of `NgControl`.
   * Only used by the forms module.
   *
   * @publicApi
   */
  return AbstractControlDirective;
})();
let ControlContainer = /*#__PURE__*/(() => {
  class ControlContainer extends AbstractControlDirective {
    /**
     * @description
     * The top-level form directive for the control.
     */
    get formDirective() {
      return null;
    }
    /**
     * @description
     * The path to this group.
     */
    get path() {
      return null;
    }
  }
  ControlContainer.ɵfac = /*@__PURE__*/function () {
    let ɵControlContainer_BaseFactory;
    return function ControlContainer_Factory(t) {
      return (ɵControlContainer_BaseFactory || (ɵControlContainer_BaseFactory = core_js_["ɵɵgetInheritedFactory"](ControlContainer)))(t || ControlContainer);
    };
  }();
  ControlContainer.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: ControlContainer,
    features: [core_js_["ɵɵInheritDefinitionFeature"]]
  });

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @description
   * A base class that all `FormControl`-based directives extend. It binds a `FormControl`
   * object to a DOM element.
   *
   * @publicApi
   */
  return ControlContainer;
})();
class NgControl extends AbstractControlDirective {
  constructor() {
    super(...arguments);
    /**
     * @description
     * The parent form for the control.
     *
     * @internal
     */
    this._parent = null;
    /**
     * @description
     * The name for the control
     */
    this.name = null;
    /**
     * @description
     * The value accessor for the control
     */
    this.valueAccessor = null;
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class AbstractControlStatus {
  constructor(cd) {
    this._cd = cd;
  }
  is(status) {
    var _a, _b, _c;
    // Currently with ViewEngine (in AOT mode) it's not possible to use private methods in host
    // bindings.
    // TODO: once ViewEngine is removed, this function should be refactored:
    //  - make the `is` method `protected`, so it's not accessible publicly
    //  - move the `submitted` status logic to the `NgControlStatusGroup` class
    //    and make it `private` or `protected` too.
    if (status === 'submitted') {
      // We check for the `submitted` field from `NgForm` and `FormGroupDirective` classes, but
      // we avoid instanceof checks to prevent non-tree-shakable references to those types.
      return !!((_a = this._cd) === null || _a === void 0 ? void 0 : _a.submitted);
    }
    return !!((_c = (_b = this._cd) === null || _b === void 0 ? void 0 : _b.control) === null || _c === void 0 ? void 0 : _c[status]);
  }
}
const ngControlStatusHost = {
  '[class.ng-untouched]': 'is("untouched")',
  '[class.ng-touched]': 'is("touched")',
  '[class.ng-pristine]': 'is("pristine")',
  '[class.ng-dirty]': 'is("dirty")',
  '[class.ng-valid]': 'is("valid")',
  '[class.ng-invalid]': 'is("invalid")',
  '[class.ng-pending]': 'is("pending")'
};
const ngGroupStatusHost = {
  '[class.ng-untouched]': 'is("untouched")',
  '[class.ng-touched]': 'is("touched")',
  '[class.ng-pristine]': 'is("pristine")',
  '[class.ng-dirty]': 'is("dirty")',
  '[class.ng-valid]': 'is("valid")',
  '[class.ng-invalid]': 'is("invalid")',
  '[class.ng-pending]': 'is("pending")',
  '[class.ng-submitted]': 'is("submitted")'
};
/**
 * @description
 * Directive automatically applied to Angular form controls that sets CSS classes
 * based on control status.
 *
 * @usageNotes
 *
 * ### CSS classes applied
 *
 * The following classes are applied as the properties become true:
 *
 * * ng-valid
 * * ng-invalid
 * * ng-pending
 * * ng-pristine
 * * ng-dirty
 * * ng-untouched
 * * ng-touched
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let NgControlStatus = /*#__PURE__*/(() => {
  class NgControlStatus extends AbstractControlStatus {
    constructor(cd) {
      super(cd);
    }
  }
  NgControlStatus.ɵfac = function NgControlStatus_Factory(t) {
    return new (t || NgControlStatus)(core_js_["ɵɵdirectiveInject"](NgControl, 2));
  };
  NgControlStatus.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: NgControlStatus,
    selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]],
    hostVars: 14,
    hostBindings: function NgControlStatus_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("ng-untouched", ctx.is("untouched"))("ng-touched", ctx.is("touched"))("ng-pristine", ctx.is("pristine"))("ng-dirty", ctx.is("dirty"))("ng-valid", ctx.is("valid"))("ng-invalid", ctx.is("invalid"))("ng-pending", ctx.is("pending"));
      }
    },
    features: [core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return NgControlStatus;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Directive automatically applied to Angular form groups that sets CSS classes
 * based on control status (valid/invalid/dirty/etc). On groups, this includes the additional
 * class ng-submitted.
 *
 * @see `NgControlStatus`
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let NgControlStatusGroup = /*#__PURE__*/(() => {
  class NgControlStatusGroup extends AbstractControlStatus {
    constructor(cd) {
      super(cd);
    }
  }
  NgControlStatusGroup.ɵfac = function NgControlStatusGroup_Factory(t) {
    return new (t || NgControlStatusGroup)(core_js_["ɵɵdirectiveInject"](ControlContainer, 10));
  };
  NgControlStatusGroup.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: NgControlStatusGroup,
    selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]],
    hostVars: 16,
    hostBindings: function NgControlStatusGroup_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("ng-untouched", ctx.is("untouched"))("ng-touched", ctx.is("touched"))("ng-pristine", ctx.is("pristine"))("ng-dirty", ctx.is("dirty"))("ng-valid", ctx.is("valid"))("ng-invalid", ctx.is("invalid"))("ng-pending", ctx.is("pending"))("ng-submitted", ctx.is("submitted"));
      }
    },
    features: [core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return NgControlStatusGroup;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const formControlNameExample = `
  <div [formGroup]="myGroup">
    <input formControlName="firstName">
  </div>

  In your class:

  this.myGroup = new FormGroup({
      firstName: new FormControl()
  });`;
const formGroupNameExample = `
  <div [formGroup]="myGroup">
      <div formGroupName="person">
        <input formControlName="firstName">
      </div>
  </div>

  In your class:

  this.myGroup = new FormGroup({
      person: new FormGroup({ firstName: new FormControl() })
  });`;
const formArrayNameExample = `
  <div [formGroup]="myGroup">
    <div formArrayName="cities">
      <div *ngFor="let city of cityArray.controls; index as i">
        <input [formControlName]="i">
      </div>
    </div>
  </div>

  In your class:

  this.cityArray = new FormArray([new FormControl('SF')]);
  this.myGroup = new FormGroup({
    cities: this.cityArray
  });`;
const ngModelGroupExample = `
  <form>
      <div ngModelGroup="person">
        <input [(ngModel)]="person.name" name="firstName">
      </div>
  </form>`;
const ngModelWithFormGroupExample = `
  <div [formGroup]="myGroup">
      <input formControlName="firstName">
      <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">
  </div>
`;

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function controlParentException() {
  return new Error(`formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formControlNameExample}`);
}
function ngModelGroupException() {
  return new Error(`formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents
      that also have a "form" prefix: formGroupName, formArrayName, or formGroup.

      Option 1:  Update the parent to be formGroupName (reactive form strategy)

      ${formGroupNameExample}

      Option 2: Use ngModel instead of formControlName (template-driven strategy)

      ${ngModelGroupExample}`);
}
function missingFormException() {
  return new Error(`formGroup expects a FormGroup instance. Please pass one in.

      Example:

      ${formControlNameExample}`);
}
function groupParentException() {
  return new Error(`formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup
    directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formGroupNameExample}`);
}
function arrayParentException() {
  return new Error(`formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      Example:

      ${formArrayNameExample}`);
}
const disabledAttrWarning = `
  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true
  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for
  you. We recommend using this approach to avoid 'changed after checked' errors.

  Example:
  form = new FormGroup({
    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),
    last: new FormControl('Drew', Validators.required)
  });
`;
function ngModelWarning(directiveName) {
  return `
  It looks like you're using ngModel on the same form field as ${directiveName}.
  Support for using the ngModel input property and ngModelChange event with
  reactive form directives has been deprecated in Angular v6 and will be removed
  in a future version of Angular.

  For more information on this, see our API docs here:
  https://angular.io/api/forms/${directiveName === 'formControl' ? 'FormControlDirective' : 'FormControlName'}#use-with-ngmodel
  `;
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function controlPath(name, parent) {
  return [...parent.path, name];
}
/**
 * Links a Form control and a Form directive by setting up callbacks (such as `onChange`) on both
 * instances. This function is typically invoked when form directive is being initialized.
 *
 * @param control Form control instance that should be linked.
 * @param dir Directive that should be linked with a given control.
 */
function setUpControl(control, dir) {
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    if (!control) _throwError(dir, 'Cannot find control with');
    if (!dir.valueAccessor) _throwError(dir, 'No value accessor for form control with');
  }
  setUpValidators(control, dir);
  dir.valueAccessor.writeValue(control.value);
  setUpViewChangePipeline(control, dir);
  setUpModelChangePipeline(control, dir);
  setUpBlurPipeline(control, dir);
  setUpDisabledChangeHandler(control, dir);
}
/**
 * Reverts configuration performed by the `setUpControl` control function.
 * Effectively disconnects form control with a given form directive.
 * This function is typically invoked when corresponding form directive is being destroyed.
 *
 * @param control Form control which should be cleaned up.
 * @param dir Directive that should be disconnected from a given control.
 * @param validateControlPresenceOnChange Flag that indicates whether onChange handler should
 *     contain asserts to verify that it's not called once directive is destroyed. We need this flag
 *     to avoid potentially breaking changes caused by better control cleanup introduced in #39235.
 */
function cleanUpControl(control, dir, validateControlPresenceOnChange = true) {
  const noop = () => {
    if (validateControlPresenceOnChange && (typeof ngDevMode === 'undefined' || ngDevMode)) {
      _noControlError(dir);
    }
  };
  // The `valueAccessor` field is typically defined on FromControl and FormControlName directive
  // instances and there is a logic in `selectValueAccessor` function that throws if it's not the
  // case. We still check the presence of `valueAccessor` before invoking its methods to make sure
  // that cleanup works correctly if app code or tests are setup to ignore the error thrown from
  // `selectValueAccessor`. See https://github.com/angular/angular/issues/40521.
  if (dir.valueAccessor) {
    dir.valueAccessor.registerOnChange(noop);
    dir.valueAccessor.registerOnTouched(noop);
  }
  cleanUpValidators(control, dir);
  if (control) {
    dir._invokeOnDestroyCallbacks();
    control._registerOnCollectionChange(() => {});
  }
}
function registerOnValidatorChange(validators, onChange) {
  validators.forEach(validator => {
    if (validator.registerOnValidatorChange) validator.registerOnValidatorChange(onChange);
  });
}
/**
 * Sets up disabled change handler function on a given form control if ControlValueAccessor
 * associated with a given directive instance supports the `setDisabledState` call.
 *
 * @param control Form control where disabled change handler should be setup.
 * @param dir Corresponding directive instance associated with this control.
 */
function setUpDisabledChangeHandler(control, dir) {
  if (dir.valueAccessor.setDisabledState) {
    const onDisabledChange = isDisabled => {
      dir.valueAccessor.setDisabledState(isDisabled);
    };
    control.registerOnDisabledChange(onDisabledChange);
    // Register a callback function to cleanup disabled change handler
    // from a control instance when a directive is destroyed.
    dir._registerOnDestroy(() => {
      control._unregisterOnDisabledChange(onDisabledChange);
    });
  }
}
/**
 * Sets up sync and async directive validators on provided form control.
 * This function merges validators from the directive into the validators of the control.
 *
 * @param control Form control where directive validators should be setup.
 * @param dir Directive instance that contains validators to be setup.
 */
function setUpValidators(control, dir) {
  const validators = getControlValidators(control);
  if (dir.validator !== null) {
    control.setValidators(mergeValidators(validators, dir.validator));
  } else if (typeof validators === 'function') {
    // If sync validators are represented by a single validator function, we force the
    // `Validators.compose` call to happen by executing the `setValidators` function with
    // an array that contains that function. We need this to avoid possible discrepancies in
    // validators behavior, so sync validators are always processed by the `Validators.compose`.
    // Note: we should consider moving this logic inside the `setValidators` function itself, so we
    // have consistent behavior on AbstractControl API level. The same applies to the async
    // validators logic below.
    control.setValidators([validators]);
  }
  const asyncValidators = getControlAsyncValidators(control);
  if (dir.asyncValidator !== null) {
    control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));
  } else if (typeof asyncValidators === 'function') {
    control.setAsyncValidators([asyncValidators]);
  }
  // Re-run validation when validator binding changes, e.g. minlength=3 -> minlength=4
  const onValidatorChange = () => control.updateValueAndValidity();
  registerOnValidatorChange(dir._rawValidators, onValidatorChange);
  registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);
}
/**
 * Cleans up sync and async directive validators on provided form control.
 * This function reverts the setup performed by the `setUpValidators` function, i.e.
 * removes directive-specific validators from a given control instance.
 *
 * @param control Form control from where directive validators should be removed.
 * @param dir Directive instance that contains validators to be removed.
 * @returns true if a control was updated as a result of this action.
 */
function cleanUpValidators(control, dir) {
  let isControlUpdated = false;
  if (control !== null) {
    if (dir.validator !== null) {
      const validators = getControlValidators(control);
      if (Array.isArray(validators) && validators.length > 0) {
        // Filter out directive validator function.
        const updatedValidators = validators.filter(validator => validator !== dir.validator);
        if (updatedValidators.length !== validators.length) {
          isControlUpdated = true;
          control.setValidators(updatedValidators);
        }
      }
    }
    if (dir.asyncValidator !== null) {
      const asyncValidators = getControlAsyncValidators(control);
      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {
        // Filter out directive async validator function.
        const updatedAsyncValidators = asyncValidators.filter(asyncValidator => asyncValidator !== dir.asyncValidator);
        if (updatedAsyncValidators.length !== asyncValidators.length) {
          isControlUpdated = true;
          control.setAsyncValidators(updatedAsyncValidators);
        }
      }
    }
  }
  // Clear onValidatorChange callbacks by providing a noop function.
  const noop = () => {};
  registerOnValidatorChange(dir._rawValidators, noop);
  registerOnValidatorChange(dir._rawAsyncValidators, noop);
  return isControlUpdated;
}
function setUpViewChangePipeline(control, dir) {
  dir.valueAccessor.registerOnChange(newValue => {
    control._pendingValue = newValue;
    control._pendingChange = true;
    control._pendingDirty = true;
    if (control.updateOn === 'change') updateControl(control, dir);
  });
}
function setUpBlurPipeline(control, dir) {
  dir.valueAccessor.registerOnTouched(() => {
    control._pendingTouched = true;
    if (control.updateOn === 'blur' && control._pendingChange) updateControl(control, dir);
    if (control.updateOn !== 'submit') control.markAsTouched();
  });
}
function updateControl(control, dir) {
  if (control._pendingDirty) control.markAsDirty();
  control.setValue(control._pendingValue, {
    emitModelToViewChange: false
  });
  dir.viewToModelUpdate(control._pendingValue);
  control._pendingChange = false;
}
function setUpModelChangePipeline(control, dir) {
  const onChange = (newValue, emitModelEvent) => {
    // control -> view
    dir.valueAccessor.writeValue(newValue);
    // control -> ngModel
    if (emitModelEvent) dir.viewToModelUpdate(newValue);
  };
  control.registerOnChange(onChange);
  // Register a callback function to cleanup onChange handler
  // from a control instance when a directive is destroyed.
  dir._registerOnDestroy(() => {
    control._unregisterOnChange(onChange);
  });
}
/**
 * Links a FormGroup or FormArray instance and corresponding Form directive by setting up validators
 * present in the view.
 *
 * @param control FormGroup or FormArray instance that should be linked.
 * @param dir Directive that provides view validators.
 */
function setUpFormContainer(control, dir) {
  if (control == null && (typeof ngDevMode === 'undefined' || ngDevMode)) _throwError(dir, 'Cannot find control with');
  setUpValidators(control, dir);
}
/**
 * Reverts the setup performed by the `setUpFormContainer` function.
 *
 * @param control FormGroup or FormArray instance that should be cleaned up.
 * @param dir Directive that provided view validators.
 * @returns true if a control was updated as a result of this action.
 */
function cleanUpFormContainer(control, dir) {
  return cleanUpValidators(control, dir);
}
function _noControlError(dir) {
  return _throwError(dir, 'There is no FormControl instance attached to form control element with');
}
function _throwError(dir, message) {
  let messageEnd;
  if (dir.path.length > 1) {
    messageEnd = `path: '${dir.path.join(' -> ')}'`;
  } else if (dir.path[0]) {
    messageEnd = `name: '${dir.path}'`;
  } else {
    messageEnd = 'unspecified name attribute';
  }
  throw new Error(`${message} ${messageEnd}`);
}
function isPropertyUpdated(changes, viewModel) {
  if (!changes.hasOwnProperty('model')) return false;
  const change = changes['model'];
  if (change.isFirstChange()) return true;
  return !Object.is(viewModel, change.currentValue);
}
function isBuiltInAccessor(valueAccessor) {
  // Check if a given value accessor is an instance of a class that directly extends
  // `BuiltInControlValueAccessor` one.
  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;
}
function syncPendingControls(form, directives) {
  form._syncPendingControls();
  directives.forEach(dir => {
    const control = dir.control;
    if (control.updateOn === 'submit' && control._pendingChange) {
      dir.viewToModelUpdate(control._pendingValue);
      control._pendingChange = false;
    }
  });
}
// TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented
function selectValueAccessor(dir, valueAccessors) {
  if (!valueAccessors) return null;
  if (!Array.isArray(valueAccessors) && (typeof ngDevMode === 'undefined' || ngDevMode)) _throwError(dir, 'Value accessor was not provided as an array for form control with');
  let defaultAccessor = undefined;
  let builtinAccessor = undefined;
  let customAccessor = undefined;
  valueAccessors.forEach(v => {
    if (v.constructor === DefaultValueAccessor) {
      defaultAccessor = v;
    } else if (isBuiltInAccessor(v)) {
      if (builtinAccessor && (typeof ngDevMode === 'undefined' || ngDevMode)) _throwError(dir, 'More than one built-in value accessor matches form control with');
      builtinAccessor = v;
    } else {
      if (customAccessor && (typeof ngDevMode === 'undefined' || ngDevMode)) _throwError(dir, 'More than one custom value accessor matches form control with');
      customAccessor = v;
    }
  });
  if (customAccessor) return customAccessor;
  if (builtinAccessor) return builtinAccessor;
  if (defaultAccessor) return defaultAccessor;
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    _throwError(dir, 'No valid value accessor for form control with');
  }
  return null;
}
function removeListItem(list, el) {
  const index = list.indexOf(el);
  if (index > -1) list.splice(index, 1);
}
// TODO(kara): remove after deprecation period
function _ngModelWarning(name, type, instance, warningConfig) {
  if (warningConfig === 'never') return;
  if ((warningConfig === null || warningConfig === 'once') && !type._ngModelWarningSentOnce || warningConfig === 'always' && !instance._ngModelWarningSent) {
    console.warn(ngModelWarning(name));
    type._ngModelWarningSentOnce = true;
    instance._ngModelWarningSent = true;
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Reports that a FormControl is valid, meaning that no errors exist in the input value.
 *
 * @see `status`
 */
const VALID = 'VALID';
/**
 * Reports that a FormControl is invalid, meaning that an error exists in the input value.
 *
 * @see `status`
 */
const INVALID = 'INVALID';
/**
 * Reports that a FormControl is pending, meaning that that async validation is occurring and
 * errors are not yet available for the input value.
 *
 * @see `markAsPending`
 * @see `status`
 */
const PENDING = 'PENDING';
/**
 * Reports that a FormControl is disabled, meaning that the control is exempt from ancestor
 * calculations of validity or value.
 *
 * @see `markAsDisabled`
 * @see `status`
 */
const DISABLED = 'DISABLED';
function _find(control, path, delimiter) {
  if (path == null) return null;
  if (!Array.isArray(path)) {
    path = path.split(delimiter);
  }
  if (Array.isArray(path) && path.length === 0) return null;
  // Not using Array.reduce here due to a Chrome 80 bug
  // https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
  let controlToFind = control;
  path.forEach(name => {
    if (controlToFind instanceof FormGroup) {
      controlToFind = controlToFind.controls.hasOwnProperty(name) ? controlToFind.controls[name] : null;
    } else if (controlToFind instanceof FormArray) {
      controlToFind = controlToFind.at(name) || null;
    } else {
      controlToFind = null;
    }
  });
  return controlToFind;
}
/**
 * Gets validators from either an options object or given validators.
 */
function pickValidators(validatorOrOpts) {
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;
}
/**
 * Creates validator function by combining provided validators.
 */
function coerceToValidator(validator) {
  return Array.isArray(validator) ? composeValidators(validator) : validator || null;
}
/**
 * Gets async validators from either an options object or given validators.
 */
function pickAsyncValidators(asyncValidator, validatorOrOpts) {
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;
}
/**
 * Creates async validator function by combining provided async validators.
 */
function coerceToAsyncValidator(asyncValidator) {
  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator || null;
}
function isOptionsObj(validatorOrOpts) {
  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) && typeof validatorOrOpts === 'object';
}
/**
 * This is the base class for `FormControl`, `FormGroup`, and `FormArray`.
 *
 * It provides some of the shared behavior that all controls and groups of controls have, like
 * running validators, calculating status, and resetting state. It also defines the properties
 * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be
 * instantiated directly.
 *
 * @see [Forms Guide](/guide/forms)
 * @see [Reactive Forms Guide](/guide/reactive-forms)
 * @see [Dynamic Forms Guide](/guide/dynamic-form)
 *
 * @publicApi
 */
class AbstractControl {
  /**
   * Initialize the AbstractControl instance.
   *
   * @param validators The function or array of functions that is used to determine the validity of
   *     this control synchronously.
   * @param asyncValidators The function or array of functions that is used to determine validity of
   *     this control asynchronously.
   */
  constructor(validators, asyncValidators) {
    /**
     * Indicates that a control has its own pending asynchronous validation in progress.
     *
     * @internal
     */
    this._hasOwnPendingAsyncValidator = false;
    /** @internal */
    this._onCollectionChange = () => {};
    this._parent = null;
    /**
     * A control is `pristine` if the user has not yet changed
     * the value in the UI.
     *
     * @returns True if the user has not yet changed the value in the UI; compare `dirty`.
     * Programmatic changes to a control's value do not mark it dirty.
     */
    this.pristine = true;
    /**
     * True if the control is marked as `touched`.
     *
     * A control is marked `touched` once the user has triggered
     * a `blur` event on it.
     */
    this.touched = false;
    /** @internal */
    this._onDisabledChange = [];
    this._rawValidators = validators;
    this._rawAsyncValidators = asyncValidators;
    this._composedValidatorFn = coerceToValidator(this._rawValidators);
    this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);
  }
  /**
   * Returns the function that is used to determine the validity of this control synchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get validator() {
    return this._composedValidatorFn;
  }
  set validator(validatorFn) {
    this._rawValidators = this._composedValidatorFn = validatorFn;
  }
  /**
   * Returns the function that is used to determine the validity of this control asynchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get asyncValidator() {
    return this._composedAsyncValidatorFn;
  }
  set asyncValidator(asyncValidatorFn) {
    this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;
  }
  /**
   * The parent control.
   */
  get parent() {
    return this._parent;
  }
  /**
   * A control is `valid` when its `status` is `VALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control has passed all of its validation tests,
   * false otherwise.
   */
  get valid() {
    return this.status === VALID;
  }
  /**
   * A control is `invalid` when its `status` is `INVALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control has failed one or more of its validation checks,
   * false otherwise.
   */
  get invalid() {
    return this.status === INVALID;
  }
  /**
   * A control is `pending` when its `status` is `PENDING`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control is in the process of conducting a validation check,
   * false otherwise.
   */
  get pending() {
    return this.status == PENDING;
  }
  /**
   * A control is `disabled` when its `status` is `DISABLED`.
   *
   * Disabled controls are exempt from validation checks and
   * are not included in the aggregate value of their ancestor
   * controls.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control is disabled, false otherwise.
   */
  get disabled() {
    return this.status === DISABLED;
  }
  /**
   * A control is `enabled` as long as its `status` is not `DISABLED`.
   *
   * @returns True if the control has any status other than 'DISABLED',
   * false if the status is 'DISABLED'.
   *
   * @see {@link AbstractControl.status}
   *
   */
  get enabled() {
    return this.status !== DISABLED;
  }
  /**
   * A control is `dirty` if the user has changed the value
   * in the UI.
   *
   * @returns True if the user has changed the value of this control in the UI; compare `pristine`.
   * Programmatic changes to a control's value do not mark it dirty.
   */
  get dirty() {
    return !this.pristine;
  }
  /**
   * True if the control has not been marked as touched
   *
   * A control is `untouched` if the user has not yet triggered
   * a `blur` event on it.
   */
  get untouched() {
    return !this.touched;
  }
  /**
   * Reports the update strategy of the `AbstractControl` (meaning
   * the event on which the control updates itself).
   * Possible values: `'change'` | `'blur'` | `'submit'`
   * Default value: `'change'`
   */
  get updateOn() {
    return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : 'change';
  }
  /**
   * Sets the synchronous validators that are active on this control.  Calling
   * this overwrites any existing synchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addValidators()` method instead.
   */
  setValidators(validators) {
    this._rawValidators = validators;
    this._composedValidatorFn = coerceToValidator(validators);
  }
  /**
   * Sets the asynchronous validators that are active on this control. Calling this
   * overwrites any existing asynchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addAsyncValidators()` method instead.
   */
  setAsyncValidators(validators) {
    this._rawAsyncValidators = validators;
    this._composedAsyncValidatorFn = coerceToAsyncValidator(validators);
  }
  /**
   * Add a synchronous validator or validators to this control, without affecting other validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect. If duplicate validator functions
   * are present in the `validators` array, only the first instance would be added to a form
   * control.
   *
   * @param validators The new validator function or functions to add to this control.
   */
  addValidators(validators) {
    this.setValidators(addValidators(validators, this._rawValidators));
  }
  /**
   * Add an asynchronous validator or validators to this control, without affecting other
   * validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect.
   *
   * @param validators The new asynchronous validator function or functions to add to this control.
   */
  addAsyncValidators(validators) {
    this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Remove a synchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found,
   * it is ignored.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The validator or validators to remove.
   */
  removeValidators(validators) {
    this.setValidators(removeValidators(validators, this._rawValidators));
  }
  /**
   * Remove an asynchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found, it
   * is ignored.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The asynchronous validator or validators to remove.
   */
  removeAsyncValidators(validators) {
    this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Check whether a synchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @param validator The validator to check for presence. Compared by function reference.
   * @returns Whether the provided validator was found on this control.
   */
  hasValidator(validator) {
    return hasValidator(this._rawValidators, validator);
  }
  /**
   * Check whether an asynchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @param validator The asynchronous validator to check for presence. Compared by function
   *     reference.
   * @returns Whether the provided asynchronous validator was found on this control.
   */
  hasAsyncValidator(validator) {
    return hasValidator(this._rawAsyncValidators, validator);
  }
  /**
   * Empties out the synchronous validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearValidators() {
    this.validator = null;
  }
  /**
   * Empties out the async validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearAsyncValidators() {
    this.asyncValidator = null;
  }
  /**
   * Marks the control as `touched`. A control is touched by focus and
   * blur events that do not change the value.
   *
   * @see `markAsUntouched()`
   * @see `markAsDirty()`
   * @see `markAsPristine()`
   *
   * @param opts Configuration options that determine how the control propagates changes
   * and emits events after marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsTouched(opts = {}) {
    this.touched = true;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsTouched(opts);
    }
  }
  /**
   * Marks the control and all its descendant controls as `touched`.
   * @see `markAsTouched()`
   */
  markAllAsTouched() {
    this.markAsTouched({
      onlySelf: true
    });
    this._forEachChild(control => control.markAllAsTouched());
  }
  /**
   * Marks the control as `untouched`.
   *
   * If the control has any children, also marks all children as `untouched`
   * and recalculates the `touched` status of all parent controls.
   *
   * @see `markAsTouched()`
   * @see `markAsDirty()`
   * @see `markAsPristine()`
   *
   * @param opts Configuration options that determine how the control propagates changes
   * and emits events after the marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsUntouched(opts = {}) {
    this.touched = false;
    this._pendingTouched = false;
    this._forEachChild(control => {
      control.markAsUntouched({
        onlySelf: true
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts);
    }
  }
  /**
   * Marks the control as `dirty`. A control becomes dirty when
   * the control's value is changed through the UI; compare `markAsTouched`.
   *
   * @see `markAsTouched()`
   * @see `markAsUntouched()`
   * @see `markAsPristine()`
   *
   * @param opts Configuration options that determine how the control propagates changes
   * and emits events after marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsDirty(opts = {}) {
    this.pristine = false;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsDirty(opts);
    }
  }
  /**
   * Marks the control as `pristine`.
   *
   * If the control has any children, marks all children as `pristine`,
   * and recalculates the `pristine` status of all parent
   * controls.
   *
   * @see `markAsTouched()`
   * @see `markAsUntouched()`
   * @see `markAsDirty()`
   *
   * @param opts Configuration options that determine how the control emits events after
   * marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsPristine(opts = {}) {
    this.pristine = true;
    this._pendingDirty = false;
    this._forEachChild(control => {
      control.markAsPristine({
        onlySelf: true
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts);
    }
  }
  /**
   * Marks the control as `pending`.
   *
   * A control is pending while the control performs async validation.
   *
   * @see {@link AbstractControl.status}
   *
   * @param opts Configuration options that determine how the control propagates changes and
   * emits events after marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`
   * observable emits an event with the latest status the control is marked pending.
   * When false, no events are emitted.
   *
   */
  markAsPending(opts = {}) {
    this.status = PENDING;
    if (opts.emitEvent !== false) {
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsPending(opts);
    }
  }
  /**
   * Disables the control. This means the control is exempt from validation checks and
   * excluded from the aggregate value of any parent. Its status is `DISABLED`.
   *
   * If the control has children, all children are also disabled.
   *
   * @see {@link AbstractControl.status}
   *
   * @param opts Configuration options that determine how the control propagates
   * changes and emits events after the control is disabled.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is disabled.
   * When false, no events are emitted.
   */
  disable(opts = {}) {
    // If parent has been marked artificially dirty we don't want to re-calculate the
    // parent's dirtiness based on the children.
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = DISABLED;
    this.errors = null;
    this._forEachChild(control => {
      control.disable(Object.assign(Object.assign({}, opts), {
        onlySelf: true
      }));
    });
    this._updateValue();
    if (opts.emitEvent !== false) {
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    this._updateAncestors(Object.assign(Object.assign({}, opts), {
      skipPristineCheck
    }));
    this._onDisabledChange.forEach(changeFn => changeFn(true));
  }
  /**
   * Enables the control. This means the control is included in validation checks and
   * the aggregate value of its parent. Its status recalculates based on its value and
   * its validators.
   *
   * By default, if the control has children, all children are enabled.
   *
   * @see {@link AbstractControl.status}
   *
   * @param opts Configure options that control how the control propagates changes and
   * emits events when marked as untouched
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is enabled.
   * When false, no events are emitted.
   */
  enable(opts = {}) {
    // If parent has been marked artificially dirty we don't want to re-calculate the
    // parent's dirtiness based on the children.
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = VALID;
    this._forEachChild(control => {
      control.enable(Object.assign(Object.assign({}, opts), {
        onlySelf: true
      }));
    });
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
    this._updateAncestors(Object.assign(Object.assign({}, opts), {
      skipPristineCheck
    }));
    this._onDisabledChange.forEach(changeFn => changeFn(false));
  }
  _updateAncestors(opts) {
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(opts);
      if (!opts.skipPristineCheck) {
        this._parent._updatePristine();
      }
      this._parent._updateTouched();
    }
  }
  /**
   * @param parent Sets the parent of the control
   */
  setParent(parent) {
    this._parent = parent;
  }
  /**
   * Recalculates the value and validation status of the control.
   *
   * By default, it also updates the value and validity of its ancestors.
   *
   * @param opts Configuration options determine how the control propagates changes and emits events
   * after updates and validity checks are applied.
   * * `onlySelf`: When true, only update this control. When false or not supplied,
   * update all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is updated.
   * When false, no events are emitted.
   */
  updateValueAndValidity(opts = {}) {
    this._setInitialStatus();
    this._updateValue();
    if (this.enabled) {
      this._cancelExistingSubscription();
      this.errors = this._runValidator();
      this.status = this._calculateStatus();
      if (this.status === VALID || this.status === PENDING) {
        this._runAsyncValidator(opts.emitEvent);
      }
    }
    if (opts.emitEvent !== false) {
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(opts);
    }
  }
  /** @internal */
  _updateTreeValidity(opts = {
    emitEvent: true
  }) {
    this._forEachChild(ctrl => ctrl._updateTreeValidity(opts));
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
  }
  _setInitialStatus() {
    this.status = this._allControlsDisabled() ? DISABLED : VALID;
  }
  _runValidator() {
    return this.validator ? this.validator(this) : null;
  }
  _runAsyncValidator(emitEvent) {
    if (this.asyncValidator) {
      this.status = PENDING;
      this._hasOwnPendingAsyncValidator = true;
      const obs = toObservable(this.asyncValidator(this));
      this._asyncValidationSubscription = obs.subscribe(errors => {
        this._hasOwnPendingAsyncValidator = false;
        // This will trigger the recalculation of the validation status, which depends on
        // the state of the asynchronous validation (whether it is in progress or not). So, it is
        // necessary that we have updated the `_hasOwnPendingAsyncValidator` boolean flag first.
        this.setErrors(errors, {
          emitEvent
        });
      });
    }
  }
  _cancelExistingSubscription() {
    if (this._asyncValidationSubscription) {
      this._asyncValidationSubscription.unsubscribe();
      this._hasOwnPendingAsyncValidator = false;
    }
  }
  /**
   * Sets errors on a form control when running validations manually, rather than automatically.
   *
   * Calling `setErrors` also updates the validity of the parent control.
   *
   * @usageNotes
   *
   * ### Manually set the errors for a control
   *
   * ```
   * const login = new FormControl('someLogin');
   * login.setErrors({
   *   notUnique: true
   * });
   *
   * expect(login.valid).toEqual(false);
   * expect(login.errors).toEqual({ notUnique: true });
   *
   * login.setValue('someOtherLogin');
   *
   * expect(login.valid).toEqual(true);
   * ```
   */
  setErrors(errors, opts = {}) {
    this.errors = errors;
    this._updateControlsErrors(opts.emitEvent !== false);
  }
  /**
   * Retrieves a child control given the control's name or path.
   *
   * @param path A dot-delimited string or array of string/number values that define the path to the
   * control.
   *
   * @usageNotes
   * ### Retrieve a nested control
   *
   * For example, to get a `name` control nested within a `person` sub-group:
   *
   * * `this.form.get('person.name');`
   *
   * -OR-
   *
   * * `this.form.get(['person', 'name']);`
   *
   * ### Retrieve a control in a FormArray
   *
   * When accessing an element inside a FormArray, you can use an element index.
   * For example, to get a `price` control from the first element in an `items` array you can use:
   *
   * * `this.form.get('items.0.price');`
   *
   * -OR-
   *
   * * `this.form.get(['items', 0, 'price']);`
   */
  get(path) {
    return _find(this, path, '.');
  }
  /**
   * @description
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * @returns error data for that particular error. If the control or error is not present,
   * null is returned.
   */
  getError(errorCode, path) {
    const control = path ? this.get(path) : this;
    return control && control.errors ? control.errors[errorCode] : null;
  }
  /**
   * @description
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * If no path is given, this method checks for the error on the current control.
   *
   * @returns whether the given error is present in the control at the given path.
   *
   * If the control is not present, false is returned.
   */
  hasError(errorCode, path) {
    return !!this.getError(errorCode, path);
  }
  /**
   * Retrieves the top-level ancestor of this control.
   */
  get root() {
    let x = this;
    while (x._parent) {
      x = x._parent;
    }
    return x;
  }
  /** @internal */
  _updateControlsErrors(emitEvent) {
    this.status = this._calculateStatus();
    if (emitEvent) {
      this.statusChanges.emit(this.status);
    }
    if (this._parent) {
      this._parent._updateControlsErrors(emitEvent);
    }
  }
  /** @internal */
  _initObservables() {
    this.valueChanges = new core_js_.EventEmitter();
    this.statusChanges = new core_js_.EventEmitter();
  }
  _calculateStatus() {
    if (this._allControlsDisabled()) return DISABLED;
    if (this.errors) return INVALID;
    if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING)) return PENDING;
    if (this._anyControlsHaveStatus(INVALID)) return INVALID;
    return VALID;
  }
  /** @internal */
  _anyControlsHaveStatus(status) {
    return this._anyControls(control => control.status === status);
  }
  /** @internal */
  _anyControlsDirty() {
    return this._anyControls(control => control.dirty);
  }
  /** @internal */
  _anyControlsTouched() {
    return this._anyControls(control => control.touched);
  }
  /** @internal */
  _updatePristine(opts = {}) {
    this.pristine = !this._anyControlsDirty();
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts);
    }
  }
  /** @internal */
  _updateTouched(opts = {}) {
    this.touched = this._anyControlsTouched();
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts);
    }
  }
  /** @internal */
  _isBoxedValue(formState) {
    return typeof formState === 'object' && formState !== null && Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;
  }
  /** @internal */
  _registerOnCollectionChange(fn) {
    this._onCollectionChange = fn;
  }
  /** @internal */
  _setUpdateStrategy(opts) {
    if (isOptionsObj(opts) && opts.updateOn != null) {
      this._updateOn = opts.updateOn;
    }
  }
  /**
   * Check to see if parent has been marked artificially dirty.
   *
   * @internal
   */
  _parentMarkedDirty(onlySelf) {
    const parentDirty = this._parent && this._parent.dirty;
    return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();
  }
}
/**
 * Tracks the value and validation status of an individual form control.
 *
 * This is one of the three fundamental building blocks of Angular forms, along with
 * `FormGroup` and `FormArray`. It extends the `AbstractControl` class that
 * implements most of the base functionality for accessing the value, validation status,
 * user interactions and events. See [usage examples below](#usage-notes).
 *
 * @see `AbstractControl`
 * @see [Reactive Forms Guide](guide/reactive-forms)
 * @see [Usage Notes](#usage-notes)
 *
 * @usageNotes
 *
 * ### Initializing Form Controls
 *
 * Instantiate a `FormControl`, with an initial value.
 *
 * ```ts
 * const control = new FormControl('some value');
 * console.log(control.value);     // 'some value'
 *```
 *
 * The following example initializes the control with a form state object. The `value`
 * and `disabled` keys are required in this case.
 *
 * ```ts
 * const control = new FormControl({ value: 'n/a', disabled: true });
 * console.log(control.value);     // 'n/a'
 * console.log(control.status);    // 'DISABLED'
 * ```
 *
 * The following example initializes the control with a synchronous validator.
 *
 * ```ts
 * const control = new FormControl('', Validators.required);
 * console.log(control.value);      // ''
 * console.log(control.status);     // 'INVALID'
 * ```
 *
 * The following example initializes the control using an options object.
 *
 * ```ts
 * const control = new FormControl('', {
 *    validators: Validators.required,
 *    asyncValidators: myAsyncValidator
 * });
 * ```
 *
 * ### Configure the control to update on a blur event
 *
 * Set the `updateOn` option to `'blur'` to update on the blur `event`.
 *
 * ```ts
 * const control = new FormControl('', { updateOn: 'blur' });
 * ```
 *
 * ### Configure the control to update on a submit event
 *
 * Set the `updateOn` option to `'submit'` to update on a submit `event`.
 *
 * ```ts
 * const control = new FormControl('', { updateOn: 'submit' });
 * ```
 *
 * ### Reset the control back to an initial value
 *
 * You reset to a specific form state by passing through a standalone
 * value or a form state object that contains both a value and a disabled state
 * (these are the only two properties that cannot be calculated).
 *
 * ```ts
 * const control = new FormControl('Nancy');
 *
 * console.log(control.value); // 'Nancy'
 *
 * control.reset('Drew');
 *
 * console.log(control.value); // 'Drew'
 * ```
 *
 * ### Reset the control back to an initial value and disabled
 *
 * ```
 * const control = new FormControl('Nancy');
 *
 * console.log(control.value); // 'Nancy'
 * console.log(control.status); // 'VALID'
 *
 * control.reset({ value: 'Drew', disabled: true });
 *
 * console.log(control.value); // 'Drew'
 * console.log(control.status); // 'DISABLED'
 * ```
 *
 * @publicApi
 */
class FormControl extends AbstractControl {
  /**
   * Creates a new `FormControl` instance.
   *
   * @param formState Initializes the control with an initial value,
   * or an object that defines the initial value and disabled state.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(formState = null, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    /** @internal */
    this._onChange = [];
    this._applyFormState(formState);
    this._setUpdateStrategy(validatorOrOpts);
    this._initObservables();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`
      // to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  /**
   * Sets a new value for the form control.
   *
   * @param value The new value for the control.
   * @param options Configuration options that determine how the control propagates changes
   * and emits events when the value changes.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   * * `emitModelToViewChange`: When true or not supplied  (the default), each change triggers an
   * `onChange` event to
   * update the view.
   * * `emitViewToModelChange`: When true or not supplied (the default), each change triggers an
   * `ngModelChange`
   * event to update the model.
   *
   */
  setValue(value, options = {}) {
    this.value = this._pendingValue = value;
    if (this._onChange.length && options.emitModelToViewChange !== false) {
      this._onChange.forEach(changeFn => changeFn(this.value, options.emitViewToModelChange !== false));
    }
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of a control.
   *
   * This function is functionally the same as {@link FormControl#setValue setValue} at this level.
   * It exists for symmetry with {@link FormGroup#patchValue patchValue} on `FormGroups` and
   * `FormArrays`, where it does behave differently.
   *
   * @see `setValue` for options
   */
  patchValue(value, options = {}) {
    this.setValue(value, options);
  }
  /**
   * Resets the form control, marking it `pristine` and `untouched`, and setting
   * the value to null.
   *
   * @param formState Resets the control with an initial value,
   * or an object that defines the initial value and disabled state.
   *
   * @param options Configuration options that determine how the control propagates changes
   * and emits events after the value changes.
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   *
   */
  reset(formState = null, options = {}) {
    this._applyFormState(formState);
    this.markAsPristine(options);
    this.markAsUntouched(options);
    this.setValue(this.value, options);
    this._pendingChange = false;
  }
  /**
   * @internal
   */
  _updateValue() {}
  /**
   * @internal
   */
  _anyControls(condition) {
    return false;
  }
  /**
   * @internal
   */
  _allControlsDisabled() {
    return this.disabled;
  }
  /**
   * Register a listener for change events.
   *
   * @param fn The method that is called when the value changes
   */
  registerOnChange(fn) {
    this._onChange.push(fn);
  }
  /**
   * Internal function to unregister a change events listener.
   * @internal
   */
  _unregisterOnChange(fn) {
    removeListItem(this._onChange, fn);
  }
  /**
   * Register a listener for disabled events.
   *
   * @param fn The method that is called when the disabled status changes.
   */
  registerOnDisabledChange(fn) {
    this._onDisabledChange.push(fn);
  }
  /**
   * Internal function to unregister a disabled event listener.
   * @internal
   */
  _unregisterOnDisabledChange(fn) {
    removeListItem(this._onDisabledChange, fn);
  }
  /**
   * @internal
   */
  _forEachChild(cb) {}
  /** @internal */
  _syncPendingControls() {
    if (this.updateOn === 'submit') {
      if (this._pendingDirty) this.markAsDirty();
      if (this._pendingTouched) this.markAsTouched();
      if (this._pendingChange) {
        this.setValue(this._pendingValue, {
          onlySelf: true,
          emitModelToViewChange: false
        });
        return true;
      }
    }
    return false;
  }
  _applyFormState(formState) {
    if (this._isBoxedValue(formState)) {
      this.value = this._pendingValue = formState.value;
      formState.disabled ? this.disable({
        onlySelf: true,
        emitEvent: false
      }) : this.enable({
        onlySelf: true,
        emitEvent: false
      });
    } else {
      this.value = this._pendingValue = formState;
    }
  }
}
/**
 * Tracks the value and validity state of a group of `FormControl` instances.
 *
 * A `FormGroup` aggregates the values of each child `FormControl` into one object,
 * with each control name as the key.  It calculates its status by reducing the status values
 * of its children. For example, if one of the controls in a group is invalid, the entire
 * group becomes invalid.
 *
 * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,
 * along with `FormControl` and `FormArray`.
 *
 * When instantiating a `FormGroup`, pass in a collection of child controls as the first
 * argument. The key for each child registers the name for the control.
 *
 * @usageNotes
 *
 * ### Create a form group with 2 controls
 *
 * ```
 * const form = new FormGroup({
 *   first: new FormControl('Nancy', Validators.minLength(2)),
 *   last: new FormControl('Drew'),
 * });
 *
 * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}
 * console.log(form.status);  // 'VALID'
 * ```
 *
 * ### Create a form group with a group-level validator
 *
 * You include group-level validators as the second arg, or group-level async
 * validators as the third arg. These come in handy when you want to perform validation
 * that considers the value of more than one child control.
 *
 * ```
 * const form = new FormGroup({
 *   password: new FormControl('', Validators.minLength(2)),
 *   passwordConfirm: new FormControl('', Validators.minLength(2)),
 * }, passwordMatchValidator);
 *
 *
 * function passwordMatchValidator(g: FormGroup) {
 *    return g.get('password').value === g.get('passwordConfirm').value
 *       ? null : {'mismatch': true};
 * }
 * ```
 *
 * Like `FormControl` instances, you choose to pass in
 * validators and async validators as part of an options object.
 *
 * ```
 * const form = new FormGroup({
 *   password: new FormControl('')
 *   passwordConfirm: new FormControl('')
 * }, { validators: passwordMatchValidator, asyncValidators: otherValidator });
 * ```
 *
 * ### Set the updateOn property for all controls in a form group
 *
 * The options object is used to set a default value for each child
 * control's `updateOn` property. If you set `updateOn` to `'blur'` at the
 * group level, all child controls default to 'blur', unless the child
 * has explicitly specified a different `updateOn` value.
 *
 * ```ts
 * const c = new FormGroup({
 *   one: new FormControl()
 * }, { updateOn: 'blur' });
 * ```
 *
 * @publicApi
 */
class FormGroup extends AbstractControl {
  /**
   * Creates a new `FormGroup` instance.
   *
   * @param controls A collection of child controls. The key for each child is the name
   * under which it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,
      // so we set `emitEvent` to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  /**
   * Registers a control with the group's list of controls.
   *
   * This method does not update the value or validity of the control.
   * Use {@link FormGroup#addControl addControl} instead.
   *
   * @param name The control name to register in the collection
   * @param control Provides the control for the given name
   */
  registerControl(name, control) {
    if (this.controls[name]) return this.controls[name];
    this.controls[name] = control;
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
    return control;
  }
  /**
   * Add a control to this group.
   *
   * If a control with a given name already exists, it would *not* be replaced with a new one.
   * If you want to replace an existing control, use the {@link FormGroup#setControl setControl}
   * method instead. This method also updates the value and validity of the control.
   *
   * @param name The control name to add to the collection
   * @param control Provides the control for the given name
   * @param options Specifies whether this FormGroup instance should emit events after a new
   *     control is added.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * added. When false, no events are emitted.
   */
  addControl(name, control, options = {}) {
    this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Remove a control from this group.
   *
   * This method also updates the value and validity of the control.
   *
   * @param name The control name to remove from the collection
   * @param options Specifies whether this FormGroup instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeControl(name, options = {}) {
    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});
    delete this.controls[name];
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Replace an existing control.
   *
   * If a control with a given name does not exist in this `FormGroup`, it will be added.
   *
   * @param name The control name to replace in the collection
   * @param control Provides the control for the given name
   * @param options Specifies whether this FormGroup instance should emit events after an
   *     existing control is replaced.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * replaced with a new one. When false, no events are emitted.
   */
  setControl(name, control, options = {}) {
    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});
    delete this.controls[name];
    if (control) this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Check whether there is an enabled control with the given name in the group.
   *
   * Reports false for disabled controls. If you'd like to check for existence in the group
   * only, use {@link AbstractControl#get get} instead.
   *
   * @param controlName The control name to check for existence in the collection
   *
   * @returns false for disabled controls, true otherwise.
   */
  contains(controlName) {
    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
  }
  /**
   * Sets the value of the `FormGroup`. It accepts an object that matches
   * the structure of the group, with control names as keys.
   *
   * @usageNotes
   * ### Set the complete value for the form group
   *
   * ```
   * const form = new FormGroup({
   *   first: new FormControl(),
   *   last: new FormControl()
   * });
   *
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.setValue({first: 'Nancy', last: 'Drew'});
   * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
   * ```
   *
   * @throws When strict checks fail, such as setting the value of a control
   * that doesn't exist or if you exclude a value of a control that does exist.
   *
   * @param value The new value for the control that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes
   * and emits events after the value changes.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   */
  setValue(value, options = {}) {
    this._checkAllValuesPresent(value);
    Object.keys(value).forEach(name => {
      this._throwIfControlMissing(name);
      this.controls[name].setValue(value[name], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormGroup`. It accepts an object with control
   * names as keys, and does its best to match the values to the correct controls
   * in the group.
   *
   * It accepts both super-sets and sub-sets of the group without throwing an error.
   *
   * @usageNotes
   * ### Patch the value for a form group
   *
   * ```
   * const form = new FormGroup({
   *    first: new FormControl(),
   *    last: new FormControl()
   * });
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.patchValue({first: 'Nancy'});
   * console.log(form.value);   // {first: 'Nancy', last: null}
   * ```
   *
   * @param value The object that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes and
   * emits events after the value is patched.
   * * `onlySelf`: When true, each change only affects this control and not its parent. Default is
   * true.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control value
   * is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value, options = {}) {
    // Even though the `value` argument type doesn't allow `null` and `undefined` values, the
    // `patchValue` can be called recursively and inner data structures might have these values, so
    // we just ignore such cases when a field containing FormGroup instance receives `null` or
    // `undefined` as a value.
    if (value == null /* both `null` and `undefined` */) return;
    Object.keys(value).forEach(name => {
      if (this.controls[name]) {
        this.controls[name].patchValue(value[name], {
          onlySelf: true,
          emitEvent: options.emitEvent
        });
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets
   * the value of all descendants to null.
   *
   * You reset to a specific form state by passing in a map of states
   * that matches the structure of your form, with control names as keys. The state
   * is a standalone value or a form state object with both a value and a disabled
   * status.
   *
   * @param value Resets the control with an initial value,
   * or an object that defines the initial value and disabled state.
   *
   * @param options Configuration options that determine how the control propagates changes
   * and emits events when the group is reset.
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * @usageNotes
   *
   * ### Reset the form group values
   *
   * ```ts
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * console.log(form.value);  // {first: 'first name', last: 'last name'}
   *
   * form.reset({ first: 'name', last: 'last name' });
   *
   * console.log(form.value);  // {first: 'name', last: 'last name'}
   * ```
   *
   * ### Reset the form group values and disabled status
   *
   * ```
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * form.reset({
   *   first: {value: 'name', disabled: true},
   *   last: 'last'
   * });
   *
   * console.log(form.value);  // {last: 'last'}
   * console.log(form.get('first').status);  // 'DISABLED'
   * ```
   */
  reset(value = {}, options = {}) {
    this._forEachChild((control, name) => {
      control.reset(value[name], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options);
    this._updateTouched(options);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the `FormGroup`, including any disabled controls.
   *
   * Retrieves all values regardless of disabled status.
   * The `value` property is the best way to get the value of the group, because
   * it excludes disabled controls in the `FormGroup`.
   */
  getRawValue() {
    return this._reduceChildren({}, (acc, control, name) => {
      acc[name] = control instanceof FormControl ? control.value : control.getRawValue();
      return acc;
    });
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this._reduceChildren(false, (updated, child) => {
      return child._syncPendingControls() ? true : updated;
    });
    if (subtreeUpdated) this.updateValueAndValidity({
      onlySelf: true
    });
    return subtreeUpdated;
  }
  /** @internal */
  _throwIfControlMissing(name) {
    if (!Object.keys(this.controls).length) {
      throw new Error(`
        There are no form controls registered with this group yet. If you're using ngModel,
        you may want to check next tick (e.g. use setTimeout).
      `);
    }
    if (!this.controls[name]) {
      throw new Error(`Cannot find form control with name: ${name}.`);
    }
  }
  /** @internal */
  _forEachChild(cb) {
    Object.keys(this.controls).forEach(key => {
      // The list of controls can change (for ex. controls might be removed) while the loop
      // is running (as a result of invoking Forms API in `valueChanges` subscription), so we
      // have to null check before invoking the callback.
      const control = this.controls[key];
      control && cb(control, key);
    });
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild(control => {
      control.setParent(this);
      control._registerOnCollectionChange(this._onCollectionChange);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this._reduceValue();
  }
  /** @internal */
  _anyControls(condition) {
    for (const controlName of Object.keys(this.controls)) {
      const control = this.controls[controlName];
      if (this.contains(controlName) && condition(control)) {
        return true;
      }
    }
    return false;
  }
  /** @internal */
  _reduceValue() {
    return this._reduceChildren({}, (acc, control, name) => {
      if (control.enabled || this.disabled) {
        acc[name] = control.value;
      }
      return acc;
    });
  }
  /** @internal */
  _reduceChildren(initValue, fn) {
    let res = initValue;
    this._forEachChild((control, name) => {
      res = fn(res, control, name);
    });
    return res;
  }
  /** @internal */
  _allControlsDisabled() {
    for (const controlName of Object.keys(this.controls)) {
      if (this.controls[controlName].enabled) {
        return false;
      }
    }
    return Object.keys(this.controls).length > 0 || this.disabled;
  }
  /** @internal */
  _checkAllValuesPresent(value) {
    this._forEachChild((control, name) => {
      if (value[name] === undefined) {
        throw new Error(`Must supply a value for form control with name: '${name}'.`);
      }
    });
  }
}
/**
 * Tracks the value and validity state of an array of `FormControl`,
 * `FormGroup` or `FormArray` instances.
 *
 * A `FormArray` aggregates the values of each child `FormControl` into an array.
 * It calculates its status by reducing the status values of its children. For example, if one of
 * the controls in a `FormArray` is invalid, the entire array becomes invalid.
 *
 * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,
 * along with `FormControl` and `FormGroup`.
 *
 * @usageNotes
 *
 * ### Create an array of form controls
 *
 * ```
 * const arr = new FormArray([
 *   new FormControl('Nancy', Validators.minLength(2)),
 *   new FormControl('Drew'),
 * ]);
 *
 * console.log(arr.value);   // ['Nancy', 'Drew']
 * console.log(arr.status);  // 'VALID'
 * ```
 *
 * ### Create a form array with array-level validators
 *
 * You include array-level validators and async validators. These come in handy
 * when you want to perform validation that considers the value of more than one child
 * control.
 *
 * The two types of validators are passed in separately as the second and third arg
 * respectively, or together as part of an options object.
 *
 * ```
 * const arr = new FormArray([
 *   new FormControl('Nancy'),
 *   new FormControl('Drew')
 * ], {validators: myValidator, asyncValidators: myAsyncValidator});
 * ```
 *
 * ### Set the updateOn property for all controls in a form array
 *
 * The options object is used to set a default value for each child
 * control's `updateOn` property. If you set `updateOn` to `'blur'` at the
 * array level, all child controls default to 'blur', unless the child
 * has explicitly specified a different `updateOn` value.
 *
 * ```ts
 * const arr = new FormArray([
 *    new FormControl()
 * ], {updateOn: 'blur'});
 * ```
 *
 * ### Adding or removing controls from a form array
 *
 * To change the controls in the array, use the `push`, `insert`, `removeAt` or `clear` methods
 * in `FormArray` itself. These methods ensure the controls are properly tracked in the
 * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate
 * the `FormArray` directly, as that result in strange and unexpected behavior such
 * as broken change detection.
 *
 * @publicApi
 */
class FormArray extends AbstractControl {
  /**
   * Creates a new `FormArray` instance.
   *
   * @param controls An array of child controls. Each child control is given an index
   * where it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`
      // to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  /**
   * Get the `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to retrieve the control
   */
  at(index) {
    return this.controls[index];
  }
  /**
   * Insert a new `AbstractControl` at the end of the array.
   *
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is added.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  push(control, options = {}) {
    this.controls.push(control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Insert a new `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to insert the control
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is inserted.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  insert(index, control, options = {}) {
    this.controls.splice(index, 0, control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Remove the control at the given `index` in the array.
   *
   * @param index Index in the array to remove the control
   * @param options Specifies whether this FormArray instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeAt(index, options = {}) {
    if (this.controls[index]) this.controls[index]._registerOnCollectionChange(() => {});
    this.controls.splice(index, 1);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Replace an existing control.
   *
   * @param index Index in the array to replace the control
   * @param control The `AbstractControl` control to replace the existing control
   * @param options Specifies whether this FormArray instance should emit events after an
   *     existing control is replaced with a new one.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * replaced with a new one. When false, no events are emitted.
   */
  setControl(index, control, options = {}) {
    if (this.controls[index]) this.controls[index]._registerOnCollectionChange(() => {});
    this.controls.splice(index, 1);
    if (control) {
      this.controls.splice(index, 0, control);
      this._registerControl(control);
    }
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Length of the control array.
   */
  get length() {
    return this.controls.length;
  }
  /**
   * Sets the value of the `FormArray`. It accepts an array that matches
   * the structure of the control.
   *
   * This method performs strict checks, and throws an error if you try
   * to set the value of a control that doesn't exist or if you exclude the
   * value of a control.
   *
   * @usageNotes
   * ### Set the values for the controls in the form array
   *
   * ```
   * const arr = new FormArray([
   *   new FormControl(),
   *   new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.setValue(['Nancy', 'Drew']);
   * console.log(arr.value);   // ['Nancy', 'Drew']
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  setValue(value, options = {}) {
    this._checkAllValuesPresent(value);
    value.forEach((newValue, index) => {
      this._throwIfControlMissing(index);
      this.at(index).setValue(newValue, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormArray`. It accepts an array that matches the
   * structure of the control, and does its best to match the values to the correct
   * controls in the group.
   *
   * It accepts both super-sets and sub-sets of the array without throwing an error.
   *
   * @usageNotes
   * ### Patch the values for controls in a form array
   *
   * ```
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.patchValue(['Nancy']);
   * console.log(arr.value);   // ['Nancy', null]
   * ```
   *
   * @param value Array of latest values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control value
   * is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value, options = {}) {
    // Even though the `value` argument type doesn't allow `null` and `undefined` values, the
    // `patchValue` can be called recursively and inner data structures might have these values, so
    // we just ignore such cases when a field containing FormArray instance receives `null` or
    // `undefined` as a value.
    if (value == null /* both `null` and `undefined` */) return;
    value.forEach((newValue, index) => {
      if (this.at(index)) {
        this.at(index).patchValue(newValue, {
          onlySelf: true,
          emitEvent: options.emitEvent
        });
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the
   * value of all descendants to null or null maps.
   *
   * You reset to a specific form state by passing in an array of states
   * that matches the structure of the control. The state is a standalone value
   * or a form state object with both a value and a disabled status.
   *
   * @usageNotes
   * ### Reset the values in a form array
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * arr.reset(['name', 'last name']);
   *
   * console.log(arr.value);  // ['name', 'last name']
   * ```
   *
   * ### Reset the values in a form array and the disabled status for the first control
   *
   * ```
   * arr.reset([
   *   {value: 'name', disabled: true},
   *   'last'
   * ]);
   *
   * console.log(arr.value);  // ['last']
   * console.log(arr.at(0).status);  // 'DISABLED'
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  reset(value = [], options = {}) {
    this._forEachChild((control, index) => {
      control.reset(value[index], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options);
    this._updateTouched(options);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the array, including any disabled controls.
   *
   * Reports all values regardless of disabled status.
   * For enabled controls only, the `value` property is the best way to get the value of the array.
   */
  getRawValue() {
    return this.controls.map(control => {
      return control instanceof FormControl ? control.value : control.getRawValue();
    });
  }
  /**
   * Remove all controls in the `FormArray`.
   *
   * @param options Specifies whether this FormArray instance should emit events after all
   *     controls are removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when all controls
   * in this FormArray instance are removed. When false, no events are emitted.
   *
   * @usageNotes
   * ### Remove all elements from a FormArray
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.length);  // 2
   *
   * arr.clear();
   * console.log(arr.length);  // 0
   * ```
   *
   * It's a simpler and more efficient alternative to removing all elements one by one:
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   *
   * while (arr.length) {
   *    arr.removeAt(0);
   * }
   * ```
   */
  clear(options = {}) {
    if (this.controls.length < 1) return;
    this._forEachChild(control => control._registerOnCollectionChange(() => {}));
    this.controls.splice(0);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this.controls.reduce((updated, child) => {
      return child._syncPendingControls() ? true : updated;
    }, false);
    if (subtreeUpdated) this.updateValueAndValidity({
      onlySelf: true
    });
    return subtreeUpdated;
  }
  /** @internal */
  _throwIfControlMissing(index) {
    if (!this.controls.length) {
      throw new Error(`
        There are no form controls registered with this array yet. If you're using ngModel,
        you may want to check next tick (e.g. use setTimeout).
      `);
    }
    if (!this.at(index)) {
      throw new Error(`Cannot find form control at index ${index}`);
    }
  }
  /** @internal */
  _forEachChild(cb) {
    this.controls.forEach((control, index) => {
      cb(control, index);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this.controls.filter(control => control.enabled || this.disabled).map(control => control.value);
  }
  /** @internal */
  _anyControls(condition) {
    return this.controls.some(control => control.enabled && condition(control));
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild(control => this._registerControl(control));
  }
  /** @internal */
  _checkAllValuesPresent(value) {
    this._forEachChild((control, i) => {
      if (value[i] === undefined) {
        throw new Error(`Must supply a value for form control at index: ${i}.`);
      }
    });
  }
  /** @internal */
  _allControlsDisabled() {
    for (const control of this.controls) {
      if (control.enabled) return false;
    }
    return this.controls.length > 0 || this.disabled;
  }
  _registerControl(control) {
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const formDirectiveProvider = {
  provide: ControlContainer,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => NgForm)
};
const ɵ0 = () => Promise.resolve(null);
const resolvedPromise = /*#__PURE__*/ɵ0();
/**
 * @description
 * Creates a top-level `FormGroup` instance and binds it to a form
 * to track aggregate form value and validation status.
 *
 * As soon as you import the `FormsModule`, this directive becomes active by default on
 * all `<form>` tags.  You don't need to add a special selector.
 *
 * You optionally export the directive into a local template variable using `ngForm` as the key
 * (ex: `#myForm="ngForm"`). This is optional, but useful.  Many properties from the underlying
 * `FormGroup` instance are duplicated on the directive itself, so a reference to it
 * gives you access to the aggregate value and validity status of the form, as well as
 * user interaction properties like `dirty` and `touched`.
 *
 * To register child controls with the form, use `NgModel` with a `name`
 * attribute. You may use `NgModelGroup` to create sub-groups within the form.
 *
 * If necessary, listen to the directive's `ngSubmit` event to be notified when the user has
 * triggered a form submission. The `ngSubmit` event emits the original form
 * submission event.
 *
 * In template driven forms, all `<form>` tags are automatically tagged as `NgForm`.
 * To import the `FormsModule` but skip its usage in some forms,
 * for example, to use native HTML5 validation, add the `ngNoForm` and the `<form>`
 * tags won't create an `NgForm` directive. In reactive forms, using `ngNoForm` is
 * unnecessary because the `<form>` tags are inert. In that case, you would
 * refrain from using the `formGroup` directive.
 *
 * @usageNotes
 *
 * ### Listening for form submission
 *
 * The following example shows how to capture the form values from the "ngSubmit" event.
 *
 * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
 *
 * ### Setting the update options
 *
 * The following example shows you how to change the "updateOn" option from its default using
 * ngFormOptions.
 *
 * ```html
 * <form [ngFormOptions]="{updateOn: 'blur'}">
 *    <input name="one" ngModel>  <!-- this ngModel will update on blur -->
 * </form>
 * ```
 *
 * ### Native DOM validation UI
 *
 * In order to prevent the native DOM form validation UI from interfering with Angular's form
 * validation, Angular automatically adds the `novalidate` attribute on any `<form>` whenever
 * `FormModule` or `ReactiveFormModule` are imported into the application.
 * If you want to explicitly enable native DOM validation UI with Angular forms, you can add the
 * `ngNativeValidate` attribute to the `<form>` element:
 *
 * ```html
 * <form ngNativeValidate>
 *   ...
 * </form>
 * ```
 *
 * @ngModule FormsModule
 * @publicApi
 */
let NgForm = /*#__PURE__*/(() => {
  class NgForm extends ControlContainer {
    constructor(validators, asyncValidators) {
      super();
      /**
       * @description
       * Returns whether the form submission has been triggered.
       */
      this.submitted = false;
      this._directives = [];
      /**
       * @description
       * Event emitter for the "ngSubmit" event
       */
      this.ngSubmit = new core_js_.EventEmitter();
      this.form = new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
    }
    /** @nodoc */
    ngAfterViewInit() {
      this._setUpdateStrategy();
    }
    /**
     * @description
     * The directive instance.
     */
    get formDirective() {
      return this;
    }
    /**
     * @description
     * The internal `FormGroup` instance.
     */
    get control() {
      return this.form;
    }
    /**
     * @description
     * Returns an array representing the path to this group. Because this directive
     * always lives at the top level of a form, it is always an empty array.
     */
    get path() {
      return [];
    }
    /**
     * @description
     * Returns a map of the controls in this group.
     */
    get controls() {
      return this.form.controls;
    }
    /**
     * @description
     * Method that sets up the control directive in this group, re-calculates its value
     * and validity, and adds the instance to the internal list of directives.
     *
     * @param dir The `NgModel` directive instance.
     */
    addControl(dir) {
      resolvedPromise.then(() => {
        const container = this._findContainer(dir.path);
        dir.control = container.registerControl(dir.name, dir.control);
        setUpControl(dir.control, dir);
        dir.control.updateValueAndValidity({
          emitEvent: false
        });
        this._directives.push(dir);
      });
    }
    /**
     * @description
     * Retrieves the `FormControl` instance from the provided `NgModel` directive.
     *
     * @param dir The `NgModel` directive instance.
     */
    getControl(dir) {
      return this.form.get(dir.path);
    }
    /**
     * @description
     * Removes the `NgModel` instance from the internal list of directives
     *
     * @param dir The `NgModel` directive instance.
     */
    removeControl(dir) {
      resolvedPromise.then(() => {
        const container = this._findContainer(dir.path);
        if (container) {
          container.removeControl(dir.name);
        }
        removeListItem(this._directives, dir);
      });
    }
    /**
     * @description
     * Adds a new `NgModelGroup` directive instance to the form.
     *
     * @param dir The `NgModelGroup` directive instance.
     */
    addFormGroup(dir) {
      resolvedPromise.then(() => {
        const container = this._findContainer(dir.path);
        const group = new FormGroup({});
        setUpFormContainer(group, dir);
        container.registerControl(dir.name, group);
        group.updateValueAndValidity({
          emitEvent: false
        });
      });
    }
    /**
     * @description
     * Removes the `NgModelGroup` directive instance from the form.
     *
     * @param dir The `NgModelGroup` directive instance.
     */
    removeFormGroup(dir) {
      resolvedPromise.then(() => {
        const container = this._findContainer(dir.path);
        if (container) {
          container.removeControl(dir.name);
        }
      });
    }
    /**
     * @description
     * Retrieves the `FormGroup` for a provided `NgModelGroup` directive instance
     *
     * @param dir The `NgModelGroup` directive instance.
     */
    getFormGroup(dir) {
      return this.form.get(dir.path);
    }
    /**
     * Sets the new value for the provided `NgControl` directive.
     *
     * @param dir The `NgControl` directive instance.
     * @param value The new value for the directive's control.
     */
    updateModel(dir, value) {
      resolvedPromise.then(() => {
        const ctrl = this.form.get(dir.path);
        ctrl.setValue(value);
      });
    }
    /**
     * @description
     * Sets the value for this `FormGroup`.
     *
     * @param value The new value
     */
    setValue(value) {
      this.control.setValue(value);
    }
    /**
     * @description
     * Method called when the "submit" event is triggered on the form.
     * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
     *
     * @param $event The "submit" event object
     */
    onSubmit($event) {
      this.submitted = true;
      syncPendingControls(this.form, this._directives);
      this.ngSubmit.emit($event);
      return false;
    }
    /**
     * @description
     * Method called when the "reset" event is triggered on the form.
     */
    onReset() {
      this.resetForm();
    }
    /**
     * @description
     * Resets the form to an initial value and resets its submitted status.
     *
     * @param value The new value for the form.
     */
    resetForm(value = undefined) {
      this.form.reset(value);
      this.submitted = false;
    }
    _setUpdateStrategy() {
      if (this.options && this.options.updateOn != null) {
        this.form._updateOn = this.options.updateOn;
      }
    }
    /** @internal */
    _findContainer(path) {
      path.pop();
      return path.length ? this.form.get(path) : this.form;
    }
  }
  NgForm.ɵfac = function NgForm_Factory(t) {
    return new (t || NgForm)(core_js_["ɵɵdirectiveInject"](NG_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10));
  };
  NgForm.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: NgForm,
    selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]],
    hostBindings: function NgForm_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("submit", function NgForm_submit_HostBindingHandler($event) {
          return ctx.onSubmit($event);
        })("reset", function NgForm_reset_HostBindingHandler() {
          return ctx.onReset();
        });
      }
    },
    inputs: {
      options: ["ngFormOptions", "options"]
    },
    outputs: {
      ngSubmit: "ngSubmit"
    },
    exportAs: ["ngForm"],
    features: [core_js_["ɵɵProvidersFeature"]([formDirectiveProvider]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return NgForm;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @description
 * A base class for code shared between the `NgModelGroup` and `FormGroupName` directives.
 *
 * @publicApi
 */
let AbstractFormGroupDirective = /*#__PURE__*/(() => {
  class AbstractFormGroupDirective extends ControlContainer {
    /** @nodoc */
    ngOnInit() {
      this._checkParentType();
      // Register the group with its parent group.
      this.formDirective.addFormGroup(this);
    }
    /** @nodoc */
    ngOnDestroy() {
      if (this.formDirective) {
        // Remove the group from its parent group.
        this.formDirective.removeFormGroup(this);
      }
    }
    /**
     * @description
     * The `FormGroup` bound to this directive.
     */
    get control() {
      return this.formDirective.getFormGroup(this);
    }
    /**
     * @description
     * The path to this group from the top-level directive.
     */
    get path() {
      return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
    }
    /**
     * @description
     * The top-level directive for this group if present, otherwise null.
     */
    get formDirective() {
      return this._parent ? this._parent.formDirective : null;
    }
    /** @internal */
    _checkParentType() {}
  }
  AbstractFormGroupDirective.ɵfac = /*@__PURE__*/function () {
    let ɵAbstractFormGroupDirective_BaseFactory;
    return function AbstractFormGroupDirective_Factory(t) {
      return (ɵAbstractFormGroupDirective_BaseFactory || (ɵAbstractFormGroupDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](AbstractFormGroupDirective)))(t || AbstractFormGroupDirective);
    };
  }();
  AbstractFormGroupDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: AbstractFormGroupDirective,
    features: [core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return AbstractFormGroupDirective;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function modelParentException() {
  return new Error(`
    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using
    formGroup's partner directive "formControlName" instead.  Example:

    ${formControlNameExample}

    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:

    Example:

    ${ngModelWithFormGroupExample}`);
}
function formGroupNameException() {
  return new Error(`
    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.

    Option 1: Use formControlName instead of ngModel (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):

    ${ngModelGroupExample}`);
}
function missingNameException() {
  return new Error(`If ngModel is used within a form tag, either the name attribute must be set or the form
    control must be defined as 'standalone' in ngModelOptions.

    Example 1: <input [(ngModel)]="person.firstName" name="first">
    Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">`);
}
function modelGroupParentException() {
  return new Error(`
    ngModelGroup cannot be used with a parent formGroup directive.

    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):

    ${ngModelGroupExample}`);
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const modelGroupProvider = {
  provide: ControlContainer,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => NgModelGroup)
};
/**
 * @description
 * Creates and binds a `FormGroup` instance to a DOM element.
 *
 * This directive can only be used as a child of `NgForm` (within `<form>` tags).
 *
 * Use this directive to validate a sub-group of your form separately from the
 * rest of your form, or if some values in your domain model make more sense
 * to consume together in a nested object.
 *
 * Provide a name for the sub-group and it will become the key
 * for the sub-group in the form's full value. If you need direct access, export the directive into
 * a local template variable using `ngModelGroup` (ex: `#myGroup="ngModelGroup"`).
 *
 * @usageNotes
 *
 * ### Consuming controls in a grouping
 *
 * The following example shows you how to combine controls together in a sub-group
 * of the form.
 *
 * {@example forms/ts/ngModelGroup/ng_model_group_example.ts region='Component'}
 *
 * @ngModule FormsModule
 * @publicApi
 */
let NgModelGroup = /*#__PURE__*/(() => {
  class NgModelGroup extends AbstractFormGroupDirective {
    constructor(parent, validators, asyncValidators) {
      super();
      this._parent = parent;
      this._setValidators(validators);
      this._setAsyncValidators(asyncValidators);
    }
    /** @internal */
    _checkParentType() {
      if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm) && (typeof ngDevMode === 'undefined' || ngDevMode)) {
        throw modelGroupParentException();
      }
    }
  }
  NgModelGroup.ɵfac = function NgModelGroup_Factory(t) {
    return new (t || NgModelGroup)(core_js_["ɵɵdirectiveInject"](ControlContainer, 5), core_js_["ɵɵdirectiveInject"](NG_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10));
  };
  NgModelGroup.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: NgModelGroup,
    selectors: [["", "ngModelGroup", ""]],
    inputs: {
      name: ["ngModelGroup", "name"]
    },
    exportAs: ["ngModelGroup"],
    features: [core_js_["ɵɵProvidersFeature"]([modelGroupProvider]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return NgModelGroup;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const formControlBinding = {
  provide: NgControl,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => NgModel)
};
const ɵ0$1 = () => Promise.resolve(null);
/**
 * `ngModel` forces an additional change detection run when its inputs change:
 * E.g.:
 * ```
 * <div>{{myModel.valid}}</div>
 * <input [(ngModel)]="myValue" #myModel="ngModel">
 * ```
 * I.e. `ngModel` can export itself on the element and then be used in the template.
 * Normally, this would result in expressions before the `input` that use the exported directive
 * to have an old value as they have been
 * dirty checked before. As this is a very common case for `ngModel`, we added this second change
 * detection run.
 *
 * Notes:
 * - this is just one extra run no matter how many `ngModel`s have been changed.
 * - this is a general problem when using `exportAs` for directives!
 */
const resolvedPromise$1 = /*#__PURE__*/ɵ0$1();
/**
 * @description
 * Creates a `FormControl` instance from a domain model and binds it
 * to a form control element.
 *
 * The `FormControl` instance tracks the value, user interaction, and
 * validation status of the control and keeps the view synced with the model. If used
 * within a parent form, the directive also registers itself with the form as a child
 * control.
 *
 * This directive is used by itself or as part of a larger form. Use the
 * `ngModel` selector to activate it.
 *
 * It accepts a domain model as an optional `Input`. If you have a one-way binding
 * to `ngModel` with `[]` syntax, changing the domain model's value in the component
 * class sets the value in the view. If you have a two-way binding with `[()]` syntax
 * (also known as 'banana-in-a-box syntax'), the value in the UI always syncs back to
 * the domain model in your class.
 *
 * To inspect the properties of the associated `FormControl` (like the validity state),
 * export the directive into a local template variable using `ngModel` as the key (ex:
 * `#myVar="ngModel"`). You can then access the control using the directive's `control` property.
 * However, the most commonly used properties (like `valid` and `dirty`) also exist on the control
 * for direct access. See a full list of properties directly available in
 * `AbstractControlDirective`.
 *
 * @see `RadioControlValueAccessor`
 * @see `SelectControlValueAccessor`
 *
 * @usageNotes
 *
 * ### Using ngModel on a standalone control
 *
 * The following examples show a simple standalone control using `ngModel`:
 *
 * {@example forms/ts/simpleNgModel/simple_ng_model_example.ts region='Component'}
 *
 * When using the `ngModel` within `<form>` tags, you'll also need to supply a `name` attribute
 * so that the control can be registered with the parent form under that name.
 *
 * In the context of a parent form, it's often unnecessary to include one-way or two-way binding,
 * as the parent form syncs the value for you. You access its properties by exporting it into a
 * local template variable using `ngForm` such as (`#f="ngForm"`). Use the variable where
 * needed on form submission.
 *
 * If you do need to populate initial values into your form, using a one-way binding for
 * `ngModel` tends to be sufficient as long as you use the exported form's value rather
 * than the domain model's value on submit.
 *
 * ### Using ngModel within a form
 *
 * The following example shows controls using `ngModel` within a form:
 *
 * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
 *
 * ### Using a standalone ngModel within a group
 *
 * The following example shows you how to use a standalone ngModel control
 * within a form. This controls the display of the form, but doesn't contain form data.
 *
 * ```html
 * <form>
 *   <input name="login" ngModel placeholder="Login">
 *   <input type="checkbox" ngModel [ngModelOptions]="{standalone: true}"> Show more options?
 * </form>
 * <!-- form value: {login: ''} -->
 * ```
 *
 * ### Setting the ngModel `name` attribute through options
 *
 * The following example shows you an alternate way to set the name attribute. Here,
 * an attribute identified as name is used within a custom form control component. To still be able
 * to specify the NgModel's name, you must specify it using the `ngModelOptions` input instead.
 *
 * ```html
 * <form>
 *   <my-custom-form-control name="Nancy" ngModel [ngModelOptions]="{name: 'user'}">
 *   </my-custom-form-control>
 * </form>
 * <!-- form value: {user: ''} -->
 * ```
 *
 * @ngModule FormsModule
 * @publicApi
 */
let NgModel = /*#__PURE__*/(() => {
  class NgModel extends NgControl {
    constructor(parent, validators, asyncValidators, valueAccessors) {
      super();
      this.control = new FormControl();
      /** @internal */
      this._registered = false;
      /**
       * @description
       * Event emitter for producing the `ngModelChange` event after
       * the view model updates.
       */
      this.update = new core_js_.EventEmitter();
      this._parent = parent;
      this._setValidators(validators);
      this._setAsyncValidators(asyncValidators);
      this.valueAccessor = selectValueAccessor(this, valueAccessors);
    }
    /** @nodoc */
    ngOnChanges(changes) {
      this._checkForErrors();
      if (!this._registered) this._setUpControl();
      if ('isDisabled' in changes) {
        this._updateDisabled(changes);
      }
      if (isPropertyUpdated(changes, this.viewModel)) {
        this._updateValue(this.model);
        this.viewModel = this.model;
      }
    }
    /** @nodoc */
    ngOnDestroy() {
      this.formDirective && this.formDirective.removeControl(this);
    }
    /**
     * @description
     * Returns an array that represents the path from the top-level form to this control.
     * Each index is the string name of the control on that level.
     */
    get path() {
      return this._parent ? controlPath(this.name, this._parent) : [this.name];
    }
    /**
     * @description
     * The top-level directive for this control if present, otherwise null.
     */
    get formDirective() {
      return this._parent ? this._parent.formDirective : null;
    }
    /**
     * @description
     * Sets the new value for the view model and emits an `ngModelChange` event.
     *
     * @param newValue The new value emitted by `ngModelChange`.
     */
    viewToModelUpdate(newValue) {
      this.viewModel = newValue;
      this.update.emit(newValue);
    }
    _setUpControl() {
      this._setUpdateStrategy();
      this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);
      this._registered = true;
    }
    _setUpdateStrategy() {
      if (this.options && this.options.updateOn != null) {
        this.control._updateOn = this.options.updateOn;
      }
    }
    _isStandalone() {
      return !this._parent || !!(this.options && this.options.standalone);
    }
    _setUpStandalone() {
      setUpControl(this.control, this);
      this.control.updateValueAndValidity({
        emitEvent: false
      });
    }
    _checkForErrors() {
      if (!this._isStandalone()) {
        this._checkParentType();
      }
      this._checkName();
    }
    _checkParentType() {
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
        if (!(this._parent instanceof NgModelGroup) && this._parent instanceof AbstractFormGroupDirective) {
          throw formGroupNameException();
        } else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
          throw modelParentException();
        }
      }
    }
    _checkName() {
      if (this.options && this.options.name) this.name = this.options.name;
      if (!this._isStandalone() && !this.name && (typeof ngDevMode === 'undefined' || ngDevMode)) {
        throw missingNameException();
      }
    }
    _updateValue(value) {
      resolvedPromise$1.then(() => {
        this.control.setValue(value, {
          emitViewToModelChange: false
        });
      });
    }
    _updateDisabled(changes) {
      const disabledValue = changes['isDisabled'].currentValue;
      const isDisabled = disabledValue === '' || disabledValue && disabledValue !== 'false';
      resolvedPromise$1.then(() => {
        if (isDisabled && !this.control.disabled) {
          this.control.disable();
        } else if (!isDisabled && this.control.disabled) {
          this.control.enable();
        }
      });
    }
  }
  NgModel.ɵfac = function NgModel_Factory(t) {
    return new (t || NgModel)(core_js_["ɵɵdirectiveInject"](ControlContainer, 9), core_js_["ɵɵdirectiveInject"](NG_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_VALUE_ACCESSOR, 10));
  };
  NgModel.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: NgModel,
    selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]],
    inputs: {
      name: "name",
      isDisabled: ["disabled", "isDisabled"],
      model: ["ngModel", "model"],
      options: ["ngModelOptions", "options"]
    },
    outputs: {
      update: "ngModelChange"
    },
    exportAs: ["ngModel"],
    features: [core_js_["ɵɵProvidersFeature"]([formControlBinding]), core_js_["ɵɵInheritDefinitionFeature"], core_js_["ɵɵNgOnChangesFeature"]]
  });
  return NgModel;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @description
 *
 * Adds `novalidate` attribute to all forms by default.
 *
 * `novalidate` is used to disable browser's native form validation.
 *
 * If you want to use native validation with Angular forms, just add `ngNativeValidate` attribute:
 *
 * ```
 * <form ngNativeValidate></form>
 * ```
 *
 * @publicApi
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 */
let ɵNgNoValidate = /*#__PURE__*/(() => {
  class ɵNgNoValidate {}
  ɵNgNoValidate.ɵfac = function ɵNgNoValidate_Factory(t) {
    return new (t || ɵNgNoValidate)();
  };
  ɵNgNoValidate.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: ɵNgNoValidate,
    selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]],
    hostAttrs: ["novalidate", ""]
  });
  return ɵNgNoValidate;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const NUMBER_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => NumberValueAccessor),
  multi: true
};
/**
 * @description
 * The `ControlValueAccessor` for writing a number value and listening to number input changes.
 * The value accessor is used by the `FormControlDirective`, `FormControlName`, and `NgModel`
 * directives.
 *
 * @usageNotes
 *
 * ### Using a number input with a reactive form.
 *
 * The following example shows how to use a number input with a reactive form.
 *
 * ```ts
 * const totalCountControl = new FormControl();
 * ```
 *
 * ```
 * <input type="number" [formControl]="totalCountControl">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let NumberValueAccessor = /*#__PURE__*/(() => {
  class NumberValueAccessor extends BuiltInControlValueAccessor {
    /**
     * Sets the "value" property on the input element.
     * @nodoc
     */
    writeValue(value) {
      // The value needs to be normalized for IE9, otherwise it is set to 'null' when null
      const normalizedValue = value == null ? '' : value;
      this.setProperty('value', normalizedValue);
    }
    /**
     * Registers a function called when the control value changes.
     * @nodoc
     */
    registerOnChange(fn) {
      this.onChange = value => {
        fn(value == '' ? null : parseFloat(value));
      };
    }
  }
  NumberValueAccessor.ɵfac = /*@__PURE__*/function () {
    let ɵNumberValueAccessor_BaseFactory;
    return function NumberValueAccessor_Factory(t) {
      return (ɵNumberValueAccessor_BaseFactory || (ɵNumberValueAccessor_BaseFactory = core_js_["ɵɵgetInheritedFactory"](NumberValueAccessor)))(t || NumberValueAccessor);
    };
  }();
  NumberValueAccessor.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: NumberValueAccessor,
    selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]],
    hostBindings: function NumberValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("input", function NumberValueAccessor_input_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function NumberValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    features: [core_js_["ɵɵProvidersFeature"]([NUMBER_VALUE_ACCESSOR]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return NumberValueAccessor;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const RADIO_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => RadioControlValueAccessor),
  multi: true
};
function throwNameError() {
  throw new Error(`
      If you define both a name and a formControlName attribute on your radio button, their values
      must match. Ex: <input type="radio" formControlName="food" name="food">
    `);
}
/**
 * Internal-only NgModule that works as a host for the `RadioControlRegistry` tree-shakable
 * provider. Note: the `InternalFormsSharedModule` can not be used here directly, since it's
 * declared *after* the `RadioControlRegistry` class and the `providedIn` doesn't support
 * `forwardRef` logic.
 */
let RadioControlRegistryModule = /*#__PURE__*/(() => {
  class RadioControlRegistryModule {}
  RadioControlRegistryModule.ɵfac = function RadioControlRegistryModule_Factory(t) {
    return new (t || RadioControlRegistryModule)();
  };
  RadioControlRegistryModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: RadioControlRegistryModule
  });
  RadioControlRegistryModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return RadioControlRegistryModule;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Class used by Angular to track radio buttons. For internal use only.
 */
let RadioControlRegistry = /*#__PURE__*/(() => {
  class RadioControlRegistry {
    constructor() {
      this._accessors = [];
    }
    /**
     * @description
     * Adds a control to the internal registry. For internal use only.
     */
    add(control, accessor) {
      this._accessors.push([control, accessor]);
    }
    /**
     * @description
     * Removes a control from the internal registry. For internal use only.
     */
    remove(accessor) {
      for (let i = this._accessors.length - 1; i >= 0; --i) {
        if (this._accessors[i][1] === accessor) {
          this._accessors.splice(i, 1);
          return;
        }
      }
    }
    /**
     * @description
     * Selects a radio button. For internal use only.
     */
    select(accessor) {
      this._accessors.forEach(c => {
        if (this._isSameGroup(c, accessor) && c[1] !== accessor) {
          c[1].fireUncheck(accessor.value);
        }
      });
    }
    _isSameGroup(controlPair, accessor) {
      if (!controlPair[0].control) return false;
      return controlPair[0]._parent === accessor._control._parent && controlPair[1].name === accessor.name;
    }
  }
  RadioControlRegistry.ɵfac = function RadioControlRegistry_Factory(t) {
    return new (t || RadioControlRegistry)();
  };
  RadioControlRegistry.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function RadioControlRegistry_Factory() {
      return new RadioControlRegistry();
    },
    token: RadioControlRegistry,
    providedIn: RadioControlRegistryModule
  });
  return RadioControlRegistry;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * The `ControlValueAccessor` for writing radio control values and listening to radio control
 * changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and
 * `NgModel` directives.
 *
 * @usageNotes
 *
 * ### Using radio buttons with reactive form directives
 *
 * The follow example shows how to use radio buttons in a reactive form. When using radio buttons in
 * a reactive form, radio buttons in the same group should have the same `formControlName`.
 * Providing a `name` attribute is optional.
 *
 * {@example forms/ts/reactiveRadioButtons/reactive_radio_button_example.ts region='Reactive'}
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let RadioControlValueAccessor = /*#__PURE__*/(() => {
  class RadioControlValueAccessor extends BuiltInControlValueAccessor {
    constructor(renderer, elementRef, _registry, _injector) {
      super(renderer, elementRef);
      this._registry = _registry;
      this._injector = _injector;
      /**
       * The registered callback function called when a change event occurs on the input element.
       * Note: we declare `onChange` here (also used as host listener) as a function with no arguments
       * to override the `onChange` function (which expects 1 argument) in the parent
       * `BaseControlValueAccessor` class.
       * @nodoc
       */
      this.onChange = () => {};
    }
    /** @nodoc */
    ngOnInit() {
      this._control = this._injector.get(NgControl);
      this._checkName();
      this._registry.add(this._control, this);
    }
    /** @nodoc */
    ngOnDestroy() {
      this._registry.remove(this);
    }
    /**
     * Sets the "checked" property value on the radio input element.
     * @nodoc
     */
    writeValue(value) {
      this._state = value === this.value;
      this.setProperty('checked', this._state);
    }
    /**
     * Registers a function called when the control value changes.
     * @nodoc
     */
    registerOnChange(fn) {
      this._fn = fn;
      this.onChange = () => {
        fn(this.value);
        this._registry.select(this);
      };
    }
    /**
     * Sets the "value" on the radio input element and unchecks it.
     *
     * @param value
     */
    fireUncheck(value) {
      this.writeValue(value);
    }
    _checkName() {
      if (this.name && this.formControlName && this.name !== this.formControlName && (typeof ngDevMode === 'undefined' || ngDevMode)) {
        throwNameError();
      }
      if (!this.name && this.formControlName) this.name = this.formControlName;
    }
  }
  RadioControlValueAccessor.ɵfac = function RadioControlValueAccessor_Factory(t) {
    return new (t || RadioControlValueAccessor)(core_js_["ɵɵdirectiveInject"](core_js_.Renderer2), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](RadioControlRegistry), core_js_["ɵɵdirectiveInject"](core_js_.Injector));
  };
  RadioControlValueAccessor.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: RadioControlValueAccessor,
    selectors: [["input", "type", "radio", "formControlName", ""], ["input", "type", "radio", "formControl", ""], ["input", "type", "radio", "ngModel", ""]],
    hostBindings: function RadioControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("change", function RadioControlValueAccessor_change_HostBindingHandler() {
          return ctx.onChange();
        })("blur", function RadioControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      name: "name",
      formControlName: "formControlName",
      value: "value"
    },
    features: [core_js_["ɵɵProvidersFeature"]([RADIO_VALUE_ACCESSOR]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return RadioControlValueAccessor;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const RANGE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => RangeValueAccessor),
  multi: true
};
/**
 * @description
 * The `ControlValueAccessor` for writing a range value and listening to range input changes.
 * The value accessor is used by the `FormControlDirective`, `FormControlName`, and  `NgModel`
 * directives.
 *
 * @usageNotes
 *
 * ### Using a range input with a reactive form
 *
 * The following example shows how to use a range input with a reactive form.
 *
 * ```ts
 * const ageControl = new FormControl();
 * ```
 *
 * ```
 * <input type="range" [formControl]="ageControl">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let RangeValueAccessor = /*#__PURE__*/(() => {
  class RangeValueAccessor extends BuiltInControlValueAccessor {
    /**
     * Sets the "value" property on the input element.
     * @nodoc
     */
    writeValue(value) {
      this.setProperty('value', parseFloat(value));
    }
    /**
     * Registers a function called when the control value changes.
     * @nodoc
     */
    registerOnChange(fn) {
      this.onChange = value => {
        fn(value == '' ? null : parseFloat(value));
      };
    }
  }
  RangeValueAccessor.ɵfac = /*@__PURE__*/function () {
    let ɵRangeValueAccessor_BaseFactory;
    return function RangeValueAccessor_Factory(t) {
      return (ɵRangeValueAccessor_BaseFactory || (ɵRangeValueAccessor_BaseFactory = core_js_["ɵɵgetInheritedFactory"](RangeValueAccessor)))(t || RangeValueAccessor);
    };
  }();
  RangeValueAccessor.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: RangeValueAccessor,
    selectors: [["input", "type", "range", "formControlName", ""], ["input", "type", "range", "formControl", ""], ["input", "type", "range", "ngModel", ""]],
    hostBindings: function RangeValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("change", function RangeValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("input", function RangeValueAccessor_input_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function RangeValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    features: [core_js_["ɵɵProvidersFeature"]([RANGE_VALUE_ACCESSOR]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return RangeValueAccessor;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Token to provide to turn off the ngModel warning on formControl and formControlName.
 */
const NG_MODEL_WITH_FORM_CONTROL_WARNING = /*#__PURE__*/new core_js_.InjectionToken('NgModelWithFormControlWarning');
const formControlBinding$1 = {
  provide: NgControl,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => FormControlDirective)
};
/**
 * @description
 * Synchronizes a standalone `FormControl` instance to a form control element.
 *
 * Note that support for using the `ngModel` input property and `ngModelChange` event with reactive
 * form directives was deprecated in Angular v6 and is scheduled for removal in
 * a future version of Angular.
 * For details, see [Deprecated features](guide/deprecations#ngmodel-with-reactive-forms).
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 * @see `FormControl`
 * @see `AbstractControl`
 *
 * @usageNotes
 *
 * The following example shows how to register a standalone control and set its value.
 *
 * {@example forms/ts/simpleFormControl/simple_form_control_example.ts region='Component'}
 *
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
let FormControlDirective = /*#__PURE__*/(() => {
  class FormControlDirective extends NgControl {
    constructor(validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
      super();
      this._ngModelWarningConfig = _ngModelWarningConfig;
      /** @deprecated as of v6 */
      this.update = new core_js_.EventEmitter();
      /**
       * @description
       * Instance property used to track whether an ngModel warning has been sent out for this
       * particular `FormControlDirective` instance. Used to support warning config of "always".
       *
       * @internal
       */
      this._ngModelWarningSent = false;
      this._setValidators(validators);
      this._setAsyncValidators(asyncValidators);
      this.valueAccessor = selectValueAccessor(this, valueAccessors);
    }
    /**
     * @description
     * Triggers a warning in dev mode that this input should not be used with reactive forms.
     */
    set isDisabled(isDisabled) {
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
        console.warn(disabledAttrWarning);
      }
    }
    /** @nodoc */
    ngOnChanges(changes) {
      if (this._isControlChanged(changes)) {
        const previousForm = changes['form'].previousValue;
        if (previousForm) {
          cleanUpControl(previousForm, this, /* validateControlPresenceOnChange */false);
        }
        setUpControl(this.form, this);
        if (this.control.disabled && this.valueAccessor.setDisabledState) {
          this.valueAccessor.setDisabledState(true);
        }
        this.form.updateValueAndValidity({
          emitEvent: false
        });
      }
      if (isPropertyUpdated(changes, this.viewModel)) {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
          _ngModelWarning('formControl', FormControlDirective, this, this._ngModelWarningConfig);
        }
        this.form.setValue(this.model);
        this.viewModel = this.model;
      }
    }
    /** @nodoc */
    ngOnDestroy() {
      if (this.form) {
        cleanUpControl(this.form, this, /* validateControlPresenceOnChange */false);
      }
    }
    /**
     * @description
     * Returns an array that represents the path from the top-level form to this control.
     * Each index is the string name of the control on that level.
     */
    get path() {
      return [];
    }
    /**
     * @description
     * The `FormControl` bound to this directive.
     */
    get control() {
      return this.form;
    }
    /**
     * @description
     * Sets the new value for the view model and emits an `ngModelChange` event.
     *
     * @param newValue The new value for the view model.
     */
    viewToModelUpdate(newValue) {
      this.viewModel = newValue;
      this.update.emit(newValue);
    }
    _isControlChanged(changes) {
      return changes.hasOwnProperty('form');
    }
  }
  FormControlDirective.ɵfac = function FormControlDirective_Factory(t) {
    return new (t || FormControlDirective)(core_js_["ɵɵdirectiveInject"](NG_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_VALUE_ACCESSOR, 10), core_js_["ɵɵdirectiveInject"](NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));
  };
  FormControlDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: FormControlDirective,
    selectors: [["", "formControl", ""]],
    inputs: {
      isDisabled: ["disabled", "isDisabled"],
      form: ["formControl", "form"],
      model: ["ngModel", "model"]
    },
    outputs: {
      update: "ngModelChange"
    },
    exportAs: ["ngForm"],
    features: [core_js_["ɵɵProvidersFeature"]([formControlBinding$1]), core_js_["ɵɵInheritDefinitionFeature"], core_js_["ɵɵNgOnChangesFeature"]]
  });
  /**
   * @description
   * Static property used to track whether any ngModel warnings have been sent across
   * all instances of FormControlDirective. Used to support warning config of "once".
   *
   * @internal
   */
  FormControlDirective._ngModelWarningSentOnce = false;
  return FormControlDirective;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const formDirectiveProvider$1 = {
  provide: ControlContainer,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => FormGroupDirective)
};
/**
 * @description
 *
 * Binds an existing `FormGroup` to a DOM element.
 *
 * This directive accepts an existing `FormGroup` instance. It will then use this
 * `FormGroup` instance to match any child `FormControl`, `FormGroup`,
 * and `FormArray` instances to child `FormControlName`, `FormGroupName`,
 * and `FormArrayName` directives.
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 * @see `AbstractControl`
 *
 * @usageNotes
 * ### Register Form Group
 *
 * The following example registers a `FormGroup` with first name and last name controls,
 * and listens for the *ngSubmit* event when the button is clicked.
 *
 * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
 *
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
let FormGroupDirective = /*#__PURE__*/(() => {
  class FormGroupDirective extends ControlContainer {
    constructor(validators, asyncValidators) {
      super();
      this.validators = validators;
      this.asyncValidators = asyncValidators;
      /**
       * @description
       * Reports whether the form submission has been triggered.
       */
      this.submitted = false;
      /**
       * Callback that should be invoked when controls in FormGroup or FormArray collection change
       * (added or removed). This callback triggers corresponding DOM updates.
       */
      this._onCollectionChange = () => this._updateDomValue();
      /**
       * @description
       * Tracks the list of added `FormControlName` instances
       */
      this.directives = [];
      /**
       * @description
       * Tracks the `FormGroup` bound to this directive.
       */
      this.form = null;
      /**
       * @description
       * Emits an event when the form submission has been triggered.
       */
      this.ngSubmit = new core_js_.EventEmitter();
      this._setValidators(validators);
      this._setAsyncValidators(asyncValidators);
    }
    /** @nodoc */
    ngOnChanges(changes) {
      this._checkFormPresent();
      if (changes.hasOwnProperty('form')) {
        this._updateValidators();
        this._updateDomValue();
        this._updateRegistrations();
        this._oldForm = this.form;
      }
    }
    /** @nodoc */
    ngOnDestroy() {
      if (this.form) {
        cleanUpValidators(this.form, this);
        // Currently the `onCollectionChange` callback is rewritten each time the
        // `_registerOnCollectionChange` function is invoked. The implication is that cleanup should
        // happen *only* when the `onCollectionChange` callback was set by this directive instance.
        // Otherwise it might cause overriding a callback of some other directive instances. We should
        // consider updating this logic later to make it similar to how `onChange` callbacks are
        // handled, see https://github.com/angular/angular/issues/39732 for additional info.
        if (this.form._onCollectionChange === this._onCollectionChange) {
          this.form._registerOnCollectionChange(() => {});
        }
      }
    }
    /**
     * @description
     * Returns this directive's instance.
     */
    get formDirective() {
      return this;
    }
    /**
     * @description
     * Returns the `FormGroup` bound to this directive.
     */
    get control() {
      return this.form;
    }
    /**
     * @description
     * Returns an array representing the path to this group. Because this directive
     * always lives at the top level of a form, it always an empty array.
     */
    get path() {
      return [];
    }
    /**
     * @description
     * Method that sets up the control directive in this group, re-calculates its value
     * and validity, and adds the instance to the internal list of directives.
     *
     * @param dir The `FormControlName` directive instance.
     */
    addControl(dir) {
      const ctrl = this.form.get(dir.path);
      setUpControl(ctrl, dir);
      ctrl.updateValueAndValidity({
        emitEvent: false
      });
      this.directives.push(dir);
      return ctrl;
    }
    /**
     * @description
     * Retrieves the `FormControl` instance from the provided `FormControlName` directive
     *
     * @param dir The `FormControlName` directive instance.
     */
    getControl(dir) {
      return this.form.get(dir.path);
    }
    /**
     * @description
     * Removes the `FormControlName` instance from the internal list of directives
     *
     * @param dir The `FormControlName` directive instance.
     */
    removeControl(dir) {
      cleanUpControl(dir.control || null, dir, /* validateControlPresenceOnChange */false);
      removeListItem(this.directives, dir);
    }
    /**
     * Adds a new `FormGroupName` directive instance to the form.
     *
     * @param dir The `FormGroupName` directive instance.
     */
    addFormGroup(dir) {
      this._setUpFormContainer(dir);
    }
    /**
     * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the
     * view.
     *
     * @param dir The `FormGroupName` directive instance.
     */
    removeFormGroup(dir) {
      this._cleanUpFormContainer(dir);
    }
    /**
     * @description
     * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance
     *
     * @param dir The `FormGroupName` directive instance.
     */
    getFormGroup(dir) {
      return this.form.get(dir.path);
    }
    /**
     * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.
     *
     * @param dir The `FormArrayName` directive instance.
     */
    addFormArray(dir) {
      this._setUpFormContainer(dir);
    }
    /**
     * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the
     * view.
     *
     * @param dir The `FormArrayName` directive instance.
     */
    removeFormArray(dir) {
      this._cleanUpFormContainer(dir);
    }
    /**
     * @description
     * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.
     *
     * @param dir The `FormArrayName` directive instance.
     */
    getFormArray(dir) {
      return this.form.get(dir.path);
    }
    /**
     * Sets the new value for the provided `FormControlName` directive.
     *
     * @param dir The `FormControlName` directive instance.
     * @param value The new value for the directive's control.
     */
    updateModel(dir, value) {
      const ctrl = this.form.get(dir.path);
      ctrl.setValue(value);
    }
    /**
     * @description
     * Method called with the "submit" event is triggered on the form.
     * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
     *
     * @param $event The "submit" event object
     */
    onSubmit($event) {
      this.submitted = true;
      syncPendingControls(this.form, this.directives);
      this.ngSubmit.emit($event);
      return false;
    }
    /**
     * @description
     * Method called when the "reset" event is triggered on the form.
     */
    onReset() {
      this.resetForm();
    }
    /**
     * @description
     * Resets the form to an initial value and resets its submitted status.
     *
     * @param value The new value for the form.
     */
    resetForm(value = undefined) {
      this.form.reset(value);
      this.submitted = false;
    }
    /** @internal */
    _updateDomValue() {
      this.directives.forEach(dir => {
        const oldCtrl = dir.control;
        const newCtrl = this.form.get(dir.path);
        if (oldCtrl !== newCtrl) {
          // Note: the value of the `dir.control` may not be defined, for example when it's a first
          // `FormControl` that is added to a `FormGroup` instance (via `addControl` call).
          cleanUpControl(oldCtrl || null, dir);
          // Check whether new control at the same location inside the corresponding `FormGroup` is an
          // instance of `FormControl` and perform control setup only if that's the case.
          // Note: we don't need to clear the list of directives (`this.directives`) here, it would be
          // taken care of in the `removeControl` method invoked when corresponding `formControlName`
          // directive instance is being removed (invoked from `FormControlName.ngOnDestroy`).
          if (newCtrl instanceof FormControl) {
            setUpControl(newCtrl, dir);
            dir.control = newCtrl;
          }
        }
      });
      this.form._updateTreeValidity({
        emitEvent: false
      });
    }
    _setUpFormContainer(dir) {
      const ctrl = this.form.get(dir.path);
      setUpFormContainer(ctrl, dir);
      // NOTE: this operation looks unnecessary in case no new validators were added in
      // `setUpFormContainer` call. Consider updating this code to match the logic in
      // `_cleanUpFormContainer` function.
      ctrl.updateValueAndValidity({
        emitEvent: false
      });
    }
    _cleanUpFormContainer(dir) {
      if (this.form) {
        const ctrl = this.form.get(dir.path);
        if (ctrl) {
          const isControlUpdated = cleanUpFormContainer(ctrl, dir);
          if (isControlUpdated) {
            // Run validity check only in case a control was updated (i.e. view validators were
            // removed) as removing view validators might cause validity to change.
            ctrl.updateValueAndValidity({
              emitEvent: false
            });
          }
        }
      }
    }
    _updateRegistrations() {
      this.form._registerOnCollectionChange(this._onCollectionChange);
      if (this._oldForm) {
        this._oldForm._registerOnCollectionChange(() => {});
      }
    }
    _updateValidators() {
      setUpValidators(this.form, this);
      if (this._oldForm) {
        cleanUpValidators(this._oldForm, this);
      }
    }
    _checkFormPresent() {
      if (!this.form && (typeof ngDevMode === 'undefined' || ngDevMode)) {
        throw missingFormException();
      }
    }
  }
  FormGroupDirective.ɵfac = function FormGroupDirective_Factory(t) {
    return new (t || FormGroupDirective)(core_js_["ɵɵdirectiveInject"](NG_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10));
  };
  FormGroupDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: FormGroupDirective,
    selectors: [["", "formGroup", ""]],
    hostBindings: function FormGroupDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("submit", function FormGroupDirective_submit_HostBindingHandler($event) {
          return ctx.onSubmit($event);
        })("reset", function FormGroupDirective_reset_HostBindingHandler() {
          return ctx.onReset();
        });
      }
    },
    inputs: {
      form: ["formGroup", "form"]
    },
    outputs: {
      ngSubmit: "ngSubmit"
    },
    exportAs: ["ngForm"],
    features: [core_js_["ɵɵProvidersFeature"]([formDirectiveProvider$1]), core_js_["ɵɵInheritDefinitionFeature"], core_js_["ɵɵNgOnChangesFeature"]]
  });
  return FormGroupDirective;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const formGroupNameProvider = {
  provide: ControlContainer,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => FormGroupName)
};
/**
 * @description
 *
 * Syncs a nested `FormGroup` to a DOM element.
 *
 * This directive can only be used with a parent `FormGroupDirective`.
 *
 * It accepts the string name of the nested `FormGroup` to link, and
 * looks for a `FormGroup` registered with that name in the parent
 * `FormGroup` instance you passed into `FormGroupDirective`.
 *
 * Use nested form groups to validate a sub-group of a
 * form separately from the rest or to group the values of certain
 * controls into their own nested object.
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 *
 * @usageNotes
 *
 * ### Access the group by name
 *
 * The following example uses the {@link AbstractControl#get get} method to access the
 * associated `FormGroup`
 *
 * ```ts
 *   this.form.get('name');
 * ```
 *
 * ### Access individual controls in the group
 *
 * The following example uses the {@link AbstractControl#get get} method to access
 * individual controls within the group using dot syntax.
 *
 * ```ts
 *   this.form.get('name.first');
 * ```
 *
 * ### Register a nested `FormGroup`.
 *
 * The following example registers a nested *name* `FormGroup` within an existing `FormGroup`,
 * and provides methods to retrieve the nested `FormGroup` and individual controls.
 *
 * {@example forms/ts/nestedFormGroup/nested_form_group_example.ts region='Component'}
 *
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
let FormGroupName = /*#__PURE__*/(() => {
  class FormGroupName extends AbstractFormGroupDirective {
    constructor(parent, validators, asyncValidators) {
      super();
      this._parent = parent;
      this._setValidators(validators);
      this._setAsyncValidators(asyncValidators);
    }
    /** @internal */
    _checkParentType() {
      if (_hasInvalidParent(this._parent) && (typeof ngDevMode === 'undefined' || ngDevMode)) {
        throw groupParentException();
      }
    }
  }
  FormGroupName.ɵfac = function FormGroupName_Factory(t) {
    return new (t || FormGroupName)(core_js_["ɵɵdirectiveInject"](ControlContainer, 13), core_js_["ɵɵdirectiveInject"](NG_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10));
  };
  FormGroupName.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: FormGroupName,
    selectors: [["", "formGroupName", ""]],
    inputs: {
      name: ["formGroupName", "name"]
    },
    features: [core_js_["ɵɵProvidersFeature"]([formGroupNameProvider]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return FormGroupName;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
const formArrayNameProvider = {
  provide: ControlContainer,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => FormArrayName)
};
/**
 * @description
 *
 * Syncs a nested `FormArray` to a DOM element.
 *
 * This directive is designed to be used with a parent `FormGroupDirective` (selector:
 * `[formGroup]`).
 *
 * It accepts the string name of the nested `FormArray` you want to link, and
 * will look for a `FormArray` registered with that name in the parent
 * `FormGroup` instance you passed into `FormGroupDirective`.
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 * @see `AbstractControl`
 *
 * @usageNotes
 *
 * ### Example
 *
 * {@example forms/ts/nestedFormArray/nested_form_array_example.ts region='Component'}
 *
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
let FormArrayName = /*#__PURE__*/(() => {
  class FormArrayName extends ControlContainer {
    constructor(parent, validators, asyncValidators) {
      super();
      this._parent = parent;
      this._setValidators(validators);
      this._setAsyncValidators(asyncValidators);
    }
    /**
     * A lifecycle method called when the directive's inputs are initialized. For internal use only.
     * @throws If the directive does not have a valid parent.
     * @nodoc
     */
    ngOnInit() {
      this._checkParentType();
      this.formDirective.addFormArray(this);
    }
    /**
     * A lifecycle method called before the directive's instance is destroyed. For internal use only.
     * @nodoc
     */
    ngOnDestroy() {
      if (this.formDirective) {
        this.formDirective.removeFormArray(this);
      }
    }
    /**
     * @description
     * The `FormArray` bound to this directive.
     */
    get control() {
      return this.formDirective.getFormArray(this);
    }
    /**
     * @description
     * The top-level directive for this group if present, otherwise null.
     */
    get formDirective() {
      return this._parent ? this._parent.formDirective : null;
    }
    /**
     * @description
     * Returns an array that represents the path from the top-level form to this control.
     * Each index is the string name of the control on that level.
     */
    get path() {
      return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
    }
    _checkParentType() {
      if (_hasInvalidParent(this._parent) && (typeof ngDevMode === 'undefined' || ngDevMode)) {
        throw arrayParentException();
      }
    }
  }
  FormArrayName.ɵfac = function FormArrayName_Factory(t) {
    return new (t || FormArrayName)(core_js_["ɵɵdirectiveInject"](ControlContainer, 13), core_js_["ɵɵdirectiveInject"](NG_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10));
  };
  FormArrayName.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: FormArrayName,
    selectors: [["", "formArrayName", ""]],
    inputs: {
      name: ["formArrayName", "name"]
    },
    features: [core_js_["ɵɵProvidersFeature"]([formArrayNameProvider]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return FormArrayName;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
function _hasInvalidParent(parent) {
  return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName);
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const controlNameBinding = {
  provide: NgControl,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => FormControlName)
};
/**
 * @description
 * Syncs a `FormControl` in an existing `FormGroup` to a form control
 * element by name.
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 * @see `FormControl`
 * @see `AbstractControl`
 *
 * @usageNotes
 *
 * ### Register `FormControl` within a group
 *
 * The following example shows how to register multiple form controls within a form group
 * and set their value.
 *
 * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
 *
 * To see `formControlName` examples with different form control types, see:
 *
 * * Radio buttons: `RadioControlValueAccessor`
 * * Selects: `SelectControlValueAccessor`
 *
 * ### Use with ngModel is deprecated
 *
 * Support for using the `ngModel` input property and `ngModelChange` event with reactive
 * form directives has been deprecated in Angular v6 and is scheduled for removal in
 * a future version of Angular.
 *
 * For details, see [Deprecated features](guide/deprecations#ngmodel-with-reactive-forms).
 *
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
let FormControlName = /*#__PURE__*/(() => {
  class FormControlName extends NgControl {
    constructor(parent, validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
      super();
      this._ngModelWarningConfig = _ngModelWarningConfig;
      this._added = false;
      /** @deprecated as of v6 */
      this.update = new core_js_.EventEmitter();
      /**
       * @description
       * Instance property used to track whether an ngModel warning has been sent out for this
       * particular FormControlName instance. Used to support warning config of "always".
       *
       * @internal
       */
      this._ngModelWarningSent = false;
      this._parent = parent;
      this._setValidators(validators);
      this._setAsyncValidators(asyncValidators);
      this.valueAccessor = selectValueAccessor(this, valueAccessors);
    }
    /**
     * @description
     * Triggers a warning in dev mode that this input should not be used with reactive forms.
     */
    set isDisabled(isDisabled) {
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
        console.warn(disabledAttrWarning);
      }
    }
    /** @nodoc */
    ngOnChanges(changes) {
      if (!this._added) this._setUpControl();
      if (isPropertyUpdated(changes, this.viewModel)) {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
          _ngModelWarning('formControlName', FormControlName, this, this._ngModelWarningConfig);
        }
        this.viewModel = this.model;
        this.formDirective.updateModel(this, this.model);
      }
    }
    /** @nodoc */
    ngOnDestroy() {
      if (this.formDirective) {
        this.formDirective.removeControl(this);
      }
    }
    /**
     * @description
     * Sets the new value for the view model and emits an `ngModelChange` event.
     *
     * @param newValue The new value for the view model.
     */
    viewToModelUpdate(newValue) {
      this.viewModel = newValue;
      this.update.emit(newValue);
    }
    /**
     * @description
     * Returns an array that represents the path from the top-level form to this control.
     * Each index is the string name of the control on that level.
     */
    get path() {
      return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
    }
    /**
     * @description
     * The top-level directive for this group if present, otherwise null.
     */
    get formDirective() {
      return this._parent ? this._parent.formDirective : null;
    }
    _checkParentType() {
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
        if (!(this._parent instanceof FormGroupName) && this._parent instanceof AbstractFormGroupDirective) {
          throw ngModelGroupException();
        } else if (!(this._parent instanceof FormGroupName) && !(this._parent instanceof FormGroupDirective) && !(this._parent instanceof FormArrayName)) {
          throw controlParentException();
        }
      }
    }
    _setUpControl() {
      this._checkParentType();
      this.control = this.formDirective.addControl(this);
      if (this.control.disabled && this.valueAccessor.setDisabledState) {
        this.valueAccessor.setDisabledState(true);
      }
      this._added = true;
    }
  }
  FormControlName.ɵfac = function FormControlName_Factory(t) {
    return new (t || FormControlName)(core_js_["ɵɵdirectiveInject"](ControlContainer, 13), core_js_["ɵɵdirectiveInject"](NG_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_VALUE_ACCESSOR, 10), core_js_["ɵɵdirectiveInject"](NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));
  };
  FormControlName.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: FormControlName,
    selectors: [["", "formControlName", ""]],
    inputs: {
      isDisabled: ["disabled", "isDisabled"],
      name: ["formControlName", "name"],
      model: ["ngModel", "model"]
    },
    outputs: {
      update: "ngModelChange"
    },
    features: [core_js_["ɵɵProvidersFeature"]([controlNameBinding]), core_js_["ɵɵInheritDefinitionFeature"], core_js_["ɵɵNgOnChangesFeature"]]
  });
  /**
   * @description
   * Static property used to track whether any ngModel warnings have been sent across
   * all instances of FormControlName. Used to support warning config of "once".
   *
   * @internal
   */
  FormControlName._ngModelWarningSentOnce = false;
  return FormControlName;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const SELECT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => SelectControlValueAccessor),
  multi: true
};
function _buildValueString(id, value) {
  if (id == null) return `${value}`;
  if (value && typeof value === 'object') value = 'Object';
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId(valueString) {
  return valueString.split(':')[0];
}
/**
 * @description
 * The `ControlValueAccessor` for writing select control values and listening to select control
 * changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and
 * `NgModel` directives.
 *
 * @usageNotes
 *
 * ### Using select controls in a reactive form
 *
 * The following examples show how to use a select control in a reactive form.
 *
 * {@example forms/ts/reactiveSelectControl/reactive_select_control_example.ts region='Component'}
 *
 * ### Using select controls in a template-driven form
 *
 * To use a select in a template-driven form, simply add an `ngModel` and a `name`
 * attribute to the main `<select>` tag.
 *
 * {@example forms/ts/selectControl/select_control_example.ts region='Component'}
 *
 * ### Customizing option selection
 *
 * Angular uses object identity to select option. It's possible for the identities of items
 * to change while the data does not. This can happen, for example, if the items are produced
 * from an RPC to the server, and that RPC is re-run. Even if the data hasn't changed, the
 * second response will produce objects with different identities.
 *
 * To customize the default option comparison algorithm, `<select>` supports `compareWith` input.
 * `compareWith` takes a **function** which has two arguments: `option1` and `option2`.
 * If `compareWith` is given, Angular selects option by the return value of the function.
 *
 * ```ts
 * const selectedCountriesControl = new FormControl();
 * ```
 *
 * ```
 * <select [compareWith]="compareFn"  [formControl]="selectedCountriesControl">
 *     <option *ngFor="let country of countries" [ngValue]="country">
 *         {{country.name}}
 *     </option>
 * </select>
 *
 * compareFn(c1: Country, c2: Country): boolean {
 *     return c1 && c2 ? c1.id === c2.id : c1 === c2;
 * }
 * ```
 *
 * **Note:** We listen to the 'change' event because 'input' events aren't fired
 * for selects in IE, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event#browser_compatibility
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let SelectControlValueAccessor = /*#__PURE__*/(() => {
  class SelectControlValueAccessor extends BuiltInControlValueAccessor {
    constructor() {
      super(...arguments);
      /** @internal */
      this._optionMap = new Map();
      /** @internal */
      this._idCounter = 0;
      this._compareWith = Object.is;
    }
    /**
     * @description
     * Tracks the option comparison algorithm for tracking identities when
     * checking for changes.
     */
    set compareWith(fn) {
      if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {
        throw new Error(`compareWith must be a function, but received ${JSON.stringify(fn)}`);
      }
      this._compareWith = fn;
    }
    /**
     * Sets the "value" property on the input element. The "selectedIndex"
     * property is also set if an ID is provided on the option element.
     * @nodoc
     */
    writeValue(value) {
      this.value = value;
      const id = this._getOptionId(value);
      if (id == null) {
        this.setProperty('selectedIndex', -1);
      }
      const valueString = _buildValueString(id, value);
      this.setProperty('value', valueString);
    }
    /**
     * Registers a function called when the control value changes.
     * @nodoc
     */
    registerOnChange(fn) {
      this.onChange = valueString => {
        this.value = this._getOptionValue(valueString);
        fn(this.value);
      };
    }
    /** @internal */
    _registerOption() {
      return (this._idCounter++).toString();
    }
    /** @internal */
    _getOptionId(value) {
      for (const id of Array.from(this._optionMap.keys())) {
        if (this._compareWith(this._optionMap.get(id), value)) return id;
      }
      return null;
    }
    /** @internal */
    _getOptionValue(valueString) {
      const id = _extractId(valueString);
      return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
    }
  }
  SelectControlValueAccessor.ɵfac = /*@__PURE__*/function () {
    let ɵSelectControlValueAccessor_BaseFactory;
    return function SelectControlValueAccessor_Factory(t) {
      return (ɵSelectControlValueAccessor_BaseFactory || (ɵSelectControlValueAccessor_BaseFactory = core_js_["ɵɵgetInheritedFactory"](SelectControlValueAccessor)))(t || SelectControlValueAccessor);
    };
  }();
  SelectControlValueAccessor.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: SelectControlValueAccessor,
    selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]],
    hostBindings: function SelectControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("change", function SelectControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function SelectControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      compareWith: "compareWith"
    },
    features: [core_js_["ɵɵProvidersFeature"]([SELECT_VALUE_ACCESSOR]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return SelectControlValueAccessor;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Marks `<option>` as dynamic, so Angular can be notified when options change.
 *
 * @see `SelectControlValueAccessor`
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let NgSelectOption = /*#__PURE__*/(() => {
  class NgSelectOption {
    constructor(_element, _renderer, _select) {
      this._element = _element;
      this._renderer = _renderer;
      this._select = _select;
      if (this._select) this.id = this._select._registerOption();
    }
    /**
     * @description
     * Tracks the value bound to the option element. Unlike the value binding,
     * ngValue supports binding to objects.
     */
    set ngValue(value) {
      if (this._select == null) return;
      this._select._optionMap.set(this.id, value);
      this._setElementValue(_buildValueString(this.id, value));
      this._select.writeValue(this._select.value);
    }
    /**
     * @description
     * Tracks simple string values bound to the option element.
     * For objects, use the `ngValue` input binding.
     */
    set value(value) {
      this._setElementValue(value);
      if (this._select) this._select.writeValue(this._select.value);
    }
    /** @internal */
    _setElementValue(value) {
      this._renderer.setProperty(this._element.nativeElement, 'value', value);
    }
    /** @nodoc */
    ngOnDestroy() {
      if (this._select) {
        this._select._optionMap.delete(this.id);
        this._select.writeValue(this._select.value);
      }
    }
  }
  NgSelectOption.ɵfac = function NgSelectOption_Factory(t) {
    return new (t || NgSelectOption)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.Renderer2), core_js_["ɵɵdirectiveInject"](SelectControlValueAccessor, 9));
  };
  NgSelectOption.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: NgSelectOption,
    selectors: [["option"]],
    inputs: {
      ngValue: "ngValue",
      value: "value"
    }
  });
  return NgSelectOption;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const SELECT_MULTIPLE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => SelectMultipleControlValueAccessor),
  multi: true
};
function _buildValueString$1(id, value) {
  if (id == null) return `${value}`;
  if (typeof value === 'string') value = `'${value}'`;
  if (value && typeof value === 'object') value = 'Object';
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId$1(valueString) {
  return valueString.split(':')[0];
}
/** Mock interface for HTMLCollection */
class HTMLCollection {}
/**
 * @description
 * The `ControlValueAccessor` for writing multi-select control values and listening to multi-select
 * control changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and
 * `NgModel` directives.
 *
 * @see `SelectControlValueAccessor`
 *
 * @usageNotes
 *
 * ### Using a multi-select control
 *
 * The follow example shows you how to use a multi-select control with a reactive form.
 *
 * ```ts
 * const countryControl = new FormControl();
 * ```
 *
 * ```
 * <select multiple name="countries" [formControl]="countryControl">
 *   <option *ngFor="let country of countries" [ngValue]="country">
 *     {{ country.name }}
 *   </option>
 * </select>
 * ```
 *
 * ### Customizing option selection
 *
 * To customize the default option comparison algorithm, `<select>` supports `compareWith` input.
 * See the `SelectControlValueAccessor` for usage.
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let SelectMultipleControlValueAccessor = /*#__PURE__*/(() => {
  class SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor {
    constructor() {
      super(...arguments);
      /** @internal */
      this._optionMap = new Map();
      /** @internal */
      this._idCounter = 0;
      this._compareWith = Object.is;
    }
    /**
     * @description
     * Tracks the option comparison algorithm for tracking identities when
     * checking for changes.
     */
    set compareWith(fn) {
      if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {
        throw new Error(`compareWith must be a function, but received ${JSON.stringify(fn)}`);
      }
      this._compareWith = fn;
    }
    /**
     * Sets the "value" property on one or of more of the select's options.
     * @nodoc
     */
    writeValue(value) {
      this.value = value;
      let optionSelectedStateSetter;
      if (Array.isArray(value)) {
        // convert values to ids
        const ids = value.map(v => this._getOptionId(v));
        optionSelectedStateSetter = (opt, o) => {
          opt._setSelected(ids.indexOf(o.toString()) > -1);
        };
      } else {
        optionSelectedStateSetter = (opt, o) => {
          opt._setSelected(false);
        };
      }
      this._optionMap.forEach(optionSelectedStateSetter);
    }
    /**
     * Registers a function called when the control value changes
     * and writes an array of the selected options.
     * @nodoc
     */
    registerOnChange(fn) {
      this.onChange = _ => {
        const selected = [];
        if (_.selectedOptions !== undefined) {
          const options = _.selectedOptions;
          for (let i = 0; i < options.length; i++) {
            const opt = options.item(i);
            const val = this._getOptionValue(opt.value);
            selected.push(val);
          }
        }
        // Degrade on IE
        else {
          const options = _.options;
          for (let i = 0; i < options.length; i++) {
            const opt = options.item(i);
            if (opt.selected) {
              const val = this._getOptionValue(opt.value);
              selected.push(val);
            }
          }
        }
        this.value = selected;
        fn(selected);
      };
    }
    /** @internal */
    _registerOption(value) {
      const id = (this._idCounter++).toString();
      this._optionMap.set(id, value);
      return id;
    }
    /** @internal */
    _getOptionId(value) {
      for (const id of Array.from(this._optionMap.keys())) {
        if (this._compareWith(this._optionMap.get(id)._value, value)) return id;
      }
      return null;
    }
    /** @internal */
    _getOptionValue(valueString) {
      const id = _extractId$1(valueString);
      return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
    }
  }
  SelectMultipleControlValueAccessor.ɵfac = /*@__PURE__*/function () {
    let ɵSelectMultipleControlValueAccessor_BaseFactory;
    return function SelectMultipleControlValueAccessor_Factory(t) {
      return (ɵSelectMultipleControlValueAccessor_BaseFactory || (ɵSelectMultipleControlValueAccessor_BaseFactory = core_js_["ɵɵgetInheritedFactory"](SelectMultipleControlValueAccessor)))(t || SelectMultipleControlValueAccessor);
    };
  }();
  SelectMultipleControlValueAccessor.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: SelectMultipleControlValueAccessor,
    selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]],
    hostBindings: function SelectMultipleControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("change", function SelectMultipleControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target);
        })("blur", function SelectMultipleControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      compareWith: "compareWith"
    },
    features: [core_js_["ɵɵProvidersFeature"]([SELECT_MULTIPLE_VALUE_ACCESSOR]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return SelectMultipleControlValueAccessor;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Marks `<option>` as dynamic, so Angular can be notified when options change.
 *
 * @see `SelectMultipleControlValueAccessor`
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let ɵNgSelectMultipleOption = /*#__PURE__*/(() => {
  class ɵNgSelectMultipleOption {
    constructor(_element, _renderer, _select) {
      this._element = _element;
      this._renderer = _renderer;
      this._select = _select;
      if (this._select) {
        this.id = this._select._registerOption(this);
      }
    }
    /**
     * @description
     * Tracks the value bound to the option element. Unlike the value binding,
     * ngValue supports binding to objects.
     */
    set ngValue(value) {
      if (this._select == null) return;
      this._value = value;
      this._setElementValue(_buildValueString$1(this.id, value));
      this._select.writeValue(this._select.value);
    }
    /**
     * @description
     * Tracks simple string values bound to the option element.
     * For objects, use the `ngValue` input binding.
     */
    set value(value) {
      if (this._select) {
        this._value = value;
        this._setElementValue(_buildValueString$1(this.id, value));
        this._select.writeValue(this._select.value);
      } else {
        this._setElementValue(value);
      }
    }
    /** @internal */
    _setElementValue(value) {
      this._renderer.setProperty(this._element.nativeElement, 'value', value);
    }
    /** @internal */
    _setSelected(selected) {
      this._renderer.setProperty(this._element.nativeElement, 'selected', selected);
    }
    /** @nodoc */
    ngOnDestroy() {
      if (this._select) {
        this._select._optionMap.delete(this.id);
        this._select.writeValue(this._select.value);
      }
    }
  }
  ɵNgSelectMultipleOption.ɵfac = function ɵNgSelectMultipleOption_Factory(t) {
    return new (t || ɵNgSelectMultipleOption)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.Renderer2), core_js_["ɵɵdirectiveInject"](SelectMultipleControlValueAccessor, 9));
  };
  ɵNgSelectMultipleOption.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: ɵNgSelectMultipleOption,
    selectors: [["option"]],
    inputs: {
      ngValue: "ngValue",
      value: "value"
    }
  });
  return ɵNgSelectMultipleOption;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @description
 * Method that updates string to integer if not alread a number
 *
 * @param value The value to convert to integer
 * @returns value of parameter in number or integer.
 */
function toNumber(value) {
  return typeof value === 'number' ? value : parseInt(value, 10);
}
/**
 * A base class for Validator-based Directives. The class contains common logic shared across such
 * Directives.
 *
 * For internal use only, this class is not intended for use outside of the Forms package.
 */
let AbstractValidatorDirective = /*#__PURE__*/(() => {
  class AbstractValidatorDirective {
    constructor() {
      this._validator = nullValidator;
    }
    /**
     * Helper function invoked from child classes to process changes (from `ngOnChanges` hook).
     * @nodoc
     */
    handleChanges(changes) {
      if (this.inputName in changes) {
        const input = this.normalizeInput(changes[this.inputName].currentValue);
        this._validator = this.createValidator(input);
        if (this._onChange) {
          this._onChange();
        }
      }
    }
    /** @nodoc */
    validate(control) {
      return this._validator(control);
    }
    /** @nodoc */
    registerOnValidatorChange(fn) {
      this._onChange = fn;
    }
  }
  AbstractValidatorDirective.ɵfac = function AbstractValidatorDirective_Factory(t) {
    return new (t || AbstractValidatorDirective)();
  };
  AbstractValidatorDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: AbstractValidatorDirective
  });
  return AbstractValidatorDirective;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Provider which adds `MaxValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const MAX_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => MaxValidator),
  multi: true
};
/**
 * A directive which installs the {@link MaxValidator} for any `formControlName`,
 * `formControl`, or control with `ngModel` that also has a `max` attribute.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a max validator
 *
 * The following example shows how to add a max validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input type="number" ngModel max="4">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let MaxValidator = /*#__PURE__*/(() => {
  class MaxValidator extends AbstractValidatorDirective {
    constructor() {
      super(...arguments);
      /** @internal */
      this.inputName = 'max';
      /** @internal */
      this.normalizeInput = input => parseFloat(input);
      /** @internal */
      this.createValidator = max => maxValidator(max);
    }
    /**
     * Declare `ngOnChanges` lifecycle hook at the main directive level (vs keeping it in base class)
     * to avoid differences in handling inheritance of lifecycle hooks between Ivy and ViewEngine in
     * AOT mode. This could be refactored once ViewEngine is removed.
     * @nodoc
     */
    ngOnChanges(changes) {
      this.handleChanges(changes);
    }
  }
  MaxValidator.ɵfac = /*@__PURE__*/function () {
    let ɵMaxValidator_BaseFactory;
    return function MaxValidator_Factory(t) {
      return (ɵMaxValidator_BaseFactory || (ɵMaxValidator_BaseFactory = core_js_["ɵɵgetInheritedFactory"](MaxValidator)))(t || MaxValidator);
    };
  }();
  MaxValidator.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: MaxValidator,
    selectors: [["input", "type", "number", "max", "", "formControlName", ""], ["input", "type", "number", "max", "", "formControl", ""], ["input", "type", "number", "max", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MaxValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        let tmp_b_0;
        core_js_["ɵɵattribute"]("max", (tmp_b_0 = ctx.max) !== null && tmp_b_0 !== undefined ? tmp_b_0 : null);
      }
    },
    inputs: {
      max: "max"
    },
    features: [core_js_["ɵɵProvidersFeature"]([MAX_VALIDATOR]), core_js_["ɵɵInheritDefinitionFeature"], core_js_["ɵɵNgOnChangesFeature"]]
  });
  return MaxValidator;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Provider which adds `MinValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const MIN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => MinValidator),
  multi: true
};
/**
 * A directive which installs the {@link MinValidator} for any `formControlName`,
 * `formControl`, or control with `ngModel` that also has a `min` attribute.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a min validator
 *
 * The following example shows how to add a min validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input type="number" ngModel min="4">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let MinValidator = /*#__PURE__*/(() => {
  class MinValidator extends AbstractValidatorDirective {
    constructor() {
      super(...arguments);
      /** @internal */
      this.inputName = 'min';
      /** @internal */
      this.normalizeInput = input => parseFloat(input);
      /** @internal */
      this.createValidator = min => minValidator(min);
    }
    /**
     * Declare `ngOnChanges` lifecycle hook at the main directive level (vs keeping it in base class)
     * to avoid differences in handling inheritance of lifecycle hooks between Ivy and ViewEngine in
     * AOT mode. This could be refactored once ViewEngine is removed.
     * @nodoc
     */
    ngOnChanges(changes) {
      this.handleChanges(changes);
    }
  }
  MinValidator.ɵfac = /*@__PURE__*/function () {
    let ɵMinValidator_BaseFactory;
    return function MinValidator_Factory(t) {
      return (ɵMinValidator_BaseFactory || (ɵMinValidator_BaseFactory = core_js_["ɵɵgetInheritedFactory"](MinValidator)))(t || MinValidator);
    };
  }();
  MinValidator.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: MinValidator,
    selectors: [["input", "type", "number", "min", "", "formControlName", ""], ["input", "type", "number", "min", "", "formControl", ""], ["input", "type", "number", "min", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MinValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        let tmp_b_0;
        core_js_["ɵɵattribute"]("min", (tmp_b_0 = ctx.min) !== null && tmp_b_0 !== undefined ? tmp_b_0 : null);
      }
    },
    inputs: {
      min: "min"
    },
    features: [core_js_["ɵɵProvidersFeature"]([MIN_VALIDATOR]), core_js_["ɵɵInheritDefinitionFeature"], core_js_["ɵɵNgOnChangesFeature"]]
  });
  return MinValidator;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Provider which adds `RequiredValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => RequiredValidator),
  multi: true
};
/**
 * @description
 * Provider which adds `CheckboxRequiredValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const CHECKBOX_REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => CheckboxRequiredValidator),
  multi: true
};
/**
 * @description
 * A directive that adds the `required` validator to any controls marked with the
 * `required` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a required validator using template-driven forms
 *
 * ```
 * <input name="fullName" ngModel required>
 * ```
 *
 * @ngModule FormsModule
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
let RequiredValidator = /*#__PURE__*/(() => {
  class RequiredValidator {
    constructor() {
      this._required = false;
    }
    /**
     * @description
     * Tracks changes to the required attribute bound to this directive.
     */
    get required() {
      return this._required;
    }
    set required(value) {
      this._required = value != null && value !== false && `${value}` !== 'false';
      if (this._onChange) this._onChange();
    }
    /**
     * Method that validates whether the control is empty.
     * Returns the validation result if enabled, otherwise null.
     * @nodoc
     */
    validate(control) {
      return this.required ? requiredValidator(control) : null;
    }
    /**
     * Registers a callback function to call when the validator inputs change.
     * @nodoc
     */
    registerOnValidatorChange(fn) {
      this._onChange = fn;
    }
  }
  RequiredValidator.ɵfac = function RequiredValidator_Factory(t) {
    return new (t || RequiredValidator)();
  };
  RequiredValidator.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: RequiredValidator,
    selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]],
    hostVars: 1,
    hostBindings: function RequiredValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("required", ctx.required ? "" : null);
      }
    },
    inputs: {
      required: "required"
    },
    features: [core_js_["ɵɵProvidersFeature"]([REQUIRED_VALIDATOR])]
  });
  return RequiredValidator;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * A Directive that adds the `required` validator to checkbox controls marked with the
 * `required` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a required checkbox validator using template-driven forms
 *
 * The following example shows how to add a checkbox required validator to an input attached to an
 * ngModel binding.
 *
 * ```
 * <input type="checkbox" name="active" ngModel required>
 * ```
 *
 * @publicApi
 * @ngModule FormsModule
 * @ngModule ReactiveFormsModule
 */
let CheckboxRequiredValidator = /*#__PURE__*/(() => {
  class CheckboxRequiredValidator extends RequiredValidator {
    /**
     * Method that validates whether or not the checkbox has been checked.
     * Returns the validation result if enabled, otherwise null.
     * @nodoc
     */
    validate(control) {
      return this.required ? requiredTrueValidator(control) : null;
    }
  }
  CheckboxRequiredValidator.ɵfac = /*@__PURE__*/function () {
    let ɵCheckboxRequiredValidator_BaseFactory;
    return function CheckboxRequiredValidator_Factory(t) {
      return (ɵCheckboxRequiredValidator_BaseFactory || (ɵCheckboxRequiredValidator_BaseFactory = core_js_["ɵɵgetInheritedFactory"](CheckboxRequiredValidator)))(t || CheckboxRequiredValidator);
    };
  }();
  CheckboxRequiredValidator.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: CheckboxRequiredValidator,
    selectors: [["input", "type", "checkbox", "required", "", "formControlName", ""], ["input", "type", "checkbox", "required", "", "formControl", ""], ["input", "type", "checkbox", "required", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function CheckboxRequiredValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("required", ctx.required ? "" : null);
      }
    },
    features: [core_js_["ɵɵProvidersFeature"]([CHECKBOX_REQUIRED_VALIDATOR]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return CheckboxRequiredValidator;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Provider which adds `EmailValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const EMAIL_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => EmailValidator),
  multi: true
};
/**
 * A directive that adds the `email` validator to controls marked with the
 * `email` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding an email validator
 *
 * The following example shows how to add an email validator to an input attached to an ngModel
 * binding.
 *
 * ```
 * <input type="email" name="email" ngModel email>
 * <input type="email" name="email" ngModel email="true">
 * <input type="email" name="email" ngModel [email]="true">
 * ```
 *
 * @publicApi
 * @ngModule FormsModule
 * @ngModule ReactiveFormsModule
 */
let EmailValidator = /*#__PURE__*/(() => {
  class EmailValidator {
    constructor() {
      this._enabled = false;
    }
    /**
     * @description
     * Tracks changes to the email attribute bound to this directive.
     */
    set email(value) {
      this._enabled = value === '' || value === true || value === 'true';
      if (this._onChange) this._onChange();
    }
    /**
     * Method that validates whether an email address is valid.
     * Returns the validation result if enabled, otherwise null.
     * @nodoc
     */
    validate(control) {
      return this._enabled ? emailValidator(control) : null;
    }
    /**
     * Registers a callback function to call when the validator inputs change.
     * @nodoc
     */
    registerOnValidatorChange(fn) {
      this._onChange = fn;
    }
  }
  EmailValidator.ɵfac = function EmailValidator_Factory(t) {
    return new (t || EmailValidator)();
  };
  EmailValidator.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: EmailValidator,
    selectors: [["", "email", "", "formControlName", ""], ["", "email", "", "formControl", ""], ["", "email", "", "ngModel", ""]],
    inputs: {
      email: "email"
    },
    features: [core_js_["ɵɵProvidersFeature"]([EMAIL_VALIDATOR])]
  });
  return EmailValidator;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Provider which adds `MinLengthValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const MIN_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => MinLengthValidator),
  multi: true
};
/**
 * A directive that adds minimum length validation to controls marked with the
 * `minlength` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a minimum length validator
 *
 * The following example shows how to add a minimum length validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input name="firstName" ngModel minlength="4">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let MinLengthValidator = /*#__PURE__*/(() => {
  class MinLengthValidator {
    constructor() {
      this._validator = nullValidator;
    }
    /** @nodoc */
    ngOnChanges(changes) {
      if ('minlength' in changes) {
        this._createValidator();
        if (this._onChange) this._onChange();
      }
    }
    /**
     * Method that validates whether the value meets a minimum length requirement.
     * Returns the validation result if enabled, otherwise null.
     * @nodoc
     */
    validate(control) {
      return this.enabled() ? this._validator(control) : null;
    }
    /**
     * Registers a callback function to call when the validator inputs change.
     * @nodoc
     */
    registerOnValidatorChange(fn) {
      this._onChange = fn;
    }
    _createValidator() {
      this._validator = this.enabled() ? minLengthValidator(toNumber(this.minlength)) : nullValidator;
    }
    /** @nodoc */
    enabled() {
      return this.minlength != null /* both `null` and `undefined` */;
    }
  }

  MinLengthValidator.ɵfac = function MinLengthValidator_Factory(t) {
    return new (t || MinLengthValidator)();
  };
  MinLengthValidator.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: MinLengthValidator,
    selectors: [["", "minlength", "", "formControlName", ""], ["", "minlength", "", "formControl", ""], ["", "minlength", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MinLengthValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("minlength", ctx.enabled() ? ctx.minlength : null);
      }
    },
    inputs: {
      minlength: "minlength"
    },
    features: [core_js_["ɵɵProvidersFeature"]([MIN_LENGTH_VALIDATOR]), core_js_["ɵɵNgOnChangesFeature"]]
  });
  return MinLengthValidator;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Provider which adds `MaxLengthValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const MAX_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => MaxLengthValidator),
  multi: true
};
/**
 * A directive that adds max length validation to controls marked with the
 * `maxlength` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a maximum length validator
 *
 * The following example shows how to add a maximum length validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input name="firstName" ngModel maxlength="25">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let MaxLengthValidator = /*#__PURE__*/(() => {
  class MaxLengthValidator {
    constructor() {
      this._validator = nullValidator;
    }
    /** @nodoc */
    ngOnChanges(changes) {
      if ('maxlength' in changes) {
        this._createValidator();
        if (this._onChange) this._onChange();
      }
    }
    /**
     * Method that validates whether the value exceeds the maximum length requirement.
     * @nodoc
     */
    validate(control) {
      return this.enabled() ? this._validator(control) : null;
    }
    /**
     * Registers a callback function to call when the validator inputs change.
     * @nodoc
     */
    registerOnValidatorChange(fn) {
      this._onChange = fn;
    }
    _createValidator() {
      this._validator = this.enabled() ? maxLengthValidator(toNumber(this.maxlength)) : nullValidator;
    }
    /** @nodoc */
    enabled() {
      return this.maxlength != null /* both `null` and `undefined` */;
    }
  }

  MaxLengthValidator.ɵfac = function MaxLengthValidator_Factory(t) {
    return new (t || MaxLengthValidator)();
  };
  MaxLengthValidator.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: MaxLengthValidator,
    selectors: [["", "maxlength", "", "formControlName", ""], ["", "maxlength", "", "formControl", ""], ["", "maxlength", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MaxLengthValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("maxlength", ctx.enabled() ? ctx.maxlength : null);
      }
    },
    inputs: {
      maxlength: "maxlength"
    },
    features: [core_js_["ɵɵProvidersFeature"]([MAX_LENGTH_VALIDATOR]), core_js_["ɵɵNgOnChangesFeature"]]
  });
  return MaxLengthValidator;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Provider which adds `PatternValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const PATTERN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => PatternValidator),
  multi: true
};
/**
 * @description
 * A directive that adds regex pattern validation to controls marked with the
 * `pattern` attribute. The regex must match the entire control value.
 * The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a pattern validator
 *
 * The following example shows how to add a pattern validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input name="firstName" ngModel pattern="[a-zA-Z ]*">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let PatternValidator = /*#__PURE__*/(() => {
  class PatternValidator {
    constructor() {
      this._validator = nullValidator;
    }
    /** @nodoc */
    ngOnChanges(changes) {
      if ('pattern' in changes) {
        this._createValidator();
        if (this._onChange) this._onChange();
      }
    }
    /**
     * Method that validates whether the value matches the pattern requirement.
     * @nodoc
     */
    validate(control) {
      return this._validator(control);
    }
    /**
     * Registers a callback function to call when the validator inputs change.
     * @nodoc
     */
    registerOnValidatorChange(fn) {
      this._onChange = fn;
    }
    _createValidator() {
      this._validator = patternValidator(this.pattern);
    }
  }
  PatternValidator.ɵfac = function PatternValidator_Factory(t) {
    return new (t || PatternValidator)();
  };
  PatternValidator.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: PatternValidator,
    selectors: [["", "pattern", "", "formControlName", ""], ["", "pattern", "", "formControl", ""], ["", "pattern", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function PatternValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("pattern", ctx.pattern ? ctx.pattern : null);
      }
    },
    inputs: {
      pattern: "pattern"
    },
    features: [core_js_["ɵɵProvidersFeature"]([PATTERN_VALIDATOR]), core_js_["ɵɵNgOnChangesFeature"]]
  });
  return PatternValidator;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const SHARED_FORM_DIRECTIVES = [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator];
const TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
const REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
/**
 * Internal module used for sharing directives between FormsModule and ReactiveFormsModule
 */
let ɵInternalFormsSharedModule = /*#__PURE__*/(() => {
  class ɵInternalFormsSharedModule {}
  ɵInternalFormsSharedModule.ɵfac = function ɵInternalFormsSharedModule_Factory(t) {
    return new (t || ɵInternalFormsSharedModule)();
  };
  ɵInternalFormsSharedModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: ɵInternalFormsSharedModule
  });
  ɵInternalFormsSharedModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[RadioControlRegistryModule]]
  });
  return ɵInternalFormsSharedModule;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/*#__PURE__*/(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](ɵInternalFormsSharedModule, {
    declarations: [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator],
    imports: [RadioControlRegistryModule],
    exports: [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator]
  });
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Exports the required providers and directives for template-driven forms,
 * making them available for import by NgModules that import this module.
 *
 * Providers associated with this module:
 * * `RadioControlRegistry`
 *
 * @see [Forms Overview](/guide/forms-overview)
 * @see [Template-driven Forms Guide](/guide/forms)
 *
 * @publicApi
 */
let FormsModule = /*#__PURE__*/(() => {
  class FormsModule {}
  FormsModule.ɵfac = function FormsModule_Factory(t) {
    return new (t || FormsModule)();
  };
  FormsModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: FormsModule
  });
  FormsModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [ɵInternalFormsSharedModule]
  });
  return FormsModule;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/*#__PURE__*/(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](FormsModule, {
    declarations: [NgModel, NgModelGroup, NgForm],
    exports: [ɵInternalFormsSharedModule, NgModel, NgModelGroup, NgForm]
  });
})();
/**
 * Exports the required infrastructure and directives for reactive forms,
 * making them available for import by NgModules that import this module.
 *
 * Providers associated with this module:
 * * `FormBuilder`
 * * `RadioControlRegistry`
 *
 * @see [Forms Overview](guide/forms-overview)
 * @see [Reactive Forms Guide](guide/reactive-forms)
 *
 * @publicApi
 */
let ReactiveFormsModule = /*#__PURE__*/(() => {
  class ReactiveFormsModule {
    /**
     * @description
     * Provides options for configuring the reactive forms module.
     *
     * @param opts An object of configuration options
     * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`
     * binding is used with reactive form directives.
     */
    static withConfig(opts) {
      return {
        ngModule: ReactiveFormsModule,
        providers: [{
          provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,
          useValue: opts.warnOnNgModelWithFormControl
        }]
      };
    }
  }
  ReactiveFormsModule.ɵfac = function ReactiveFormsModule_Factory(t) {
    return new (t || ReactiveFormsModule)();
  };
  ReactiveFormsModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: ReactiveFormsModule
  });
  ReactiveFormsModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [ɵInternalFormsSharedModule]
  });
  return ReactiveFormsModule;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/*#__PURE__*/(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](ReactiveFormsModule, {
    declarations: [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName],
    exports: [ɵInternalFormsSharedModule, FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName]
  });
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function isAbstractControlOptions(options) {
  return options.asyncValidators !== undefined || options.validators !== undefined || options.updateOn !== undefined;
}
/**
 * @description
 * Creates an `AbstractControl` from a user-specified configuration.
 *
 * The `FormBuilder` provides syntactic sugar that shortens creating instances of a `FormControl`,
 * `FormGroup`, or `FormArray`. It reduces the amount of boilerplate needed to build complex
 * forms.
 *
 * @see [Reactive Forms Guide](/guide/reactive-forms)
 *
 * @publicApi
 */
let FormBuilder = /*#__PURE__*/(() => {
  class FormBuilder {
    group(controlsConfig, options = null) {
      const controls = this._reduceControls(controlsConfig);
      let validators = null;
      let asyncValidators = null;
      let updateOn = undefined;
      if (options != null) {
        if (isAbstractControlOptions(options)) {
          // `options` are `AbstractControlOptions`
          validators = options.validators != null ? options.validators : null;
          asyncValidators = options.asyncValidators != null ? options.asyncValidators : null;
          updateOn = options.updateOn != null ? options.updateOn : undefined;
        } else {
          // `options` are legacy form group options
          validators = options['validator'] != null ? options['validator'] : null;
          asyncValidators = options['asyncValidator'] != null ? options['asyncValidator'] : null;
        }
      }
      return new FormGroup(controls, {
        asyncValidators,
        updateOn,
        validators
      });
    }
    /**
     * @description
     * Construct a new `FormControl` with the given state, validators and options.
     *
     * @param formState Initializes the control with an initial state value, or
     * with an object that contains both a value and a disabled status.
     *
     * @param validatorOrOpts A synchronous validator function, or an array of
     * such functions, or an `AbstractControlOptions` object that contains
     * validation functions and a validation trigger.
     *
     * @param asyncValidator A single async validator or array of async validator
     * functions.
     *
     * @usageNotes
     *
     * ### Initialize a control as disabled
     *
     * The following example returns a control with an initial value in a disabled state.
     *
     * <code-example path="forms/ts/formBuilder/form_builder_example.ts" region="disabled-control">
     * </code-example>
     */
    control(formState, validatorOrOpts, asyncValidator) {
      return new FormControl(formState, validatorOrOpts, asyncValidator);
    }
    /**
     * Constructs a new `FormArray` from the given array of configurations,
     * validators and options.
     *
     * @param controlsConfig An array of child controls or control configs. Each
     * child control is given an index when it is registered.
     *
     * @param validatorOrOpts A synchronous validator function, or an array of
     * such functions, or an `AbstractControlOptions` object that contains
     * validation functions and a validation trigger.
     *
     * @param asyncValidator A single async validator or array of async validator
     * functions.
     */
    array(controlsConfig, validatorOrOpts, asyncValidator) {
      const controls = controlsConfig.map(c => this._createControl(c));
      return new FormArray(controls, validatorOrOpts, asyncValidator);
    }
    /** @internal */
    _reduceControls(controlsConfig) {
      const controls = {};
      Object.keys(controlsConfig).forEach(controlName => {
        controls[controlName] = this._createControl(controlsConfig[controlName]);
      });
      return controls;
    }
    /** @internal */
    _createControl(controlConfig) {
      if (controlConfig instanceof FormControl || controlConfig instanceof FormGroup || controlConfig instanceof FormArray) {
        return controlConfig;
      } else if (Array.isArray(controlConfig)) {
        const value = controlConfig[0];
        const validator = controlConfig.length > 1 ? controlConfig[1] : null;
        const asyncValidator = controlConfig.length > 2 ? controlConfig[2] : null;
        return this.control(value, validator, asyncValidator);
      } else {
        return this.control(controlConfig);
      }
    }
  }
  FormBuilder.ɵfac = function FormBuilder_Factory(t) {
    return new (t || FormBuilder)();
  };
  FormBuilder.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function FormBuilder_Factory() {
      return new FormBuilder();
    },
    token: FormBuilder,
    providedIn: ReactiveFormsModule
  });
  return FormBuilder;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @publicApi
 */
const VERSION = /*#__PURE__*/new core_js_.Version('12.2.17');

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// This file only reexports content of the `src` folder. Keep it that way.

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=forms.js.map

/***/ }),

/***/ 1211:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BrowserModule: () => (/* binding */ BrowserModule),
/* harmony export */   BrowserTransferStateModule: () => (/* binding */ BrowserTransferStateModule),
/* harmony export */   By: () => (/* binding */ By),
/* harmony export */   DomSanitizer: () => (/* binding */ DomSanitizer),
/* harmony export */   EVENT_MANAGER_PLUGINS: () => (/* binding */ EVENT_MANAGER_PLUGINS),
/* harmony export */   EventManager: () => (/* binding */ EventManager),
/* harmony export */   HAMMER_GESTURE_CONFIG: () => (/* binding */ HAMMER_GESTURE_CONFIG),
/* harmony export */   HAMMER_LOADER: () => (/* binding */ HAMMER_LOADER),
/* harmony export */   HammerGestureConfig: () => (/* binding */ HammerGestureConfig),
/* harmony export */   HammerModule: () => (/* binding */ HammerModule),
/* harmony export */   Meta: () => (/* binding */ Meta),
/* harmony export */   Title: () => (/* binding */ Title),
/* harmony export */   TransferState: () => (/* binding */ TransferState),
/* harmony export */   VERSION: () => (/* binding */ VERSION),
/* harmony export */   disableDebugTools: () => (/* binding */ disableDebugTools),
/* harmony export */   enableDebugTools: () => (/* binding */ enableDebugTools),
/* harmony export */   makeStateKey: () => (/* binding */ makeStateKey),
/* harmony export */   platformBrowser: () => (/* binding */ platformBrowser),
/* harmony export */   "ɵBROWSER_SANITIZATION_PROVIDERS": () => (/* binding */ BROWSER_SANITIZATION_PROVIDERS),
/* harmony export */   "ɵBROWSER_SANITIZATION_PROVIDERS__POST_R3__": () => (/* binding */ BROWSER_SANITIZATION_PROVIDERS__POST_R3__),
/* harmony export */   "ɵBrowserDomAdapter": () => (/* binding */ BrowserDomAdapter),
/* harmony export */   "ɵBrowserGetTestability": () => (/* binding */ BrowserGetTestability),
/* harmony export */   "ɵDomEventsPlugin": () => (/* binding */ DomEventsPlugin),
/* harmony export */   "ɵDomRendererFactory2": () => (/* binding */ DomRendererFactory2),
/* harmony export */   "ɵDomSanitizerImpl": () => (/* binding */ DomSanitizerImpl),
/* harmony export */   "ɵDomSharedStylesHost": () => (/* binding */ DomSharedStylesHost),
/* harmony export */   "ɵELEMENT_PROBE_PROVIDERS": () => (/* binding */ ELEMENT_PROBE_PROVIDERS),
/* harmony export */   "ɵELEMENT_PROBE_PROVIDERS__POST_R3__": () => (/* binding */ ELEMENT_PROBE_PROVIDERS__POST_R3__),
/* harmony export */   "ɵHAMMER_PROVIDERS__POST_R3__": () => (/* binding */ HAMMER_PROVIDERS__POST_R3__),
/* harmony export */   "ɵHammerGesturesPlugin": () => (/* binding */ HammerGesturesPlugin),
/* harmony export */   "ɵINTERNAL_BROWSER_PLATFORM_PROVIDERS": () => (/* binding */ INTERNAL_BROWSER_PLATFORM_PROVIDERS),
/* harmony export */   "ɵKeyEventsPlugin": () => (/* binding */ KeyEventsPlugin),
/* harmony export */   "ɵNAMESPACE_URIS": () => (/* binding */ NAMESPACE_URIS),
/* harmony export */   "ɵSharedStylesHost": () => (/* binding */ SharedStylesHost),
/* harmony export */   "ɵTRANSITION_ID": () => (/* binding */ TRANSITION_ID),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_a": () => (/* binding */ errorHandler),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_b": () => (/* binding */ _document),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_c": () => (/* binding */ BROWSER_MODULE_PROVIDERS),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_d": () => (/* binding */ createMeta),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_e": () => (/* binding */ createTitle),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_f": () => (/* binding */ initTransferState),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_g": () => (/* binding */ EventManagerPlugin),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_h": () => (/* binding */ HAMMER_PROVIDERS__PRE_R3__),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_i": () => (/* binding */ HAMMER_PROVIDERS),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_j": () => (/* binding */ domSanitizerImplFactory),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_k": () => (/* binding */ appInitializerFactory),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_l": () => (/* binding */ SERVER_TRANSITION_PROVIDERS),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_m": () => (/* binding */ _createNgProbeR2),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_n": () => (/* binding */ ELEMENT_PROBE_PROVIDERS__PRE_R3__),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_o": () => (/* binding */ BrowserXhr),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_p": () => (/* binding */ GenericBrowserDomAdapter),
/* harmony export */   "ɵescapeHtml": () => (/* binding */ escapeHtml),
/* harmony export */   "ɵflattenStyles": () => (/* binding */ flattenStyles),
/* harmony export */   "ɵgetDOM": () => (/* reexport safe */ _angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵgetDOM"]),
/* harmony export */   "ɵinitDomAdapter": () => (/* binding */ initDomAdapter),
/* harmony export */   "ɵshimContentAttribute": () => (/* binding */ shimContentAttribute),
/* harmony export */   "ɵshimHostAttribute": () => (/* binding */ shimHostAttribute)
/* harmony export */ });
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3008);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_1__);
/**
 * @license Angular v12.2.17
 * (c) 2010-2021 Google LLC. https://angular.io/
 * License: MIT
 */






/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Provides DOM operations in any browser environment.
 *
 * @security Tread carefully! Interacting with the DOM directly is dangerous and
 * can introduce XSS risks.
 */
class GenericBrowserDomAdapter extends _angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵDomAdapter"] {
  constructor() {
    super(...arguments);
    this.supportsDOMEvents = true;
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A `DomAdapter` powered by full browser DOM APIs.
 *
 * @security Tread carefully! Interacting with the DOM directly is dangerous and
 * can introduce XSS risks.
 */
/* tslint:disable:requireParameterType no-console */
class BrowserDomAdapter extends GenericBrowserDomAdapter {
  static makeCurrent() {
    (0,_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵsetRootDomAdapter"])(new BrowserDomAdapter());
  }
  onAndCancel(el, evt, listener) {
    el.addEventListener(evt, listener, false);
    // Needed to follow Dart's subscription semantic, until fix of
    // https://code.google.com/p/dart/issues/detail?id=17406
    return () => {
      el.removeEventListener(evt, listener, false);
    };
  }
  dispatchEvent(el, evt) {
    el.dispatchEvent(evt);
  }
  remove(node) {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
  createElement(tagName, doc) {
    doc = doc || this.getDefaultDocument();
    return doc.createElement(tagName);
  }
  createHtmlDocument() {
    return document.implementation.createHTMLDocument('fakeTitle');
  }
  getDefaultDocument() {
    return document;
  }
  isElementNode(node) {
    return node.nodeType === Node.ELEMENT_NODE;
  }
  isShadowRoot(node) {
    return node instanceof DocumentFragment;
  }
  /** @deprecated No longer being used in Ivy code. To be removed in version 14. */
  getGlobalEventTarget(doc, target) {
    if (target === 'window') {
      return window;
    }
    if (target === 'document') {
      return doc;
    }
    if (target === 'body') {
      return doc.body;
    }
    return null;
  }
  getBaseHref(doc) {
    const href = getBaseElementHref();
    return href == null ? null : relativePath(href);
  }
  resetBaseElement() {
    baseElement = null;
  }
  getUserAgent() {
    return window.navigator.userAgent;
  }
  getCookie(name) {
    return (0,_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵparseCookieValue"])(document.cookie, name);
  }
}
let baseElement = null;
function getBaseElementHref() {
  baseElement = baseElement || document.querySelector('base');
  return baseElement ? baseElement.getAttribute('href') : null;
}
// based on urlUtils.js in AngularJS 1
let urlParsingNode;
function relativePath(url) {
  urlParsingNode = urlParsingNode || document.createElement('a');
  urlParsingNode.setAttribute('href', url);
  const pathName = urlParsingNode.pathname;
  return pathName.charAt(0) === '/' ? pathName : `/${pathName}`;
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * An id that identifies a particular application being bootstrapped, that should
 * match across the client/server boundary.
 */
const TRANSITION_ID = /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('TRANSITION_ID');
function appInitializerFactory(transitionId, document, injector) {
  return () => {
    // Wait for all application initializers to be completed before removing the styles set by
    // the server.
    injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_1__.ApplicationInitStatus).donePromise.then(() => {
      const dom = (0,_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵgetDOM"])();
      const styles = document.querySelectorAll(`style[ng-transition="${transitionId}"]`);
      for (let i = 0; i < styles.length; i++) {
        dom.remove(styles[i]);
      }
    });
  };
}
const SERVER_TRANSITION_PROVIDERS = [{
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_INITIALIZER,
  useFactory: appInitializerFactory,
  deps: [TRANSITION_ID, _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT, _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injector],
  multi: true
}];

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class BrowserGetTestability {
  static init() {
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.setTestabilityGetter)(new BrowserGetTestability());
  }
  addToWindow(registry) {
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵglobal"]['getAngularTestability'] = (elem, findInAncestors = true) => {
      const testability = registry.findTestabilityInTree(elem, findInAncestors);
      if (testability == null) {
        throw new Error('Could not find testability for element.');
      }
      return testability;
    };
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵglobal"]['getAllAngularTestabilities'] = () => registry.getAllTestabilities();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵglobal"]['getAllAngularRootElements'] = () => registry.getAllRootElements();
    const whenAllStable = (callback /** TODO #9100 */) => {
      const testabilities = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵglobal"]['getAllAngularTestabilities']();
      let count = testabilities.length;
      let didWork = false;
      const decrement = function (didWork_ /** TODO #9100 */) {
        didWork = didWork || didWork_;
        count--;
        if (count == 0) {
          callback(didWork);
        }
      };
      testabilities.forEach(function (testability /** TODO #9100 */) {
        testability.whenStable(decrement);
      });
    };
    if (!_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵglobal"]['frameworkStabilizers']) {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵglobal"]['frameworkStabilizers'] = [];
    }
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵglobal"]['frameworkStabilizers'].push(whenAllStable);
  }
  findTestabilityInTree(registry, elem, findInAncestors) {
    if (elem == null) {
      return null;
    }
    const t = registry.getTestability(elem);
    if (t != null) {
      return t;
    } else if (!findInAncestors) {
      return null;
    }
    if ((0,_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵgetDOM"])().isShadowRoot(elem)) {
      return this.findTestabilityInTree(registry, elem.host, true);
    }
    return this.findTestabilityInTree(registry, elem.parentElement, true);
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A factory for `HttpXhrBackend` that uses the `XMLHttpRequest` browser API.
 */
let BrowserXhr = /*#__PURE__*/(() => {
  class BrowserXhr {
    build() {
      return new XMLHttpRequest();
    }
  }
  BrowserXhr.ɵfac = function BrowserXhr_Factory(t) {
    return new (t || BrowserXhr)();
  };
  BrowserXhr.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: BrowserXhr,
    factory: BrowserXhr.ɵfac
  });
  return BrowserXhr;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const CAMEL_CASE_REGEXP = /([A-Z])/g;
const DASH_CASE_REGEXP = /-([a-z])/g;
function camelCaseToDashCase(input) {
  return input.replace(CAMEL_CASE_REGEXP, (...m) => '-' + m[1].toLowerCase());
}
function dashCaseToCamelCase(input) {
  return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());
}
/**
 * Exports the value under a given `name` in the global property `ng`. For example `ng.probe` if
 * `name` is `'probe'`.
 * @param name Name under which it will be exported. Keep in mind this will be a property of the
 * global `ng` object.
 * @param value The value to export.
 */
function exportNgVar(name, value) {
  if (typeof COMPILED === 'undefined' || !COMPILED) {
    // Note: we can't export `ng` when using closure enhanced optimization as:
    // - closure declares globals itself for minified names, which sometimes clobber our `ng` global
    // - we can't declare a closure extern as the namespace `ng` is already used within Google
    //   for typings for angularJS (via `goog.provide('ng....')`).
    const ng = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵglobal"]['ng'] = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵglobal"]['ng'] || {};
    ng[name] = value;
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const ɵ0 = () => ({
  'ApplicationRef': _angular_core__WEBPACK_IMPORTED_MODULE_1__.ApplicationRef,
  'NgZone': _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone
});
const CORE_TOKENS = /*#__PURE__*/ɵ0();
const INSPECT_GLOBAL_NAME = 'probe';
const CORE_TOKENS_GLOBAL_NAME = 'coreTokens';
/**
 * Returns a {@link DebugElement} for the given native DOM element, or
 * null if the given native element does not have an Angular view associated
 * with it.
 */
function inspectNativeElementR2(element) {
  return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵgetDebugNodeR2"])(element);
}
function _createNgProbeR2(coreTokens) {
  exportNgVar(INSPECT_GLOBAL_NAME, inspectNativeElementR2);
  exportNgVar(CORE_TOKENS_GLOBAL_NAME, Object.assign(Object.assign({}, CORE_TOKENS), _ngProbeTokensToMap(coreTokens || [])));
  return () => inspectNativeElementR2;
}
function _ngProbeTokensToMap(tokens) {
  return tokens.reduce((prev, t) => (prev[t.name] = t.token, prev), {});
}
/**
 * In Ivy, we don't support NgProbe because we have our own set of testing utilities
 * with more robust functionality.
 *
 * We shouldn't bring in NgProbe because it prevents DebugNode and friends from
 * tree-shaking properly.
 */
const ELEMENT_PROBE_PROVIDERS__POST_R3__ = [];
/**
 * Providers which support debugging Angular applications (e.g. via `ng.probe`).
 */
const ELEMENT_PROBE_PROVIDERS__PRE_R3__ = [{
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_INITIALIZER,
  useFactory: _createNgProbeR2,
  deps: [[_angular_core__WEBPACK_IMPORTED_MODULE_1__.NgProbeToken, /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional()]],
  multi: true
}];
const ELEMENT_PROBE_PROVIDERS = ELEMENT_PROBE_PROVIDERS__POST_R3__;

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * The injection token for the event-manager plug-in service.
 *
 * @publicApi
 */
const EVENT_MANAGER_PLUGINS = /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('EventManagerPlugins');
/**
 * An injectable service that provides event management for Angular
 * through a browser plug-in.
 *
 * @publicApi
 */
let EventManager = /*#__PURE__*/(() => {
  class EventManager {
    /**
     * Initializes an instance of the event-manager service.
     */
    constructor(plugins, _zone) {
      this._zone = _zone;
      this._eventNameToPlugin = new Map();
      plugins.forEach(p => p.manager = this);
      this._plugins = plugins.slice().reverse();
    }
    /**
     * Registers a handler for a specific element and event.
     *
     * @param element The HTML element to receive event notifications.
     * @param eventName The name of the event to listen for.
     * @param handler A function to call when the notification occurs. Receives the
     * event object as an argument.
     * @returns  A callback function that can be used to remove the handler.
     */
    addEventListener(element, eventName, handler) {
      const plugin = this._findPluginFor(eventName);
      return plugin.addEventListener(element, eventName, handler);
    }
    /**
     * Registers a global handler for an event in a target view.
     *
     * @param target A target for global event notifications. One of "window", "document", or "body".
     * @param eventName The name of the event to listen for.
     * @param handler A function to call when the notification occurs. Receives the
     * event object as an argument.
     * @returns A callback function that can be used to remove the handler.
     * @deprecated No longer being used in Ivy code. To be removed in version 14.
     */
    addGlobalEventListener(target, eventName, handler) {
      const plugin = this._findPluginFor(eventName);
      return plugin.addGlobalEventListener(target, eventName, handler);
    }
    /**
     * Retrieves the compilation zone in which event listeners are registered.
     */
    getZone() {
      return this._zone;
    }
    /** @internal */
    _findPluginFor(eventName) {
      const plugin = this._eventNameToPlugin.get(eventName);
      if (plugin) {
        return plugin;
      }
      const plugins = this._plugins;
      for (let i = 0; i < plugins.length; i++) {
        const plugin = plugins[i];
        if (plugin.supports(eventName)) {
          this._eventNameToPlugin.set(eventName, plugin);
          return plugin;
        }
      }
      throw new Error(`No event manager plugin found for event ${eventName}`);
    }
  }
  EventManager.ɵfac = function EventManager_Factory(t) {
    return new (t || EventManager)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](EVENT_MANAGER_PLUGINS), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone));
  };
  EventManager.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: EventManager,
    factory: EventManager.ɵfac
  });
  return EventManager;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
class EventManagerPlugin {
  constructor(_doc) {
    this._doc = _doc;
  }
  addGlobalEventListener(element, eventName, handler) {
    const target = (0,_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵgetDOM"])().getGlobalEventTarget(this._doc, element);
    if (!target) {
      throw new Error(`Unsupported event target ${target} for event ${eventName}`);
    }
    return this.addEventListener(target, eventName, handler);
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
let SharedStylesHost = /*#__PURE__*/(() => {
  class SharedStylesHost {
    constructor() {
      /** @internal */
      this._stylesSet = new Set();
    }
    addStyles(styles) {
      const additions = new Set();
      styles.forEach(style => {
        if (!this._stylesSet.has(style)) {
          this._stylesSet.add(style);
          additions.add(style);
        }
      });
      this.onStylesAdded(additions);
    }
    onStylesAdded(additions) {}
    getAllStyles() {
      return Array.from(this._stylesSet);
    }
  }
  SharedStylesHost.ɵfac = function SharedStylesHost_Factory(t) {
    return new (t || SharedStylesHost)();
  };
  SharedStylesHost.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: SharedStylesHost,
    factory: SharedStylesHost.ɵfac
  });
  return SharedStylesHost;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
let DomSharedStylesHost = /*#__PURE__*/(() => {
  class DomSharedStylesHost extends SharedStylesHost {
    constructor(_doc) {
      super();
      this._doc = _doc;
      // Maps all registered host nodes to a list of style nodes that have been added to the host node.
      this._hostNodes = new Map();
      this._hostNodes.set(_doc.head, []);
    }
    _addStylesToHost(styles, host, styleNodes) {
      styles.forEach(style => {
        const styleEl = this._doc.createElement('style');
        styleEl.textContent = style;
        styleNodes.push(host.appendChild(styleEl));
      });
    }
    addHost(hostNode) {
      const styleNodes = [];
      this._addStylesToHost(this._stylesSet, hostNode, styleNodes);
      this._hostNodes.set(hostNode, styleNodes);
    }
    removeHost(hostNode) {
      const styleNodes = this._hostNodes.get(hostNode);
      if (styleNodes) {
        styleNodes.forEach(removeStyle);
      }
      this._hostNodes.delete(hostNode);
    }
    onStylesAdded(additions) {
      this._hostNodes.forEach((styleNodes, hostNode) => {
        this._addStylesToHost(additions, hostNode, styleNodes);
      });
    }
    ngOnDestroy() {
      this._hostNodes.forEach(styleNodes => styleNodes.forEach(removeStyle));
    }
  }
  DomSharedStylesHost.ɵfac = function DomSharedStylesHost_Factory(t) {
    return new (t || DomSharedStylesHost)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));
  };
  DomSharedStylesHost.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: DomSharedStylesHost,
    factory: DomSharedStylesHost.ɵfac
  });
  return DomSharedStylesHost;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
function removeStyle(styleNode) {
  (0,_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵgetDOM"])().remove(styleNode);
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const NAMESPACE_URIS = {
  'svg': 'http://www.w3.org/2000/svg',
  'xhtml': 'http://www.w3.org/1999/xhtml',
  'xlink': 'http://www.w3.org/1999/xlink',
  'xml': 'http://www.w3.org/XML/1998/namespace',
  'xmlns': 'http://www.w3.org/2000/xmlns/'
};
const COMPONENT_REGEX = /%COMP%/g;
const NG_DEV_MODE = typeof ngDevMode === 'undefined' || !!ngDevMode;
const COMPONENT_VARIABLE = '%COMP%';
const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
function shimContentAttribute(componentShortId) {
  return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function shimHostAttribute(componentShortId) {
  return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function flattenStyles(compId, styles, target) {
  for (let i = 0; i < styles.length; i++) {
    let style = styles[i];
    if (Array.isArray(style)) {
      flattenStyles(compId, style, target);
    } else {
      style = style.replace(COMPONENT_REGEX, compId);
      target.push(style);
    }
  }
  return target;
}
function decoratePreventDefault(eventHandler) {
  // `DebugNode.triggerEventHandler` needs to know if the listener was created with
  // decoratePreventDefault or is a listener added outside the Angular context so it can handle the
  // two differently. In the first case, the special '__ngUnwrap__' token is passed to the unwrap
  // the listener (see below).
  return event => {
    // Ivy uses '__ngUnwrap__' as a special token that allows us to unwrap the function
    // so that it can be invoked programmatically by `DebugNode.triggerEventHandler`. The debug_node
    // can inspect the listener toString contents for the existence of this special token. Because
    // the token is a string literal, it is ensured to not be modified by compiled code.
    if (event === '__ngUnwrap__') {
      return eventHandler;
    }
    const allowDefaultBehavior = eventHandler(event);
    if (allowDefaultBehavior === false) {
      // TODO(tbosch): move preventDefault into event plugins...
      event.preventDefault();
      event.returnValue = false;
    }
    return undefined;
  };
}
let hasLoggedNativeEncapsulationWarning = false;
let DomRendererFactory2 = /*#__PURE__*/(() => {
  class DomRendererFactory2 {
    constructor(eventManager, sharedStylesHost, appId) {
      this.eventManager = eventManager;
      this.sharedStylesHost = sharedStylesHost;
      this.appId = appId;
      this.rendererByCompId = new Map();
      this.defaultRenderer = new DefaultDomRenderer2(eventManager);
    }
    createRenderer(element, type) {
      if (!element || !type) {
        return this.defaultRenderer;
      }
      switch (type.encapsulation) {
        case _angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewEncapsulation.Emulated:
          {
            let renderer = this.rendererByCompId.get(type.id);
            if (!renderer) {
              renderer = new EmulatedEncapsulationDomRenderer2(this.eventManager, this.sharedStylesHost, type, this.appId);
              this.rendererByCompId.set(type.id, renderer);
            }
            renderer.applyToHost(element);
            return renderer;
          }
        // @ts-ignore TODO: Remove as part of FW-2290. TS complains about us dealing with an enum
        // value that is not known (but previously was the value for ViewEncapsulation.Native)
        case 1:
        case _angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewEncapsulation.ShadowDom:
          // TODO(FW-2290): remove the `case 1:` fallback logic and the warning in v12.
          if ((typeof ngDevMode === 'undefined' || ngDevMode) &&
          // @ts-ignore TODO: Remove as part of FW-2290. TS complains about us dealing with an
          // enum value that is not known (but previously was the value for
          // ViewEncapsulation.Native)
          !hasLoggedNativeEncapsulationWarning && type.encapsulation === 1) {
            hasLoggedNativeEncapsulationWarning = true;
            console.warn('ViewEncapsulation.Native is no longer supported. Falling back to ViewEncapsulation.ShadowDom. The fallback will be removed in v12.');
          }
          return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);
        default:
          {
            if (!this.rendererByCompId.has(type.id)) {
              const styles = flattenStyles(type.id, type.styles, []);
              this.sharedStylesHost.addStyles(styles);
              this.rendererByCompId.set(type.id, this.defaultRenderer);
            }
            return this.defaultRenderer;
          }
      }
    }
    begin() {}
    end() {}
  }
  DomRendererFactory2.ɵfac = function DomRendererFactory2_Factory(t) {
    return new (t || DomRendererFactory2)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](EventManager), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](DomSharedStylesHost), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_ID));
  };
  DomRendererFactory2.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: DomRendererFactory2,
    factory: DomRendererFactory2.ɵfac
  });
  return DomRendererFactory2;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
class DefaultDomRenderer2 {
  constructor(eventManager) {
    this.eventManager = eventManager;
    this.data = Object.create(null);
  }
  destroy() {}
  createElement(name, namespace) {
    if (namespace) {
      // In cases where Ivy (not ViewEngine) is giving us the actual namespace, the look up by key
      // will result in undefined, so we just return the namespace here.
      return document.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);
    }
    return document.createElement(name);
  }
  createComment(value) {
    return document.createComment(value);
  }
  createText(value) {
    return document.createTextNode(value);
  }
  appendChild(parent, newChild) {
    parent.appendChild(newChild);
  }
  insertBefore(parent, newChild, refChild) {
    if (parent) {
      parent.insertBefore(newChild, refChild);
    }
  }
  removeChild(parent, oldChild) {
    if (parent) {
      parent.removeChild(oldChild);
    }
  }
  selectRootElement(selectorOrNode, preserveContent) {
    let el = typeof selectorOrNode === 'string' ? document.querySelector(selectorOrNode) : selectorOrNode;
    if (!el) {
      throw new Error(`The selector "${selectorOrNode}" did not match any elements`);
    }
    if (!preserveContent) {
      el.textContent = '';
    }
    return el;
  }
  parentNode(node) {
    return node.parentNode;
  }
  nextSibling(node) {
    return node.nextSibling;
  }
  setAttribute(el, name, value, namespace) {
    if (namespace) {
      name = namespace + ':' + name;
      // TODO(FW-811): Ivy may cause issues here because it's passing around
      // full URIs for namespaces, therefore this lookup will fail.
      const namespaceUri = NAMESPACE_URIS[namespace];
      if (namespaceUri) {
        el.setAttributeNS(namespaceUri, name, value);
      } else {
        el.setAttribute(name, value);
      }
    } else {
      el.setAttribute(name, value);
    }
  }
  removeAttribute(el, name, namespace) {
    if (namespace) {
      // TODO(FW-811): Ivy may cause issues here because it's passing around
      // full URIs for namespaces, therefore this lookup will fail.
      const namespaceUri = NAMESPACE_URIS[namespace];
      if (namespaceUri) {
        el.removeAttributeNS(namespaceUri, name);
      } else {
        // TODO(FW-811): Since ivy is passing around full URIs for namespaces
        // this could result in properties like `http://www.w3.org/2000/svg:cx="123"`,
        // which is wrong.
        el.removeAttribute(`${namespace}:${name}`);
      }
    } else {
      el.removeAttribute(name);
    }
  }
  addClass(el, name) {
    el.classList.add(name);
  }
  removeClass(el, name) {
    el.classList.remove(name);
  }
  setStyle(el, style, value, flags) {
    if (flags & (_angular_core__WEBPACK_IMPORTED_MODULE_1__.RendererStyleFlags2.DashCase | _angular_core__WEBPACK_IMPORTED_MODULE_1__.RendererStyleFlags2.Important)) {
      el.style.setProperty(style, value, flags & _angular_core__WEBPACK_IMPORTED_MODULE_1__.RendererStyleFlags2.Important ? 'important' : '');
    } else {
      el.style[style] = value;
    }
  }
  removeStyle(el, style, flags) {
    if (flags & _angular_core__WEBPACK_IMPORTED_MODULE_1__.RendererStyleFlags2.DashCase) {
      el.style.removeProperty(style);
    } else {
      // IE requires '' instead of null
      // see https://github.com/angular/angular/issues/7916
      el.style[style] = '';
    }
  }
  setProperty(el, name, value) {
    NG_DEV_MODE && checkNoSyntheticProp(name, 'property');
    el[name] = value;
  }
  setValue(node, value) {
    node.nodeValue = value;
  }
  listen(target, event, callback) {
    NG_DEV_MODE && checkNoSyntheticProp(event, 'listener');
    if (typeof target === 'string') {
      return this.eventManager.addGlobalEventListener(target, event, decoratePreventDefault(callback));
    }
    return this.eventManager.addEventListener(target, event, decoratePreventDefault(callback));
  }
}
const ɵ0$1 = () => '@'.charCodeAt(0);
const AT_CHARCODE = /*#__PURE__*/ɵ0$1();
function checkNoSyntheticProp(name, nameKind) {
  if (name.charCodeAt(0) === AT_CHARCODE) {
    throw new Error(`Unexpected synthetic ${nameKind} ${name} found. Please make sure that:
  - Either \`BrowserAnimationsModule\` or \`NoopAnimationsModule\` are imported in your application.
  - There is corresponding configuration for the animation named \`${name}\` defined in the \`animations\` field of the \`@Component\` decorator (see https://angular.io/api/core/Component#animations).`);
  }
}
class EmulatedEncapsulationDomRenderer2 extends DefaultDomRenderer2 {
  constructor(eventManager, sharedStylesHost, component, appId) {
    super(eventManager);
    this.component = component;
    const styles = flattenStyles(appId + '-' + component.id, component.styles, []);
    sharedStylesHost.addStyles(styles);
    this.contentAttr = shimContentAttribute(appId + '-' + component.id);
    this.hostAttr = shimHostAttribute(appId + '-' + component.id);
  }
  applyToHost(element) {
    super.setAttribute(element, this.hostAttr, '');
  }
  createElement(parent, name) {
    const el = super.createElement(parent, name);
    super.setAttribute(el, this.contentAttr, '');
    return el;
  }
}
class ShadowDomRenderer extends DefaultDomRenderer2 {
  constructor(eventManager, sharedStylesHost, hostEl, component) {
    super(eventManager);
    this.sharedStylesHost = sharedStylesHost;
    this.hostEl = hostEl;
    this.shadowRoot = hostEl.attachShadow({
      mode: 'open'
    });
    this.sharedStylesHost.addHost(this.shadowRoot);
    const styles = flattenStyles(component.id, component.styles, []);
    for (let i = 0; i < styles.length; i++) {
      const styleEl = document.createElement('style');
      styleEl.textContent = styles[i];
      this.shadowRoot.appendChild(styleEl);
    }
  }
  nodeOrShadowRoot(node) {
    return node === this.hostEl ? this.shadowRoot : node;
  }
  destroy() {
    this.sharedStylesHost.removeHost(this.shadowRoot);
  }
  appendChild(parent, newChild) {
    return super.appendChild(this.nodeOrShadowRoot(parent), newChild);
  }
  insertBefore(parent, newChild, refChild) {
    return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);
  }
  removeChild(parent, oldChild) {
    return super.removeChild(this.nodeOrShadowRoot(parent), oldChild);
  }
  parentNode(node) {
    return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
let DomEventsPlugin = /*#__PURE__*/(() => {
  class DomEventsPlugin extends EventManagerPlugin {
    constructor(doc) {
      super(doc);
    }
    // This plugin should come last in the list of plugins, because it accepts all
    // events.
    supports(eventName) {
      return true;
    }
    addEventListener(element, eventName, handler) {
      element.addEventListener(eventName, handler, false);
      return () => this.removeEventListener(element, eventName, handler);
    }
    removeEventListener(target, eventName, callback) {
      return target.removeEventListener(eventName, callback);
    }
  }
  DomEventsPlugin.ɵfac = function DomEventsPlugin_Factory(t) {
    return new (t || DomEventsPlugin)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));
  };
  DomEventsPlugin.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: DomEventsPlugin,
    factory: DomEventsPlugin.ɵfac
  });
  return DomEventsPlugin;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Supported HammerJS recognizer event names.
 */
const EVENT_NAMES = {
  // pan
  'pan': true,
  'panstart': true,
  'panmove': true,
  'panend': true,
  'pancancel': true,
  'panleft': true,
  'panright': true,
  'panup': true,
  'pandown': true,
  // pinch
  'pinch': true,
  'pinchstart': true,
  'pinchmove': true,
  'pinchend': true,
  'pinchcancel': true,
  'pinchin': true,
  'pinchout': true,
  // press
  'press': true,
  'pressup': true,
  // rotate
  'rotate': true,
  'rotatestart': true,
  'rotatemove': true,
  'rotateend': true,
  'rotatecancel': true,
  // swipe
  'swipe': true,
  'swipeleft': true,
  'swiperight': true,
  'swipeup': true,
  'swipedown': true,
  // tap
  'tap': true,
  'doubletap': true
};
/**
 * DI token for providing [HammerJS](https://hammerjs.github.io/) support to Angular.
 * @see `HammerGestureConfig`
 *
 * @ngModule HammerModule
 * @publicApi
 */
const HAMMER_GESTURE_CONFIG = /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('HammerGestureConfig');
/**
 * Injection token used to provide a {@link HammerLoader} to Angular.
 *
 * @publicApi
 */
const HAMMER_LOADER = /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('HammerLoader');
/**
 * An injectable [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)
 * for gesture recognition. Configures specific event recognition.
 * @publicApi
 */
let HammerGestureConfig = /*#__PURE__*/(() => {
  class HammerGestureConfig {
    constructor() {
      /**
       * A set of supported event names for gestures to be used in Angular.
       * Angular supports all built-in recognizers, as listed in
       * [HammerJS documentation](https://hammerjs.github.io/).
       */
      this.events = [];
      /**
       * Maps gesture event names to a set of configuration options
       * that specify overrides to the default values for specific properties.
       *
       * The key is a supported event name to be configured,
       * and the options object contains a set of properties, with override values
       * to be applied to the named recognizer event.
       * For example, to disable recognition of the rotate event, specify
       *  `{"rotate": {"enable": false}}`.
       *
       * Properties that are not present take the HammerJS default values.
       * For information about which properties are supported for which events,
       * and their allowed and default values, see
       * [HammerJS documentation](https://hammerjs.github.io/).
       *
       */
      this.overrides = {};
    }
    /**
     * Creates a [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)
     * and attaches it to a given HTML element.
     * @param element The element that will recognize gestures.
     * @returns A HammerJS event-manager object.
     */
    buildHammer(element) {
      const mc = new Hammer(element, this.options);
      mc.get('pinch').set({
        enable: true
      });
      mc.get('rotate').set({
        enable: true
      });
      for (const eventName in this.overrides) {
        mc.get(eventName).set(this.overrides[eventName]);
      }
      return mc;
    }
  }
  HammerGestureConfig.ɵfac = function HammerGestureConfig_Factory(t) {
    return new (t || HammerGestureConfig)();
  };
  HammerGestureConfig.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: HammerGestureConfig,
    factory: HammerGestureConfig.ɵfac
  });
  return HammerGestureConfig;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * Event plugin that adds Hammer support to an application.
 *
 * @ngModule HammerModule
 */
let HammerGesturesPlugin = /*#__PURE__*/(() => {
  class HammerGesturesPlugin extends EventManagerPlugin {
    constructor(doc, _config, console, loader) {
      super(doc);
      this._config = _config;
      this.console = console;
      this.loader = loader;
      this._loaderPromise = null;
    }
    supports(eventName) {
      if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
        return false;
      }
      if (!window.Hammer && !this.loader) {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
          this.console.warn(`The "${eventName}" event cannot be bound because Hammer.JS is not ` + `loaded and no custom loader has been specified.`);
        }
        return false;
      }
      return true;
    }
    addEventListener(element, eventName, handler) {
      const zone = this.manager.getZone();
      eventName = eventName.toLowerCase();
      // If Hammer is not present but a loader is specified, we defer adding the event listener
      // until Hammer is loaded.
      if (!window.Hammer && this.loader) {
        this._loaderPromise = this._loaderPromise || this.loader();
        // This `addEventListener` method returns a function to remove the added listener.
        // Until Hammer is loaded, the returned function needs to *cancel* the registration rather
        // than remove anything.
        let cancelRegistration = false;
        let deregister = () => {
          cancelRegistration = true;
        };
        this._loaderPromise.then(() => {
          // If Hammer isn't actually loaded when the custom loader resolves, give up.
          if (!window.Hammer) {
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
              this.console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);
            }
            deregister = () => {};
            return;
          }
          if (!cancelRegistration) {
            // Now that Hammer is loaded and the listener is being loaded for real,
            // the deregistration function changes from canceling registration to removal.
            deregister = this.addEventListener(element, eventName, handler);
          }
        }).catch(() => {
          if (typeof ngDevMode === 'undefined' || ngDevMode) {
            this.console.warn(`The "${eventName}" event cannot be bound because the custom ` + `Hammer.JS loader failed.`);
          }
          deregister = () => {};
        });
        // Return a function that *executes* `deregister` (and not `deregister` itself) so that we
        // can change the behavior of `deregister` once the listener is added. Using a closure in
        // this way allows us to avoid any additional data structures to track listener removal.
        return () => {
          deregister();
        };
      }
      return zone.runOutsideAngular(() => {
        // Creating the manager bind events, must be done outside of angular
        const mc = this._config.buildHammer(element);
        const callback = function (eventObj) {
          zone.runGuarded(function () {
            handler(eventObj);
          });
        };
        mc.on(eventName, callback);
        return () => {
          mc.off(eventName, callback);
          // destroy mc to prevent memory leak
          if (typeof mc.destroy === 'function') {
            mc.destroy();
          }
        };
      });
    }
    isCustomEvent(eventName) {
      return this._config.events.indexOf(eventName) > -1;
    }
  }
  HammerGesturesPlugin.ɵfac = function HammerGesturesPlugin_Factory(t) {
    return new (t || HammerGesturesPlugin)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](HAMMER_GESTURE_CONFIG), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵConsole"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](HAMMER_LOADER, 8));
  };
  HammerGesturesPlugin.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: HammerGesturesPlugin,
    factory: HammerGesturesPlugin.ɵfac
  });
  return HammerGesturesPlugin;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * In Ivy, support for Hammer gestures is optional, so applications must
 * import the `HammerModule` at root to turn on support. This means that
 * Hammer-specific code can be tree-shaken away if not needed.
 */
const HAMMER_PROVIDERS__POST_R3__ = [];
/**
 * In View Engine, support for Hammer gestures is built-in by default.
 */
const HAMMER_PROVIDERS__PRE_R3__ = [{
  provide: EVENT_MANAGER_PLUGINS,
  useClass: HammerGesturesPlugin,
  multi: true,
  deps: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT, HAMMER_GESTURE_CONFIG, _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵConsole"], [/*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional(), HAMMER_LOADER]]
}, {
  provide: HAMMER_GESTURE_CONFIG,
  useClass: HammerGestureConfig,
  deps: []
}];
const HAMMER_PROVIDERS = HAMMER_PROVIDERS__POST_R3__;
/**
 * Adds support for HammerJS.
 *
 * Import this module at the root of your application so that Angular can work with
 * HammerJS to detect gesture events.
 *
 * Note that applications still need to include the HammerJS script itself. This module
 * simply sets up the coordination layer between HammerJS and Angular's EventManager.
 *
 * @publicApi
 */
let HammerModule = /*#__PURE__*/(() => {
  class HammerModule {}
  HammerModule.ɵfac = function HammerModule_Factory(t) {
    return new (t || HammerModule)();
  };
  HammerModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
    type: HammerModule
  });
  HammerModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
    providers: HAMMER_PROVIDERS__PRE_R3__
  });
  return HammerModule;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Defines supported modifiers for key events.
 */
const MODIFIER_KEYS = ['alt', 'control', 'meta', 'shift'];
const DOM_KEY_LOCATION_NUMPAD = 3;
// Map to convert some key or keyIdentifier values to what will be returned by getEventKey
const _keyMap = {
  // The following values are here for cross-browser compatibility and to match the W3C standard
  // cf https://www.w3.org/TR/DOM-Level-3-Events-key/
  '\b': 'Backspace',
  '\t': 'Tab',
  '\x7F': 'Delete',
  '\x1B': 'Escape',
  'Del': 'Delete',
  'Esc': 'Escape',
  'Left': 'ArrowLeft',
  'Right': 'ArrowRight',
  'Up': 'ArrowUp',
  'Down': 'ArrowDown',
  'Menu': 'ContextMenu',
  'Scroll': 'ScrollLock',
  'Win': 'OS'
};
// There is a bug in Chrome for numeric keypad keys:
// https://code.google.com/p/chromium/issues/detail?id=155654
// 1, 2, 3 ... are reported as A, B, C ...
const _chromeNumKeyPadMap = {
  'A': '1',
  'B': '2',
  'C': '3',
  'D': '4',
  'E': '5',
  'F': '6',
  'G': '7',
  'H': '8',
  'I': '9',
  'J': '*',
  'K': '+',
  'M': '-',
  'N': '.',
  'O': '/',
  '\x60': '0',
  '\x90': 'NumLock'
};
const ɵ0$2 = event => event.altKey,
  ɵ1 = event => event.ctrlKey,
  ɵ2 = event => event.metaKey,
  ɵ3 = event => event.shiftKey;
/**
 * Retrieves modifiers from key-event objects.
 */
const MODIFIER_KEY_GETTERS = {
  'alt': ɵ0$2,
  'control': ɵ1,
  'meta': ɵ2,
  'shift': ɵ3
};
/**
 * @publicApi
 * A browser plug-in that provides support for handling of key events in Angular.
 */
let KeyEventsPlugin = /*#__PURE__*/(() => {
  class KeyEventsPlugin extends EventManagerPlugin {
    /**
     * Initializes an instance of the browser plug-in.
     * @param doc The document in which key events will be detected.
     */
    constructor(doc) {
      super(doc);
    }
    /**
     * Reports whether a named key event is supported.
     * @param eventName The event name to query.
     * @return True if the named key event is supported.
     */
    supports(eventName) {
      return KeyEventsPlugin.parseEventName(eventName) != null;
    }
    /**
     * Registers a handler for a specific element and key event.
     * @param element The HTML element to receive event notifications.
     * @param eventName The name of the key event to listen for.
     * @param handler A function to call when the notification occurs. Receives the
     * event object as an argument.
     * @returns The key event that was registered.
     */
    addEventListener(element, eventName, handler) {
      const parsedEvent = KeyEventsPlugin.parseEventName(eventName);
      const outsideHandler = KeyEventsPlugin.eventCallback(parsedEvent['fullKey'], handler, this.manager.getZone());
      return this.manager.getZone().runOutsideAngular(() => {
        return (0,_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵgetDOM"])().onAndCancel(element, parsedEvent['domEventName'], outsideHandler);
      });
    }
    static parseEventName(eventName) {
      const parts = eventName.toLowerCase().split('.');
      const domEventName = parts.shift();
      if (parts.length === 0 || !(domEventName === 'keydown' || domEventName === 'keyup')) {
        return null;
      }
      const key = KeyEventsPlugin._normalizeKey(parts.pop());
      let fullKey = '';
      MODIFIER_KEYS.forEach(modifierName => {
        const index = parts.indexOf(modifierName);
        if (index > -1) {
          parts.splice(index, 1);
          fullKey += modifierName + '.';
        }
      });
      fullKey += key;
      if (parts.length != 0 || key.length === 0) {
        // returning null instead of throwing to let another plugin process the event
        return null;
      }
      // NOTE: Please don't rewrite this as so, as it will break JSCompiler property renaming.
      //       The code must remain in the `result['domEventName']` form.
      // return {domEventName, fullKey};
      const result = {};
      result['domEventName'] = domEventName;
      result['fullKey'] = fullKey;
      return result;
    }
    static getEventFullKey(event) {
      let fullKey = '';
      let key = getEventKey(event);
      key = key.toLowerCase();
      if (key === ' ') {
        key = 'space'; // for readability
      } else if (key === '.') {
        key = 'dot'; // because '.' is used as a separator in event names
      }

      MODIFIER_KEYS.forEach(modifierName => {
        if (modifierName != key) {
          const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
          if (modifierGetter(event)) {
            fullKey += modifierName + '.';
          }
        }
      });
      fullKey += key;
      return fullKey;
    }
    /**
     * Configures a handler callback for a key event.
     * @param fullKey The event name that combines all simultaneous keystrokes.
     * @param handler The function that responds to the key event.
     * @param zone The zone in which the event occurred.
     * @returns A callback function.
     */
    static eventCallback(fullKey, handler, zone) {
      return (event /** TODO #9100 */) => {
        if (KeyEventsPlugin.getEventFullKey(event) === fullKey) {
          zone.runGuarded(() => handler(event));
        }
      };
    }
    /** @internal */
    static _normalizeKey(keyName) {
      // TODO: switch to a Map if the mapping grows too much
      switch (keyName) {
        case 'esc':
          return 'escape';
        default:
          return keyName;
      }
    }
  }
  KeyEventsPlugin.ɵfac = function KeyEventsPlugin_Factory(t) {
    return new (t || KeyEventsPlugin)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));
  };
  KeyEventsPlugin.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: KeyEventsPlugin,
    factory: KeyEventsPlugin.ɵfac
  });
  return KeyEventsPlugin;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
function getEventKey(event) {
  let key = event.key;
  if (key == null) {
    key = event.keyIdentifier;
    // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and
    // Safari cf
    // https://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces
    if (key == null) {
      return 'Unidentified';
    }
    if (key.startsWith('U+')) {
      key = String.fromCharCode(parseInt(key.substring(2), 16));
      if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
        // There is a bug in Chrome for numeric keypad keys:
        // https://code.google.com/p/chromium/issues/detail?id=155654
        // 1, 2, 3 ... are reported as A, B, C ...
        key = _chromeNumKeyPadMap[key];
      }
    }
  }
  return _keyMap[key] || key;
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing
 * values to be safe to use in the different DOM contexts.
 *
 * For example, when binding a URL in an `<a [href]="someValue">` hyperlink, `someValue` will be
 * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on
 * the website.
 *
 * In specific situations, it might be necessary to disable sanitization, for example if the
 * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.
 * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`
 * methods, and then binding to that value from the template.
 *
 * These situations should be very rare, and extraordinary care must be taken to avoid creating a
 * Cross Site Scripting (XSS) security bug!
 *
 * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as
 * close as possible to the source of the value, to make it easy to verify no security bug is
 * created by its use.
 *
 * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that
 * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous
 * code. The sanitizer leaves safe values intact.
 *
 * @security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in
 * sanitization for the value passed in. Carefully check and audit all values and code paths going
 * into this call. Make sure any user data is appropriately escaped for this security context.
 * For more detail, see the [Security Guide](https://g.co/ng/security).
 *
 * @publicApi
 */
let DomSanitizer = /*#__PURE__*/(() => {
  class DomSanitizer {}
  DomSanitizer.ɵfac = function DomSanitizer_Factory(t) {
    return new (t || DomSanitizer)();
  };
  DomSanitizer.ɵprov = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    factory: function DomSanitizer_Factory() {
      return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(DomSanitizerImpl);
    },
    token: DomSanitizer,
    providedIn: "root"
  });
  return DomSanitizer;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
function domSanitizerImplFactory(injector) {
  return new DomSanitizerImpl(injector.get(_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));
}
let DomSanitizerImpl = /*#__PURE__*/(() => {
  class DomSanitizerImpl extends DomSanitizer {
    constructor(_doc) {
      super();
      this._doc = _doc;
    }
    sanitize(ctx, value) {
      if (value == null) return null;
      switch (ctx) {
        case _angular_core__WEBPACK_IMPORTED_MODULE_1__.SecurityContext.NONE:
          return value;
        case _angular_core__WEBPACK_IMPORTED_MODULE_1__.SecurityContext.HTML:
          if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵallowSanitizationBypassAndThrow"])(value, "HTML" /* Html */)) {
            return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵunwrapSafeValue"])(value);
          }
          return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵ_sanitizeHtml"])(this._doc, String(value)).toString();
        case _angular_core__WEBPACK_IMPORTED_MODULE_1__.SecurityContext.STYLE:
          if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵallowSanitizationBypassAndThrow"])(value, "Style" /* Style */)) {
            return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵunwrapSafeValue"])(value);
          }
          return value;
        case _angular_core__WEBPACK_IMPORTED_MODULE_1__.SecurityContext.SCRIPT:
          if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵallowSanitizationBypassAndThrow"])(value, "Script" /* Script */)) {
            return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵunwrapSafeValue"])(value);
          }
          throw new Error('unsafe value used in a script context');
        case _angular_core__WEBPACK_IMPORTED_MODULE_1__.SecurityContext.URL:
          const type = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵgetSanitizationBypassType"])(value);
          if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵallowSanitizationBypassAndThrow"])(value, "URL" /* Url */)) {
            return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵunwrapSafeValue"])(value);
          }
          return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵ_sanitizeUrl"])(String(value));
        case _angular_core__WEBPACK_IMPORTED_MODULE_1__.SecurityContext.RESOURCE_URL:
          if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵallowSanitizationBypassAndThrow"])(value, "ResourceURL" /* ResourceUrl */)) {
            return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵunwrapSafeValue"])(value);
          }
          throw new Error('unsafe value used in a resource URL context (see https://g.co/ng/security#xss)');
        default:
          throw new Error(`Unexpected SecurityContext ${ctx} (see https://g.co/ng/security#xss)`);
      }
    }
    bypassSecurityTrustHtml(value) {
      return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵbypassSanitizationTrustHtml"])(value);
    }
    bypassSecurityTrustStyle(value) {
      return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵbypassSanitizationTrustStyle"])(value);
    }
    bypassSecurityTrustScript(value) {
      return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵbypassSanitizationTrustScript"])(value);
    }
    bypassSecurityTrustUrl(value) {
      return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵbypassSanitizationTrustUrl"])(value);
    }
    bypassSecurityTrustResourceUrl(value) {
      return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵbypassSanitizationTrustResourceUrl"])(value);
    }
  }
  DomSanitizerImpl.ɵfac = function DomSanitizerImpl_Factory(t) {
    return new (t || DomSanitizerImpl)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));
  };
  DomSanitizerImpl.ɵprov = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    factory: function DomSanitizerImpl_Factory() {
      return domSanitizerImplFactory((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__.INJECTOR));
    },
    token: DomSanitizerImpl,
    providedIn: "root"
  });
  return DomSanitizerImpl;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function initDomAdapter() {
  BrowserDomAdapter.makeCurrent();
  BrowserGetTestability.init();
}
function errorHandler() {
  return new _angular_core__WEBPACK_IMPORTED_MODULE_1__.ErrorHandler();
}
function _document() {
  // Tell ivy about the global document
  (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetDocument"])(document);
  return document;
}
const ɵ0$3 = _angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵPLATFORM_BROWSER_ID"];
const INTERNAL_BROWSER_PLATFORM_PROVIDERS = [{
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_ID,
  useValue: ɵ0$3
}, {
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_INITIALIZER,
  useValue: initDomAdapter,
  multi: true
}, {
  provide: _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT,
  useFactory: _document,
  deps: []
}];
const BROWSER_SANITIZATION_PROVIDERS__PRE_R3__ = [{
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Sanitizer,
  useExisting: DomSanitizer
}, {
  provide: DomSanitizer,
  useClass: DomSanitizerImpl,
  deps: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]
}];
const BROWSER_SANITIZATION_PROVIDERS__POST_R3__ = [];
/**
 * @security Replacing built-in sanitization providers exposes the application to XSS risks.
 * Attacker-controlled data introduced by an unsanitized provider could expose your
 * application to XSS risks. For more detail, see the [Security Guide](https://g.co/ng/security).
 * @publicApi
 */
const BROWSER_SANITIZATION_PROVIDERS = BROWSER_SANITIZATION_PROVIDERS__POST_R3__;
/**
 * A factory function that returns a `PlatformRef` instance associated with browser service
 * providers.
 *
 * @publicApi
 */
const platformBrowser = /*#__PURE__*/(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.createPlatformFactory)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.platformCore, 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);
const BROWSER_MODULE_PROVIDERS = [BROWSER_SANITIZATION_PROVIDERS, {
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵINJECTOR_SCOPE"],
  useValue: 'root'
}, {
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ErrorHandler,
  useFactory: errorHandler,
  deps: []
}, {
  provide: EVENT_MANAGER_PLUGINS,
  useClass: DomEventsPlugin,
  multi: true,
  deps: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT, _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone, _angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_ID]
}, {
  provide: EVENT_MANAGER_PLUGINS,
  useClass: KeyEventsPlugin,
  multi: true,
  deps: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]
}, HAMMER_PROVIDERS, {
  provide: DomRendererFactory2,
  useClass: DomRendererFactory2,
  deps: [EventManager, DomSharedStylesHost, _angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_ID]
}, {
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.RendererFactory2,
  useExisting: DomRendererFactory2
}, {
  provide: SharedStylesHost,
  useExisting: DomSharedStylesHost
}, {
  provide: DomSharedStylesHost,
  useClass: DomSharedStylesHost,
  deps: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]
}, {
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Testability,
  useClass: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Testability,
  deps: [_angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone]
}, {
  provide: EventManager,
  useClass: EventManager,
  deps: [EVENT_MANAGER_PLUGINS, _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone]
}, {
  provide: _angular_common__WEBPACK_IMPORTED_MODULE_0__.XhrFactory,
  useClass: BrowserXhr,
  deps: []
}, ELEMENT_PROBE_PROVIDERS];
/**
 * Exports required infrastructure for all Angular apps.
 * Included by default in all Angular apps created with the CLI
 * `new` command.
 * Re-exports `CommonModule` and `ApplicationModule`, making their
 * exports and providers available to all apps.
 *
 * @publicApi
 */
let BrowserModule = /*#__PURE__*/(() => {
  class BrowserModule {
    constructor(parentModule) {
      if (parentModule) {
        throw new Error(`BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.`);
      }
    }
    /**
     * Configures a browser-based app to transition from a server-rendered app, if
     * one is present on the page.
     *
     * @param params An object containing an identifier for the app to transition.
     * The ID must match between the client and server versions of the app.
     * @returns The reconfigured `BrowserModule` to import into the app's root `AppModule`.
     */
    static withServerTransition(params) {
      return {
        ngModule: BrowserModule,
        providers: [{
          provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_ID,
          useValue: params.appId
        }, {
          provide: TRANSITION_ID,
          useExisting: _angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_ID
        }, SERVER_TRANSITION_PROVIDERS]
      };
    }
  }
  BrowserModule.ɵfac = function BrowserModule_Factory(t) {
    return new (t || BrowserModule)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](BrowserModule, 12));
  };
  BrowserModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
    type: BrowserModule
  });
  BrowserModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
    providers: BROWSER_MODULE_PROVIDERS,
    imports: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.CommonModule, _angular_core__WEBPACK_IMPORTED_MODULE_1__.ApplicationModule]
  });
  return BrowserModule;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/*#__PURE__*/(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵsetNgModuleScope"](BrowserModule, {
    exports: function () {
      return [_angular_common__WEBPACK_IMPORTED_MODULE_0__.CommonModule, _angular_core__WEBPACK_IMPORTED_MODULE_1__.ApplicationModule];
    }
  });
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Factory to create a `Meta` service instance for the current DOM document.
 */
function createMeta() {
  return new Meta((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));
}
/**
 * A service for managing HTML `<meta>` tags.
 *
 * Properties of the `MetaDefinition` object match the attributes of the
 * HTML `<meta>` tag. These tags define document metadata that is important for
 * things like configuring a Content Security Policy, defining browser compatibility
 * and security settings, setting HTTP Headers, defining rich content for social sharing,
 * and Search Engine Optimization (SEO).
 *
 * To identify specific `<meta>` tags in a document, use an attribute selection
 * string in the format `"tag_attribute='value string'"`.
 * For example, an `attrSelector` value of `"name='description'"` matches a tag
 * whose `name` attribute has the value `"description"`.
 * Selectors are used with the `querySelector()` Document method,
 * in the format `meta[{attrSelector}]`.
 *
 * @see [HTML meta tag](https://developer.mozilla.org/docs/Web/HTML/Element/meta)
 * @see [Document.querySelector()](https://developer.mozilla.org/docs/Web/API/Document/querySelector)
 *
 *
 * @publicApi
 */
let Meta = /*#__PURE__*/(() => {
  class Meta {
    constructor(_doc) {
      this._doc = _doc;
      this._dom = (0,_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵgetDOM"])();
    }
    /**
     * Retrieves or creates a specific `<meta>` tag element in the current HTML document.
     * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute
     * values in the provided tag definition, and verifies that all other attribute values are equal.
     * If an existing element is found, it is returned and is not modified in any way.
     * @param tag The definition of a `<meta>` element to match or create.
     * @param forceCreation True to create a new element without checking whether one already exists.
     * @returns The existing element with the same attributes and values if found,
     * the new element if no match is found, or `null` if the tag parameter is not defined.
     */
    addTag(tag, forceCreation = false) {
      if (!tag) return null;
      return this._getOrCreateElement(tag, forceCreation);
    }
    /**
     * Retrieves or creates a set of `<meta>` tag elements in the current HTML document.
     * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute
     * values in the provided tag definition, and verifies that all other attribute values are equal.
     * @param tags An array of tag definitions to match or create.
     * @param forceCreation True to create new elements without checking whether they already exist.
     * @returns The matching elements if found, or the new elements.
     */
    addTags(tags, forceCreation = false) {
      if (!tags) return [];
      return tags.reduce((result, tag) => {
        if (tag) {
          result.push(this._getOrCreateElement(tag, forceCreation));
        }
        return result;
      }, []);
    }
    /**
     * Retrieves a `<meta>` tag element in the current HTML document.
     * @param attrSelector The tag attribute and value to match against, in the format
     * `"tag_attribute='value string'"`.
     * @returns The matching element, if any.
     */
    getTag(attrSelector) {
      if (!attrSelector) return null;
      return this._doc.querySelector(`meta[${attrSelector}]`) || null;
    }
    /**
     * Retrieves a set of `<meta>` tag elements in the current HTML document.
     * @param attrSelector The tag attribute and value to match against, in the format
     * `"tag_attribute='value string'"`.
     * @returns The matching elements, if any.
     */
    getTags(attrSelector) {
      if (!attrSelector) return [];
      const list /*NodeList*/ = this._doc.querySelectorAll(`meta[${attrSelector}]`);
      return list ? [].slice.call(list) : [];
    }
    /**
     * Modifies an existing `<meta>` tag element in the current HTML document.
     * @param tag The tag description with which to replace the existing tag content.
     * @param selector A tag attribute and value to match against, to identify
     * an existing tag. A string in the format `"tag_attribute=`value string`"`.
     * If not supplied, matches a tag with the same `name` or `property` attribute value as the
     * replacement tag.
     * @return The modified element.
     */
    updateTag(tag, selector) {
      if (!tag) return null;
      selector = selector || this._parseSelector(tag);
      const meta = this.getTag(selector);
      if (meta) {
        return this._setMetaElementAttributes(tag, meta);
      }
      return this._getOrCreateElement(tag, true);
    }
    /**
     * Removes an existing `<meta>` tag element from the current HTML document.
     * @param attrSelector A tag attribute and value to match against, to identify
     * an existing tag. A string in the format `"tag_attribute=`value string`"`.
     */
    removeTag(attrSelector) {
      this.removeTagElement(this.getTag(attrSelector));
    }
    /**
     * Removes an existing `<meta>` tag element from the current HTML document.
     * @param meta The tag definition to match against to identify an existing tag.
     */
    removeTagElement(meta) {
      if (meta) {
        this._dom.remove(meta);
      }
    }
    _getOrCreateElement(meta, forceCreation = false) {
      if (!forceCreation) {
        const selector = this._parseSelector(meta);
        // It's allowed to have multiple elements with the same name so it's not enough to
        // just check that element with the same name already present on the page. We also need to
        // check if element has tag attributes
        const elem = this.getTags(selector).filter(elem => this._containsAttributes(meta, elem))[0];
        if (elem !== undefined) return elem;
      }
      const element = this._dom.createElement('meta');
      this._setMetaElementAttributes(meta, element);
      const head = this._doc.getElementsByTagName('head')[0];
      head.appendChild(element);
      return element;
    }
    _setMetaElementAttributes(tag, el) {
      Object.keys(tag).forEach(prop => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]));
      return el;
    }
    _parseSelector(tag) {
      const attr = tag.name ? 'name' : 'property';
      return `${attr}="${tag[attr]}"`;
    }
    _containsAttributes(tag, elem) {
      return Object.keys(tag).every(key => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]);
    }
    _getMetaKeyMap(prop) {
      return META_KEYS_MAP[prop] || prop;
    }
  }
  Meta.ɵfac = function Meta_Factory(t) {
    return new (t || Meta)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));
  };
  Meta.ɵprov = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    factory: createMeta,
    token: Meta,
    providedIn: "root"
  });
  return Meta;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * Mapping for MetaDefinition properties with their correct meta attribute names
 */
const META_KEYS_MAP = {
  httpEquiv: 'http-equiv'
};

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Factory to create Title service.
 */
function createTitle() {
  return new Title((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));
}
/**
 * A service that can be used to get and set the title of a current HTML document.
 *
 * Since an Angular application can't be bootstrapped on the entire HTML document (`<html>` tag)
 * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements
 * (representing the `<title>` tag). Instead, this service can be used to set and get the current
 * title value.
 *
 * @publicApi
 */
let Title = /*#__PURE__*/(() => {
  class Title {
    constructor(_doc) {
      this._doc = _doc;
    }
    /**
     * Get the title of the current HTML document.
     */
    getTitle() {
      return this._doc.title;
    }
    /**
     * Set the title of the current HTML document.
     * @param newTitle
     */
    setTitle(newTitle) {
      this._doc.title = newTitle || '';
    }
  }
  Title.ɵfac = function Title_Factory(t) {
    return new (t || Title)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));
  };
  Title.ɵprov = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    factory: createTitle,
    token: Title,
    providedIn: "root"
  });
  return Title;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const win = typeof window !== 'undefined' && window || {};

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class ChangeDetectionPerfRecord {
  constructor(msPerTick, numTicks) {
    this.msPerTick = msPerTick;
    this.numTicks = numTicks;
  }
}
/**
 * Entry point for all Angular profiling-related debug tools. This object
 * corresponds to the `ng.profiler` in the dev console.
 */
class AngularProfiler {
  constructor(ref) {
    this.appRef = ref.injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_1__.ApplicationRef);
  }
  // tslint:disable:no-console
  /**
   * Exercises change detection in a loop and then prints the average amount of
   * time in milliseconds how long a single round of change detection takes for
   * the current state of the UI. It runs a minimum of 5 rounds for a minimum
   * of 500 milliseconds.
   *
   * Optionally, a user may pass a `config` parameter containing a map of
   * options. Supported options are:
   *
   * `record` (boolean) - causes the profiler to record a CPU profile while
   * it exercises the change detector. Example:
   *
   * ```
   * ng.profiler.timeChangeDetection({record: true})
   * ```
   */
  timeChangeDetection(config) {
    const record = config && config['record'];
    const profileName = 'Change Detection';
    // Profiler is not available in Android browsers without dev tools opened
    const isProfilerAvailable = win.console.profile != null;
    if (record && isProfilerAvailable) {
      win.console.profile(profileName);
    }
    const start = performanceNow();
    let numTicks = 0;
    while (numTicks < 5 || performanceNow() - start < 500) {
      this.appRef.tick();
      numTicks++;
    }
    const end = performanceNow();
    if (record && isProfilerAvailable) {
      win.console.profileEnd(profileName);
    }
    const msPerTick = (end - start) / numTicks;
    win.console.log(`ran ${numTicks} change detection cycles`);
    win.console.log(`${msPerTick.toFixed(2)} ms per check`);
    return new ChangeDetectionPerfRecord(msPerTick, numTicks);
  }
}
function performanceNow() {
  return win.performance && win.performance.now ? win.performance.now() : new Date().getTime();
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const PROFILER_GLOBAL_NAME = 'profiler';
/**
 * Enabled Angular debug tools that are accessible via your browser's
 * developer console.
 *
 * Usage:
 *
 * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)
 * 1. Type `ng.` (usually the console will show auto-complete suggestion)
 * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`
 *    then hit Enter.
 *
 * @publicApi
 */
function enableDebugTools(ref) {
  exportNgVar(PROFILER_GLOBAL_NAME, new AngularProfiler(ref));
  return ref;
}
/**
 * Disables Angular tools.
 *
 * @publicApi
 */
function disableDebugTools() {
  exportNgVar(PROFILER_GLOBAL_NAME, null);
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function escapeHtml(text) {
  const escapedText = {
    '&': '&a;',
    '"': '&q;',
    '\'': '&s;',
    '<': '&l;',
    '>': '&g;'
  };
  return text.replace(/[&"'<>]/g, s => escapedText[s]);
}
function unescapeHtml(text) {
  const unescapedText = {
    '&a;': '&',
    '&q;': '"',
    '&s;': '\'',
    '&l;': '<',
    '&g;': '>'
  };
  return text.replace(/&[^;]+;/g, s => unescapedText[s]);
}
/**
 * Create a `StateKey<T>` that can be used to store value of type T with `TransferState`.
 *
 * Example:
 *
 * ```
 * const COUNTER_KEY = makeStateKey<number>('counter');
 * let value = 10;
 *
 * transferState.set(COUNTER_KEY, value);
 * ```
 *
 * @publicApi
 */
function makeStateKey(key) {
  return key;
}
/**
 * A key value store that is transferred from the application on the server side to the application
 * on the client side.
 *
 * `TransferState` will be available as an injectable token. To use it import
 * `ServerTransferStateModule` on the server and `BrowserTransferStateModule` on the client.
 *
 * The values in the store are serialized/deserialized using JSON.stringify/JSON.parse. So only
 * boolean, number, string, null and non-class objects will be serialized and deserialized in a
 * non-lossy manner.
 *
 * @publicApi
 */
let TransferState = /*#__PURE__*/(() => {
  class TransferState {
    constructor() {
      this.store = {};
      this.onSerializeCallbacks = {};
    }
    /** @internal */
    static init(initState) {
      const transferState = new TransferState();
      transferState.store = initState;
      return transferState;
    }
    /**
     * Get the value corresponding to a key. Return `defaultValue` if key is not found.
     */
    get(key, defaultValue) {
      return this.store[key] !== undefined ? this.store[key] : defaultValue;
    }
    /**
     * Set the value corresponding to a key.
     */
    set(key, value) {
      this.store[key] = value;
    }
    /**
     * Remove a key from the store.
     */
    remove(key) {
      delete this.store[key];
    }
    /**
     * Test whether a key exists in the store.
     */
    hasKey(key) {
      return this.store.hasOwnProperty(key);
    }
    /**
     * Register a callback to provide the value for a key when `toJson` is called.
     */
    onSerialize(key, callback) {
      this.onSerializeCallbacks[key] = callback;
    }
    /**
     * Serialize the current state of the store to JSON.
     */
    toJson() {
      // Call the onSerialize callbacks and put those values into the store.
      for (const key in this.onSerializeCallbacks) {
        if (this.onSerializeCallbacks.hasOwnProperty(key)) {
          try {
            this.store[key] = this.onSerializeCallbacks[key]();
          } catch (e) {
            console.warn('Exception in onSerialize callback: ', e);
          }
        }
      }
      return JSON.stringify(this.store);
    }
  }
  TransferState.ɵfac = function TransferState_Factory(t) {
    return new (t || TransferState)();
  };
  TransferState.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: TransferState,
    factory: TransferState.ɵfac
  });
  return TransferState;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
function initTransferState(doc, appId) {
  // Locate the script tag with the JSON data transferred from the server.
  // The id of the script tag is set to the Angular appId + 'state'.
  const script = doc.getElementById(appId + '-state');
  let initialState = {};
  if (script && script.textContent) {
    try {
      // Avoid using any here as it triggers lint errors in google3 (any is not allowed).
      initialState = JSON.parse(unescapeHtml(script.textContent));
    } catch (e) {
      console.warn('Exception while restoring TransferState for app ' + appId, e);
    }
  }
  return TransferState.init(initialState);
}
/**
 * NgModule to install on the client side while using the `TransferState` to transfer state from
 * server to client.
 *
 * @publicApi
 */
let BrowserTransferStateModule = /*#__PURE__*/(() => {
  class BrowserTransferStateModule {}
  BrowserTransferStateModule.ɵfac = function BrowserTransferStateModule_Factory(t) {
    return new (t || BrowserTransferStateModule)();
  };
  BrowserTransferStateModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
    type: BrowserTransferStateModule
  });
  BrowserTransferStateModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
    providers: [{
      provide: TransferState,
      useFactory: initTransferState,
      deps: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT, _angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_ID]
    }]
  });
  return BrowserTransferStateModule;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Predicates for use with {@link DebugElement}'s query functions.
 *
 * @publicApi
 */
class By {
  /**
   * Match all nodes.
   *
   * @usageNotes
   * ### Example
   *
   * {@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}
   */
  static all() {
    return () => true;
  }
  /**
   * Match elements by the given CSS selector.
   *
   * @usageNotes
   * ### Example
   *
   * {@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}
   */
  static css(selector) {
    return debugElement => {
      return debugElement.nativeElement != null ? elementMatches(debugElement.nativeElement, selector) : false;
    };
  }
  /**
   * Match nodes that have the given directive present.
   *
   * @usageNotes
   * ### Example
   *
   * {@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}
   */
  static directive(type) {
    return debugNode => debugNode.providerTokens.indexOf(type) !== -1;
  }
}
function elementMatches(n, selector) {
  if ((0,_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵgetDOM"])().isElementNode(n)) {
    return n.matches && n.matches(selector) || n.msMatchesSelector && n.msMatchesSelector(selector) || n.webkitMatchesSelector && n.webkitMatchesSelector(selector);
  }
  return false;
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @publicApi
 */
const VERSION = /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_1__.Version('12.2.17');

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// This file only reexports content of the `src` folder. Keep it that way.

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=platform-browser.js.map

/***/ }),

/***/ 2579:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ct: () => (/* binding */ LOCATION),
/* harmony export */   H3: () => (/* binding */ LOCAL_STORAGE),
/* harmony export */   L1: () => (/* binding */ ANIMATION_FRAME),
/* harmony export */   m9: () => (/* binding */ WINDOW),
/* harmony export */   ux: () => (/* binding */ CSS),
/* harmony export */   yZ: () => (/* binding */ USER_AGENT)
/* harmony export */ });
/* unused harmony exports NAVIGATOR, NETWORK_INFORMATION, PAGE_VISIBILITY, PERFORMANCE, SESSION_STORAGE, SPEECH_RECOGNITION, SPEECH_SYNTHESIS */
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3008);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5917);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1927);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(2759);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9196);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8002);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8819);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(9761);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(7519);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_1__);





/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const WINDOW = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over global window object', {
  factory: () => {
    const {
      defaultView
    } = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT);
    if (!defaultView) {
      throw new Error('Window is not available');
    }
    return defaultView;
  }
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PERFORMANCE = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.performance object', {
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(WINDOW).performance
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// interval has bug: https://github.com/ReactiveX/rxjs/issues/4972, scheduled only present in rxjs 6.5+
/** @type {?} */
const ANIMATION_FRAME = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('Shared Observable based on `window.requestAnimationFrame`', {
  factory: () => {
    /** @type {?} */
    const performanceRef = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(PERFORMANCE);
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(0, rxjs__WEBPACK_IMPORTED_MODULE_3__/* .animationFrameScheduler */ .Z).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__/* .repeat */ .r)(), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__/* .map */ .U)(() => performanceRef.now()), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__/* .share */ .B)());
  }
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CSS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.CSS object', {
  factory: () => /** @type {?} */(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(WINDOW).CSS || {
    escape: v => v,
    supports: () => false
  }
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOCAL_STORAGE = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.localStorage object', {
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(WINDOW).localStorage
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOCATION = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.location object', {
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(WINDOW).location
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NAVIGATOR = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.navigator object', {
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(WINDOW).navigator
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NETWORK_INFORMATION = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.navigator.connection object', {
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(NAVIGATOR).connection || null
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PAGE_VISIBILITY = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('Shared Observable based on `document visibility changed`', {
  factory: () => {
    /** @type {?} */
    const documentRef = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT);
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_7__/* .fromEvent */ .R)(documentRef, 'visibilitychange').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__/* .startWith */ .O)(0), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__/* .map */ .U)(() => !documentRef.hidden), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__/* .distinctUntilChanged */ .x)(), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__/* .share */ .B)());
  }
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SESSION_STORAGE = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.sessionStorage object', {
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(WINDOW).sessionStorage
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SPEECH_RECOGNITION = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over SpeechRecognition class', {
  factory: () => {
    /** @type {?} */
    const windowRef = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(WINDOW);
    return windowRef.speechRecogniton || windowRef.webkitSpeechRecognition || null;
  }
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SPEECH_SYNTHESIS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.speechSynthesis object', {
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(WINDOW).speechSynthesis
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const USER_AGENT = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.navigator.userAgent object', {
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(NAVIGATOR).userAgent
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */



//# sourceMappingURL=ng-web-apis-common.js.map

/***/ }),

/***/ 9052:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Or: () => (/* binding */ TUI_DOC_LOGO),
  V5: () => (/* binding */ TUI_DOC_PAGES),
  fV: () => (/* binding */ TuiAddonDocModule),
  c0: () => (/* binding */ TuiDocCodeComponent),
  JF: () => (/* binding */ TuiDocCodeModule),
  zb: () => (/* binding */ TuiDocDocumentationComponent),
  B7: () => (/* binding */ TuiDocDocumentationPropertyConnectorDirective),
  $5: () => (/* binding */ TuiDocMainComponent),
  qn: () => (/* binding */ TuiDocMainModule),
  qo: () => (/* binding */ TuiDocPageComponent),
  Lq: () => (/* binding */ TuiDocPageModule),
  nj: () => (/* binding */ TuiDocPageTabConnectorDirective),
  iY: () => (/* binding */ generateRoutes)
});

// UNUSED EXPORTS: DEMO_TEXTS, DOC_TEXTS, EXAMPLE_TEXTS, TUI_DOC_CODE_EDITOR, TUI_DOC_DEFAULT_TABS, TUI_DOC_DEMO_TEXTS, TUI_DOC_DOCUMENTATION_TEXTS, TUI_DOC_EXAMPLE_CONTENT_PROCESSOR, TUI_DOC_EXAMPLE_TEXTS, TUI_DOC_MENU_TEXT, TUI_DOC_RUSSIAN, TUI_DOC_SEARCH_TEXT, TUI_DOC_SEE_ALSO, TUI_DOC_SEE_ALSO_TEXT, TUI_DOC_SOURCE_CODE, TUI_DOC_SOURCE_CODE_TEXT, TUI_DOC_TITLE, TuiDocCopyComponent, TuiDocCopyModule, TuiDocDemoComponent, TuiDocDemoModule, TuiDocDocumentationModule, TuiDocExampleComponent, TuiDocExampleModule, TuiDocNavigationComponent, TuiDocNavigationModule, ɵa, ɵb, ɵc, ɵd, ɵe, ɵf, ɵg, ɵh, ɵi, ɵj, ɵk, ɵl, ɵm, ɵn, ɵo, ɵp, ɵq, ɵr

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.mjs
var tslib_es6 = __webpack_require__(7582);
// EXTERNAL MODULE: consume shared module (default) @angular/core@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/core/fesm2015/core.js)
var core_js_ = __webpack_require__(8312);
// EXTERNAL MODULE: consume shared module (default) @angular/common@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/common/fesm2015/common.js)
var common_js_ = __webpack_require__(3008);
// EXTERNAL MODULE: ./node_modules/ngx-highlightjs/fesm2015/ngx-highlightjs.js + 1 modules
var ngx_highlightjs = __webpack_require__(7841);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-services.js + 1 modules
var taiga_ui_cdk_services = __webpack_require__(3503);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-decorators.js
var taiga_ui_cdk_decorators = __webpack_require__(4358);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-tokens.js
var taiga_ui_cdk_tokens = __webpack_require__(8096);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-observables.js + 2 modules
var taiga_ui_cdk_observables = __webpack_require__(908);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/filter.js
var filter = __webpack_require__(5435);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js
var map = __webpack_require__(8002);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-drag.js





let TuiDragDirective = /*#__PURE__*/(() => {
  let TuiDragDirective = class TuiDragDirective {
    constructor(elementRef) {
      this.elementRef = elementRef;
      this.dragAndDropFrom$ = (0,taiga_ui_cdk_observables/* dragAndDropFrom */.AA)(this.elementRef.nativeElement);
      this.start = this.dragAndDropFrom$.pipe((0,filter/* filter */.h)(({
        stage
      }) => stage === 0 /* Start */), (0,map/* map */.U)(({
        event
      }) => event));
      this.continues = this.dragAndDropFrom$.pipe((0,filter/* filter */.h)(({
        stage
      }) => stage === 1 /* Continues */), (0,map/* map */.U)(({
        event
      }) => event));
      this.end = this.dragAndDropFrom$.pipe((0,filter/* filter */.h)(({
        stage
      }) => stage === 2 /* End */), (0,map/* map */.U)(({
        event
      }) => event));
    }
  };
  TuiDragDirective.ɵfac = function TuiDragDirective_Factory(t) {
    return new (t || TuiDragDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef));
  };
  TuiDragDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiDragDirective,
    selectors: [["", "tuiDragStart", ""], ["", "tuiDragContinues", ""], ["", "tuiDragEnd", ""]],
    outputs: {
      start: "tuiDragStart",
      continues: "tuiDragContinues",
      end: "tuiDragEnd"
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)('tuiDragStart')], TuiDragDirective.prototype, "start", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)('tuiDragContinues')], TuiDragDirective.prototype, "continues", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)('tuiDragEnd')], TuiDragDirective.prototype, "end", void 0);
  TuiDragDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef))], TuiDragDirective);
  return TuiDragDirective;
})();
let TuiDragModule = /*#__PURE__*/(() => {
  let TuiDragModule = class TuiDragModule {};
  TuiDragModule.ɵfac = function TuiDragModule_Factory(t) {
    return new (t || TuiDragModule)();
  };
  TuiDragModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDragModule
  });
  TuiDragModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiDragModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDragModule, {
    declarations: [TuiDragDirective],
    exports: [TuiDragDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-drag.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-miscellaneous.js
var taiga_ui_cdk_utils_miscellaneous = __webpack_require__(8659);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Observable.js + 2 modules
var Observable = __webpack_require__(8891);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/startWith.js
var startWith = __webpack_require__(9761);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js
var distinctUntilChanged = __webpack_require__(7519);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscriber.js
var Subscriber = __webpack_require__(7393);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/skip.js

function skip(count) {
  return source => source.lift(new SkipOperator(count));
}
class SkipOperator {
  constructor(total) {
    this.total = total;
  }
  call(subscriber, source) {
    return source.subscribe(new SkipSubscriber(subscriber, this.total));
  }
}
class SkipSubscriber extends Subscriber/* Subscriber */.L {
  constructor(destination, total) {
    super(destination);
    this.total = total;
    this.count = 0;
  }
  _next(x) {
    if (++this.count > this.total) {
      this.destination.next(x);
    }
  }
}
//# sourceMappingURL=skip.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-active-zone.js









var TuiActiveZoneDirective_1;
let TuiActiveZoneDirective = TuiActiveZoneDirective_1 = class TuiActiveZoneDirective {
  constructor(active$, ngZone, elementRef, directParentActiveZone) {
    this.active$ = active$;
    this.ngZone = ngZone;
    this.elementRef = elementRef;
    this.directParentActiveZone = directParentActiveZone;
    this.subActiveZones = [];
    this.tuiActiveZoneParent = null;
    this.tuiActiveZoneChange = this.active$.pipe((0,map/* map */.U)(element => !!element && this.contains(element)), (0,startWith/* startWith */.O)(false), (0,distinctUntilChanged/* distinctUntilChanged */.x)(), skip(1), (0,taiga_ui_cdk_observables/* tuiZoneOptimized */.Yr)(this.ngZone));
    if (this.directParentActiveZone) {
      this.directParentActiveZone.addSubActiveZone(this);
    }
  }
  set tuiActiveZoneParentSetter(zone) {
    if (this.tuiActiveZoneParent) {
      this.tuiActiveZoneParent.removeSubActiveZone(this);
    }
    if (zone) {
      zone.addSubActiveZone(this);
    }
    this.tuiActiveZoneParent = zone;
  }
  ngOnDestroy() {
    if (!!this.directParentActiveZone) {
      this.directParentActiveZone.removeSubActiveZone(this);
    }
    if (!!this.tuiActiveZoneParent) {
      this.tuiActiveZoneParent.removeSubActiveZone(this);
    }
  }
  contains(node) {
    return this.elementRef.nativeElement.contains(node) || this.subActiveZones.some((item, index, array) => array.indexOf(item) === index && item.contains(node));
  }
  addSubActiveZone(activeZone) {
    this.subActiveZones = [...this.subActiveZones, activeZone];
  }
  removeSubActiveZone(activeZone) {
    const index = this.subActiveZones.findIndex(item => item === activeZone);
    this.subActiveZones = [...this.subActiveZones.slice(0, index), ...this.subActiveZones.slice(index + 1)];
  }
};
TuiActiveZoneDirective.ɵfac = function TuiActiveZoneDirective_Factory(t) {
  return new (t || TuiActiveZoneDirective)(core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_ACTIVE_ELEMENT */.wk), core_js_["ɵɵdirectiveInject"](core_js_.NgZone), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](TuiActiveZoneDirective_1, 12));
};
TuiActiveZoneDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiActiveZoneDirective,
  selectors: [["", "tuiActiveZone", "", 5, "ng-container"], ["", "tuiActiveZoneChange", "", 5, "ng-container"], ["", "tuiActiveZoneParent", "", 5, "ng-container"]],
  inputs: {
    tuiActiveZoneParentSetter: ["tuiActiveZoneParent", "tuiActiveZoneParentSetter"]
  },
  outputs: {
    tuiActiveZoneChange: "tuiActiveZoneChange"
  },
  exportAs: ["tuiActiveZone"]
});
TuiActiveZoneDirective.ctorParameters = () => [{
  type: Observable/* Observable */.y,
  decorators: [{
    type: core_js_.Inject,
    args: [taiga_ui_cdk_tokens/* TUI_ACTIVE_ELEMENT */.wk]
  }]
}, {
  type: core_js_.NgZone,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.NgZone]
  }]
}, {
  type: core_js_.ElementRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ElementRef]
  }]
}, {
  type: TuiActiveZoneDirective,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.SkipSelf
  }, {
    type: core_js_.Inject,
    args: [TuiActiveZoneDirective_1]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiActiveZoneParent'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiActiveZoneDirective.prototype, "tuiActiveZoneParentSetter", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiActiveZoneDirective.prototype, "tuiActiveZoneChange", void 0);
TuiActiveZoneDirective = TuiActiveZoneDirective_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_ACTIVE_ELEMENT */.wk)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.NgZone)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.SkipSelf)()), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TuiActiveZoneDirective_1))], TuiActiveZoneDirective);
let TuiActiveZoneModule = /*#__PURE__*/(() => {
  let TuiActiveZoneModule = class TuiActiveZoneModule {};
  TuiActiveZoneModule.ɵfac = function TuiActiveZoneModule_Factory(t) {
    return new (t || TuiActiveZoneModule)();
  };
  TuiActiveZoneModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiActiveZoneModule
  });
  TuiActiveZoneModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiActiveZoneModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiActiveZoneModule, {
    declarations: [TuiActiveZoneDirective],
    exports: [TuiActiveZoneDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-active-zone.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-let.js
var taiga_ui_cdk_directives_let = __webpack_require__(2668);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-constants.js
var taiga_ui_cdk_constants = __webpack_require__(3770);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/i18n/fesm2015/taiga-ui-i18n-tools.js + 1 modules
var taiga_ui_i18n_tools = __webpack_require__(121);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-tokens.js


const TUI_CALENDAR_DATA_STREAM = new core_js_.InjectionToken('Stream that emits calendar data change');
const TUI_MOBILE_AWARE = new core_js_.InjectionToken('A flag enabling mobile-specific behavior for supporting components', {
  factory: () => false
});
const TUI_MOBILE_CALENDAR = new core_js_.InjectionToken('A component for mobile data picker');
const TUI_TAG_STATUS = new core_js_.InjectionToken('Status for tags inside InputTag component', {
  factory: () => "primary" /* Primary */
});

const TUI_VALIDATION_ERRORS = new core_js_.InjectionToken('Validation errors', {
  factory: () => ({})
});
const TUI_CANCEL_WORD = new core_js_.InjectionToken(`i18n 'cancel' word`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.H)('cancel')
});
const TUI_DONE_WORD = new core_js_.InjectionToken(`i18n 'done' word`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.H)('done')
});
const TUI_MORE_WORD = new core_js_.InjectionToken(`i18n 'more' word`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.H)('more')
});
const TUI_OTHER_DATE_TEXT = new core_js_.InjectionToken(`i18n 'Other date' text`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.H)('otherDate')
});
const TUI_CHOOSE_DAY_OR_RANGE_TEXTS = new core_js_.InjectionToken(`choose day or range i18n texts`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.H)('mobileCalendarTexts')
});
const TUI_FROM_TO_TEXTS = new core_js_.InjectionToken(`from and to i18n texts`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.H)('range')
});
const TUI_PLUS_MINUS_TEXTS = new core_js_.InjectionToken(`plus and minus i18n texts`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.H)('countTexts')
});
const TUI_TIME_TEXTS = new core_js_.InjectionToken(`time i18n texts`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.H)('time')
});
const TUI_DIGITAL_INFORMATION_UNITS = new core_js_.InjectionToken(`short bytes, kilobytes and megabytes i18n texts`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.H)('digitalInformationUnits')
});
const TUI_COPY_TEXTS = new core_js_.InjectionToken('copy i18n texts', {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.H)('copyTexts')
});
const TUI_PASSWORD_TEXTS = new core_js_.InjectionToken('password i18n texts', {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.H)('passwordTexts')
});
const TUI_CALENDAR_MONTHS = new core_js_.InjectionToken('short calendar months i18n', {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.H)('shortCalendarMonths')
});
const TUI_FILE_TEXTS = new core_js_.InjectionToken('file i18n texts', {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.H)('fileTexts')
});
const TUI_PAGINATION_TEXTS = new core_js_.InjectionToken('pagination i18n texts', {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.H)('paginationTexts')
});
const TUI_INPUT_FILE_TEXTS = new core_js_.InjectionToken('tui-input-file i18n texts', {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.H)('inputFileTexts')
});

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-tokens.js.map
// EXTERNAL MODULE: ./node_modules/@angular/forms/fesm2015/forms.js + 1 modules
var fesm2015_forms = __webpack_require__(3738);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-abstract.js
var taiga_ui_cdk_abstract = __webpack_require__(6480);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-focus.js
var taiga_ui_cdk_utils_focus = __webpack_require__(7179);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/merge.js
var merge = __webpack_require__(6682);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/noop.js
var noop = __webpack_require__(8640);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/observable/never.js


const NEVER = new Observable/* Observable */.y(noop/* noop */.Z);
function never() {
  return NEVER;
}
//# sourceMappingURL=never.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/takeUntil.js
var takeUntil = __webpack_require__(6782);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-directives-textfield-controller.js






class TuiTextfieldController {
  constructor(change$, autocompleteDirective, cleanerDirective, customContentDirective, exampleTextDirective, inputModeDirective, labelOutsideDirective, maxLengthDirective, sizeDirective, typeDirective) {
    this.change$ = change$;
    this.autocompleteDirective = autocompleteDirective;
    this.cleanerDirective = cleanerDirective;
    this.customContentDirective = customContentDirective;
    this.exampleTextDirective = exampleTextDirective;
    this.inputModeDirective = inputModeDirective;
    this.labelOutsideDirective = labelOutsideDirective;
    this.maxLengthDirective = maxLengthDirective;
    this.sizeDirective = sizeDirective;
    this.typeDirective = typeDirective;
  }
  get autocomplete() {
    return this.autocompleteDirective.autocomplete;
  }
  get cleaner() {
    return this.cleanerDirective.cleaner;
  }
  get customContent() {
    return this.customContentDirective.customContent;
  }
  get exampleText() {
    return this.exampleTextDirective.exampleText;
  }
  get inputMode() {
    return this.inputModeDirective.inputMode;
  }
  get labelOutside() {
    return this.labelOutsideDirective.labelOutside;
  }
  get maxLength() {
    return this.maxLengthDirective.maxLength;
  }
  get size() {
    return this.sizeDirective.size;
  }
  get type() {
    return this.typeDirective.type;
  }
}
var TuiTextfieldAutocompleteDirective_1;
const TUI_TEXTFIELD_AUTOCOMPLETE = new core_js_.InjectionToken('tuiTextfieldAutocomplete', {
  factory: autocompleteDirectiveFactory
});
let TuiTextfieldAutocompleteDirective = TuiTextfieldAutocompleteDirective_1 = class TuiTextfieldAutocompleteDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor() {
    super(...arguments);
    this.autocomplete = null;
  }
};
TuiTextfieldAutocompleteDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiTextfieldAutocompleteDirective_BaseFactory;
  return function TuiTextfieldAutocompleteDirective_Factory(t) {
    return (ɵTuiTextfieldAutocompleteDirective_BaseFactory || (ɵTuiTextfieldAutocompleteDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiTextfieldAutocompleteDirective)))(t || TuiTextfieldAutocompleteDirective);
  };
}();
TuiTextfieldAutocompleteDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiTextfieldAutocompleteDirective,
  selectors: [["", "tuiTextfieldAutocomplete", ""]],
  inputs: {
    autocomplete: ["tuiTextfieldAutocomplete", "autocomplete"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_TEXTFIELD_AUTOCOMPLETE,
    useExisting: (0,core_js_.forwardRef)(() => TuiTextfieldAutocompleteDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiTextfieldAutocomplete')], TuiTextfieldAutocompleteDirective.prototype, "autocomplete", void 0);
function autocompleteDirectiveFactory() {
  return new TuiTextfieldAutocompleteDirective();
}
var TuiTextfieldCleanerDirective_1;
const TUI_TEXTFIELD_CLEANER = new core_js_.InjectionToken('tuiTextfieldCleaner', {
  factory: cleanerDirectiveFactory
});
let TuiTextfieldCleanerDirective = TuiTextfieldCleanerDirective_1 = class TuiTextfieldCleanerDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor() {
    super(...arguments);
    this.cleaner = false;
  }
};
TuiTextfieldCleanerDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiTextfieldCleanerDirective_BaseFactory;
  return function TuiTextfieldCleanerDirective_Factory(t) {
    return (ɵTuiTextfieldCleanerDirective_BaseFactory || (ɵTuiTextfieldCleanerDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiTextfieldCleanerDirective)))(t || TuiTextfieldCleanerDirective);
  };
}();
TuiTextfieldCleanerDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiTextfieldCleanerDirective,
  selectors: [["", "tuiTextfieldCleaner", ""]],
  inputs: {
    cleaner: ["tuiTextfieldCleaner", "cleaner"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_TEXTFIELD_CLEANER,
    useExisting: (0,core_js_.forwardRef)(() => TuiTextfieldCleanerDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiTextfieldCleaner')], TuiTextfieldCleanerDirective.prototype, "cleaner", void 0);
function cleanerDirectiveFactory() {
  return new TuiTextfieldCleanerDirective();
}
var TuiTextfieldCustomContentDirective_1;
const TUI_TEXTFIELD_CUSTOM_CONTENT = new core_js_.InjectionToken('tuiTextfieldCustomContent', {
  factory: customContentDirectiveFactory
});
let TuiTextfieldCustomContentDirective = TuiTextfieldCustomContentDirective_1 = class TuiTextfieldCustomContentDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor() {
    super(...arguments);
    this.customContent = null;
  }
};
TuiTextfieldCustomContentDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiTextfieldCustomContentDirective_BaseFactory;
  return function TuiTextfieldCustomContentDirective_Factory(t) {
    return (ɵTuiTextfieldCustomContentDirective_BaseFactory || (ɵTuiTextfieldCustomContentDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiTextfieldCustomContentDirective)))(t || TuiTextfieldCustomContentDirective);
  };
}();
TuiTextfieldCustomContentDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiTextfieldCustomContentDirective,
  selectors: [["", "tuiTextfieldCustomContent", ""]],
  inputs: {
    customContent: ["tuiTextfieldCustomContent", "customContent"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_TEXTFIELD_CUSTOM_CONTENT,
    useExisting: (0,core_js_.forwardRef)(() => TuiTextfieldCustomContentDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiTextfieldCustomContent')], TuiTextfieldCustomContentDirective.prototype, "customContent", void 0);
function customContentDirectiveFactory() {
  return new TuiTextfieldCustomContentDirective();
}
var TuiTextfieldExampleTextDirective_1;
const TUI_TEXTFIELD_EXAMPLE_TEXT = new core_js_.InjectionToken('tuiTextfieldExampleText', {
  factory: exampleTextDirectiveFactory
});
let TuiTextfieldExampleTextDirective = TuiTextfieldExampleTextDirective_1 = class TuiTextfieldExampleTextDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor() {
    super(...arguments);
    this.exampleText = '';
  }
};
TuiTextfieldExampleTextDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiTextfieldExampleTextDirective_BaseFactory;
  return function TuiTextfieldExampleTextDirective_Factory(t) {
    return (ɵTuiTextfieldExampleTextDirective_BaseFactory || (ɵTuiTextfieldExampleTextDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiTextfieldExampleTextDirective)))(t || TuiTextfieldExampleTextDirective);
  };
}();
TuiTextfieldExampleTextDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiTextfieldExampleTextDirective,
  selectors: [["", "tuiTextfieldExampleText", ""]],
  inputs: {
    exampleText: ["tuiTextfieldExampleText", "exampleText"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_TEXTFIELD_EXAMPLE_TEXT,
    useExisting: (0,core_js_.forwardRef)(() => TuiTextfieldExampleTextDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiTextfieldExampleText')], TuiTextfieldExampleTextDirective.prototype, "exampleText", void 0);
function exampleTextDirectiveFactory() {
  return new TuiTextfieldExampleTextDirective();
}
var TuiTextfieldInputModeDirective_1;
const TUI_TEXTFIELD_INPUT_MODE = new core_js_.InjectionToken('tuiTextfieldInputMode', {
  factory: inputModeDirectiveFactory
});
let TuiTextfieldInputModeDirective = TuiTextfieldInputModeDirective_1 = class TuiTextfieldInputModeDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor() {
    super(...arguments);
    this.inputMode = "text" /* Text */;
  }
};

TuiTextfieldInputModeDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiTextfieldInputModeDirective_BaseFactory;
  return function TuiTextfieldInputModeDirective_Factory(t) {
    return (ɵTuiTextfieldInputModeDirective_BaseFactory || (ɵTuiTextfieldInputModeDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiTextfieldInputModeDirective)))(t || TuiTextfieldInputModeDirective);
  };
}();
TuiTextfieldInputModeDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiTextfieldInputModeDirective,
  selectors: [["", "tuiTextfieldInputMode", ""]],
  inputs: {
    inputMode: ["tuiTextfieldInputMode", "inputMode"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_TEXTFIELD_INPUT_MODE,
    useExisting: (0,core_js_.forwardRef)(() => TuiTextfieldInputModeDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiTextfieldInputMode')], TuiTextfieldInputModeDirective.prototype, "inputMode", void 0);
function inputModeDirectiveFactory() {
  return new TuiTextfieldInputModeDirective();
}
var TuiTextfieldLabelOutsideDirective_1;
const TUI_TEXTFIELD_LABEL_OUTSIDE = new core_js_.InjectionToken('tuiTextfieldLabelOutside', {
  factory: labelOutsideDirectiveFactory
});
let TuiTextfieldLabelOutsideDirective = TuiTextfieldLabelOutsideDirective_1 = class TuiTextfieldLabelOutsideDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor() {
    super(...arguments);
    this.labelOutside = false;
  }
};
TuiTextfieldLabelOutsideDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiTextfieldLabelOutsideDirective_BaseFactory;
  return function TuiTextfieldLabelOutsideDirective_Factory(t) {
    return (ɵTuiTextfieldLabelOutsideDirective_BaseFactory || (ɵTuiTextfieldLabelOutsideDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiTextfieldLabelOutsideDirective)))(t || TuiTextfieldLabelOutsideDirective);
  };
}();
TuiTextfieldLabelOutsideDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiTextfieldLabelOutsideDirective,
  selectors: [["", "tuiTextfieldLabelOutside", ""]],
  inputs: {
    labelOutside: ["tuiTextfieldLabelOutside", "labelOutside"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_TEXTFIELD_LABEL_OUTSIDE,
    useExisting: (0,core_js_.forwardRef)(() => TuiTextfieldLabelOutsideDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiTextfieldLabelOutside')], TuiTextfieldLabelOutsideDirective.prototype, "labelOutside", void 0);
function labelOutsideDirectiveFactory() {
  return new TuiTextfieldLabelOutsideDirective();
}
var TuiTextfieldMaxLengthDirective_1;
const TUI_TEXTFIELD_MAX_LENGTH = new core_js_.InjectionToken('tuiTextfieldMaxLength', {
  factory: maxLengthDirectiveFactory
});
let TuiTextfieldMaxLengthDirective = TuiTextfieldMaxLengthDirective_1 = class TuiTextfieldMaxLengthDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor() {
    super(...arguments);
    this.maxLength = null;
  }
};
TuiTextfieldMaxLengthDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiTextfieldMaxLengthDirective_BaseFactory;
  return function TuiTextfieldMaxLengthDirective_Factory(t) {
    return (ɵTuiTextfieldMaxLengthDirective_BaseFactory || (ɵTuiTextfieldMaxLengthDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiTextfieldMaxLengthDirective)))(t || TuiTextfieldMaxLengthDirective);
  };
}();
TuiTextfieldMaxLengthDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiTextfieldMaxLengthDirective,
  selectors: [["", "tuiTextfieldMaxLength", ""]],
  inputs: {
    maxLength: ["tuiTextfieldMaxLength", "maxLength"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_TEXTFIELD_MAX_LENGTH,
    useExisting: (0,core_js_.forwardRef)(() => TuiTextfieldMaxLengthDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiTextfieldMaxLength')], TuiTextfieldMaxLengthDirective.prototype, "maxLength", void 0);
function maxLengthDirectiveFactory() {
  return new TuiTextfieldMaxLengthDirective();
}
var TuiTextfieldSizeDirective_1;
const TUI_TEXTFIELD_SIZE = new core_js_.InjectionToken('tuiTextfieldSize', {
  factory: sizeDirectiveFactory
});
let TuiTextfieldSizeDirective = TuiTextfieldSizeDirective_1 = class TuiTextfieldSizeDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor() {
    super(...arguments);
    this.size = 'l';
  }
};
TuiTextfieldSizeDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiTextfieldSizeDirective_BaseFactory;
  return function TuiTextfieldSizeDirective_Factory(t) {
    return (ɵTuiTextfieldSizeDirective_BaseFactory || (ɵTuiTextfieldSizeDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiTextfieldSizeDirective)))(t || TuiTextfieldSizeDirective);
  };
}();
TuiTextfieldSizeDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiTextfieldSizeDirective,
  selectors: [["", "tuiTextfieldSize", ""]],
  inputs: {
    size: ["tuiTextfieldSize", "size"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_TEXTFIELD_SIZE,
    useExisting: (0,core_js_.forwardRef)(() => TuiTextfieldSizeDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiTextfieldSize')], TuiTextfieldSizeDirective.prototype, "size", void 0);
function sizeDirectiveFactory() {
  return new TuiTextfieldSizeDirective();
}
var TuiTextfieldTypeDirective_1;
const TUI_TEXTFIELD_TYPE = new core_js_.InjectionToken('tuiTextfieldType', {
  factory: typeDirectiveFactory
});
let TuiTextfieldTypeDirective = TuiTextfieldTypeDirective_1 = class TuiTextfieldTypeDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor() {
    super(...arguments);
    this.type = "text" /* Text */;
  }
};

TuiTextfieldTypeDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiTextfieldTypeDirective_BaseFactory;
  return function TuiTextfieldTypeDirective_Factory(t) {
    return (ɵTuiTextfieldTypeDirective_BaseFactory || (ɵTuiTextfieldTypeDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiTextfieldTypeDirective)))(t || TuiTextfieldTypeDirective);
  };
}();
TuiTextfieldTypeDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiTextfieldTypeDirective,
  selectors: [["", "tuiTextfieldType", ""]],
  inputs: {
    type: ["tuiTextfieldType", "type"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_TEXTFIELD_TYPE,
    useExisting: (0,core_js_.forwardRef)(() => TuiTextfieldTypeDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiTextfieldType')], TuiTextfieldTypeDirective.prototype, "type", void 0);
function typeDirectiveFactory() {
  return new TuiTextfieldTypeDirective();
}
let TuiTextfieldControllerModule = /*#__PURE__*/(() => {
  let TuiTextfieldControllerModule = class TuiTextfieldControllerModule {};
  TuiTextfieldControllerModule.ɵfac = function TuiTextfieldControllerModule_Factory(t) {
    return new (t || TuiTextfieldControllerModule)();
  };
  TuiTextfieldControllerModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiTextfieldControllerModule
  });
  TuiTextfieldControllerModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiTextfieldControllerModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiTextfieldControllerModule, {
    declarations: [TuiTextfieldAutocompleteDirective, TuiTextfieldCleanerDirective, TuiTextfieldCustomContentDirective, TuiTextfieldExampleTextDirective, TuiTextfieldInputModeDirective, TuiTextfieldLabelOutsideDirective, TuiTextfieldMaxLengthDirective, TuiTextfieldSizeDirective, TuiTextfieldTypeDirective],
    exports: [TuiTextfieldAutocompleteDirective, TuiTextfieldCleanerDirective, TuiTextfieldCustomContentDirective, TuiTextfieldExampleTextDirective, TuiTextfieldInputModeDirective, TuiTextfieldLabelOutsideDirective, TuiTextfieldMaxLengthDirective, TuiTextfieldSizeDirective, TuiTextfieldTypeDirective]
  });
})();
const TUI_TEXTFIELD_WATCHED_CONTROLLER = new core_js_.InjectionToken('watched textfield controller');
function textfieldWatchedControllerFactory(changeDetectorRef, destroy$, ...controllers) {
  const change$ = (0,merge/* merge */.T)(...controllers.map(({
    change$
  }) => change$ || NEVER)).pipe((0,taiga_ui_cdk_observables/* watch */.YP)(changeDetectorRef), (0,takeUntil/* takeUntil */.R)(destroy$));
  change$.subscribe();
  return new TuiTextfieldController(change$, ...controllers);
}
const TEXTFIELD_CONTROLLER_PROVIDER = [taiga_ui_cdk_services/* TuiDestroyService */.a3, {
  provide: TUI_TEXTFIELD_WATCHED_CONTROLLER,
  deps: [core_js_.ChangeDetectorRef, taiga_ui_cdk_services/* TuiDestroyService */.a3, TUI_TEXTFIELD_AUTOCOMPLETE, TUI_TEXTFIELD_CLEANER, TUI_TEXTFIELD_CUSTOM_CONTENT, TUI_TEXTFIELD_EXAMPLE_TEXT, TUI_TEXTFIELD_INPUT_MODE, TUI_TEXTFIELD_LABEL_OUTSIDE, TUI_TEXTFIELD_MAX_LENGTH, TUI_TEXTFIELD_SIZE, TUI_TEXTFIELD_TYPE],
  useFactory: textfieldWatchedControllerFactory
}];

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-directives-textfield-controller.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-tokens.js
var taiga_ui_core_tokens = __webpack_require__(1587);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/empty.js
var empty = __webpack_require__(9193);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/switchMap.js
var switchMap = __webpack_require__(3190);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/take.js
var take = __webpack_require__(5257);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/tap.js
var tap = __webpack_require__(8307);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/shareReplay.js
var shareReplay = __webpack_require__(7349);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/mapTo.js
var mapTo = __webpack_require__(6736);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/debounceTime.js
var debounceTime = __webpack_require__(4395);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-components-portal-host.js



const _c0 = ["positionFixedOffset"];
const _c1 = ["*"];
const NO_HOST = 'Portals cannot be used without TuiPortalHostComponent';
/**
 * Service for displaying portals
 */
let TuiPortalService = /*#__PURE__*/(() => {
  let TuiPortalService = class TuiPortalService {
    get safeHost() {
      if (!this.host) {
        throw new Error(NO_HOST);
      }
      return this.host;
    }
    attach(host) {
      this.host = host;
    }
    add(componentFactory, injector) {
      return this.safeHost.addComponentChild(componentFactory, injector);
    }
    remove({
      hostView
    }) {
      hostView.destroy();
    }
    addTemplate(templateRef, context) {
      return this.safeHost.addTemplateChild(templateRef, context);
    }
    removeTemplate(viewRef) {
      viewRef.destroy();
    }
  };
  TuiPortalService.ɵfac = function TuiPortalService_Factory(t) {
    return new (t || TuiPortalService)();
  };
  TuiPortalService.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function TuiPortalService_Factory() {
      return new TuiPortalService();
    },
    token: TuiPortalService,
    providedIn: "root"
  });
  return TuiPortalService;
})();
var TuiPortalHostComponent_1;
const BLANK_CLIENT_RECT = {
  bottom: 0,
  height: 0,
  left: 0,
  right: 0,
  top: 0,
  width: 0
};
/**
 * Host element for dynamically created portals, for example using {@link TuiDropdownDirective}.
 */
let TuiPortalHostComponent = TuiPortalHostComponent_1 = class TuiPortalHostComponent {
  constructor(viewContainerRef, elementRef, portalService) {
    this.viewContainerRef = viewContainerRef;
    this.elementRef = elementRef;
    portalService.attach(this);
  }
  get clientRect() {
    return this.elementRef.nativeElement.getBoundingClientRect();
  }
  addComponentChild(componentFactory, injector) {
    return this.viewContainerRef.createComponent(componentFactory, undefined, core_js_.Injector.create({
      parent: injector,
      providers: [{
        provide: TuiPortalHostComponent_1,
        useValue: this
      }]
    }));
  }
  addTemplateChild(templateRef, context) {
    return this.viewContainerRef.createEmbeddedView(templateRef, context);
  }
  fixedPositionOffset() {
    return this.positionFixedOffsetRef ? this.positionFixedOffsetRef.nativeElement.getBoundingClientRect() : BLANK_CLIENT_RECT;
  }
};
TuiPortalHostComponent.ɵfac = function TuiPortalHostComponent_Factory(t) {
  return new (t || TuiPortalHostComponent)(core_js_["ɵɵdirectiveInject"](core_js_.ViewContainerRef), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](TuiPortalService));
};
TuiPortalHostComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiPortalHostComponent,
  selectors: [["tui-portal-host"]],
  viewQuery: function TuiPortalHostComponent_Query(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵviewQuery"](_c0, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.positionFixedOffsetRef = _t.first);
    }
  },
  ngContentSelectors: _c1,
  decls: 3,
  vars: 0,
  consts: [[1, "position-fixed-offset"], ["positionFixedOffset", ""]],
  template: function TuiPortalHostComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"]();
      core_js_["ɵɵelement"](0, "div", 0, 1);
      core_js_["ɵɵprojection"](2);
    }
  },
  styles: ["[_nghost-%COMP%]{position:relative;display:block;height:100%;z-index:0}[_nghost-%COMP%]:before{content:'';display:block;overflow:hidden}.position-fixed-offset[_ngcontent-%COMP%]{position:fixed;left:0;top:0;pointer-events:none;visibility:hidden;width:100%;height:100%}"],
  changeDetection: 0
});
TuiPortalHostComponent.ctorParameters = () => [{
  type: core_js_.ViewContainerRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ViewContainerRef]
  }]
}, {
  type: core_js_.ElementRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ElementRef]
  }]
}, {
  type: TuiPortalService,
  decorators: [{
    type: core_js_.Inject,
    args: [TuiPortalService]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('positionFixedOffset')], TuiPortalHostComponent.prototype, "positionFixedOffsetRef", void 0);
TuiPortalHostComponent = TuiPortalHostComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ViewContainerRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(TuiPortalService))], TuiPortalHostComponent);
let TuiPortalHostModule = /*#__PURE__*/(() => {
  let TuiPortalHostModule = class TuiPortalHostModule {};
  TuiPortalHostModule.ɵfac = function TuiPortalHostModule_Factory(t) {
    return new (t || TuiPortalHostModule)();
  };
  TuiPortalHostModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiPortalHostModule
  });
  TuiPortalHostModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiPortalHostModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiPortalHostModule, {
    declarations: [TuiPortalHostComponent],
    exports: [TuiPortalHostComponent]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-components-portal-host.js.map
// EXTERNAL MODULE: ./node_modules/@ng-web-apis/common/fesm2015/ng-web-apis-common.js
var ng_web_apis_common = __webpack_require__(2579);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-dom.js
var taiga_ui_cdk_utils_dom = __webpack_require__(5242);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-math.js
var taiga_ui_cdk_utils_math = __webpack_require__(5648);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-classes.js
var taiga_ui_cdk_classes = __webpack_require__(8939);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-format.js


/**
 * Pads a string with symbols in the beginning
 *
 * @param sourceString
 * @param minResultLength
 * @param padString string to pad with
 */
function padStart(sourceString, minResultLength, padString = ' ') {
  const padSize = minResultLength - sourceString.length;
  if (padSize <= 0) {
    return sourceString;
  }
  return padString.repeat(padSize / padString.length).slice(0, padSize) + sourceString;
}

/**
 * Adds 'px' to the number and turns it into a string
 */
function px(value) {
  taiga_ui_cdk_classes/* tuiAssert */.z.assert(Number.isFinite(value), 'Value must be finite number');
  return `${value}px`;
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-utils-format.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-overscroll.js








/**
 * Directive to isolate scrolling, i.e. prevent body scroll behind modal dialog
 * @dynamic
 */


let TuiOverscrollDirective = /*#__PURE__*/(() => {
  let TuiOverscrollDirective = class TuiOverscrollDirective {
    constructor({
      nativeElement
    }, ngZone, destroy$) {
      this.mode = "scroll" /* Scroll */;
      (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, 'wheel', {
        passive: false
      }).pipe((0,filter/* filter */.h)(() => this.enabled), (0,takeUntil/* takeUntil */.R)(destroy$), (0,taiga_ui_cdk_observables/* tuiZoneOptimized */.Yr)(ngZone)).subscribe(event => {
        this.processEvent(event, !!event.deltaY, event.deltaY ? event.deltaY < 0 : event.deltaX < 0);
      });
      (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, 'touchstart', {
        passive: true
      }).pipe((0,switchMap/* switchMap */.w)(({
        touches
      }) => {
        let {
          clientX,
          clientY
        } = touches[0];
        let deltaX = 0;
        let deltaY = 0;
        let vertical;
        return (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, 'touchmove', {
          passive: false
        }).pipe((0,filter/* filter */.h)(() => this.enabled), (0,taiga_ui_cdk_observables/* tuiZoneOptimized */.Yr)(ngZone), (0,tap/* tap */.b)(event => {
          // We have to have it in tap instead of subscribe due to variables in closure
          const changedTouch = event.changedTouches[0];
          deltaX = clientX - changedTouch.clientX;
          deltaY = clientY - changedTouch.clientY;
          clientX = changedTouch.clientX;
          clientY = changedTouch.clientY;
          if (vertical === undefined) {
            vertical = Math.abs(deltaY) > Math.abs(deltaX);
          }
          this.processEvent(event, vertical, vertical ? deltaY < 0 : deltaX < 0);
        }));
      }), (0,takeUntil/* takeUntil */.R)(destroy$)).subscribe();
    }
    get enabled() {
      return this.mode !== "none" /* None */;
    }

    get overscrollBehavior() {
      return this.enabled ? 'contain' : null;
    }
    processEvent(event, vertical, negative) {
      const {
        target,
        currentTarget,
        cancelable
      } = event;
      if (!cancelable || !(target instanceof Element)) {
        return;
      }
      // This is all what's needed in Chrome/Firefox thanks to CSS overscroll-behavior
      if (this.mode === "all" /* All */ && (vertical && !currentTarget.contains((0,taiga_ui_cdk_utils_dom/* getScrollParent */.rP)(target)) || !vertical && !currentTarget.contains((0,taiga_ui_cdk_utils_dom/* getScrollParent */.rP)(target, false)))) {
        event.preventDefault();
        return;
      }
      // This is Safari/IE/Edge fallback
      if (vertical && (negative && !(0,taiga_ui_cdk_utils_dom/* canScroll */.eE)(target, currentTarget, true, false) || !negative && !(0,taiga_ui_cdk_utils_dom/* canScroll */.eE)(target, currentTarget, true, true))) {
        event.preventDefault();
        return;
      }
      if (!vertical && (negative && !(0,taiga_ui_cdk_utils_dom/* canScroll */.eE)(target, currentTarget, false, false) || !negative && !(0,taiga_ui_cdk_utils_dom/* canScroll */.eE)(target, currentTarget, false, true))) {
        event.preventDefault();
      }
    }
  };
  TuiOverscrollDirective.ɵfac = function TuiOverscrollDirective_Factory(t) {
    return new (t || TuiOverscrollDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.NgZone), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3));
  };
  TuiOverscrollDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiOverscrollDirective,
    selectors: [["", "tuiOverscroll", ""]],
    hostVars: 2,
    hostBindings: function TuiOverscrollDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵstyleProp"]("overscroll-behavior", ctx.overscrollBehavior);
      }
    },
    inputs: {
      mode: ["tuiOverscroll", "mode"]
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiOverscroll')], TuiOverscrollDirective.prototype, "mode", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('style.overscrollBehavior')], TuiOverscrollDirective.prototype, "overscrollBehavior", null);
  TuiOverscrollDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.NgZone)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3))], TuiOverscrollDirective);
  return TuiOverscrollDirective;
})();
let TuiOverscrollModule = /*#__PURE__*/(() => {
  let TuiOverscrollModule = class TuiOverscrollModule {};
  TuiOverscrollModule.ɵfac = function TuiOverscrollModule_Factory(t) {
    return new (t || TuiOverscrollModule)();
  };
  TuiOverscrollModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiOverscrollModule
  });
  TuiOverscrollModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiOverscrollModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiOverscrollModule, {
    declarations: [TuiOverscrollDirective],
    exports: [TuiOverscrollDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-overscroll.js.map
// EXTERNAL MODULE: ./node_modules/@angular/animations/fesm2015/animations.js
var animations = __webpack_require__(6083);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-animations.js

const TRANSITION = '{{duration}}ms ease-in-out';
const DURATION = {
  params: {
    duration: 300
  }
};
const STAGGER = 300;
const tuiHeightCollapse = (0,animations/* trigger */.X$)('tuiHeightCollapse', [(0,animations/* transition */.eR)(':enter', [(0,animations/* style */.oB)({
  height: 0
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  height: '*'
}))], DURATION), (0,animations/* transition */.eR)(':leave', [(0,animations/* style */.oB)({
  height: '*'
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  height: 0
}))], DURATION)]);
const tuiHeightCollapseList = (0,animations/* trigger */.X$)('tuiHeightCollapseList', [(0,animations/* transition */.eR)('* => *', [(0,animations/* query */.IO)(':enter', [(0,animations/* style */.oB)({
  height: 0
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  height: '*'
}))])], {
  optional: true
}), (0,animations/* query */.IO)(':leave', [(0,animations/* style */.oB)({
  height: '*'
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  height: 0
}))])], {
  optional: true
})], DURATION)]);
const tuiWidthCollapse = (0,animations/* trigger */.X$)('tuiWidthCollapse', [(0,animations/* transition */.eR)(':enter', [(0,animations/* style */.oB)({
  width: 0
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  width: '*'
}))], DURATION), (0,animations/* transition */.eR)(':leave', [(0,animations/* style */.oB)({
  width: '*'
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  width: 0
}))], DURATION)]);
const tuiWidthCollapseList = (0,animations/* trigger */.X$)('tuiWidthCollapseList', [(0,animations/* transition */.eR)('* => *', [(0,animations/* query */.IO)(':enter', [(0,animations/* style */.oB)({
  width: 0
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  width: '*'
}))])], {
  optional: true
}), (0,animations/* query */.IO)(':leave', [(0,animations/* style */.oB)({
  width: '*'
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  width: 0
}))])], {
  optional: true
})], DURATION)]);
const tuiFadeIn = (0,animations/* trigger */.X$)('tuiFadeIn', [(0,animations/* transition */.eR)(':enter', [(0,animations/* style */.oB)({
  opacity: 0
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  opacity: 1
}))], DURATION), (0,animations/* transition */.eR)(':leave', [(0,animations/* style */.oB)({
  opacity: 1
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  opacity: 0
}))], DURATION)]);
const tuiFadeInList = (0,animations/* trigger */.X$)('tuiFadeInList', [(0,animations/* transition */.eR)('* => *', [(0,animations/* query */.IO)(':enter', [(0,animations/* style */.oB)({
  opacity: 0
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  opacity: 1
}))])], {
  optional: true
}), (0,animations/* query */.IO)(':leave', [(0,animations/* style */.oB)({
  opacity: 1
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  opacity: 0
}))])], {
  optional: true
})], DURATION)]);
const tuiFadeInTop = (0,animations/* trigger */.X$)('tuiFadeInTop', [(0,animations/* transition */.eR)(':enter', [(0,animations/* style */.oB)({
  transform: 'translateY(-10px)',
  opacity: 0
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateY(0)',
  opacity: 1
}))], DURATION), (0,animations/* transition */.eR)(':leave', [(0,animations/* style */.oB)({
  transform: 'translateY(0)',
  opacity: 1
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateY(-10px)',
  opacity: 0
}))], DURATION)]);
const tuiFadeInBottom = (0,animations/* trigger */.X$)('tuiFadeInBottom', [(0,animations/* transition */.eR)(':enter', [(0,animations/* style */.oB)({
  transform: 'translateY(10px)',
  opacity: 0
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateY(0)',
  opacity: 1
}))], DURATION), (0,animations/* transition */.eR)(':leave', [(0,animations/* style */.oB)({
  transform: 'translateY(0)',
  opacity: 1
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateY(10px)',
  opacity: 0
}))], DURATION)]);
const tuiDropdownAnimation = (0,animations/* trigger */.X$)('tuiDropdownAnimation', [(0,animations/* transition */.eR)(`* => ${"fadeInTop" /* FadeInTop */}`, [(0,animations/* style */.oB)({
  transform: 'translateY(-10px)',
  opacity: 0
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateY(0)',
  opacity: 1
}))], DURATION), (0,animations/* transition */.eR)(`* => ${"fadeInBottom" /* FadeInBottom */}`, [(0,animations/* style */.oB)({
  transform: 'translateY(10px)',
  opacity: 0
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateY(0)',
  opacity: 1
}))], DURATION), (0,animations/* transition */.eR)(`${"fadeInBottom" /* FadeInBottom */} => *`, [(0,animations/* style */.oB)({
  transform: 'translateY(0)',
  opacity: 1
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateY(10px)',
  opacity: 0
}))], DURATION), (0,animations/* transition */.eR)(`${"fadeInTop" /* FadeInTop */} => *`, [(0,animations/* style */.oB)({
  transform: 'translateY(0)',
  opacity: 1
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateY(-10px)',
  opacity: 0
}))], DURATION)]);
const tuiScaleIn = (0,animations/* trigger */.X$)('tuiScaleIn', [(0,animations/* transition */.eR)(':enter', [(0,animations/* style */.oB)({
  transform: 'scale(0)'
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'scale(1)'
}))], DURATION), (0,animations/* transition */.eR)(':leave', [(0,animations/* style */.oB)({
  transform: 'scale(1)'
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'scale(0)'
}))], DURATION)]);
const tuiScaleInList = (0,animations/* trigger */.X$)('tuiScaleInList', [(0,animations/* transition */.eR)('* => *', [(0,animations/* query */.IO)(':enter', [(0,animations/* style */.oB)({
  transform: 'scale(0)'
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'scale(1)'
}))])], {
  optional: true
}), (0,animations/* query */.IO)(':leave', [(0,animations/* style */.oB)({
  transform: 'scale(1)'
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'scale(0)'
}))])], {
  optional: true
})], DURATION)]);
const tuiSlideIn = (0,animations/* trigger */.X$)('tuiSlideIn', [(0,animations/* transition */.eR)(`* => left`, [(0,animations/* style */.oB)({
  transform: 'translateX(-100%)'
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateX(0)'
}))], DURATION), (0,animations/* transition */.eR)('left => *', [(0,animations/* style */.oB)({
  transform: 'translateX(0)'
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateX(-100%)'
}))], DURATION), (0,animations/* transition */.eR)('* => right', [(0,animations/* style */.oB)({
  transform: 'translateX(100%)'
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateX(0)'
}))], DURATION), (0,animations/* transition */.eR)('right => *', [(0,animations/* style */.oB)({
  transform: 'translateX(0)'
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateX(100%)'
}))], DURATION)]);
const tuiSlideInLeft = (0,animations/* trigger */.X$)('tuiSlideInLeft', [(0,animations/* transition */.eR)(':enter', [(0,animations/* style */.oB)({
  transform: 'translateX(-100%)'
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateX(0)'
}))], DURATION), (0,animations/* transition */.eR)(':leave', [(0,animations/* style */.oB)({
  transform: 'translateX(0)'
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateX(-100%)'
}))], DURATION)]);
const tuiSlideInLeftList = (0,animations/* trigger */.X$)('tuiSlideInLeftList', [(0,animations/* transition */.eR)('* => *', [(0,animations/* query */.IO)(':enter', [(0,animations/* style */.oB)({
  transform: 'translateX(-100%)'
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateX(0)'
}))])], {
  optional: true
}), (0,animations/* query */.IO)(':leave', [(0,animations/* style */.oB)({
  transform: 'translateX(0)'
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateX(-100%)'
}))])], {
  optional: true
})], DURATION)]);
const tuiSlideInRight = (0,animations/* trigger */.X$)('tuiSlideInRight', [(0,animations/* transition */.eR)(':enter', [(0,animations/* style */.oB)({
  transform: 'translateX(100%)'
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateX(0)'
}))], DURATION), (0,animations/* transition */.eR)(':leave', [(0,animations/* style */.oB)({
  transform: 'translateX(0)'
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateX(100%)'
}))], DURATION)]);
const tuiSlideInRightList = (0,animations/* trigger */.X$)('tuiSlideInRightList', [(0,animations/* transition */.eR)('* => *', [(0,animations/* query */.IO)(':enter', [(0,animations/* style */.oB)({
  transform: 'translateX(100%)'
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateX(0)'
}))])], {
  optional: true
}), (0,animations/* query */.IO)(':leave', [(0,animations/* style */.oB)({
  transform: 'translateX(0)'
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateX(100%)'
}))])], {
  optional: true
})], DURATION)]);
const tuiSlideInTop = (0,animations/* trigger */.X$)('tuiSlideInTop', [(0,animations/* transition */.eR)(':enter', [(0,animations/* style */.oB)({
  transform: 'translate3d(0,{{start}},0)'
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translate3d(0,{{end}},0)'
}))], {
  params: {
    end: 0,
    start: '100%',
    duration: 300
  }
}), (0,animations/* transition */.eR)(':leave', [(0,animations/* style */.oB)({
  transform: 'translate3d(0,{{end}},0)'
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translate3d(0,{{start}},0)'
}))], {
  params: {
    end: 0,
    start: '100%',
    duration: 300
  }
})]);
const tuiSlideInTopList = (0,animations/* trigger */.X$)('tuiSlideInTopList', [(0,animations/* transition */.eR)('* => *', [(0,animations/* query */.IO)(':enter', [(0,animations/* style */.oB)({
  transform: 'translateY(100%)'
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateY(0)'
}))])], {
  optional: true
}), (0,animations/* query */.IO)(':leave', [(0,animations/* style */.oB)({
  transform: 'translateY(0)'
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateY(100%)'
}))])], {
  optional: true
})], DURATION)]);
const tuiSlideInBottom = (0,animations/* trigger */.X$)('tuiSlideInBottom', [(0,animations/* transition */.eR)(':enter', [(0,animations/* style */.oB)({
  transform: 'translateY(-100%)'
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateY(0)'
}))], DURATION), (0,animations/* transition */.eR)(':leave', [(0,animations/* style */.oB)({
  transform: 'translateY(0)'
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateY(-100%)'
}))], DURATION)]);
const tuiSlideInBottomList = (0,animations/* trigger */.X$)('tuiSlideInBottomList', [(0,animations/* transition */.eR)('* => *', [(0,animations/* query */.IO)(':enter', [(0,animations/* style */.oB)({
  transform: 'translateY(-100%)'
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateY(0)'
}))])], {
  optional: true
}), (0,animations/* query */.IO)(':leave', [(0,animations/* style */.oB)({
  transform: 'translateY(0)'
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: 'translateY(-100%)'
}))])], {
  optional: true
})], DURATION)]);

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-animations.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-constants.js
var taiga_ui_core_constants = __webpack_require__(8269);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-utils-dom.js
var taiga_ui_core_utils_dom = __webpack_require__(7766);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/interval.js
var interval = __webpack_require__(945);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/fromEvent.js
var fromEvent = __webpack_require__(2759);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-browser.js
var taiga_ui_cdk_utils_browser = __webpack_require__(1213);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-providers.js
var taiga_ui_core_providers = __webpack_require__(2130);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-scroll-controls.js














function TuiScrollControlsComponent_ng_container_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 3);
    core_js_["ɵɵelement"](1, "div", 4);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const bars_r1 = core_js_["ɵɵnextContext"]().tuiLet;
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵclassProp"]("bar_has-horizontal", bars_r1[1]);
    core_js_["ɵɵproperty"]("@tuiFadeIn", ctx_r2.animation);
  }
}
function TuiScrollControlsComponent_ng_container_0_div_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 5);
    core_js_["ɵɵelement"](1, "div", 6);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const bars_r1 = core_js_["ɵɵnextContext"]().tuiLet;
    const ctx_r3 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵclassProp"]("bar_has-vertical", bars_r1[0]);
    core_js_["ɵɵproperty"]("@tuiFadeIn", ctx_r3.animation);
  }
}
function TuiScrollControlsComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiScrollControlsComponent_ng_container_0_div_1_Template, 2, 3, "div", 1);
    core_js_["ɵɵtemplate"](2, TuiScrollControlsComponent_ng_container_0_div_2_Template, 2, 3, "div", 2);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const bars_r1 = ctx.tuiLet;
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", bars_r1[0]);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", bars_r1[1]);
  }
}
const MIN_WIDTH = 24;
// @dynamic
let TuiScrollbarDirective = /*#__PURE__*/(() => {
  let TuiScrollbarDirective = class TuiScrollbarDirective {
    constructor(ngZone, renderer, destroy$, wrapper, container, documentRef, windowRef, elementRef, viewportScroller) {
      this.wrapper = wrapper;
      this.container = container;
      this.documentRef = documentRef;
      this.windowRef = windowRef;
      this.elementRef = elementRef;
      this.viewportScroller = viewportScroller;
      this.tuiScrollbar = "vertical" /* Vertical */;
      const {
        nativeElement
      } = this.elementRef;
      const mousedown$ = (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, 'mousedown');
      const mousemove$ = (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(this.documentRef, 'mousemove');
      const mouseup$ = (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(this.documentRef, 'mouseup');
      const mousedownWrapper$ = (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(wrapper.nativeElement, 'mousedown');
      (0,merge/* merge */.T)(mousedownWrapper$.pipe((0,taiga_ui_cdk_observables/* preventDefault */.PF)(), (0,map/* map */.U)(event => this.getScrolled(event, 0.5, 0.5))), mousedown$.pipe((0,taiga_ui_cdk_observables/* preventDefault */.PF)(), (0,taiga_ui_cdk_observables/* stopPropagation */.UW)(), (0,switchMap/* switchMap */.w)(event => {
        const rect = nativeElement.getBoundingClientRect();
        const vertical = getOffsetVertical(event, rect);
        const horizontal = getOffsetHorizontal(event, rect);
        return mousemove$.pipe((0,map/* map */.U)(event => this.getScrolled(event, vertical, horizontal)), (0,takeUntil/* takeUntil */.R)(mouseup$));
      }))).pipe((0,takeUntil/* takeUntil */.R)(destroy$), (0,taiga_ui_cdk_observables/* tuiZonefree */.fL)(ngZone)).subscribe(([scrollTop, scrollLeft]) => {
        const [x, y] = this.viewportScroller.getScrollPosition();
        if (!this.container) {
          this.viewportScroller.scrollToPosition([this.tuiScrollbar === "vertical" /* Vertical */ ? x : scrollLeft, this.tuiScrollbar === "vertical" /* Vertical */ ? scrollTop : y]);
          return;
        }
        if (this.tuiScrollbar === "vertical" /* Vertical */) {
          renderer.setProperty(this.container.nativeElement, 'scrollTop', scrollTop);
        } else {
          renderer.setProperty(this.container.nativeElement, 'scrollLeft', scrollLeft);
        }
      });
      (0,merge/* merge */.T)((0,fromEvent/* fromEvent */.R)(this.container ? this.container.nativeElement : this.windowRef, 'scroll'), (0,interval/* interval */.F)(taiga_ui_cdk_constants/* POLLING_TIME */.Yg)).pipe((0,takeUntil/* takeUntil */.R)(destroy$), (0,taiga_ui_cdk_observables/* tuiZonefree */.fL)(ngZone)).subscribe(() => {
        if (this.tuiScrollbar === "vertical" /* Vertical */) {
          renderer.setStyle(nativeElement, 'top', `${this.thumb * 100}%`);
          renderer.setStyle(nativeElement, 'height', `${this.view * 100}%`);
        } else {
          renderer.setStyle(nativeElement, 'left', `${this.thumb * 100}%`);
          renderer.setStyle(nativeElement, 'width', `${this.view * 100}%`);
        }
      });
    }
    get scrolled() {
      const {
        scrollTop,
        scrollHeight,
        clientHeight,
        scrollLeft,
        scrollWidth,
        clientWidth
      } = this.computedContainer;
      return this.tuiScrollbar === "vertical" /* Vertical */ ? scrollTop / (scrollHeight - clientHeight) : scrollLeft / (scrollWidth - clientWidth);
    }
    get compensation() {
      const {
        clientHeight,
        scrollHeight,
        clientWidth,
        scrollWidth
      } = this.computedContainer;
      if (clientHeight * clientHeight / scrollHeight > MIN_WIDTH && this.tuiScrollbar === "vertical" /* Vertical */ || clientWidth * clientWidth / scrollWidth > MIN_WIDTH && this.tuiScrollbar === "horizontal" /* Horizontal */) {
        return 0;
      }
      return this.tuiScrollbar === "vertical" /* Vertical */ ? MIN_WIDTH / clientHeight : MIN_WIDTH / clientWidth;
    }
    get thumb() {
      const compensation = this.compensation || this.view;
      return this.scrolled * (1 - compensation);
    }
    get view() {
      const {
        clientHeight,
        scrollHeight,
        clientWidth,
        scrollWidth
      } = this.computedContainer;
      return this.tuiScrollbar === "vertical" /* Vertical */ ? Math.ceil(clientHeight / scrollHeight * 100) / 100 : Math.ceil(clientWidth / scrollWidth * 100) / 100;
    }
    get computedContainer() {
      return this.container ? this.container.nativeElement : this.documentRef.documentElement;
    }
    getScrolled({
      clientY,
      clientX
    }, offsetVertical, offsetHorizontal) {
      const {
        offsetHeight,
        offsetWidth
      } = this.elementRef.nativeElement;
      const {
        top,
        left,
        width,
        height
      } = this.wrapper.nativeElement.getBoundingClientRect();
      const maxTop = this.computedContainer.scrollHeight - height;
      const maxLeft = this.computedContainer.scrollWidth - width;
      const scrolledTop = (clientY - top - offsetHeight * offsetVertical) / (height - offsetHeight);
      const scrolledLeft = (clientX - left - offsetWidth * offsetHorizontal) / (width - offsetWidth);
      return [maxTop * scrolledTop, maxLeft * scrolledLeft];
    }
  };
  TuiScrollbarDirective.ɵfac = function TuiScrollbarDirective_Factory(t) {
    return new (t || TuiScrollbarDirective)(core_js_["ɵɵdirectiveInject"](core_js_.NgZone), core_js_["ɵɵdirectiveInject"](core_js_.Renderer2), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_ELEMENT_REF */.zP), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_SCROLL_REF */.$_, 8), core_js_["ɵɵdirectiveInject"](common_js_.DOCUMENT), core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* WINDOW */.m9), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](common_js_.ViewportScroller));
  };
  TuiScrollbarDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiScrollbarDirective,
    selectors: [["", "tuiScrollbar", ""]],
    inputs: {
      tuiScrollbar: "tuiScrollbar"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiScrollbarDirective.prototype, "tuiScrollbar", void 0);
  TuiScrollbarDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.NgZone)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.Renderer2)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_ELEMENT_REF */.zP)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_SCROLL_REF */.$_)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(common_js_.DOCUMENT)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(ng_web_apis_common/* WINDOW */.m9)), (0,tslib_es6/* __param */.fM)(7, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(8, (0,core_js_.Inject)(common_js_.ViewportScroller))], TuiScrollbarDirective);
  return TuiScrollbarDirective;
})();
function getOffsetVertical({
  clientY
}, {
  top,
  height
}) {
  return (clientY - top) / height;
}
function getOffsetHorizontal({
  clientX
}, {
  left,
  width
}) {
  return (clientX - left) / width;
}

// @dynamic
let TuiScrollControlsComponent = /*#__PURE__*/(() => {
  let TuiScrollControlsComponent = class TuiScrollControlsComponent {
    constructor(options, ngZone, documentRef, scrollRef, mode$) {
      this.options = options;
      this.ngZone = ngZone;
      this.documentRef = documentRef;
      this.scrollRef = scrollRef;
      this.mode$ = mode$;
      this.refresh$ = (0,interval/* interval */.F)(300).pipe((0,map/* map */.U)(() => this.scrollbars), (0,startWith/* startWith */.O)([false, false]), (0,distinctUntilChanged/* distinctUntilChanged */.x)((a, b) => a[0] === b[0] && a[1] === b[1]), (0,taiga_ui_cdk_observables/* tuiZoneOptimized */.Yr)(this.ngZone));
      this.animation = Object.assign({
        value: ''
      }, this.options);
    }
    get scrollbars() {
      const {
        clientHeight,
        scrollHeight,
        clientWidth,
        scrollWidth
      } = this.scrollRef ? this.scrollRef.nativeElement : this.documentRef.documentElement;
      return [Math.ceil(clientHeight / scrollHeight * 100) < 100, Math.ceil(clientWidth / scrollWidth * 100) < 100];
    }
  };
  TuiScrollControlsComponent.ɵfac = function TuiScrollControlsComponent_Factory(t) {
    return new (t || TuiScrollControlsComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw), core_js_["ɵɵdirectiveInject"](core_js_.NgZone), core_js_["ɵɵdirectiveInject"](common_js_.DOCUMENT), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_SCROLL_REF */.$_, 8), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_MODE */.Au));
  };
  TuiScrollControlsComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiScrollControlsComponent,
    selectors: [["tui-scroll-controls"]],
    hostBindings: function TuiScrollControlsComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("$.data-mode.attr", function TuiScrollControlsComponent___data_mode_attr_HostBindingHandler() {
          return ctx.mode$;
        });
      }
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_core_providers/* MODE_PROVIDER */.CV])],
    decls: 2,
    vars: 3,
    consts: [[4, "tuiLet"], ["tuiScrollbarWrapper", "", "class", "bar bar_vertical", 3, "bar_has-horizontal", 4, "ngIf"], ["tuiScrollbarWrapper", "", "class", "bar bar_horizontal", 3, "bar_has-vertical", 4, "ngIf"], ["tuiScrollbarWrapper", "", 1, "bar", "bar_vertical"], ["tuiScrollbar", "vertical", 1, "thumb"], ["tuiScrollbarWrapper", "", 1, "bar", "bar_horizontal"], ["tuiScrollbar", "horizontal", 1, "thumb"]],
    template: function TuiScrollControlsComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵtemplate"](0, TuiScrollControlsComponent_ng_container_0_Template, 3, 2, "ng-container", 0);
        core_js_["ɵɵpipe"](1, "async");
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("tuiLet", core_js_["ɵɵpipeBind1"](1, 1, ctx.refresh$));
      }
    },
    directives: function () {
      return [taiga_ui_cdk_directives_let/* TuiLetDirective */.Ls, common_js_.NgIf, TuiScrollbarWrapperDirective, TuiScrollbarDirective];
    },
    pipes: function () {
      return [common_js_.AsyncPipe];
    },
    styles: ["[_nghost-%COMP%]{position:-webkit-sticky;position:sticky;top:0;left:0;z-index:1;min-width:calc(100% - 1px);min-height:calc(100% - 1px);float:left;margin-right:calc(-100% + 1px);pointer-events:none}.bar[_ngcontent-%COMP%]{position:absolute;right:0;bottom:0;pointer-events:auto}.bar_vertical[_ngcontent-%COMP%]{top:0;width:14px}.bar_horizontal[_ngcontent-%COMP%]{left:0;height:14px}.bar_has-horizontal[_ngcontent-%COMP%]{bottom:8px}.bar_has-vertical[_ngcontent-%COMP%]{right:8px}.thumb[_ngcontent-%COMP%]{transition-duration:.15s;transition-timing-function:ease-in-out;position:absolute;border-radius:100px;border:4px solid transparent;cursor:pointer;pointer-events:auto;background:var(--tui-text-01);background-clip:content-box;box-sizing:border-box;transition-property:width,height;opacity:.2}.thumb[_ngcontent-%COMP%]:hover{opacity:.24}.thumb[_ngcontent-%COMP%]:active{opacity:.48}[data-mode=onDark][_nghost-%COMP%]   .thumb[_ngcontent-%COMP%]{background-color:var(--tui-text-01-night)}.bar_vertical[_ngcontent-%COMP%]   .thumb[_ngcontent-%COMP%]{right:0;width:12px;min-height:24px}.bar_vertical[_ngcontent-%COMP%]   .thumb[_ngcontent-%COMP%]:active, .bar_vertical[_ngcontent-%COMP%]:hover   .thumb[_ngcontent-%COMP%]{width:14px}.bar_horizontal[_ngcontent-%COMP%]   .thumb[_ngcontent-%COMP%]{bottom:0;height:12px;min-width:24px}.bar_horizontal[_ngcontent-%COMP%]   .thumb[_ngcontent-%COMP%]:active, .bar_horizontal[_ngcontent-%COMP%]:hover   .thumb[_ngcontent-%COMP%]{height:14px}"],
    data: {
      animation: [tuiFadeIn]
    },
    changeDetection: 0
  });
  TuiScrollControlsComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.NgZone)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(common_js_.DOCUMENT)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_SCROLL_REF */.$_)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_MODE */.Au))], TuiScrollControlsComponent);
  return TuiScrollControlsComponent;
})();
let TuiScrollbarWrapperDirective = /*#__PURE__*/(() => {
  let TuiScrollbarWrapperDirective = class TuiScrollbarWrapperDirective {};
  TuiScrollbarWrapperDirective.ɵfac = function TuiScrollbarWrapperDirective_Factory(t) {
    return new (t || TuiScrollbarWrapperDirective)();
  };
  TuiScrollbarWrapperDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiScrollbarWrapperDirective,
    selectors: [["", "tuiScrollbarWrapper", ""]],
    features: [core_js_["ɵɵProvidersFeature"]([{
      provide: taiga_ui_core_tokens/* TUI_ELEMENT_REF */.zP,
      useExisting: core_js_.ElementRef
    }])]
  });
  return TuiScrollbarWrapperDirective;
})();
let TuiScrollControlsModule = /*#__PURE__*/(() => {
  let TuiScrollControlsModule = class TuiScrollControlsModule {};
  TuiScrollControlsModule.ɵfac = function TuiScrollControlsModule_Factory(t) {
    return new (t || TuiScrollControlsModule)();
  };
  TuiScrollControlsModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiScrollControlsModule
  });
  TuiScrollControlsModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, taiga_ui_cdk_directives_let/* TuiLetModule */.WD]]
  });
  return TuiScrollControlsModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiScrollControlsModule, {
    declarations: function () {
      return [TuiScrollbarDirective, TuiScrollbarWrapperDirective, TuiScrollControlsComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, taiga_ui_cdk_directives_let/* TuiLetModule */.WD];
    },
    exports: function () {
      return [TuiScrollControlsComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-scroll-controls.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-scrollbar.js











function TuiScrollbarComponent_tui_scroll_controls_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-scroll-controls");
  }
}
const taiga_ui_core_components_scrollbar_c0 = ["*"];
let TuiScrollableDirective = /*#__PURE__*/(() => {
  let TuiScrollableDirective = class TuiScrollableDirective {};
  TuiScrollableDirective.ɵfac = function TuiScrollableDirective_Factory(t) {
    return new (t || TuiScrollableDirective)();
  };
  TuiScrollableDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiScrollableDirective,
    selectors: [["", "tuiScrollable", ""]]
  });
  return TuiScrollableDirective;
})();
var TuiScrollbarComponent_1;
function scrollRefFactory({
  browserScrollRef
}) {
  return browserScrollRef;
}
// @dynamic
let TuiScrollbarComponent = TuiScrollbarComponent_1 = class TuiScrollbarComponent {
  constructor(
  /**
   * TODO: remove "any" in new TS version; https://github.com/ng-web-apis/common/pull/6
   */
  cssRef, elementRef, userAgent) {
    this.cssRef = cssRef;
    this.elementRef = elementRef;
    this.userAgent = userAgent;
    this.hidden = false;
    this.isLegacy = !this.cssRef.supports('position', 'sticky') || (0,taiga_ui_cdk_utils_browser/* isFirefox */.vU)(this.userAgent) && !this.cssRef.supports('scrollbar-width', 'none');
  }
  get showScrollbars() {
    return !this.hidden && (!this.isLegacy || !!this.scrollable);
  }
  get browserScrollRef() {
    return this.scrollable || this.elementRef;
  }
  get showNative() {
    return this.isLegacy && !this.hidden && !this.scrollable;
  }
  scrollIntoView(event) {
    const {
      detail
    } = event;
    const {
      nativeElement
    } = this.browserScrollRef;
    event.stopPropagation();
    const {
      offsetTop,
      offsetLeft
    } = (0,taiga_ui_cdk_utils_dom/* getElementOffset */.pW)(nativeElement, detail);
    nativeElement.scrollTop = offsetTop + detail.offsetHeight / 2 - nativeElement.clientHeight / 2;
    nativeElement.scrollLeft = offsetLeft + detail.offsetWidth / 2 - nativeElement.clientWidth / 2;
  }
};
TuiScrollbarComponent.ɵfac = function TuiScrollbarComponent_Factory(t) {
  return new (t || TuiScrollbarComponent)(core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* CSS */.ux), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* USER_AGENT */.yZ));
};
TuiScrollbarComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiScrollbarComponent,
  selectors: [["tui-scrollbar"]],
  contentQueries: function TuiScrollbarComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      core_js_["ɵɵcontentQuery"](dirIndex, TuiScrollableDirective, 5, core_js_.ElementRef);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.scrollable = _t.first);
    }
  },
  hostVars: 4,
  hostBindings: function TuiScrollbarComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵlistener"]("tui-scroll-into-view", function TuiScrollbarComponent_tui_scroll_into_view_HostBindingHandler($event) {
        return ctx.scrollIntoView($event);
      });
    }
    if (rf & 2) {
      core_js_["ɵɵclassProp"]("_legacy", ctx.showNative)("_container", ctx.scrollable);
    }
  },
  inputs: {
    hidden: "hidden"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_core_tokens/* TUI_SCROLL_REF */.$_,
    deps: [TuiScrollbarComponent_1],
    useFactory: scrollRefFactory
  }])],
  ngContentSelectors: taiga_ui_core_components_scrollbar_c0,
  decls: 3,
  vars: 1,
  consts: [[4, "ngIf"], [1, "content"]],
  template: function TuiScrollbarComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"]();
      core_js_["ɵɵtemplate"](0, TuiScrollbarComponent_tui_scroll_controls_0_Template, 1, 0, "tui-scroll-controls", 0);
      core_js_["ɵɵelementStart"](1, "div", 1);
      core_js_["ɵɵprojection"](2);
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      core_js_["ɵɵproperty"]("ngIf", ctx.showScrollbars);
    }
  },
  directives: [common_js_.NgIf, TuiScrollControlsComponent],
  styles: ["[_nghost-%COMP%]{z-index:0;position:relative;display:flex;overflow:auto}[_nghost-%COMP%]:not(._legacy){scrollbar-width:none;-ms-overflow-style:none}[_nghost-%COMP%]:not(._legacy)::-webkit-scrollbar, [_nghost-%COMP%]:not(._legacy)::-webkit-scrollbar-thumb{background:0 0;width:0;height:0}._legacy[_nghost-%COMP%]{overflow:overlay}@media all and (-webkit-min-device-pixel-ratio:0) and (min-resolution:0.001dpcm){._legacy[_nghost-%COMP%]::-webkit-scrollbar, ._legacy[_nghost-%COMP%]::-webkit-scrollbar-thumb{width:16px;height:16px;border-radius:100px;background-clip:padding-box;border:6px solid transparent}._legacy[_nghost-%COMP%]::-webkit-scrollbar{background-color:transparent}._legacy[_nghost-%COMP%]::-webkit-scrollbar-thumb{background-color:var(--tui-clear-hover)}._legacy[_nghost-%COMP%]::-webkit-scrollbar-thumb:hover{background-color:var(--tui-clear-active)}._legacy[_nghost-%COMP%]::-webkit-scrollbar-thumb:active{background-color:var(--tui-text-03)}}._container[_nghost-%COMP%]   tui-scroll-controls[_ngcontent-%COMP%]{position:absolute}.content[_ngcontent-%COMP%]{position:relative;z-index:0;flex:1;flex-basis:auto;width:100%;height:-webkit-max-content;height:-moz-max-content;height:max-content}"],
  changeDetection: 0
});
TuiScrollbarComponent.ctorParameters = () => [{
  type: undefined,
  decorators: [{
    type: core_js_.Inject,
    args: [ng_web_apis_common/* CSS */.ux]
  }]
}, {
  type: core_js_.ElementRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ElementRef]
  }]
}, {
  type: String,
  decorators: [{
    type: core_js_.Inject,
    args: [ng_web_apis_common/* USER_AGENT */.yZ]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiScrollbarComponent.prototype, "hidden", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._container'), (0,core_js_.ContentChild)(TuiScrollableDirective, {
  read: core_js_.ElementRef
})], TuiScrollbarComponent.prototype, "scrollable", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._legacy')], TuiScrollbarComponent.prototype, "showNative", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)(taiga_ui_core_constants/* TUI_SCROLL_INTO_VIEW */.fe, ['$event'])], TuiScrollbarComponent.prototype, "scrollIntoView", null);
TuiScrollbarComponent = TuiScrollbarComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(ng_web_apis_common/* CSS */.ux)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(ng_web_apis_common/* USER_AGENT */.yZ))], TuiScrollbarComponent);
const SCROLL_REF_SELECTOR = '[tuiScrollRef]';
let TuiScrollRefDirective = /*#__PURE__*/(() => {
  let TuiScrollRefDirective = class TuiScrollRefDirective {};
  TuiScrollRefDirective.ɵfac = function TuiScrollRefDirective_Factory(t) {
    return new (t || TuiScrollRefDirective)();
  };
  TuiScrollRefDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiScrollRefDirective,
    selectors: [["", "tuiScrollRef", ""]],
    features: [core_js_["ɵɵProvidersFeature"]([{
      provide: taiga_ui_core_tokens/* TUI_SCROLL_REF */.$_,
      useExisting: core_js_.ElementRef
    }])]
  });
  return TuiScrollRefDirective;
})();
let TuiScrollbarModule = /*#__PURE__*/(() => {
  let TuiScrollbarModule = class TuiScrollbarModule {};
  TuiScrollbarModule.ɵfac = function TuiScrollbarModule_Factory(t) {
    return new (t || TuiScrollbarModule)();
  };
  TuiScrollbarModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiScrollbarModule
  });
  TuiScrollbarModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, TuiScrollControlsModule]]
  });
  return TuiScrollbarModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiScrollbarModule, {
    declarations: function () {
      return [TuiScrollbarComponent, TuiScrollRefDirective, TuiScrollableDirective];
    },
    imports: function () {
      return [common_js_.CommonModule, TuiScrollControlsModule];
    },
    exports: function () {
      return [TuiScrollbarComponent, TuiScrollRefDirective, TuiScrollableDirective];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-scrollbar.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-directives-mode.js
var taiga_ui_core_directives_mode = __webpack_require__(5452);
// EXTERNAL MODULE: ./node_modules/@tinkoff/ng-polymorpheus/fesm2015/tinkoff-ng-polymorpheus.js
var tinkoff_ng_polymorpheus = __webpack_require__(9570);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-dropdown-box.js














/**
 *  This component is used to show template in a portal using default style of white rounded box with a shadow
 */
// @bad TODO: OnPush
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic





const taiga_ui_core_components_dropdown_box_c0 = ["content"];
let TuiDropdownBoxComponent = /*#__PURE__*/(() => {
  let TuiDropdownBoxComponent = class TuiDropdownBoxComponent {
    constructor(destroy$, ngZone, directive, windowRef, elementRef, portalHost, options) {
      this.directive = directive;
      this.windowRef = windowRef;
      this.elementRef = elementRef;
      this.portalHost = portalHost;
      this.options = options;
      this.animationTop = Object.assign({
        value: "fadeInTop" /* FadeInTop */
      }, this.options);
      this.animationBottom = Object.assign({
        value: "fadeInBottom" /* FadeInBottom */
      }, this.options);
      /**
       * Is previous position on top (to prevent jumping up and down on scroll)
       */
      this.prevDirectionIsTop = false;
      (0,merge/* merge */.T)((0,interval/* interval */.F)(taiga_ui_cdk_constants/* POLLING_TIME */.Yg), this.directive.refresh$, (0,fromEvent/* fromEvent */.R)(this.windowRef, 'resize')).pipe((0,taiga_ui_cdk_observables/* tuiZonefree */.fL)(ngZone), (0,takeUntil/* takeUntil */.R)(destroy$)).subscribe(() => {
        this.calculatePositionAndSize();
      });
    }
    get overscroll() {
      return this.inModal ? "all" /* All */ : "scroll" /* Scroll */;
    }

    ngAfterViewChecked() {
      this.calculatePositionAndSize();
    }
    onTopFocus() {
      this.moveFocusOutside(true);
    }
    onBottomFocus() {
      this.moveFocusOutside(false);
    }
    get inModal() {
      // @awful TODO: get rid of component tag name dependency
      return !!(0,taiga_ui_cdk_utils_dom/* getClosestElement */.Q4)(this.directive.host, 'tui-dialog-host');
    }
    calculatePositionAndSize() {
      const {
        clientRect
      } = this.directive;
      const {
        style
      } = this.elementRef.nativeElement;
      const hostRect = this.directive.fixed ? this.portalHost.fixedPositionOffset() : this.portalHost.clientRect;
      style.position = this.directive.fixed ? 'fixed' : 'absolute';
      this.calculateVerticalPosition(style, clientRect, hostRect);
      this.calculateHorizontalPosition(style, clientRect, hostRect);
      this.calculateWidth(style, clientRect);
    }
    getFinalAlign(style, directiveRect) {
      const dropdownRect = this.elementRef.nativeElement.getBoundingClientRect();
      const dropdownWidth = this.elementRef.nativeElement.offsetWidth;
      const screenWidth = (0,taiga_ui_core_utils_dom/* getScreenWidth */.zP)(this.windowRef.document);
      const isDropdownSizeHypotheticallyFitsViewport = directiveRect.left + dropdownWidth < screenWidth || directiveRect.right - dropdownWidth > 0;
      const isDropdownSizeActuallyFitsViewport = dropdownRect.right <= screenWidth && dropdownRect.left >= 0;
      let finalAlign = this.directive.align;
      switch (this.directive.align) {
        case 'left':
          if (isDropdownSizeHypotheticallyFitsViewport && dropdownRect.right > screenWidth) {
            finalAlign = 'right';
          }
          break;
        case 'right':
          if (isDropdownSizeHypotheticallyFitsViewport && dropdownRect.left < 0) {
            finalAlign = 'left';
          }
          break;
      }
      if (style.right === 'auto' && isDropdownSizeActuallyFitsViewport) {
        finalAlign = 'left';
      }
      if (style.left === 'auto' && isDropdownSizeActuallyFitsViewport) {
        finalAlign = 'right';
      }
      return finalAlign;
    }
    /**
     * Calculates horizontal position
     *
     * @param style dropdownBox elementRef styles object
     * @param directiveRect ClientRect of hosting directive
     * @param hostRect ClientRect of  portal host
     */
    calculateHorizontalPosition(style, directiveRect, hostRect) {
      const offset = this.directive.sided ? this.elementRef.nativeElement.getBoundingClientRect().width + taiga_ui_core_constants/* DEFAULT_MARGIN */.jK : 0;
      const left = Math.ceil(directiveRect.left - hostRect.left - offset);
      const right = Math.floor(hostRect.right - directiveRect.right - offset);
      switch (this.getFinalAlign(style, directiveRect)) {
        case 'left':
          if (right + taiga_ui_core_constants/* DEFAULT_MARGIN */.jK > this.windowRef.innerWidth || (0,taiga_ui_cdk_utils_math/* inRange */.Z2)(left + taiga_ui_core_constants/* DEFAULT_MARGIN */.jK, 0, this.windowRef.innerWidth)) {
            style.left = px(left);
            style.right = 'auto';
          } else {
            style.left = 'auto';
            style.right = px(right);
          }
          break;
        case 'right':
          if ((0,taiga_ui_cdk_utils_math/* inRange */.Z2)(right + taiga_ui_core_constants/* DEFAULT_MARGIN */.jK, 0, this.windowRef.innerWidth) || left + taiga_ui_core_constants/* DEFAULT_MARGIN */.jK > this.windowRef.innerWidth) {
            style.left = 'auto';
            style.right = px(right);
          } else {
            style.left = px(left);
            style.right = 'auto';
          }
          break;
      }
    }
    /**
     * Calculates vertical position and height
     *
     * @param style dropdownBox elementRef styles object
     * @param directiveRect ClientRect of hosting directive
     * @param hostRect ClientRect of  portal host
     */
    calculateVerticalPosition(style, directiveRect, hostRect) {
      const windowHeight = this.windowRef.innerHeight;
      // Maximum height of the box
      const boxHeightLimit = Math.min(this.directive.maxHeight, windowHeight - taiga_ui_core_constants/* DEFAULT_MARGIN */.jK * 2);
      const offset = this.directive.sided ? taiga_ui_core_constants/* DEFAULT_MARGIN */.jK - directiveRect.height : taiga_ui_core_constants/* DEFAULT_MARGIN */.jK * 2;
      const topAvailableHeight = directiveRect.top - offset;
      const bottomAvailableHeight = windowHeight - directiveRect.bottom - offset;
      const finalDirection = this.getFinalDirection(directiveRect);
      this.prevDirectionIsTop = finalDirection === 'top';
      if (finalDirection === 'top') {
        this.dropdownAnimation = this.animationBottom;
        style.maxHeight = px(Math.min(boxHeightLimit, topAvailableHeight));
        style.top = 'auto';
        style.bottom = px(hostRect.bottom - directiveRect.top - taiga_ui_core_constants/* DEFAULT_MARGIN */.jK + offset);
      } else {
        this.dropdownAnimation = this.animationTop;
        style.maxHeight = px(Math.min(boxHeightLimit, bottomAvailableHeight));
        style.top = px(directiveRect.bottom - hostRect.top - taiga_ui_core_constants/* DEFAULT_MARGIN */.jK + offset);
        style.bottom = 'auto';
      }
    }
    getFinalDirection(directiveRect) {
      const windowHeight = this.windowRef.innerHeight;
      const offset = this.directive.sided ? taiga_ui_core_constants/* DEFAULT_MARGIN */.jK - directiveRect.height : taiga_ui_core_constants/* DEFAULT_MARGIN */.jK * 2;
      // Maximum space available on top and on the bottom in the viewport
      const topAvailableHeight = directiveRect.top - offset;
      const bottomAvailableHeight = windowHeight - directiveRect.bottom - offset;
      let finalDirection = null;
      // Given direction is applied if we can fit the box in the limits that way
      switch (this.directive.direction) {
        case 'top':
          if (topAvailableHeight >= this.directive.minHeight) {
            finalDirection = 'top';
          }
          break;
        case 'bottom':
          if (bottomAvailableHeight >= this.directive.minHeight) {
            finalDirection = 'bottom';
          }
          break;
      }
      // Maximum height of the box
      const boxHeightLimit = Math.min(this.directive.maxHeight, windowHeight - taiga_ui_core_constants/* DEFAULT_MARGIN */.jK * 2);
      // Choose direction if given direction did not fit
      if (finalDirection === null && this.contentElementRef) {
        // Box height if it fits without scroll
        const visualHeight = Math.min(this.contentElementRef.nativeElement.getBoundingClientRect().height + (this.elementRef.nativeElement.offsetHeight - this.elementRef.nativeElement.clientHeight), boxHeightLimit);
        // If there is enough space to fit below without scroll,
        // choose 'bottom', unless it was previously on the top
        if (this.prevDirectionIsTop && topAvailableHeight >= visualHeight) {
          finalDirection = 'top';
        } else if (bottomAvailableHeight >= visualHeight) {
          finalDirection = 'bottom';
        } else {
          // Corner case — select direction with more space
          finalDirection = bottomAvailableHeight >= topAvailableHeight ? 'bottom' : 'top';
        }
      }
      return finalDirection;
    }
    /**
     * Calculates width
     *
     * @param style dropdownBox elementRef styles object
     * @param directiveRect ClientRect of hosting directive
     */
    calculateWidth(style, directiveRect) {
      style.width = this.directive.limitMinWidth === "fixed" /* Fixed */ && !this.directive.sided ? px(directiveRect.width) : '';
      if (this.directive.limitMinWidth === "min" /* Min */ && !this.directive.sided) {
        style.minWidth = px(directiveRect.width);
        style.maxWidth = px(taiga_ui_core_constants/* DEFAULT_MAX_WIDTH */.yA);
        return;
      }
      style.minWidth = '';
      style.maxWidth = '';
    }
    moveFocusOutside(previous) {
      const {
        host
      } = this.directive;
      const {
        ownerDocument
      } = host;
      const root = ownerDocument ? ownerDocument.body : host;
      let focusable = (0,taiga_ui_cdk_utils_focus/* getClosestFocusable */.kA)(host, previous, root);
      while (focusable !== null && host.contains(focusable)) {
        focusable = (0,taiga_ui_cdk_utils_focus/* getClosestFocusable */.kA)(focusable, previous, root);
      }
      if (focusable === null) {
        return;
      }
      (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(focusable);
    }
  };
  TuiDropdownBoxComponent.ɵfac = function TuiDropdownBoxComponent_Factory(t) {
    return new (t || TuiDropdownBoxComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3), core_js_["ɵɵdirectiveInject"](core_js_.NgZone), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_DROPDOWN_DIRECTIVE */.Jd), core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* WINDOW */.m9), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](TuiPortalHostComponent), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw));
  };
  TuiDropdownBoxComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDropdownBoxComponent,
    selectors: [["tui-dropdown-box"]],
    viewQuery: function TuiDropdownBoxComponent_Query(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵviewQuery"](taiga_ui_core_components_dropdown_box_c0, 5, core_js_.ElementRef);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.contentElementRef = _t.first);
      }
    },
    hostVars: 1,
    hostBindings: function TuiDropdownBoxComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵsyntheticHostProperty"]("@tuiDropdownAnimation", ctx.dropdownAnimation);
      }
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])],
    decls: 6,
    vars: 4,
    consts: [[1, "wrapper", 3, "tuiOverscroll", "tuiMode", "tuiActiveZoneParent"], [1, "scroll"], ["tabindex", "0", 3, "focus"], ["polymorpheus-outlet", "", 1, "content", 3, "content"], ["content", ""]],
    template: function TuiDropdownBoxComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵelementStart"](0, "div", 0);
        core_js_["ɵɵelementStart"](1, "tui-scrollbar", 1);
        core_js_["ɵɵelementStart"](2, "div", 2);
        core_js_["ɵɵlistener"]("focus", function TuiDropdownBoxComponent_Template_div_focus_2_listener() {
          return ctx.onTopFocus();
        });
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelement"](3, "div", 3, 4);
        core_js_["ɵɵelementStart"](5, "div", 2);
        core_js_["ɵɵlistener"]("focus", function TuiDropdownBoxComponent_Template_div_focus_5_listener() {
          return ctx.onBottomFocus();
        });
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("tuiOverscroll", ctx.overscroll)("tuiMode", null)("tuiActiveZoneParent", ctx.directive.activeZone);
        core_js_["ɵɵadvance"](3);
        core_js_["ɵɵproperty"]("content", ctx.directive.content);
      }
    },
    directives: [TuiOverscrollDirective, taiga_ui_core_directives_mode/* TuiModeDirective */.w, TuiActiveZoneDirective, TuiScrollbarComponent, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1],
    styles: ["[_nghost-%COMP%]{z-index:0;box-shadow:0 8px 16px rgba(51,51,51,.2);position:absolute;top:0;left:0;display:flex;background-color:#fff;background-color:var(--tui-base-01);border-radius:var(--tui-radius-m);overflow:hidden;border:1px solid var(--tui-base-03);box-sizing:border-box}.ng-animating[_nghost-%COMP%]{pointer-events:none}.content[_ngcontent-%COMP%]{display:flex;flex-direction:column;max-height:100%}.wrapper[_ngcontent-%COMP%]{flex-grow:1;max-width:100%;max-height:inherit;overflow:visible}.scroll[_ngcontent-%COMP%]{height:100%}"],
    data: {
      animation: [tuiDropdownAnimation]
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('@tuiDropdownAnimation')], TuiDropdownBoxComponent.prototype, "dropdownAnimation", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('content', {
    read: core_js_.ElementRef
  })], TuiDropdownBoxComponent.prototype, "contentElementRef", void 0);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDropdownBoxComponent.prototype, "inModal", null);
  TuiDropdownBoxComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.NgZone)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_DROPDOWN_DIRECTIVE */.Jd)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(ng_web_apis_common/* WINDOW */.m9)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(TuiPortalHostComponent)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw))], TuiDropdownBoxComponent);
  return TuiDropdownBoxComponent;
})();
let TuiDropdownBoxModule = /*#__PURE__*/(() => {
  let TuiDropdownBoxModule = class TuiDropdownBoxModule {};
  TuiDropdownBoxModule.ɵfac = function TuiDropdownBoxModule_Factory(t) {
    return new (t || TuiDropdownBoxModule)();
  };
  TuiDropdownBoxModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDropdownBoxModule
  });
  TuiDropdownBoxModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[TuiActiveZoneModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiOverscrollModule, TuiScrollbarModule, taiga_ui_core_directives_mode/* TuiModeModule */.z]]
  });
  return TuiDropdownBoxModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDropdownBoxModule, {
    declarations: function () {
      return [TuiDropdownBoxComponent];
    },
    imports: function () {
      return [TuiActiveZoneModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiOverscrollModule, TuiScrollbarModule, taiga_ui_core_directives_mode/* TuiModeModule */.z];
    },
    exports: function () {
      return [TuiDropdownBoxComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-dropdown-box.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-services.js
var taiga_ui_core_services = __webpack_require__(7941);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-abstract.js








// @bad TODO: Possibly refactor to make more abstract



let AbstractTuiDropdown = /*#__PURE__*/(() => {
  let AbstractTuiDropdown = class AbstractTuiDropdown {
    constructor(componentFactoryResolver, injector, portalService, elementRef, activeZone) {
      this.componentFactoryResolver = componentFactoryResolver;
      this.injector = injector;
      this.portalService = portalService;
      this.elementRef = elementRef;
      this.activeZone = activeZone;
      this.content = '';
      this.tuiDropdownHost = null;
      this.minHeight = taiga_ui_core_constants/* DEFAULT_MIN_HEIGHT */.q_;
      this.maxHeight = taiga_ui_core_constants/* DEFAULT_MAX_HEIGHT */.ze;
      this.align = 'left';
      this.direction = null;
      this.sided = false;
      this.limitMinWidth = "min" /* Min */;
      this.dropdownBoxRef = null;
    }
    ngOnDestroy() {
      this.closeDropdownBox();
    }
    ngAfterViewChecked() {
      // @awful TODO: This is probably wrong to call both but in TuiHostedDropdown some changes do not propagate otherwise
      if (this.dropdownBoxRef !== null) {
        this.dropdownBoxRef.changeDetectorRef.detectChanges();
        this.dropdownBoxRef.changeDetectorRef.markForCheck();
      }
    }
    get clientRect() {
      return this.elementRef.nativeElement.getBoundingClientRect();
    }
    get host() {
      return this.tuiDropdownHost || this.elementRef.nativeElement;
    }
    get fixed() {
      return (0,taiga_ui_core_utils_dom/* checkFixedPosition */.rn)(this.elementRef.nativeElement);
    }
    openDropdownBox() {
      if (this.dropdownBoxRef !== null) {
        return;
      }
      const componentFactory = this.componentFactoryResolver.resolveComponentFactory(TuiDropdownBoxComponent);
      this.dropdownBoxRef = this.portalService.add(componentFactory, this.injector);
      this.dropdownBoxRef.changeDetectorRef.detectChanges();
    }
    closeDropdownBox() {
      if (this.dropdownBoxRef === null) {
        return;
      }
      this.portalService.remove(this.dropdownBoxRef);
      this.dropdownBoxRef = null;
    }
  };
  AbstractTuiDropdown.ɵfac = function AbstractTuiDropdown_Factory(t) {
    return new (t || AbstractTuiDropdown)(core_js_["ɵɵdirectiveInject"](core_js_.ComponentFactoryResolver), core_js_["ɵɵdirectiveInject"](core_js_.Injector), core_js_["ɵɵdirectiveInject"](TuiPortalService), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](TuiActiveZoneDirective));
  };
  AbstractTuiDropdown.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: AbstractTuiDropdown,
    inputs: {
      content: ["tuiDropdownContent", "content"],
      tuiDropdownHost: "tuiDropdownHost",
      minHeight: ["tuiDropdownMinHeight", "minHeight"],
      maxHeight: ["tuiDropdownMaxHeight", "maxHeight"],
      align: ["tuiDropdownAlign", "align"],
      direction: ["tuiDropdownDirection", "direction"],
      sided: ["tuiDropdownSided", "sided"],
      limitMinWidth: ["tuiDropdownLimitWidth", "limitMinWidth"]
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdownContent'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiDropdown.prototype, "content", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdownHost'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiDropdown.prototype, "tuiDropdownHost", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdownMinHeight'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiDropdown.prototype, "minHeight", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdownMaxHeight'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiDropdown.prototype, "maxHeight", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdownAlign'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiDropdown.prototype, "align", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdownDirection'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiDropdown.prototype, "direction", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdownSided'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiDropdown.prototype, "sided", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdownLimitWidth'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiDropdown.prototype, "limitMinWidth", void 0);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], AbstractTuiDropdown.prototype, "fixed", null);
  return AbstractTuiDropdown;
})();
let AbstractTuiHint = /*#__PURE__*/(() => {
  let AbstractTuiHint = class AbstractTuiHint {
    constructor(elementRef, hintService) {
      this.elementRef = elementRef;
      this.hintService = hintService;
      this.mode = null;
      this.direction = 'bottom-left';
      this.content = '';
    }
    ngOnDestroy() {
      this.hideTooltip();
    }
    showTooltip() {
      this.hintService.add(this);
    }
    hideTooltip() {
      this.hintService.remove(this);
    }
  };
  AbstractTuiHint.ɵfac = function AbstractTuiHint_Factory(t) {
    return new (t || AbstractTuiHint)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_services/* TuiHintService */.BN));
  };
  AbstractTuiHint.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: AbstractTuiHint,
    inputs: {
      mode: ["tuiHintMode", "mode"],
      direction: ["tuiHintDirection", "direction"]
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiHintMode'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiHint.prototype, "mode", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiHintDirection'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiHint.prototype, "direction", void 0);
  return AbstractTuiHint;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-abstract.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-directives-dropdown.js








var TuiDropdownDirective_1;
let TuiDropdownDirective = TuiDropdownDirective_1 = class TuiDropdownDirective extends AbstractTuiDropdown {
  constructor(componentFactoryResolver, injector, portalService, elementRef, activeZone, refresh$) {
    super(componentFactoryResolver, injector, portalService, elementRef, activeZone);
    this.refresh$ = refresh$;
  }
  set open(value) {
    if (value) {
      this.openDropdownBox();
    } else {
      this.closeDropdownBox();
    }
  }
};
TuiDropdownDirective.ɵfac = function TuiDropdownDirective_Factory(t) {
  return new (t || TuiDropdownDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ComponentFactoryResolver), core_js_["ɵɵdirectiveInject"](core_js_.Injector), core_js_["ɵɵdirectiveInject"](TuiPortalService), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](TuiActiveZoneDirective, 8), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiParentsScrollService */.b0));
};
TuiDropdownDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiDropdownDirective,
  selectors: [["", "tuiDropdown", "", 5, "ng-container"]],
  inputs: {
    open: ["tuiDropdown", "open"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_core_tokens/* TUI_DROPDOWN_DIRECTIVE */.Jd,
    useExisting: (0,core_js_.forwardRef)(() => TuiDropdownDirective_1)
  }, taiga_ui_cdk_services/* TuiParentsScrollService */.b0]), core_js_["ɵɵInheritDefinitionFeature"]]
});
TuiDropdownDirective.ctorParameters = () => [{
  type: core_js_.ComponentFactoryResolver,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ComponentFactoryResolver]
  }]
}, {
  type: core_js_.Injector,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.Injector]
  }]
}, {
  type: TuiPortalService,
  decorators: [{
    type: core_js_.Inject,
    args: [TuiPortalService]
  }]
}, {
  type: core_js_.ElementRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ElementRef]
  }]
}, {
  type: TuiActiveZoneDirective,
  decorators: [{
    type: core_js_.Inject,
    args: [TuiActiveZoneDirective]
  }, {
    type: core_js_.Optional
  }]
}, {
  type: taiga_ui_cdk_services/* TuiParentsScrollService */.b0,
  decorators: [{
    type: core_js_.Inject,
    args: [taiga_ui_cdk_services/* TuiParentsScrollService */.b0]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdown')], TuiDropdownDirective.prototype, "open", null);
TuiDropdownDirective = TuiDropdownDirective_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ComponentFactoryResolver)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.Injector)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(TuiPortalService)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(TuiActiveZoneDirective)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiParentsScrollService */.b0))], TuiDropdownDirective);
let TuiDropdownModule = /*#__PURE__*/(() => {
  let TuiDropdownModule = class TuiDropdownModule {};
  TuiDropdownModule.ɵfac = function TuiDropdownModule_Factory(t) {
    return new (t || TuiDropdownModule)();
  };
  TuiDropdownModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDropdownModule
  });
  TuiDropdownModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[TuiDropdownBoxModule]]
  });
  return TuiDropdownModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDropdownModule, {
    declarations: function () {
      return [TuiDropdownDirective];
    },
    imports: function () {
      return [TuiDropdownBoxModule];
    },
    exports: function () {
      return [TuiDropdownDirective];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-directives-dropdown.js.map
// EXTERNAL MODULE: ./node_modules/@angular/platform-browser/fesm2015/platform-browser.js
var platform_browser = __webpack_require__(1211);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/concat.js + 1 modules
var concat = __webpack_require__(8071);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/defer.js
var defer = __webpack_require__(1439);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/takeWhile.js
var takeWhile = __webpack_require__(409);
;// CONCATENATED MODULE: ./node_modules/@tinkoff/ng-event-plugins/fesm2015/tinkoff-ng-event-plugins.js





/**
 * @fileoverview added by tsickle
 * Generated from: utils/dasharize.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} camel
 * @return {?}
 */

function dasharize(camel) {
  return camel.replace(/[a-z][A-Z]/g,
  /**
  * @param {?} letterLetter
  * @return {?}
  */
  letterLetter => {
    return `${letterLetter[0]}-${letterLetter[1].toLowerCase()}`;
  });
}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/abstract.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class AbstractEventPlugin {
  /**
   * @param {?} event
   * @return {?}
   */
  supports(event) {
    return event.split('.').indexOf(this.modifier) !== -1;
  }
  /**
   * @param {?} _element
   * @param {?} _event
   * @param {?} _handler
   * @return {?}
   */
  addGlobalEventListener(_element, _event, _handler) {
    throw new Error(`Global event targets are not supported by ${this.modifier} plugin`);
  }
  /**
   * @protected
   * @param {?} event
   * @return {?}
   */
  unwrap(event) {
    return event.split('.').filter(
    /**
    * @param {?} v
    * @return {?}
    */
    v => v !== this.modifier).join('.');
  }
}
if (false) {}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/bind.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
let BindEventPlugin = /*#__PURE__*/(() => {
  class BindEventPlugin extends AbstractEventPlugin {
    constructor() {
      super(...arguments);
      this.modifier = '$';
    }
    /**
     * @param {?} element
     * @param {?} event
     * @return {?}
     */
    addEventListener(element, event) {
      var _a;
      element[event] = (_a = element[event]) !== null && _a !== void 0 ? _a : empty/* EMPTY */.E;
      /** @type {?} */
      const method = this.getMethod(element, event);
      /** @type {?} */
      const zone$ = this.manager.getZone().onStable;
      /** @type {?} */
      const sub = (0,concat/* concat */.z)(zone$.pipe((0,takeWhile/* takeWhile */.o)(
      /**
      * @return {?}
      */
      () => element[event] === empty/* EMPTY */.E)), (0,defer/* defer */.P)(
      /**
      * @return {?}
      */
      () => element[event])).subscribe(method);
      return (
        /**
        * @return {?}
        */
        () => sub.unsubscribe()
      );
    }
    /**
     * @private
     * @param {?} element
     * @param {?} event
     * @return {?}
     */
    getMethod(element, event) {
      const [, key, value, unit = ''] = event.split('.');
      if (event.endsWith('.attr')) {
        return (
          /**
          * @param {?} v
          * @return {?}
          */
          v => v === null ? element.removeAttribute(key) : element.setAttribute(key, String(v))
        );
      }
      if (key === 'class') {
        return (
          /**
          * @param {?} v
          * @return {?}
          */
          v => element.classList.toggle(value, !!v)
        );
      }
      if (key === 'style') {
        return (
          /**
          * @param {?} v
          * @return {?}
          */
          v => element.style.setProperty(dasharize(value), `${v}${unit}`)
        );
      }
      return (
        /**
        * @param {?} v
        * @return {?}
        */
        v => element[key] = v
      );
    }
  }
  BindEventPlugin.ɵfac = /*@__PURE__*/function () {
    let ɵBindEventPlugin_BaseFactory;
    return function BindEventPlugin_Factory(t) {
      return (ɵBindEventPlugin_BaseFactory || (ɵBindEventPlugin_BaseFactory = core_js_["ɵɵgetInheritedFactory"](BindEventPlugin)))(t || BindEventPlugin);
    };
  }();
  BindEventPlugin.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: BindEventPlugin,
    factory: BindEventPlugin.ɵfac
  });
  return BindEventPlugin;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
if (false) {}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/capture.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
let CaptureEventPlugin = /*#__PURE__*/(() => {
  class CaptureEventPlugin extends AbstractEventPlugin {
    constructor() {
      super(...arguments);
      this.modifier = 'capture';
    }
    /**
     * @param {?} event
     * @return {?}
     */
    supports(event) {
      /** @type {?} */
      const split = event.split('.');
      return split.length === 2 && split.indexOf(this.modifier) !== -1;
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addEventListener(element, event, handler) {
      element.addEventListener(this.unwrap(event), handler, true);
      return (
        /**
        * @return {?}
        */
        () => element.removeEventListener(this.unwrap(event), handler)
      );
    }
  }
  CaptureEventPlugin.ɵfac = /*@__PURE__*/function () {
    let ɵCaptureEventPlugin_BaseFactory;
    return function CaptureEventPlugin_Factory(t) {
      return (ɵCaptureEventPlugin_BaseFactory || (ɵCaptureEventPlugin_BaseFactory = core_js_["ɵɵgetInheritedFactory"](CaptureEventPlugin)))(t || CaptureEventPlugin);
    };
  }();
  CaptureEventPlugin.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: CaptureEventPlugin,
    factory: CaptureEventPlugin.ɵfac
  });
  return CaptureEventPlugin;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
if (false) {}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/prevent.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
let PreventEventPlugin = /*#__PURE__*/(() => {
  class PreventEventPlugin extends AbstractEventPlugin {
    constructor() {
      super(...arguments);
      this.modifier = 'prevent';
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addEventListener(element, event, handler) {
      /** @type {?} */
      const wrapped =
      /**
      * @param {?} event
      * @return {?}
      */
      event => {
        event.preventDefault();
        handler(event);
      };
      return this.manager.addEventListener(element, this.unwrap(event), wrapped);
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addGlobalEventListener(element, event, handler) {
      /** @type {?} */
      const wrapped =
      /**
      * @param {?} event
      * @return {?}
      */
      event => {
        event.preventDefault();
        handler(event);
      };
      return this.manager.addGlobalEventListener(element, this.unwrap(event), wrapped);
    }
  }
  PreventEventPlugin.ɵfac = /*@__PURE__*/function () {
    let ɵPreventEventPlugin_BaseFactory;
    return function PreventEventPlugin_Factory(t) {
      return (ɵPreventEventPlugin_BaseFactory || (ɵPreventEventPlugin_BaseFactory = core_js_["ɵɵgetInheritedFactory"](PreventEventPlugin)))(t || PreventEventPlugin);
    };
  }();
  PreventEventPlugin.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: PreventEventPlugin,
    factory: PreventEventPlugin.ɵfac
  });
  return PreventEventPlugin;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
if (false) {}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/silent.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
let SilentEventPlugin = /*#__PURE__*/(() => {
  class SilentEventPlugin extends AbstractEventPlugin {
    constructor() {
      super(...arguments);
      this.modifier = 'silent';
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addEventListener(element, event, handler) {
      return this.manager.getZone().runOutsideAngular(
      /**
      * @return {?}
      */
      () => this.manager.addEventListener(element, this.unwrap(event), handler));
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addGlobalEventListener(element, event, handler) {
      return this.manager.getZone().runOutsideAngular(
      /**
      * @return {?}
      */
      () => this.manager.addGlobalEventListener(element, this.unwrap(event), handler));
    }
  }
  SilentEventPlugin.ɵfac = /*@__PURE__*/function () {
    let ɵSilentEventPlugin_BaseFactory;
    return function SilentEventPlugin_Factory(t) {
      return (ɵSilentEventPlugin_BaseFactory || (ɵSilentEventPlugin_BaseFactory = core_js_["ɵɵgetInheritedFactory"](SilentEventPlugin)))(t || SilentEventPlugin);
    };
  }();
  SilentEventPlugin.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: SilentEventPlugin,
    factory: SilentEventPlugin.ɵfac
  });
  return SilentEventPlugin;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
if (false) {}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/stop.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
let StopEventPlugin = /*#__PURE__*/(() => {
  class StopEventPlugin extends AbstractEventPlugin {
    constructor() {
      super(...arguments);
      this.modifier = 'stop';
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addEventListener(element, event, handler) {
      /** @type {?} */
      const wrapped =
      /**
      * @param {?} event
      * @return {?}
      */
      event => {
        event.stopPropagation();
        handler(event);
      };
      return this.manager.addEventListener(element, this.unwrap(event), wrapped);
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addGlobalEventListener(element, event, handler) {
      /** @type {?} */
      const wrapped =
      /**
      * @param {?} event
      * @return {?}
      */
      event => {
        event.stopPropagation();
        handler(event);
      };
      return this.manager.addGlobalEventListener(element, this.unwrap(event), wrapped);
    }
  }
  StopEventPlugin.ɵfac = /*@__PURE__*/function () {
    let ɵStopEventPlugin_BaseFactory;
    return function StopEventPlugin_Factory(t) {
      return (ɵStopEventPlugin_BaseFactory || (ɵStopEventPlugin_BaseFactory = core_js_["ɵɵgetInheritedFactory"](StopEventPlugin)))(t || StopEventPlugin);
    };
  }();
  StopEventPlugin.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: StopEventPlugin,
    factory: StopEventPlugin.ɵfac
  });
  return StopEventPlugin;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
if (false) {}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/zone.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * TODO: This will not be needed in Angular 10
 * when libraries are allowed to use Ivy renderer and markDirty becomes stable API
 */
let ZoneEventPlugin = /*#__PURE__*/(() => {
  class ZoneEventPlugin extends AbstractEventPlugin {
    constructor() {
      super(...arguments);
      this.modifier = 'init';
    }
    /**
     * @param {?} _element
     * @param {?} _event
     * @param {?} handler
     * @return {?}
     */
    addEventListener(_element, _event, handler) {
      return this.handle(handler);
    }
    /**
     * @param {?} _element
     * @param {?} _event
     * @param {?} handler
     * @return {?}
     */
    addGlobalEventListener(_element, _event, handler) {
      return this.handle(handler);
    }
    /**
     * @private
     * @param {?} handler
     * @return {?}
     */
    handle(handler) {
      /** @type {?} */
      const zone = this.manager.getZone();
      /** @type {?} */
      const subscription = zone.onStable.subscribe(
      /**
      * @return {?}
      */
      () => {
        subscription.unsubscribe();
        handler(zone);
      });
      return (
        /**
        * @return {?}
        */
        () => {}
      );
    }
  }
  ZoneEventPlugin.ɵfac = /*@__PURE__*/function () {
    let ɵZoneEventPlugin_BaseFactory;
    return function ZoneEventPlugin_Factory(t) {
      return (ɵZoneEventPlugin_BaseFactory || (ɵZoneEventPlugin_BaseFactory = core_js_["ɵɵgetInheritedFactory"](ZoneEventPlugin)))(t || ZoneEventPlugin);
    };
  }();
  ZoneEventPlugin.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: ZoneEventPlugin,
    factory: ZoneEventPlugin.ɵfac
  });
  return ZoneEventPlugin;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
if (false) {}

/**
 * @fileoverview added by tsickle
 * Generated from: constants/plugins.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NG_EVENT_PLUGINS = [{
  provide: platform_browser.EVENT_MANAGER_PLUGINS,
  useClass: SilentEventPlugin,
  multi: true
}, {
  provide: platform_browser.EVENT_MANAGER_PLUGINS,
  useClass: PreventEventPlugin,
  multi: true
}, {
  provide: platform_browser.EVENT_MANAGER_PLUGINS,
  useClass: StopEventPlugin,
  multi: true
}, {
  provide: platform_browser.EVENT_MANAGER_PLUGINS,
  useClass: ZoneEventPlugin,
  multi: true
}, {
  provide: platform_browser.EVENT_MANAGER_PLUGINS,
  useClass: CaptureEventPlugin,
  multi: true
}, {
  provide: platform_browser.EVENT_MANAGER_PLUGINS,
  useClass: BindEventPlugin,
  multi: true
}];

/**
 * @fileoverview added by tsickle
 * Generated from: decorators/should-call.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * TODO: This will not be needed in Angular 10
 * when libraries are allowed to use Ivy renderer and markDirty becomes stable API
 * @template T
 * @param {?} predicate
 * @return {?}
 */
function shouldCall(predicate) {
  return (
    /**
    * @param {?} _
    * @param {?} key
    * @param {?} desc
    * @return {?}
    */
    (_, key, desc) => {
      const {
        value
      } = desc;
      desc.value =
      /**
      * @return {?}
      */
      function () {
        /** @type {?} */
        const zone = /** @type {?} */arguments[0];
        Object.defineProperty(this, key, {
          /**
           * @this {?}
           * @param {...?} args
           * @return {?}
           */
          value(...args) {
            if (predicate.apply(this, args)) {
              zone.run(
              /**
              * @return {?}
              */
              () => {
                value.apply(this, args);
              });
            }
          }
        });
      };
    }
  );
}

/**
 * @fileoverview added by tsickle
 * Generated from: types/predicate.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: utils/as-callable.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} a
 * @return {?}
 */
function asCallable(a) {
  return (/** @type {?} */a
  );
}

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: tinkoff-ng-event-plugins.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */



//# sourceMappingURL=tinkoff-ng-event-plugins.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-svg.js
var taiga_ui_core_components_svg = __webpack_require__(4789);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-data-list.js

















const taiga_ui_core_components_data_list_c0 = ["tuiOption", ""];
const taiga_ui_core_components_data_list_c1 = function (a0) {
  return {
    $implicit: a0
  };
};
function TuiOptionComponent_span_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "span", 2);
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    const _r1 = core_js_["ɵɵreference"](2);
    core_js_["ɵɵproperty"]("content", ctx_r0.content)("context", core_js_["ɵɵpureFunction1"](2, taiga_ui_core_components_data_list_c1, _r1));
  }
}
function TuiOptionComponent_ng_template_1_tui_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 4);
  }
}
function TuiOptionComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵprojection"](0);
    core_js_["ɵɵtemplate"](1, TuiOptionComponent_ng_template_1_tui_svg_1_Template, 1, 0, "tui-svg", 3);
  }
  if (rf & 2) {
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", ctx_r2.dropdown);
  }
}
const _c2 = ["*"];
function TuiDataListComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "div", 2);
    core_js_["ɵɵpipe"](1, "async");
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("content", ctx_r0.emptyContent || core_js_["ɵɵpipeBind1"](1, 1, ctx_r0.defaultEmptyContent$));
  }
}
function shouldFocus({
  currentTarget
}) {
  return !(0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(currentTarget);
}
// TODO: Consider all use cases for aria roles
let TuiOptionComponent = /*#__PURE__*/(() => {
  let TuiOptionComponent = class TuiOptionComponent {
    // TODO: Fix dataList type when updated to Ivy and compilation drops metadata
    constructor(content, dataList, elementRef, host, dropdown) {
      this.content = content;
      this.dataList = dataList;
      this.elementRef = elementRef;
      this.host = host;
      this.dropdown = dropdown;
      this.size = 'm';
      this.role = 'option';
      this.disabled = false;
    }
    get active() {
      return !!this.dropdown && !!this.dropdown.dropdownBoxRef;
    }
    onClick() {
      if (this.host && this.value !== undefined) {
        this.host.handleOption(this.value);
      }
    }
    // @bad TODO: Consider aria-activedescendant for proper accessibility implementation
    onMouseMove({
      currentTarget
    }) {
      (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(currentTarget);
    }
    // Preventing focus loss upon focused option removal
    ngOnDestroy() {
      this.dataList.handleFocusLossIfNecessary(this.elementRef.nativeElement);
    }
  };
  TuiOptionComponent.ɵfac = function TuiOptionComponent_Factory(t) {
    return new (t || TuiOptionComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_OPTION_CONTENT */.IQ, 8), core_js_["ɵɵdirectiveInject"]((0,core_js_.forwardRef)(() => TuiDataListComponent)), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_DATA_LIST_HOST */.N1, 8), core_js_["ɵɵdirectiveInject"](TuiDropdownDirective, 10));
  };
  TuiOptionComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiOptionComponent,
    selectors: [["button", "tuiOption", ""], ["a", "tuiOption", ""]],
    hostAttrs: ["tabIndex", "-1", "type", "button"],
    hostVars: 5,
    hostBindings: function TuiOptionComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("click", function TuiOptionComponent_click_HostBindingHandler() {
          return ctx.onClick();
        })("init.onMouseMove", function TuiOptionComponent_init_onMouseMove_HostBindingHandler($event) {
          return ctx.onMouseMove($event);
        })("mousemove.silent", function TuiOptionComponent_mousemove_silent_HostBindingHandler($event) {
          return ctx.onMouseMove($event);
        });
      }
      if (rf & 2) {
        core_js_["ɵɵattribute"]("disabled", ctx.disabled || null)("data-size", ctx.size)("role", ctx.role);
        core_js_["ɵɵclassProp"]("_with-dropdown", ctx.active);
      }
    },
    inputs: {
      size: "size",
      role: "role",
      disabled: "disabled",
      value: "value"
    },
    attrs: taiga_ui_core_components_data_list_c0,
    ngContentSelectors: _c2,
    decls: 3,
    vars: 2,
    consts: [["polymorpheus-outlet", "", "class", "content", 3, "content", "context", 4, "ngIf", "ngIfElse"], ["base", ""], ["polymorpheus-outlet", "", 1, "content", 3, "content", "context"], ["class", "arrow", "src", "tuiIconChevronRight", 4, "ngIf"], ["src", "tuiIconChevronRight", 1, "arrow"]],
    template: function TuiOptionComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵtemplate"](0, TuiOptionComponent_span_0_Template, 1, 4, "span", 0);
        core_js_["ɵɵtemplate"](1, TuiOptionComponent_ng_template_1_Template, 2, 1, "ng-template", null, 1, core_js_["ɵɵtemplateRefExtractor"]);
      }
      if (rf & 2) {
        const _r1 = core_js_["ɵɵreference"](2);
        core_js_["ɵɵproperty"]("ngIf", ctx.content)("ngIfElse", _r1);
      }
    },
    directives: [common_js_.NgIf, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, taiga_ui_core_components_svg/* TuiSvgComponent */.P],
    styles: ["[_nghost-%COMP%]{-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:0 16px;border:0;background:padding-box;font-size:inherit;line-height:inherit;font:var(--tui-font-text-m);transition-property:background;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;display:flex;width:100%;align-items:center;justify-content:space-between;text-align:left;box-sizing:border-box;color:var(--tui-text-01);outline:0;text-decoration:none;cursor:pointer;border-top:8px solid transparent;border-bottom:8px solid transparent;margin:-8px 0}[_nghost-%COMP%]:disabled{opacity:var(--tui-disabled-opacity);cursor:default}._with-dropdown[_nghost-%COMP%], [_nghost-%COMP%]:focus{background-color:var(--tui-base-02)}[data-size=xs][_nghost-%COMP%]{font:var(--tui-font-text-s);min-height:48px}[data-size='s'][_nghost-%COMP%]{min-height:48px}[data-size='m'][_nghost-%COMP%]{min-height:60px}[data-size='l'][_nghost-%COMP%]{min-height:72px}.content[_ngcontent-%COMP%]{display:flex;flex:1}.arrow[_ngcontent-%COMP%]{margin:0 -8px 0 12px}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-size'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiOptionComponent.prototype, "size", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.role'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiOptionComponent.prototype, "role", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiOptionComponent.prototype, "disabled", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiOptionComponent.prototype, "value", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._with-dropdown')], TuiOptionComponent.prototype, "active", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('click')], TuiOptionComponent.prototype, "onClick", null);
  (0,tslib_es6/* __decorate */.gn)([shouldCall(shouldFocus), (0,core_js_.HostListener)('init.onMouseMove', ['$event']), (0,core_js_.HostListener)('mousemove.silent', ['$event'])], TuiOptionComponent.prototype, "onMouseMove", null);
  TuiOptionComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_OPTION_CONTENT */.IQ)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)((0,core_js_.forwardRef)(() => TuiDataListComponent))), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_DATA_LIST_HOST */.N1)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(TuiDropdownDirective))], TuiOptionComponent);
  return TuiOptionComponent;
})();
var TuiDataListComponent_1;
// TODO: Consider aria-activedescendant for proper accessibility implementation
// @dynamic
let TuiDataListComponent = TuiDataListComponent_1 = class TuiDataListComponent {
  constructor(elementRef, defaultEmptyContent$) {
    this.elementRef = elementRef;
    this.defaultEmptyContent$ = defaultEmptyContent$;
    this.role = 'listbox';
    this.emptyContent = '';
    this.options = taiga_ui_cdk_constants/* EMPTY_QUERY */.Mm;
  }
  get empty$() {
    return (0,taiga_ui_cdk_observables/* itemsQueryListObservable */.Fp)(this.options).pipe((0,map/* map */.U)(({
      length
    }) => !length));
  }
  getOptions(includeDisabled = false) {
    return this.options.toArray().filter(({
      disabled
    }) => includeDisabled || !disabled).map(({
      value
    }) => value).filter(taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN);
  }
  onFocusIn(relatedTarget, currentTarget) {
    if (!currentTarget.contains(relatedTarget) && !this.origin) {
      this.origin = relatedTarget;
    }
  }
  noop() {}
  onKeyDownArrow(current, step) {
    const {
      elements
    } = this;
    (0,taiga_ui_cdk_utils_focus/* moveFocus */.pr)(elements.indexOf(current), elements, step);
  }
  onFocus(element, top) {
    const {
      elements
    } = this;
    (0,taiga_ui_cdk_utils_focus/* moveFocus */.pr)(top ? -1 : elements.length, elements, top ? 1 : -1);
    this.handleFocusLossIfNecessary(element);
  }
  // TODO: Consider aria-activedescendant for proper accessibility implementation
  handleFocusLossIfNecessary(element) {
    if (this.origin && (0,taiga_ui_cdk_utils_focus/* isNativeFocusedIn */.KF)(element)) {
      (0,taiga_ui_cdk_utils_focus/* setNativeMouseFocused */.Gi)(this.origin, true, true);
    }
  }
  get elements() {
    return Array.from(this.elementRef.nativeElement.querySelectorAll('[tuiOption]'));
  }
};
TuiDataListComponent.ɵfac = function TuiDataListComponent_Factory(t) {
  return new (t || TuiDataListComponent)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_NOTHING_FOUND_MESSAGE */.PH));
};
TuiDataListComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiDataListComponent,
  selectors: [["tui-data-list"]],
  contentQueries: function TuiDataListComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      core_js_["ɵɵcontentQuery"](dirIndex, TuiOptionComponent, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.options = _t);
    }
  },
  hostVars: 1,
  hostBindings: function TuiDataListComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵlistener"]("focusin", function TuiDataListComponent_focusin_HostBindingHandler($event) {
        return ctx.onFocusIn($event.relatedTarget, $event.currentTarget);
      })("mousedown.prevent", function TuiDataListComponent_mousedown_prevent_HostBindingHandler() {
        return ctx.noop();
      })("keydown.arrowDown.prevent", function TuiDataListComponent_keydown_arrowDown_prevent_HostBindingHandler($event) {
        return ctx.onKeyDownArrow($event.target, 1);
      })("keydown.arrowUp.prevent", function TuiDataListComponent_keydown_arrowUp_prevent_HostBindingHandler($event) {
        return ctx.onKeyDownArrow($event.target, -1);
      })("mouseleave", function TuiDataListComponent_mouseleave_HostBindingHandler($event) {
        return ctx.handleFocusLossIfNecessary($event.target);
      });
    }
    if (rf & 2) {
      core_js_["ɵɵattribute"]("role", ctx.role);
    }
  },
  inputs: {
    role: "role",
    emptyContent: "emptyContent"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_core_tokens/* TUI_DATA_LIST_ACCESSOR */.Cc,
    useExisting: (0,core_js_.forwardRef)(() => TuiDataListComponent_1)
  }])],
  ngContentSelectors: _c2,
  decls: 5,
  vars: 3,
  consts: [["tabindex", "0", 1, "trap", 3, "focusin"], ["class", "empty", "polymorpheus-outlet", "", 3, "content", 4, "ngIf"], ["polymorpheus-outlet", "", 1, "empty", 3, "content"]],
  template: function TuiDataListComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"]();
      core_js_["ɵɵelementStart"](0, "div", 0);
      core_js_["ɵɵlistener"]("focusin", function TuiDataListComponent_Template_div_focusin_0_listener($event) {
        return ctx.onFocus($event.target, true);
      });
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵprojection"](1);
      core_js_["ɵɵtemplate"](2, TuiDataListComponent_div_2_Template, 2, 3, "div", 1);
      core_js_["ɵɵpipe"](3, "async");
      core_js_["ɵɵelementStart"](4, "div", 0);
      core_js_["ɵɵlistener"]("focusin", function TuiDataListComponent_Template_div_focusin_4_listener($event) {
        return ctx.onFocus($event.target, false);
      });
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      core_js_["ɵɵadvance"](2);
      core_js_["ɵɵproperty"]("ngIf", core_js_["ɵɵpipeBind1"](3, 1, ctx.empty$));
    }
  },
  directives: [common_js_.NgIf, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1],
  pipes: [common_js_.AsyncPipe],
  styles: ["tui-data-list{font:var(--tui-font-text-m);display:flex;flex-direction:column;padding:8px 0;color:var(--tui-text-03)}tui-data-list:focus-within .trap{display:none}tui-data-list:focus-within [tuiOption]._with-dropdown:not(:focus){background-color:transparent}tui-data-list>.empty{margin:12px 16px}tui-opt-group{font:var(--tui-font-text-xs);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;position:relative;display:flex;flex-direction:column;line-height:32px;padding:8px 0;margin:-8px 0}tui-opt-group:empty:after,tui-opt-group:empty:before{display:none}tui-opt-group:before{content:attr(data-label);padding:0 16px;color:var(--tui-text-02)}tui-opt-group:not(:empty)~tui-opt-group:before{padding-top:16px}tui-opt-group:not(:empty)~tui-opt-group:after{content:'';position:absolute;left:0;right:0;top:7px;height:1px;background:var(--tui-base-03)}"],
  encapsulation: 2,
  changeDetection: 0
});
TuiDataListComponent.ctorParameters = () => [{
  type: core_js_.ElementRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ElementRef]
  }]
}, {
  type: Observable/* Observable */.y,
  decorators: [{
    type: core_js_.Inject,
    args: [taiga_ui_core_tokens/* TUI_NOTHING_FOUND_MESSAGE */.PH]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.role'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDataListComponent.prototype, "role", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDataListComponent.prototype, "emptyContent", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChildren)((0,core_js_.forwardRef)(() => TuiOptionComponent), {
  descendants: true
})], TuiDataListComponent.prototype, "options", void 0);
(0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDataListComponent.prototype, "empty$", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('focusin', ['$event.relatedTarget', '$event.currentTarget'])], TuiDataListComponent.prototype, "onFocusIn", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('mousedown.prevent')], TuiDataListComponent.prototype, "noop", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('keydown.arrowDown.prevent', ['$event.target', '1']), (0,core_js_.HostListener)('keydown.arrowUp.prevent', ['$event.target', '-1'])], TuiDataListComponent.prototype, "onKeyDownArrow", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('mouseleave', ['$event.target'])], TuiDataListComponent.prototype, "handleFocusLossIfNecessary", null);
TuiDataListComponent = TuiDataListComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_NOTHING_FOUND_MESSAGE */.PH))], TuiDataListComponent);
let TuiDataListDirective = /*#__PURE__*/(() => {
  let TuiDataListDirective = class TuiDataListDirective {};
  TuiDataListDirective.ɵfac = function TuiDataListDirective_Factory(t) {
    return new (t || TuiDataListDirective)();
  };
  TuiDataListDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiDataListDirective,
    selectors: [["ng-template", "tuiDataList", ""]]
  });
  return TuiDataListDirective;
})();
let TuiDataListDropdownManagerDirective = /*#__PURE__*/(() => {
  let TuiDataListDropdownManagerDirective = class TuiDataListDropdownManagerDirective {
    constructor() {
      this.dropdowns = taiga_ui_cdk_constants/* EMPTY_QUERY */.Mm;
      this.elements = taiga_ui_cdk_constants/* EMPTY_QUERY */.Mm;
    }
    ngAfterViewInit() {
      this.right$.subscribe(index => {
        this.tryToFocus(index);
      });
      (0,merge/* merge */.T)(this.immediate$, this.debounce$).pipe((0,switchMap/* switchMap */.w)(active => {
        this.dropdowns.forEach((dropdown, index) => {
          dropdown.open = index === active;
        });
        const element = this.elements.toArray()[active];
        const dropdown = this.dropdowns.toArray()[active];
        if (!element || !dropdown || !dropdown.dropdownBoxRef) {
          return empty/* EMPTY */.E;
        }
        const {
          nativeElement
        } = dropdown.dropdownBoxRef.location;
        const mouseEnter$ = (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, 'mouseenter').pipe((0,take/* take */.q)(1));
        const esc$ = (0,merge/* merge */.T)((0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(element.nativeElement, 'keydown'), (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, 'keydown')).pipe((0,filter/* filter */.h)(({
          keyCode
        }) => keyCode === 27));
        return (0,merge/* merge */.T)(mouseEnter$, esc$).pipe((0,tap/* tap */.b)(event => {
          if (dropdown.dropdownBoxRef) {
            event.stopPropagation();
          }
          (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(element.nativeElement);
          dropdown.open = event instanceof MouseEvent;
        }));
      })).subscribe();
    }
    get elements$() {
      return (0,taiga_ui_cdk_observables/* itemsQueryListObservable */.Fp)(this.elements).pipe((0,map/* map */.U)(array => array.map(({
        nativeElement
      }) => nativeElement)), (0,shareReplay/* shareReplay */.d)(1));
    }
    get right$() {
      return this.elements$.pipe((0,switchMap/* switchMap */.w)(elements => (0,merge/* merge */.T)(...elements.map((element, index) => (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(element, 'keydown').pipe((0,filter/* filter */.h)(({
        keyCode
      }) => keyCode === 39), (0,taiga_ui_cdk_observables/* preventDefault */.PF)(), (0,mapTo/* mapTo */.h)(index))))));
    }
    get immediate$() {
      return this.elements$.pipe((0,switchMap/* switchMap */.w)(elements => (0,merge/* merge */.T)(...elements.map((element, index) => (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(element, 'click').pipe((0,mapTo/* mapTo */.h)(index))))));
    }
    get debounce$() {
      return this.elements$.pipe((0,switchMap/* switchMap */.w)(elements => (0,merge/* merge */.T)(...elements.map((element, index) => (0,merge/* merge */.T)((0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(element, 'focus'), (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(element, 'blur')).pipe((0,filter/* filter */.h)(({
        relatedTarget
      }) => this.notInDropdown(relatedTarget, index)), (0,map/* map */.U)(({
        type
      }) => type === 'focus' ? index : NaN), (0,debounceTime/* debounceTime */.b)(300))))));
    }
    notInDropdown(element, index) {
      const dropdown = this.dropdowns.toArray()[index];
      return !dropdown || !dropdown.dropdownBoxRef || !dropdown.dropdownBoxRef.location.nativeElement.contains(element);
    }
    tryToFocus(index) {
      const dropdown = this.dropdowns.toArray()[index];
      const content = dropdown && dropdown.dropdownBoxRef && dropdown.dropdownBoxRef.instance.contentElementRef;
      if (!content) {
        return;
      }
      const item = (0,taiga_ui_cdk_utils_focus/* getClosestKeyboardFocusable */.O9)(content.nativeElement, false, content.nativeElement);
      if (item) {
        (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(item);
      }
    }
  };
  TuiDataListDropdownManagerDirective.ɵfac = function TuiDataListDropdownManagerDirective_Factory(t) {
    return new (t || TuiDataListDropdownManagerDirective)();
  };
  TuiDataListDropdownManagerDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiDataListDropdownManagerDirective,
    selectors: [["tui-data-list", "tuiDataListDropdownManager", ""]],
    contentQueries: function TuiDataListDropdownManagerDirective_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        core_js_["ɵɵcontentQuery"](dirIndex, TuiDropdownDirective, 5);
        core_js_["ɵɵcontentQuery"](dirIndex, TuiDropdownDirective, 5, core_js_.ElementRef);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.dropdowns = _t);
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.elements = _t);
      }
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChildren)(TuiDropdownDirective, {
    descendants: true
  })], TuiDataListDropdownManagerDirective.prototype, "dropdowns", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChildren)(TuiDropdownDirective, {
    read: core_js_.ElementRef,
    descendants: true
  })], TuiDataListDropdownManagerDirective.prototype, "elements", void 0);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDataListDropdownManagerDirective.prototype, "elements$", null);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDataListDropdownManagerDirective.prototype, "right$", null);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDataListDropdownManagerDirective.prototype, "immediate$", null);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDataListDropdownManagerDirective.prototype, "debounce$", null);
  return TuiDataListDropdownManagerDirective;
})();
let TuiOptGroupDirective = /*#__PURE__*/(() => {
  let TuiOptGroupDirective = class TuiOptGroupDirective {
    constructor() {
      this.label = '';
    }
  };
  TuiOptGroupDirective.ɵfac = function TuiOptGroupDirective_Factory(t) {
    return new (t || TuiOptGroupDirective)();
  };
  TuiOptGroupDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiOptGroupDirective,
    selectors: [["tui-opt-group"]],
    hostAttrs: ["role", "group"],
    hostVars: 1,
    hostBindings: function TuiOptGroupDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("data-label", ctx.label);
      }
    },
    inputs: {
      label: "label"
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-label'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiOptGroupDirective.prototype, "label", void 0);
  return TuiOptGroupDirective;
})();
let TuiDataListModule = /*#__PURE__*/(() => {
  let TuiDataListModule = class TuiDataListModule {};
  TuiDataListModule.ɵfac = function TuiDataListModule_Factory(t) {
    return new (t || TuiDataListModule)();
  };
  TuiDataListModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDataListModule
  });
  TuiDataListModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq]]
  });
  return TuiDataListModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDataListModule, {
    declarations: function () {
      return [TuiDataListComponent, TuiOptionComponent, TuiOptGroupDirective, TuiDataListDirective, TuiDataListDropdownManagerDirective];
    },
    imports: function () {
      return [common_js_.CommonModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq];
    },
    exports: function () {
      return [TuiDataListComponent, TuiOptionComponent, TuiOptGroupDirective, TuiDataListDirective, TuiDataListDropdownManagerDirective];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-data-list.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-focusable.js



/**
 * Abstraction over `tabindex`
 */

let TuiFocusableDirective = /*#__PURE__*/(() => {
  let TuiFocusableDirective = class TuiFocusableDirective {
    constructor() {
      /**
       * Element can be focused with keyboard
       */
      this.focusable = true;
    }
    get tabIndex() {
      return this.focusable ? 0 : -1;
    }
  };
  TuiFocusableDirective.ɵfac = function TuiFocusableDirective_Factory(t) {
    return new (t || TuiFocusableDirective)();
  };
  TuiFocusableDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiFocusableDirective,
    selectors: [["", "tuiFocusable", ""]],
    hostVars: 1,
    hostBindings: function TuiFocusableDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵhostProperty"]("tabIndex", ctx.tabIndex);
      }
    },
    inputs: {
      focusable: ["tuiFocusable", "focusable"]
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiFocusable')], TuiFocusableDirective.prototype, "focusable", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('tabIndex')], TuiFocusableDirective.prototype, "tabIndex", null);
  return TuiFocusableDirective;
})();
let TuiFocusableModule = /*#__PURE__*/(() => {
  let TuiFocusableModule = class TuiFocusableModule {};
  TuiFocusableModule.ɵfac = function TuiFocusableModule_Factory(t) {
    return new (t || TuiFocusableModule)();
  };
  TuiFocusableModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiFocusableModule
  });
  TuiFocusableModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiFocusableModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiFocusableModule, {
    declarations: [TuiFocusableDirective],
    exports: [TuiFocusableDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-focusable.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-focused.js







/**
 * Directive to monitor focus/blur status, works with focusIn/focus-out
 * instead of focus/blur to sync events order with Internet Explorer and
 * other focus related directives that require bubbling
 */

let TuiFocusedDirective = /*#__PURE__*/(() => {
  let TuiFocusedDirective = class TuiFocusedDirective {
    constructor({
      nativeElement
    }, ngZone) {
      this.tuiFocusedChange = (0,merge/* merge */.T)((0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, 'focusin'), (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, 'focusout')).pipe((0,map/* map */.U)(() => (0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(nativeElement)), (0,startWith/* startWith */.O)(false), (0,distinctUntilChanged/* distinctUntilChanged */.x)(), skip(1), (0,taiga_ui_cdk_observables/* tuiZoneOptimized */.Yr)(ngZone));
    }
  };
  TuiFocusedDirective.ɵfac = function TuiFocusedDirective_Factory(t) {
    return new (t || TuiFocusedDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.NgZone));
  };
  TuiFocusedDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiFocusedDirective,
    selectors: [["", "tuiFocusedChange", ""]],
    outputs: {
      tuiFocusedChange: "tuiFocusedChange"
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiFocusedDirective.prototype, "tuiFocusedChange", void 0);
  TuiFocusedDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.NgZone))], TuiFocusedDirective);
  return TuiFocusedDirective;
})();
let TuiFocusedModule = /*#__PURE__*/(() => {
  let TuiFocusedModule = class TuiFocusedModule {};
  TuiFocusedModule.ɵfac = function TuiFocusedModule_Factory(t) {
    return new (t || TuiFocusedModule)();
  };
  TuiFocusedModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiFocusedModule
  });
  TuiFocusedModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiFocusedModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiFocusedModule, {
    declarations: [TuiFocusedDirective],
    exports: [TuiFocusedDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-focused.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-hovered.js





let TuiHoveredDirective = /*#__PURE__*/(() => {
  let TuiHoveredDirective = class TuiHoveredDirective {
    constructor({
      nativeElement
    }, hoveredService) {
      this.tuiHoveredChange = hoveredService.createHovered$(nativeElement);
    }
  };
  TuiHoveredDirective.ɵfac = function TuiHoveredDirective_Factory(t) {
    return new (t || TuiHoveredDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiHoveredService */.gs));
  };
  TuiHoveredDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiHoveredDirective,
    selectors: [["", "tuiHoveredChange", ""]],
    outputs: {
      tuiHoveredChange: "tuiHoveredChange"
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiHoveredDirective.prototype, "tuiHoveredChange", void 0);
  TuiHoveredDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiHoveredService */.gs))], TuiHoveredDirective);
  return TuiHoveredDirective;
})();
let TuiHoveredModule = /*#__PURE__*/(() => {
  let TuiHoveredModule = class TuiHoveredModule {};
  TuiHoveredModule.ɵfac = function TuiHoveredModule_Factory(t) {
    return new (t || TuiHoveredModule)();
  };
  TuiHoveredModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiHoveredModule
  });
  TuiHoveredModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiHoveredModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiHoveredModule, {
    declarations: [TuiHoveredDirective],
    exports: [TuiHoveredDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-hovered.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-input-mode.js




/**
 * Abstraction over `inputMode` attribute
 */

let TuiInputModeDirective = /*#__PURE__*/(() => {
  let TuiInputModeDirective = class TuiInputModeDirective {
    constructor(pattern, isIOS) {
      this.pattern = pattern;
      this.isIOS = isIOS;
      this.mode = "text" /* Text */;
    }

    get patternAttribute() {
      return this.mode === "numeric" /* Numeric */ && this.isIOS && !this.pattern ? '[0-9]*' : this.pattern;
    }
  };
  TuiInputModeDirective.ɵfac = function TuiInputModeDirective_Factory(t) {
    return new (t || TuiInputModeDirective)(core_js_["ɵɵinjectAttribute"]('pattern'), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_IOS */.FA));
  };
  TuiInputModeDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiInputModeDirective,
    selectors: [["input", "tuiInputMode", ""]],
    hostVars: 3,
    hostBindings: function TuiInputModeDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("inputmode", ctx.mode)("x-inputmode", ctx.mode)("pattern", ctx.patternAttribute);
      }
    },
    inputs: {
      mode: ["tuiInputMode", "mode"]
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiInputMode'), (0,core_js_.HostBinding)('attr.inputmode'), (0,core_js_.HostBinding)('attr.x-inputmode')], TuiInputModeDirective.prototype, "mode", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('attr.pattern')], TuiInputModeDirective.prototype, "patternAttribute", null);
  TuiInputModeDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Attribute)('pattern')), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_IOS */.FA))], TuiInputModeDirective);
  return TuiInputModeDirective;
})();
let TuiInputModeModule = /*#__PURE__*/(() => {
  let TuiInputModeModule = class TuiInputModeModule {};
  TuiInputModeModule.ɵfac = function TuiInputModeModule_Factory(t) {
    return new (t || TuiInputModeModule)();
  };
  TuiInputModeModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiInputModeModule
  });
  TuiInputModeModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiInputModeModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiInputModeModule, {
    declarations: [TuiInputModeDirective],
    exports: [TuiInputModeDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-input-mode.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-autofilled.js









const ON = 'tuiAutofillOn';
const OFF = 'tuiAutofillOff';
const STYLE = `
@keyframes ${ON} {
    from {
        content: '1';
    }

    to {
        content: '2';
    }
}

@keyframes ${OFF} {
    from {
        content: '2';
    }

    to {
        content: '1';
    }
}`;
// @dynamic
let TuiAutofilledDirective = /*#__PURE__*/(() => {
  let TuiAutofilledDirective = class TuiAutofilledDirective {
    constructor(directiveStyles, {
      nativeElement
    }, changeDetectorRef, destroy$) {
      this.tuiAutofilledChange = new core_js_.EventEmitter();
      directiveStyles.addStyle(STYLE, 'TuiAutofilledDirective');
      // Subscribing to synthetic keydown event on page reload autofill in Chrome
      (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, 'keydown').pipe((0,take/* take */.q)(1), (0,takeUntil/* takeUntil */.R)(destroy$), (0,taiga_ui_cdk_observables/* watch */.YP)(changeDetectorRef)).subscribe();
    }
    onAnimationStart({
      animationName
    }) {
      if (animationName === ON) {
        this.tuiAutofilledChange.emit(true);
      } else if (animationName === OFF) {
        this.tuiAutofilledChange.emit(false);
      }
    }
  };
  TuiAutofilledDirective.ɵfac = function TuiAutofilledDirective_Factory(t) {
    return new (t || TuiAutofilledDirective)(core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDirectiveStylesService */.gH), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3));
  };
  TuiAutofilledDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiAutofilledDirective,
    selectors: [["input", "tuiAutofilledChange", ""]],
    hostAttrs: [1, "tui-autofill"],
    hostBindings: function TuiAutofilledDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("animationstart", function TuiAutofilledDirective_animationstart_HostBindingHandler($event) {
          return ctx.onAnimationStart($event);
        });
      }
    },
    outputs: {
      tuiAutofilledChange: "tuiAutofilledChange"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiAutofilledDirective.prototype, "tuiAutofilledChange", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('animationstart', ['$event'])], TuiAutofilledDirective.prototype, "onAnimationStart", null);
  TuiAutofilledDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDirectiveStylesService */.gH)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3))], TuiAutofilledDirective);
  return TuiAutofilledDirective;
})();
let TuiAutofilledModule = /*#__PURE__*/(() => {
  let TuiAutofilledModule = class TuiAutofilledModule {};
  TuiAutofilledModule.ɵfac = function TuiAutofilledModule_Factory(t) {
    return new (t || TuiAutofilledModule)();
  };
  TuiAutofilledModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiAutofilledModule
  });
  TuiAutofilledModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiAutofilledModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiAutofilledModule, {
    declarations: [TuiAutofilledDirective],
    exports: [TuiAutofilledDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-autofilled.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-prevent-default.js







/**
 * Simple prevent default on event directive when you do not need anything
 * else on event and do not want to trigger change detection
 * @dynamic
 */


let TuiPreventDefaultDirective = /*#__PURE__*/(() => {
  let TuiPreventDefaultDirective = class TuiPreventDefaultDirective {
    constructor({
      nativeElement
    }, ngZone, destroy$, eventName) {
      (0,fromEvent/* fromEvent */.R)(nativeElement, eventName, {
        passive: false
      }).pipe((0,taiga_ui_cdk_observables/* tuiZonefree */.fL)(ngZone), (0,taiga_ui_cdk_observables/* preventDefault */.PF)(), (0,takeUntil/* takeUntil */.R)(destroy$)).subscribe();
    }
  };
  TuiPreventDefaultDirective.ɵfac = function TuiPreventDefaultDirective_Factory(t) {
    return new (t || TuiPreventDefaultDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.NgZone), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3), core_js_["ɵɵinjectAttribute"]('tuiPreventDefault'));
  };
  TuiPreventDefaultDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiPreventDefaultDirective,
    selectors: [["", "tuiPreventDefault", ""]],
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])]
  });
  TuiPreventDefaultDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.NgZone)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Attribute)('tuiPreventDefault'))], TuiPreventDefaultDirective);
  return TuiPreventDefaultDirective;
})();
let TuiPreventDefaultModule = /*#__PURE__*/(() => {
  let TuiPreventDefaultModule = class TuiPreventDefaultModule {};
  TuiPreventDefaultModule.ɵfac = function TuiPreventDefaultModule_Factory(t) {
    return new (t || TuiPreventDefaultModule)();
  };
  TuiPreventDefaultModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiPreventDefaultModule
  });
  TuiPreventDefaultModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiPreventDefaultModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiPreventDefaultModule, {
    declarations: [TuiPreventDefaultDirective],
    exports: [TuiPreventDefaultDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-prevent-default.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-directives-hint-controller.js





const TUI_HINT_CONTROLLER = new core_js_.InjectionToken('Controls configuration of hints', {
  factory: () => new TuiHintControllerDirective()
});
var TuiHintControllerDirective_1;
// TODO: v2.0 use in Charts
let TuiHintControllerDirective = TuiHintControllerDirective_1 = class TuiHintControllerDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor() {
    super(...arguments);
    this.content = null;
    this.direction = 'bottom-left';
    this.mode = null;
    this.showDelay = 500;
    this.hideDelay = 200;
  }
};
TuiHintControllerDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiHintControllerDirective_BaseFactory;
  return function TuiHintControllerDirective_Factory(t) {
    return (ɵTuiHintControllerDirective_BaseFactory || (ɵTuiHintControllerDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiHintControllerDirective)))(t || TuiHintControllerDirective);
  };
}();
TuiHintControllerDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiHintControllerDirective,
  selectors: [["", "tuiHintContent", ""]],
  inputs: {
    content: ["tuiHintContent", "content"],
    direction: ["tuiHintDirection", "direction"],
    mode: ["tuiHintMode", "mode"],
    showDelay: ["tuiHintShowDelay", "showDelay"],
    hideDelay: ["tuiHintHideDelay", "hideDelay"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_HINT_CONTROLLER,
    useExisting: (0,core_js_.forwardRef)(() => TuiHintControllerDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiHintContent'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHintControllerDirective.prototype, "content", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiHintDirection'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHintControllerDirective.prototype, "direction", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiHintMode'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHintControllerDirective.prototype, "mode", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiHintShowDelay'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHintControllerDirective.prototype, "showDelay", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiHintHideDelay'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHintControllerDirective.prototype, "hideDelay", void 0);
let TuiHintControllerModule = /*#__PURE__*/(() => {
  let TuiHintControllerModule = class TuiHintControllerModule {};
  TuiHintControllerModule.ɵfac = function TuiHintControllerModule_Factory(t) {
    return new (t || TuiHintControllerModule)();
  };
  TuiHintControllerModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiHintControllerModule
  });
  TuiHintControllerModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiHintControllerModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiHintControllerModule, {
    declarations: [TuiHintControllerDirective],
    exports: [TuiHintControllerDirective]
  });
})();
const TUI_HINT_WATCHED_CONTROLLER = new core_js_.InjectionToken('watched hint controller');
// TODO: remove in ivy compilation
const HINT_CONTROLLER_FACTORY = taiga_ui_core_providers/* watchedControllerFactory */.my;
const HINT_CONTROLLER_PROVIDER = [taiga_ui_cdk_services/* TuiDestroyService */.a3, {
  provide: TUI_HINT_WATCHED_CONTROLLER,
  deps: [TUI_HINT_CONTROLLER, core_js_.ChangeDetectorRef, taiga_ui_cdk_services/* TuiDestroyService */.a3],
  useFactory: HINT_CONTROLLER_FACTORY
}];

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-directives-hint-controller.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-utils-miscellaneous.js
var taiga_ui_core_utils_miscellaneous = __webpack_require__(6640);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/timer.js
var timer = __webpack_require__(6797);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/switchMapTo.js
var switchMapTo = __webpack_require__(9499);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-directives-described-by.js









const DELAY = 1000;
const TUI_DESCRIBED_BY_SHOW = new core_js_.InjectionToken('Accessible tooltip visibility stream');
const TUI_DESCRIBED_BY_PROVIDERS = [taiga_ui_cdk_services/* TuiDestroyService */.a3, taiga_ui_cdk_services/* TuiFocusVisibleService */.ku, {
  provide: TUI_DESCRIBED_BY_SHOW,
  deps: [taiga_ui_cdk_services/* TuiFocusVisibleService */.ku, core_js_.ElementRef],
  useFactory: describedByFactory
}];
function describedByFactory(focusVisible$, {
  nativeElement
}) {
  return (0,merge/* merge */.T)(focusVisible$.pipe((0,filter/* filter */.h)(v => v), (0,switchMapTo/* switchMapTo */.c)((0,timer/* timer */.H)(DELAY).pipe((0,mapTo/* mapTo */.h)(true), (0,takeUntil/* takeUntil */.R)((0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, 'keydown')))), (0,switchMapTo/* switchMapTo */.c)((0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, 'keydown').pipe((0,filter/* filter */.h)(({
    key
  }) => key === 'Escape'), (0,take/* take */.q)(1), (0,tap/* tap */.b)(event => {
    event.stopPropagation();
  }), (0,mapTo/* mapTo */.h)(false), (0,startWith/* startWith */.O)(true)))), (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, 'blur').pipe((0,mapTo/* mapTo */.h)(false))).pipe((0,distinctUntilChanged/* distinctUntilChanged */.x)());
}
const DESCRIBED_BY = '_described-by';
/**
 * A directive linking focusable elements and hints for accessibility
 */
let TuiDescribedByDirective = /*#__PURE__*/(() => {
  let TuiDescribedByDirective = class TuiDescribedByDirective {
    constructor(hintService, visibility$) {
      this.tuiDescribedBy = '';
      visibility$.subscribe(visible => {
        if (!this.tuiDescribedBy) {
          return;
        }
        if (visible) {
          hintService.showHintForId(this.tuiDescribedBy);
        } else {
          hintService.hideHintForId(this.tuiDescribedBy);
        }
      });
    }
    get computedDescribedBy() {
      return this.tuiDescribedBy ? this.tuiDescribedBy + DESCRIBED_BY : null;
    }
  };
  TuiDescribedByDirective.ɵfac = function TuiDescribedByDirective_Factory(t) {
    return new (t || TuiDescribedByDirective)(core_js_["ɵɵdirectiveInject"](taiga_ui_core_services/* TuiHintService */.BN), core_js_["ɵɵdirectiveInject"](TUI_DESCRIBED_BY_SHOW));
  };
  TuiDescribedByDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiDescribedByDirective,
    selectors: [["", "tuiDescribedBy", "", 5, "ng-container"]],
    hostVars: 1,
    hostBindings: function TuiDescribedByDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("aria-describedby", ctx.computedDescribedBy);
      }
    },
    inputs: {
      tuiDescribedBy: "tuiDescribedBy"
    },
    features: [core_js_["ɵɵProvidersFeature"](TUI_DESCRIBED_BY_PROVIDERS)]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDescribedByDirective.prototype, "tuiDescribedBy", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('attr.aria-describedby')], TuiDescribedByDirective.prototype, "computedDescribedBy", null);
  TuiDescribedByDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_services/* TuiHintService */.BN)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_DESCRIBED_BY_SHOW))], TuiDescribedByDirective);
  return TuiDescribedByDirective;
})();
let TuiDescribedByModule = /*#__PURE__*/(() => {
  let TuiDescribedByModule = class TuiDescribedByModule {};
  TuiDescribedByModule.ɵfac = function TuiDescribedByModule_Factory(t) {
    return new (t || TuiDescribedByModule)();
  };
  TuiDescribedByModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDescribedByModule
  });
  TuiDescribedByModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiDescribedByModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDescribedByModule, {
    declarations: [TuiDescribedByDirective],
    exports: [TuiDescribedByDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-directives-described-by.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subject.js
var Subject = __webpack_require__(9765);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/combineLatest.js
var combineLatest = __webpack_require__(9112);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/of.js
var of = __webpack_require__(5917);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/delay.js + 1 modules
var delay = __webpack_require__(1289);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-directives-hint.js











const HINT_HOVERED_CLASS = '_hint_hovered';
let TuiHintDirective = /*#__PURE__*/(() => {
  let TuiHintDirective = class TuiHintDirective extends AbstractTuiHint {
    constructor(renderer, elementRef, hintService, destroy$, obscured$, hoveredService) {
      super(elementRef, hintService);
      this.renderer = renderer;
      this.componentHovered$ = new Subject/* Subject */.xQ();
      this.tuiHintShowDelay = 500;
      this.tuiHintHideDelay = 200;
      this.tuiHintHost = null;
      // @bad TODO: Use private provider
      (0,combineLatest/* combineLatest */.aj)(hoveredService.createHovered$(elementRef.nativeElement), this.componentHovered$.pipe((0,startWith/* startWith */.O)(false))).pipe((0,map/* map */.U)(([directiveHovered, componentHovered]) => directiveHovered || componentHovered), (0,switchMap/* switchMap */.w)(visible => {
        this.toggleClass(visible);
        return (0,of.of)(visible).pipe((0,delay/* delay */.g)(visible ? this.tuiHintShowDelay : this.tuiHintHideDelay));
      }), (0,switchMap/* switchMap */.w)(visible => visible && this.mode !== "overflow" /* Overflow */ ? obscured$.pipe((0,map/* map */.U)(obscured => !obscured), (0,take/* take */.q)(2)) : (0,of.of)(visible)), (0,distinctUntilChanged/* distinctUntilChanged */.x)(), (0,takeUntil/* takeUntil */.R)(destroy$)).subscribe(visible => {
        if (visible) {
          this.showTooltip();
        } else {
          this.hideTooltip();
        }
      });
      this.hintService.register(this);
    }
    set tuiHint(value) {
      if (!value) {
        this.hideTooltip();
        this.content = '';
        return;
      }
      this.content = value;
    }
    get id() {
      return this.tuiHintId ? this.tuiHintId + DESCRIBED_BY : null;
    }
    get host() {
      return this.tuiHintHost ? this.tuiHintHost : this.elementRef.nativeElement;
    }
    getElementClientRect() {
      return this.host.getBoundingClientRect();
    }
    ngOnDestroy() {
      this.hintService.unregister(this);
    }
    showTooltip() {
      if (this.content === '') {
        return;
      }
      this.toggleClass(true);
      this.hintService.add(this);
    }
    hideTooltip() {
      this.toggleClass(false);
      this.hintService.remove(this);
    }
    toggleClass(add) {
      if (add) {
        this.renderer.addClass(this.elementRef.nativeElement, HINT_HOVERED_CLASS);
      } else {
        this.renderer.removeClass(this.elementRef.nativeElement, HINT_HOVERED_CLASS);
      }
    }
  };
  TuiHintDirective.ɵfac = function TuiHintDirective_Factory(t) {
    return new (t || TuiHintDirective)(core_js_["ɵɵdirectiveInject"](core_js_.Renderer2), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_services/* TuiHintService */.BN), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiObscuredService */.AQ, 2), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiHoveredService */.gs));
  };
  TuiHintDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiHintDirective,
    selectors: [["", "tuiHint", "", 5, "ng-container"]],
    inputs: {
      tuiHintShowDelay: "tuiHintShowDelay",
      tuiHintHideDelay: "tuiHintHideDelay",
      tuiHintHost: "tuiHintHost",
      tuiHint: "tuiHint",
      tuiHintId: "tuiHintId"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiObscuredService */.AQ, taiga_ui_cdk_services/* TuiParentsScrollService */.b0, taiga_ui_cdk_services/* TuiDestroyService */.a3]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiHintDirective.prototype, "tuiHintId", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHintDirective.prototype, "tuiHintShowDelay", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHintDirective.prototype, "tuiHintHideDelay", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHintDirective.prototype, "tuiHintHost", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiRequiredSetter */.NH)()], TuiHintDirective.prototype, "tuiHint", null);
  TuiHintDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.Renderer2)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_core_services/* TuiHintService */.BN)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiObscuredService */.AQ)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiHoveredService */.gs))], TuiHintDirective);
  return TuiHintDirective;
})();
let TuiHintModule = /*#__PURE__*/(() => {
  let TuiHintModule = class TuiHintModule {};
  TuiHintModule.ɵfac = function TuiHintModule_Factory(t) {
    return new (t || TuiHintModule)();
  };
  TuiHintModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiHintModule
  });
  TuiHintModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiHintModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiHintModule, {
    declarations: [TuiHintDirective],
    exports: [TuiHintDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-directives-hint.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-tooltip.js














let TuiTooltipComponent = /*#__PURE__*/(() => {
  let TuiTooltipComponent = class TuiTooltipComponent {
    constructor(destroy$, mode$) {
      this.content = '';
      this.mode = null;
      this.direction = 'bottom-left';
      this.showDelay = 500;
      this.hideDelay = 200;
      this.describeId = '';
      this.globalMode = null;
      mode$.pipe((0,takeUntil/* takeUntil */.R)(destroy$)).subscribe(mode => {
        this.globalMode = mode;
      });
    }
    // TODO: Simplify
    get computedMode() {
      return this.mode || this.globalMode;
    }
  };
  TuiTooltipComponent.ɵfac = function TuiTooltipComponent_Factory(t) {
    return new (t || TuiTooltipComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_MODE */.Au));
  };
  TuiTooltipComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiTooltipComponent,
    selectors: [["tui-tooltip"]],
    hostVars: 1,
    hostBindings: function TuiTooltipComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("data-mode", ctx.computedMode);
      }
    },
    inputs: {
      content: "content",
      mode: "mode",
      direction: "direction",
      showDelay: "showDelay",
      hideDelay: "hideDelay",
      describeId: "describeId"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3, taiga_ui_core_providers/* MODE_PROVIDER */.CV])],
    decls: 1,
    vars: 6,
    consts: [["src", "tuiIconTooltipLarge", "automation-id", "tui-tooltip__icon", 1, "icon", 3, "tuiHintId", "tuiHint", "tuiHintDirection", "tuiHintShowDelay", "tuiHintHideDelay", "tuiHintMode"]],
    template: function TuiTooltipComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵelement"](0, "tui-svg", 0);
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("tuiHintId", ctx.describeId)("tuiHint", ctx.content)("tuiHintDirection", ctx.direction)("tuiHintShowDelay", ctx.showDelay)("tuiHintHideDelay", ctx.hideDelay)("tuiHintMode", ctx.computedMode);
      }
    },
    directives: [taiga_ui_core_components_svg/* TuiSvgComponent */.P, TuiHintDirective],
    styles: ["[_nghost-%COMP%]{transition-property:color;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;position:relative;display:inline-block;width:24px;height:24px;vertical-align:middle;font-size:0;line-height:0;cursor:pointer;color:var(--tui-text-03)}[_nghost-%COMP%]:hover{color:var(--tui-text-02)}[data-mode=onDark][_nghost-%COMP%]{color:var(--tui-text-01-night)}[data-mode=onLight][_nghost-%COMP%]{color:var(--tui-text-01)}[data-mode=error][_nghost-%COMP%]{color:var(--tui-error-fill)}.icon[_ngcontent-%COMP%]{transition-property:opacity,color;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;width:100%;height:100%}[_nghost-%COMP%]:not([data-mode])   .icon._hint_hovered[_ngcontent-%COMP%]{color:var(--tui-text-02)}[data-mode=onDark][_nghost-%COMP%]   .icon[_ngcontent-%COMP%], [data-mode=onLight][_nghost-%COMP%]   .icon[_ngcontent-%COMP%]{opacity:var(--tui-disabled-opacity)}[data-mode=onDark][_nghost-%COMP%]   .icon._hint_hovered[_ngcontent-%COMP%], [data-mode=onDark][_nghost-%COMP%]   .icon[_ngcontent-%COMP%]:hover, [data-mode=onLight][_nghost-%COMP%]   .icon._hint_hovered[_ngcontent-%COMP%], [data-mode=onLight][_nghost-%COMP%]   .icon[_ngcontent-%COMP%]:hover{opacity:1}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTooltipComponent.prototype, "content", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTooltipComponent.prototype, "mode", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTooltipComponent.prototype, "direction", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTooltipComponent.prototype, "showDelay", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTooltipComponent.prototype, "hideDelay", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTooltipComponent.prototype, "describeId", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('attr.data-mode')], TuiTooltipComponent.prototype, "computedMode", null);
  TuiTooltipComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_MODE */.Au))], TuiTooltipComponent);
  return TuiTooltipComponent;
})();
let TuiTooltipModule = /*#__PURE__*/(() => {
  let TuiTooltipModule = class TuiTooltipModule {};
  TuiTooltipModule.ɵfac = function TuiTooltipModule_Factory(t) {
    return new (t || TuiTooltipModule)();
  };
  TuiTooltipModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiTooltipModule
  });
  TuiTooltipModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiHintModule]]
  });
  return TuiTooltipModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiTooltipModule, {
    declarations: function () {
      return [TuiTooltipComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiHintModule];
    },
    exports: function () {
      return [TuiTooltipComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-tooltip.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-wrapper.js
var taiga_ui_core_components_wrapper = __webpack_require__(1144);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-directives-mask-accessor.js





function fallbackAccessorFactory(accessor, fallback) {
  return accessor ? accessor[0] : fallback;
}
let TuiMaskAccessorDirective = /*#__PURE__*/(() => {
  let TuiMaskAccessorDirective = class TuiMaskAccessorDirective {};
  TuiMaskAccessorDirective.ɵfac = function TuiMaskAccessorDirective_Factory(t) {
    return new (t || TuiMaskAccessorDirective)();
  };
  TuiMaskAccessorDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiMaskAccessorDirective,
    selectors: [["input", "tuiMaskAccessor", ""]],
    features: [core_js_["ɵɵProvidersFeature"]([{
      provide: fesm2015_forms.NG_VALUE_ACCESSOR,
      deps: [[new core_js_.Optional(), taiga_ui_core_tokens/* TUI_VALUE_ACCESSOR */.sE], fesm2015_forms.DefaultValueAccessor],
      useFactory: fallbackAccessorFactory,
      multi: true
    }])]
  });

  /**
   * @internal
   */
  return TuiMaskAccessorDirective;
})();
let TuiMaskAccessorModule = /*#__PURE__*/(() => {
  let TuiMaskAccessorModule = class TuiMaskAccessorModule {};
  TuiMaskAccessorModule.ɵfac = function TuiMaskAccessorModule_Factory(t) {
    return new (t || TuiMaskAccessorModule)();
  };
  TuiMaskAccessorModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiMaskAccessorModule
  });
  TuiMaskAccessorModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiMaskAccessorModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiMaskAccessorModule, {
    declarations: [TuiMaskAccessorDirective],
    exports: [TuiMaskAccessorDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-directives-mask-accessor.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-primitive-textfield.js






























const taiga_ui_core_components_primitive_textfield_c0 = ["focusableElement"];
function TuiPrimitiveTextfieldComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 14);
    core_js_["ɵɵprojection"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵstyleProp"]("padding-left", ctx_r1.paddingLeft, "px")("border-right-width", ctx_r1.paddingRight, "px");
  }
}
function TuiPrimitiveTextfieldComponent_div_5_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 16);
  }
  if (rf & 2) {
    const iconSrc_r10 = ctx.$implicit;
    core_js_["ɵɵproperty"]("src", iconSrc_r10);
  }
}
function TuiPrimitiveTextfieldComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 15);
    core_js_["ɵɵtemplate"](1, TuiPrimitiveTextfieldComponent_div_5_ng_template_1_Template, 1, 1, "ng-template");
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("content", ctx_r2.iconContent);
  }
}
function TuiPrimitiveTextfieldComponent_label_9_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "label", 17);
    core_js_["ɵɵprojection"](1, 1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r3 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵclassProp"]("placeholder_raised", ctx_r3.placeholderRaised);
    core_js_["ɵɵproperty"]("for", ctx_r3.id);
  }
}
function TuiPrimitiveTextfieldComponent_div_10_span_6_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "span", 23);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r11 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵclassProp"]("postfix_shifted", ctx_r11.postfixShifted);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate"](ctx_r11.postfix);
  }
}
function TuiPrimitiveTextfieldComponent_div_10_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 18);
    core_js_["ɵɵelementStart"](1, "span", 19);
    core_js_["ɵɵelementStart"](2, "span", 20);
    core_js_["ɵɵtext"](3);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementStart"](4, "span", 21);
    core_js_["ɵɵtext"](5);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵtemplate"](6, TuiPrimitiveTextfieldComponent_div_10_span_6_Template, 2, 3, "span", 22);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r4 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](3);
    core_js_["ɵɵtextInterpolate"](ctx_r4.value);
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵtextInterpolate"](ctx_r4.computedFiller);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", ctx_r4.hasPostfix);
  }
}
function TuiPrimitiveTextfieldComponent_div_11_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 25);
  }
  if (rf & 2) {
    const iconSrc_r13 = ctx.$implicit;
    core_js_["ɵɵproperty"]("src", iconSrc_r13);
  }
}
function TuiPrimitiveTextfieldComponent_div_11_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 24);
    core_js_["ɵɵtemplate"](1, TuiPrimitiveTextfieldComponent_div_11_ng_template_1_Template, 1, 1, "ng-template");
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r5 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("content", ctx_r5.controller.customContent);
  }
}
function TuiPrimitiveTextfieldComponent_tui_svg_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r15 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "tui-svg", 26);
    core_js_["ɵɵlistener"]("click.stop", function TuiPrimitiveTextfieldComponent_tui_svg_12_Template_tui_svg_click_stop_0_listener() {
      core_js_["ɵɵrestoreView"](_r15);
      const ctx_r14 = core_js_["ɵɵnextContext"]();
      return ctx_r14.clear();
    });
    core_js_["ɵɵelementEnd"]();
  }
}
function TuiPrimitiveTextfieldComponent_tui_tooltip_13_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-tooltip", 27);
  }
  if (rf & 2) {
    const ctx_r7 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("describeId", ctx_r7.id)("content", ctx_r7.hintController.content)("direction", ctx_r7.hintController.direction)("mode", ctx_r7.hintController.mode)("showDelay", ctx_r7.hintController.showDelay)("hideDelay", ctx_r7.hintController.hideDelay);
  }
}
function TuiPrimitiveTextfieldComponent_div_14_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 16);
  }
  if (rf & 2) {
    const iconSrc_r17 = ctx.$implicit;
    core_js_["ɵɵproperty"]("src", iconSrc_r17);
  }
}
function TuiPrimitiveTextfieldComponent_div_14_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 28);
    core_js_["ɵɵtemplate"](1, TuiPrimitiveTextfieldComponent_div_14_ng_template_1_Template, 1, 1, "ng-template");
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r8 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("content", ctx_r8.iconContent);
  }
}
const taiga_ui_core_components_primitive_textfield_c1 = [[["", "polymorpheus-outlet", ""]], "*"];
const taiga_ui_core_components_primitive_textfield_c2 = ["[polymorpheus-outlet]", "*"];
const TUI_PRIMITIVE_TEXTFIELD_PROVIDERS = [{
  provide: taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ,
  useExisting: (0,core_js_.forwardRef)(() => TuiPrimitiveTextfieldComponent)
}, TEXTFIELD_CONTROLLER_PROVIDER, HINT_CONTROLLER_PROVIDER, taiga_ui_core_providers/* MODE_PROVIDER */.CV];
const ICON_PADDING = 28;
const ICON_PADDING_S = 24;
let TuiPrimitiveTextfieldComponent = /*#__PURE__*/(() => {
  let TuiPrimitiveTextfieldComponent = class TuiPrimitiveTextfieldComponent extends taiga_ui_cdk_abstract/* AbstractTuiInteractive */.Xn {
    constructor(mode$, appearance, controller, hintController) {
      super();
      this.mode$ = mode$;
      this.appearance = appearance;
      this.controller = controller;
      this.hintController = hintController;
      this.editable = true;
      this.filler = '';
      this.iconAlign = 'right';
      this.iconContent = null;
      this.readOnly = false;
      this.invalid = false;
      this.disabled = false;
      this.postfix = '';
      this.value = '';
      this.valueChange = new core_js_.EventEmitter();
      this.autofilledChange = new core_js_.EventEmitter();
      this.autofilled = false;
    }
    get nativeFocusableElement() {
      return this.computedDisabled || !this.focusableElement ? null : this.focusableElement.nativeElement;
    }
    get focused() {
      return (0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(this.nativeFocusableElement);
    }
    get size() {
      return this.controller.size;
    }
    get labelOutside() {
      return this.controller.labelOutside;
    }
    get computedInvalid() {
      return !this.readOnly && !this.disabled && this.invalid;
    }
    get inputHidden() {
      return !!this.content;
    }
    get hasTooltip() {
      return !!this.hintController && !!this.hintController.content && !this.disabled;
    }
    get hasCustomContent() {
      return !!this.controller.customContent;
    }
    get iconPaddingLeft() {
      return this.size === 's' ? ICON_PADDING_S : ICON_PADDING;
    }
    get paddingLeft() {
      return (this.iconAlignLeft ? this.iconPaddingLeft : 0) + (0,taiga_ui_core_utils_miscellaneous/* getPadding */.tQ)((0,taiga_ui_core_utils_miscellaneous/* sizeBigger */.Bb)(this.size, 'm'), false);
    }
    get paddingRight() {
      return (0,taiga_ui_core_utils_miscellaneous/* getPadding */.tQ)((0,taiga_ui_core_utils_miscellaneous/* sizeBigger */.Bb)(this.size, 'm'), this.iconAlignRight, this.hasCleaner, this.hasTooltip, this.hasCustomContent);
    }
    get hasPlaceholder() {
      return this.big && !this.labelOutside || !this.hasValue && !this.hasExampleText && !this.hasPostfix;
    }
    get placeholderRaised() {
      return this.big && !this.labelOutside && (this.computedFocused && !this.readOnly || this.hasValue || this.autofilled);
    }
    get iconAlignLeft() {
      return this.hasIcon && this.iconAlign === 'left';
    }
    get iconAlignRight() {
      return this.hasIcon && this.iconAlign === 'right';
    }
    get hasValue() {
      return !!this.value;
    }
    get hasCleaner() {
      return this.controller.cleaner && this.hasValue && !this.disabled && !this.readOnly;
    }
    get rightAligned() {
      return this.appearance === "table" /* Table */ && (this.controller.inputMode === "numeric" /* Numeric */ || this.controller.inputMode === "decimal" /* Decimal */);
    }

    get hasValueDecoration() {
      const fillerOrExampleShown = this.computedFocused && !this.readOnly && this.hasFillerOrExampleText;
      return fillerOrExampleShown || this.hasPostfix;
    }
    get hasPostfix() {
      const isPostfixAllowed = this.hasValue || this.computedFocused && !this.readOnly;
      return isPostfixAllowed && !!this.postfix;
    }
    get hasFillerOrExampleText() {
      return this.hasValue ? !!this.computedFiller : !!this.controller.exampleText;
    }
    get postfixShifted() {
      return this.postfix !== '%' && (this.hasFillerOrExampleText || this.hasValue);
    }
    get computedFiller() {
      return this.hasExampleText ? this.controller.exampleText : this.filler.slice(this.value.length);
    }
    // Safari expiration date autofill workaround
    get name() {
      return this.controller.autocomplete === "cc-exp" /* CcExp */ ? 'ccexpiryyear' : null;
    }
    clear() {
      this.updateValue('');
    }
    onMouseDown(event) {
      if (!this.focusableElement || event.target === this.focusableElement.nativeElement) {
        return;
      }
      event.preventDefault();
      (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(this.focusableElement.nativeElement);
    }
    onModelChange(value) {
      this.updateValue(value);
    }
    onHovered(hovered) {
      this.updateHovered(hovered);
    }
    onFocused(focused) {
      this.updateFocused(focused);
    }
    onAutofilled(autofilled) {
      this.updateAutofilled(autofilled);
    }
    get big() {
      return this.size !== 's';
    }
    get hasIcon() {
      return !!this.iconContent;
    }
    get hasExampleText() {
      return !!this.controller.exampleText && this.computedFocused && !this.hasValue && !this.readOnly;
    }
    updateAutofilled(autofilled) {
      if (this.autofilled === autofilled) {
        return;
      }
      this.autofilled = autofilled;
      this.autofilledChange.emit(autofilled);
    }
    updateValue(value) {
      this.value = value;
      this.valueChange.emit(value);
    }
  };
  TuiPrimitiveTextfieldComponent.ɵfac = function TuiPrimitiveTextfieldComponent_Factory(t) {
    return new (t || TuiPrimitiveTextfieldComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_MODE */.Au), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_TEXTFIELD_APPEARANCE */.jt), core_js_["ɵɵdirectiveInject"](TUI_TEXTFIELD_WATCHED_CONTROLLER), core_js_["ɵɵdirectiveInject"](TUI_HINT_WATCHED_CONTROLLER));
  };
  TuiPrimitiveTextfieldComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiPrimitiveTextfieldComponent,
    selectors: [["tui-primitive-textfield"]],
    contentQueries: function TuiPrimitiveTextfieldComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        core_js_["ɵɵcontentQuery"](dirIndex, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, 5);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.content = _t.first);
      }
    },
    viewQuery: function TuiPrimitiveTextfieldComponent_Query(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵviewQuery"](taiga_ui_core_components_primitive_textfield_c0, 5);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.focusableElement = _t.first);
      }
    },
    hostVars: 9,
    hostBindings: function TuiPrimitiveTextfieldComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("$.data-mode.attr", function TuiPrimitiveTextfieldComponent___data_mode_attr_HostBindingHandler() {
          return ctx.mode$;
        });
      }
      if (rf & 2) {
        core_js_["ɵɵattribute"]("data-tui-host-size", ctx.size);
        core_js_["ɵɵclassProp"]("_readonly", ctx.readOnly)("_label-outside", ctx.labelOutside)("_invalid", ctx.computedInvalid)("_right-aligned", ctx.rightAligned);
      }
    },
    inputs: {
      editable: "editable",
      filler: "filler",
      iconAlign: "iconAlign",
      iconContent: "iconContent",
      readOnly: "readOnly",
      invalid: "invalid",
      disabled: "disabled",
      postfix: "postfix",
      value: "value"
    },
    outputs: {
      valueChange: "valueChange",
      autofilledChange: "autofilledChange"
    },
    features: [core_js_["ɵɵProvidersFeature"](TUI_PRIMITIVE_TEXTFIELD_PROVIDERS), core_js_["ɵɵInheritDefinitionFeature"]],
    ngContentSelectors: taiga_ui_core_components_primitive_textfield_c2,
    decls: 15,
    vars: 35,
    consts: [["automation-id", "tui-primitive-textfield__wrapper", "tuiPreventDefault", "click", 3, "appearance", "readOnly", "disabled", "focused", "hovered", "pressed", "invalid", "tuiHoveredChange", "mousedown"], ["tuiMaskAccessor", "", "automation-id", "tui-primitive-textfield__native-input", 1, "input", 3, "autocomplete", "type", "id", "readOnly", "tuiInputMode", "tuiFocusable", "tuiDescribedBy", "ngModel", "ngModelChange", "tuiFocusedChange", "tuiAutofilledChange"], ["focusableElement", ""], ["automation-id", "tui-primitive-textfield__value", "class", "input input_template", 3, "paddingLeft", "borderRightWidth", 4, "ngIf"], [1, "content"], ["polymorpheus-outlet", "", "class", "icon icon_left", 3, "content", 4, "ngIf"], [1, "wrapper"], ["aria-hidden", "true", 1, "value"], ["automation-id", "tui-primitive-textfield__placeholder", "class", "placeholder", 3, "placeholder_raised", "for", 4, "ngIf"], ["class", "value-decoration", "automation-id", "tui-primitive-textfield__value-decoration", "aria-hidden", "true", 4, "ngIf"], ["polymorpheus-outlet", "", "class", "custom-content", "automation-id", "tui-primitive-textfield__custom-content", 3, "content", 4, "ngIf"], ["class", "cleaner", "automation-id", "tui-primitive-textfield__cleaner", "src", "tuiIconCloseLarge", 3, "click.stop", 4, "ngIf"], ["automation-id", "tui-primitive-textfield__tooltip", 3, "describeId", "content", "direction", "mode", "showDelay", "hideDelay", 4, "ngIf"], ["polymorpheus-outlet", "", "class", "icon", 3, "content", 4, "ngIf"], ["automation-id", "tui-primitive-textfield__value", 1, "input", "input_template"], ["polymorpheus-outlet", "", 1, "icon", "icon_left", 3, "content"], [3, "src"], ["automation-id", "tui-primitive-textfield__placeholder", 1, "placeholder", 3, "for"], ["automation-id", "tui-primitive-textfield__value-decoration", "aria-hidden", "true", 1, "value-decoration"], [1, "value-decoration-inner"], [1, "ghost"], ["automation-id", "tui-primitive-textfield__example-text"], ["class", "postfix", 3, "postfix_shifted", 4, "ngIf"], [1, "postfix"], ["polymorpheus-outlet", "", "automation-id", "tui-primitive-textfield__custom-content", 1, "custom-content", 3, "content"], [1, "custom-icon", 3, "src"], ["automation-id", "tui-primitive-textfield__cleaner", "src", "tuiIconCloseLarge", 1, "cleaner", 3, "click.stop"], ["automation-id", "tui-primitive-textfield__tooltip", 3, "describeId", "content", "direction", "mode", "showDelay", "hideDelay"], ["polymorpheus-outlet", "", 1, "icon", 3, "content"]],
    template: function TuiPrimitiveTextfieldComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"](taiga_ui_core_components_primitive_textfield_c1);
        core_js_["ɵɵelementStart"](0, "tui-wrapper", 0);
        core_js_["ɵɵlistener"]("tuiHoveredChange", function TuiPrimitiveTextfieldComponent_Template_tui_wrapper_tuiHoveredChange_0_listener($event) {
          return ctx.onHovered($event);
        })("mousedown", function TuiPrimitiveTextfieldComponent_Template_tui_wrapper_mousedown_0_listener($event) {
          return ctx.onMouseDown($event);
        });
        core_js_["ɵɵelementStart"](1, "input", 1, 2);
        core_js_["ɵɵlistener"]("ngModelChange", function TuiPrimitiveTextfieldComponent_Template_input_ngModelChange_1_listener($event) {
          return ctx.onModelChange($event);
        })("tuiFocusedChange", function TuiPrimitiveTextfieldComponent_Template_input_tuiFocusedChange_1_listener($event) {
          return ctx.onFocused($event);
        })("tuiAutofilledChange", function TuiPrimitiveTextfieldComponent_Template_input_tuiAutofilledChange_1_listener($event) {
          return ctx.onAutofilled($event);
        });
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](3, TuiPrimitiveTextfieldComponent_div_3_Template, 2, 4, "div", 3);
        core_js_["ɵɵelementStart"](4, "div", 4);
        core_js_["ɵɵtemplate"](5, TuiPrimitiveTextfieldComponent_div_5_Template, 2, 1, "div", 5);
        core_js_["ɵɵelementStart"](6, "div", 6);
        core_js_["ɵɵelementStart"](7, "span", 7);
        core_js_["ɵɵtext"](8);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](9, TuiPrimitiveTextfieldComponent_label_9_Template, 2, 3, "label", 8);
        core_js_["ɵɵtemplate"](10, TuiPrimitiveTextfieldComponent_div_10_Template, 7, 3, "div", 9);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](11, TuiPrimitiveTextfieldComponent_div_11_Template, 2, 1, "div", 10);
        core_js_["ɵɵtemplate"](12, TuiPrimitiveTextfieldComponent_tui_svg_12_Template, 1, 0, "tui-svg", 11);
        core_js_["ɵɵtemplate"](13, TuiPrimitiveTextfieldComponent_tui_tooltip_13_Template, 1, 6, "tui-tooltip", 12);
        core_js_["ɵɵtemplate"](14, TuiPrimitiveTextfieldComponent_div_14_Template, 2, 1, "div", 13);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("appearance", ctx.appearance)("readOnly", ctx.readOnly)("disabled", ctx.disabled)("focused", ctx.computedFocused)("hovered", ctx.computedHovered)("pressed", ctx.computedPressed)("invalid", ctx.computedInvalid);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵstyleProp"]("padding-left", ctx.paddingLeft, "px")("padding-right", ctx.paddingRight, "px");
        core_js_["ɵɵclassProp"]("input_hidden", ctx.inputHidden);
        core_js_["ɵɵproperty"]("autocomplete", ctx.controller.autocomplete)("type", ctx.controller.type)("id", ctx.id)("readOnly", ctx.readOnly || !ctx.editable)("tuiInputMode", ctx.controller.inputMode)("tuiFocusable", ctx.computedFocusable)("tuiDescribedBy", ctx.id)("ngModel", ctx.value);
        core_js_["ɵɵattribute"]("disabled", ctx.computedDisabled || null)("maxLength", ctx.controller.maxLength)("name", ctx.name)("aria-placeholder", ctx.controller.exampleText)("aria-invalid", ctx.computedInvalid);
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵproperty"]("ngIf", ctx.inputHidden);
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵproperty"]("ngIf", ctx.iconAlignLeft);
        core_js_["ɵɵadvance"](3);
        core_js_["ɵɵtextInterpolate"](ctx.value);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.hasPlaceholder);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.hasValueDecoration);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.hasCustomContent);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.hasCleaner);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.hasTooltip);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.iconAlignRight);
      }
    },
    directives: [taiga_ui_core_components_wrapper/* TuiWrapperComponent */.Q, TuiPreventDefaultDirective, TuiHoveredDirective, TuiMaskAccessorDirective, TuiInputModeDirective, fesm2015_forms.DefaultValueAccessor, TuiAutofilledDirective, TuiFocusableDirective, TuiDescribedByDirective, fesm2015_forms.NgControlStatus, fesm2015_forms.NgModel, TuiFocusedDirective, common_js_.NgIf, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, taiga_ui_core_components_svg/* TuiSvgComponent */.P, TuiTooltipComponent],
    styles: ["[_nghost-%COMP%]{font:var(--tui-font-text-s);color:var(--tui-text-01);position:relative;display:block;border-radius:var(--tui-radius-m)}[data-tui-host-size='s'][_nghost-%COMP%]{height:var(--tui-height-s);min-height:var(--tui-height-s);max-height:var(--tui-height-s)}[data-tui-host-size='m'][_nghost-%COMP%]{height:var(--tui-height-m);min-height:var(--tui-height-m);max-height:var(--tui-height-m)}[data-tui-host-size='l'][_nghost-%COMP%]{height:var(--tui-height-l);min-height:var(--tui-height-l);max-height:var(--tui-height-l);font-size:15px}.input[_ngcontent-%COMP%]{font:var(--tui-font-text-s);color:var(--tui-text-01);padding:0 12px;border:0;border-radius:inherit;background:0 0;font-size:inherit;line-height:inherit;font-weight:inherit;color:inherit;caret-color:currentColor;outline:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;word-break:keep-all;-webkit-text-fill-color:currentColor;position:absolute;top:0;left:0;width:100%;height:100%;box-sizing:border-box;white-space:nowrap;overflow:hidden;text-transform:inherit}.input[_ngcontent-%COMP%]:-webkit-autofill, .input[_ngcontent-%COMP%]:-webkit-autofill:focus, .input[_ngcontent-%COMP%]:-webkit-autofill:hover{border-radius:inherit;-webkit-text-fill-color:inherit!important;color:inherit!important;background-color:transparent!important;-webkit-box-shadow:0 0 0 1000px var(--tui-autofill) inset!important}[data-tui-host-size='s'][_nghost-%COMP%]   .input[_ngcontent-%COMP%]{padding:0 8px 0 12px}[data-tui-host-size='l'][_nghost-%COMP%]   .input[_ngcontent-%COMP%]{padding:0 16px}._disabled[_nghost-%COMP%]   .input[_ngcontent-%COMP%]{pointer-events:none}._right-aligned[_nghost-%COMP%]   .input[_ngcontent-%COMP%]{text-align:right}[data-tui-host-size='l'][_nghost-%COMP%]:not(._label-outside)   .input[_ngcontent-%COMP%]{padding-top:20px}[data-tui-host-size='l'][_nghost-%COMP%]:not(._label-outside)   .input[_ngcontent-%COMP%]:-webkit-autofill + .content[_ngcontent-%COMP%]   .placeholder[_ngcontent-%COMP%]{width:114%;transform:translateY(-10px) scale(.87)}[data-tui-host-size='m'][_nghost-%COMP%]:not(._label-outside)   .input[_ngcontent-%COMP%]{padding-top:18px}[data-tui-host-size='m'][_nghost-%COMP%]:not(._label-outside)   .input[_ngcontent-%COMP%]:-webkit-autofill + .content[_ngcontent-%COMP%]   .placeholder[_ngcontent-%COMP%]{width:118%;transform:translateY(-8px) scale(.85)}.ghost[_ngcontent-%COMP%]{visibility:hidden;white-space:pre;text-overflow:clip}.filler[_ngcontent-%COMP%]{vertical-align:middle}.content[_ngcontent-%COMP%]{display:flex;height:100%;width:100%;padding:0 12px;box-sizing:border-box;align-items:center;overflow:hidden}[data-tui-host-size='s'][_nghost-%COMP%]   .content[_ngcontent-%COMP%]{padding-right:8px}[data-tui-host-size='l'][_nghost-%COMP%]   .content[_ngcontent-%COMP%]{padding-left:16px}.wrapper[_ngcontent-%COMP%]{flex:1;min-width:0;padding-right:4px}.value-decoration[_ngcontent-%COMP%]{display:flex;align-items:center;height:20px;margin:-20px 0;padding:10px 0;box-sizing:content-box;color:var(--tui-text-03);letter-spacing:normal;text-transform:none}._right-aligned[_nghost-%COMP%]   .value-decoration[_ngcontent-%COMP%]{flex-direction:row-reverse;margin-right:-4px}[data-tui-host-size='m']._label-outside[_nghost-%COMP%]   .value-decoration[_ngcontent-%COMP%]{margin-top:-19px}[data-mode=onDark][_nghost-%COMP%]   .value-decoration[_ngcontent-%COMP%]{color:var(--tui-text-03-night)}.value-decoration-inner[_ngcontent-%COMP%]{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;min-width:0}.postfix[_ngcontent-%COMP%]{transition-property:color;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;color:var(--tui-text-01)}.postfix_shifted[_ngcontent-%COMP%]{margin-left:.5ch}[data-mode=onDark][_nghost-%COMP%]   .postfix[_ngcontent-%COMP%]{color:var(--tui-text-01-night)}.placeholder[_ngcontent-%COMP%]{transition-property:transform,min-width,color,letter-spacing;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;font:var(--tui-font-text-s);color:var(--tui-text-01);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;width:100%;height:20px;font-size:13px;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none;color:var(--tui-text-02);transform-origin:left;letter-spacing:normal;text-transform:none}.placeholder_raised[_ngcontent-%COMP%]{width:114%;transform:translateY(-10px) scale(.87)}[data-tui-host-size='m'][_nghost-%COMP%]   .placeholder_raised[_ngcontent-%COMP%]{width:118%;transform:translateY(-8px) scale(.85);letter-spacing:.4px}._invalid[_nghost-%COMP%]:not(._focused)   .placeholder_raised[_ngcontent-%COMP%], ._invalid[_nghost-%COMP%]:not(._focused)._hovered   .placeholder_raised[_ngcontent-%COMP%]{color:var(--tui-error-fill)}[data-mode=onDark]._invalid[_nghost-%COMP%]:not(._focused)   .placeholder_raised[_ngcontent-%COMP%], [data-mode=onDark]._invalid[_nghost-%COMP%]:not(._focused)._hovered   .placeholder_raised[_ngcontent-%COMP%]{color:var(--tui-error-fill-night)}._focused[_nghost-%COMP%]   .placeholder[_ngcontent-%COMP%], [data-tui-host-size='l']._focused._label-outside[_nghost-%COMP%]   .placeholder[_ngcontent-%COMP%], [data-tui-host-size='m']._focused._label-outside[_nghost-%COMP%]   .placeholder[_ngcontent-%COMP%]{color:var(--tui-text-03)}[data-tui-host-size='l'][_nghost-%COMP%]   .placeholder[_ngcontent-%COMP%]{font-size:15px}[data-tui-host-size='l']._focused[_nghost-%COMP%]:not(._label-outside)   .placeholder[_ngcontent-%COMP%], [data-tui-host-size='m']._focused[_nghost-%COMP%]:not(._label-outside)   .placeholder[_ngcontent-%COMP%]{color:var(--tui-text-01)}[data-mode=onDark][_nghost-%COMP%]   .placeholder[_ngcontent-%COMP%]{color:var(--tui-text-02-night)}[data-tui-host-size='l'][data-mode=onDark]._focused[_nghost-%COMP%]:not(._label-outside)   .placeholder[_ngcontent-%COMP%], [data-tui-host-size='m'][data-mode=onDark]._focused[_nghost-%COMP%]:not(._label-outside)   .placeholder[_ngcontent-%COMP%]{color:var(--tui-text-01-night)}[data-mode=onDark]._focused[_nghost-%COMP%]   .placeholder[_ngcontent-%COMP%], [data-tui-host-size='l'][data-mode=onDark]._focused._label-outside[_nghost-%COMP%]   .placeholder[_ngcontent-%COMP%], [data-tui-host-size='m'][data-mode=onDark]._focused._label-outside[_nghost-%COMP%]   .placeholder[_ngcontent-%COMP%]{color:var(--tui-text-02-night)}.cleaner[_ngcontent-%COMP%]{transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;display:flex;width:24px;height:24px;align-items:center;justify-content:center;color:var(--tui-text-03);position:relative;box-sizing:border-box;cursor:pointer;transition-property:color,transform}.cleaner[_ngcontent-%COMP%]:hover{color:var(--tui-text-02)}._disabled[_nghost-%COMP%]   .cleaner[_ngcontent-%COMP%], ._readonly[_nghost-%COMP%]   .cleaner[_ngcontent-%COMP%]{pointer-events:none}[data-mode=onDark][_nghost-%COMP%]   .cleaner[_ngcontent-%COMP%]{color:var(--tui-text-03-night)}[data-mode=onDark][_nghost-%COMP%]   .cleaner[_ngcontent-%COMP%]:hover{color:var(--tui-text-01-night)}.icon[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;color:var(--tui-text-03)}.icon_left[_ngcontent-%COMP%]{margin:0 8px 0 -4px}[data-tui-host-size='s'][_nghost-%COMP%]   .icon_left[_ngcontent-%COMP%]{margin-right:4px}.value[_ngcontent-%COMP%]{height:0;display:none;visibility:hidden;white-space:pre}table[_nghost-%COMP%]   .value[_ngcontent-%COMP%], table   [_nghost-%COMP%]   .value[_ngcontent-%COMP%]{display:block}.custom-content[_ngcontent-%COMP%]{position:relative;display:flex;align-items:center;justify-content:center;width:32px;height:32px;margin-right:4px;pointer-events:none}.custom-icon[_ngcontent-%COMP%]{width:100%;height:100%}.icon[_ngcontent-%COMP%]{transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;display:flex;width:24px;height:24px;align-items:center;justify-content:center;color:var(--tui-text-03);box-sizing:border-box;cursor:pointer;transition-property:color,transform;position:relative;pointer-events:none}.icon[_ngcontent-%COMP%]:hover{color:var(--tui-text-02)}._disabled[_nghost-%COMP%]   .icon[_ngcontent-%COMP%], ._readonly[_nghost-%COMP%]   .icon[_ngcontent-%COMP%]{pointer-events:none}[data-mode=onDark][_nghost-%COMP%]   .icon[_ngcontent-%COMP%]{color:var(--tui-text-03-night)}[data-mode=onDark][_nghost-%COMP%]   .icon[_ngcontent-%COMP%]:hover{color:var(--tui-text-01-night)}._hovered[_nghost-%COMP%]:not(._readonly)   .icon[_ngcontent-%COMP%]{color:var(--tui-text-02)}[data-mode=onDark]._hovered[_nghost-%COMP%]:not(._readonly)   .icon[_ngcontent-%COMP%]{color:var(--tui-text-01-night)}[data-mode=onLight]._hovered[_nghost-%COMP%]:not(._readonly)   .icon[_ngcontent-%COMP%]{color:var(--tui-text-01)}.input_hidden[_ngcontent-%COMP%]{opacity:0;text-indent:-10em;-webkit-user-select:none}[data-tui-host-size][_nghost-%COMP%]   .input_template[_ngcontent-%COMP%]{display:flex;width:100%;max-width:100%;align-items:center;padding-right:0;border-right:0 solid transparent;pointer-events:none}.input[_ngcontent-%COMP%]::-webkit-caps-lock-indicator{margin-right:6px;align-self:center}[data-tui-host-size='l'][_nghost-%COMP%]:not(._label-outside)   .input[_ngcontent-%COMP%]::-webkit-caps-lock-indicator{margin-top:-20px}.input[_ngcontent-%COMP%]::-webkit-contacts-auto-fill-button, .input[_ngcontent-%COMP%]::-webkit-credentials-auto-fill-button, .input[_ngcontent-%COMP%]::-webkit-credit-card-auto-fill-button{background-color:var(--tui-text-03)}[data-tui-host-size='l'][_nghost-%COMP%]:not(._label-outside)   .input[_ngcontent-%COMP%]::-webkit-contacts-auto-fill-button, [data-tui-host-size='l'][_nghost-%COMP%]:not(._label-outside)   .input[_ngcontent-%COMP%]::-webkit-credentials-auto-fill-button, [data-tui-host-size='l'][_nghost-%COMP%]:not(._label-outside)   .input[_ngcontent-%COMP%]::-webkit-credit-card-auto-fill-button{margin-top:-20px}.input[_ngcontent-%COMP%]::-webkit-contacts-auto-fill-button:hover, .input[_ngcontent-%COMP%]::-webkit-credentials-auto-fill-button:hover, .input[_ngcontent-%COMP%]::-webkit-credit-card-auto-fill-button:hover{background-color:var(--tui-text-02)}.text-template[_ngcontent-%COMP%]{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveTextfieldComponent.prototype, "editable", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveTextfieldComponent.prototype, "filler", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveTextfieldComponent.prototype, "iconAlign", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveTextfieldComponent.prototype, "iconContent", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._readonly'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveTextfieldComponent.prototype, "readOnly", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveTextfieldComponent.prototype, "invalid", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveTextfieldComponent.prototype, "disabled", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveTextfieldComponent.prototype, "postfix", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveTextfieldComponent.prototype, "value", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiPrimitiveTextfieldComponent.prototype, "valueChange", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiPrimitiveTextfieldComponent.prototype, "autofilledChange", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('focusableElement')], TuiPrimitiveTextfieldComponent.prototype, "focusableElement", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChild)(tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1)], TuiPrimitiveTextfieldComponent.prototype, "content", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('attr.data-tui-host-size')], TuiPrimitiveTextfieldComponent.prototype, "size", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._label-outside')], TuiPrimitiveTextfieldComponent.prototype, "labelOutside", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._invalid')], TuiPrimitiveTextfieldComponent.prototype, "computedInvalid", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._right-aligned')], TuiPrimitiveTextfieldComponent.prototype, "rightAligned", null);
  TuiPrimitiveTextfieldComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_MODE */.Au)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_TEXTFIELD_APPEARANCE */.jt)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(TUI_TEXTFIELD_WATCHED_CONTROLLER)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TUI_HINT_WATCHED_CONTROLLER))], TuiPrimitiveTextfieldComponent);
  return TuiPrimitiveTextfieldComponent;
})();
let TuiPrimitiveTextfieldModule = /*#__PURE__*/(() => {
  let TuiPrimitiveTextfieldModule = class TuiPrimitiveTextfieldModule {};
  TuiPrimitiveTextfieldModule.ɵfac = function TuiPrimitiveTextfieldModule_Factory(t) {
    return new (t || TuiPrimitiveTextfieldModule)();
  };
  TuiPrimitiveTextfieldModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiPrimitiveTextfieldModule
  });
  TuiPrimitiveTextfieldModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, fesm2015_forms.FormsModule, TuiMaskAccessorModule, TuiFocusableModule, TuiFocusedModule, TuiHoveredModule, TuiInputModeModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_wrapper/* TuiWrapperModule */.W, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiTooltipModule, TuiAutofilledModule, TuiDescribedByModule, TuiPreventDefaultModule]]
  });
  return TuiPrimitiveTextfieldModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiPrimitiveTextfieldModule, {
    declarations: function () {
      return [TuiPrimitiveTextfieldComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, fesm2015_forms.FormsModule, TuiMaskAccessorModule, TuiFocusableModule, TuiFocusedModule, TuiHoveredModule, TuiInputModeModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_wrapper/* TuiWrapperModule */.W, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiTooltipModule, TuiAutofilledModule, TuiDescribedByModule, TuiPreventDefaultModule];
    },
    exports: function () {
      return [TuiPrimitiveTextfieldComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-primitive-textfield.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-obscured.js








/**
 * Directive that monitors element visibility
 */



let TuiObscuredDirective = /*#__PURE__*/(() => {
  let TuiObscuredDirective = class TuiObscuredDirective {
    constructor(activeZone, obscured$) {
      this.enabled$ = new Subject/* Subject */.xQ();
      const mapped$ = obscured$.pipe((0,map/* map */.U)(obscuredBy => !!obscuredBy && (!activeZone || !obscuredBy.length || obscuredBy.every(element => !activeZone.contains(element)))));
      this.tuiObscured = this.enabled$.pipe((0,switchMap/* switchMap */.w)(enabled => enabled ? mapped$ : empty/* EMPTY */.E));
    }
    set tuiObscuredEnabled(enabled) {
      this.enabled$.next(enabled);
    }
  };
  TuiObscuredDirective.ɵfac = function TuiObscuredDirective_Factory(t) {
    return new (t || TuiObscuredDirective)(core_js_["ɵɵdirectiveInject"](TuiActiveZoneDirective, 8), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiObscuredService */.AQ, 2));
  };
  TuiObscuredDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiObscuredDirective,
    selectors: [["", "tuiObscured", ""]],
    inputs: {
      tuiObscuredEnabled: "tuiObscuredEnabled"
    },
    outputs: {
      tuiObscured: "tuiObscured"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiObscuredService */.AQ, taiga_ui_cdk_services/* TuiParentsScrollService */.b0, taiga_ui_cdk_services/* TuiDestroyService */.a3])]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiRequiredSetter */.NH)()], TuiObscuredDirective.prototype, "tuiObscuredEnabled", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiObscuredDirective.prototype, "tuiObscured", void 0);
  TuiObscuredDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TuiActiveZoneDirective)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiObscuredService */.AQ))], TuiObscuredDirective);
  return TuiObscuredDirective;
})();
let TuiObscuredModule = /*#__PURE__*/(() => {
  let TuiObscuredModule = class TuiObscuredModule {};
  TuiObscuredModule.ɵfac = function TuiObscuredModule_Factory(t) {
    return new (t || TuiObscuredModule)();
  };
  TuiObscuredModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiObscuredModule
  });
  TuiObscuredModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiObscuredModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiObscuredModule, {
    declarations: [TuiObscuredDirective],
    exports: [TuiObscuredDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-obscured.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-directives-dropdown-controller.js






const TUI_DROPDOWN_CONTROLLER = new core_js_.InjectionToken('Controls configuration of hints', {
  factory: () => new TuiDropdownControllerDirective()
});
var TuiDropdownControllerDirective_1;
let TuiDropdownControllerDirective = TuiDropdownControllerDirective_1 = class TuiDropdownControllerDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor() {
    super(...arguments);
    this.align = 'right';
    this.direction = null;
    this.limitWidth = "auto" /* Auto */;
    this.minHeight = taiga_ui_core_constants/* DEFAULT_MIN_HEIGHT */.q_;
    this.maxHeight = taiga_ui_core_constants/* DEFAULT_MAX_HEIGHT */.ze;
    this.sided = false;
  }
};
TuiDropdownControllerDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiDropdownControllerDirective_BaseFactory;
  return function TuiDropdownControllerDirective_Factory(t) {
    return (ɵTuiDropdownControllerDirective_BaseFactory || (ɵTuiDropdownControllerDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiDropdownControllerDirective)))(t || TuiDropdownControllerDirective);
  };
}();
TuiDropdownControllerDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiDropdownControllerDirective,
  selectors: [["", "tuiDropdownAlign", ""], ["", "tuiDropdownDirection", ""], ["", "tuiDropdownLimitWidth", ""], ["", "tuiDropdownMinHeight", ""], ["", "tuiDropdownMaxHeight", ""], ["", "tuiDropdownSided", ""]],
  inputs: {
    align: ["tuiDropdownAlign", "align"],
    direction: ["tuiDropdownDirection", "direction"],
    limitWidth: ["tuiDropdownLimitWidth", "limitWidth"],
    minHeight: ["tuiDropdownMinHeight", "minHeight"],
    maxHeight: ["tuiDropdownMaxHeight", "maxHeight"],
    sided: ["tuiDropdownSided", "sided"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_DROPDOWN_CONTROLLER,
    useExisting: (0,core_js_.forwardRef)(() => TuiDropdownControllerDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdownAlign'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDropdownControllerDirective.prototype, "align", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdownDirection'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDropdownControllerDirective.prototype, "direction", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdownLimitWidth'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDropdownControllerDirective.prototype, "limitWidth", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdownMinHeight'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDropdownControllerDirective.prototype, "minHeight", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdownMaxHeight'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDropdownControllerDirective.prototype, "maxHeight", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdownSided'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDropdownControllerDirective.prototype, "sided", void 0);
let TuiDropdownControllerModule = /*#__PURE__*/(() => {
  let TuiDropdownControllerModule = class TuiDropdownControllerModule {};
  TuiDropdownControllerModule.ɵfac = function TuiDropdownControllerModule_Factory(t) {
    return new (t || TuiDropdownControllerModule)();
  };
  TuiDropdownControllerModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDropdownControllerModule
  });
  TuiDropdownControllerModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiDropdownControllerModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDropdownControllerModule, {
    declarations: [TuiDropdownControllerDirective],
    exports: [TuiDropdownControllerDirective]
  });
})();
const TUI_DROPDOWN_WATCHED_CONTROLLER = new core_js_.InjectionToken('watched dropdown controller');
// TODO: remove in ivy compilation
const DROPDOWN_CONTROLLER_FACTORY = taiga_ui_core_providers/* watchedControllerFactory */.my;
const DROPDOWN_CONTROLLER_PROVIDER = [taiga_ui_cdk_services/* TuiDestroyService */.a3, {
  provide: TUI_DROPDOWN_WATCHED_CONTROLLER,
  deps: [TUI_DROPDOWN_CONTROLLER, core_js_.ChangeDetectorRef, taiga_ui_cdk_services/* TuiDestroyService */.a3],
  useFactory: DROPDOWN_CONTROLLER_FACTORY
}];

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-directives-dropdown-controller.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-hosted-dropdown.js













const taiga_ui_core_components_hosted_dropdown_c0 = ["wrapper"];
function TuiHostedDropdownComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "div", 3, 4);
    core_js_["ɵɵlistener"]("keydown.esc", function TuiHostedDropdownComponent_ng_template_2_Template_div_keydown_esc_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r4);
      const ctx_r3 = core_js_["ɵɵnextContext"]();
      return ctx_r3.onKeyDownEsc($event);
    })("keydown", function TuiHostedDropdownComponent_ng_template_2_Template_div_keydown_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r4);
      const ctx_r5 = core_js_["ɵɵnextContext"]();
      return ctx_r5.onKeydown($event);
    });
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelement"](2, "div");
  }
  if (rf & 2) {
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("content", ctx_r1.content)("context", ctx_r1.contentContext);
  }
}
const taiga_ui_core_components_hosted_dropdown_c1 = ["*"];
let TuiHostedDropdownConnectorDirective = /*#__PURE__*/(() => {
  let TuiHostedDropdownConnectorDirective = class TuiHostedDropdownConnectorDirective {};
  TuiHostedDropdownConnectorDirective.ɵfac = function TuiHostedDropdownConnectorDirective_Factory(t) {
    return new (t || TuiHostedDropdownConnectorDirective)();
  };
  TuiHostedDropdownConnectorDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiHostedDropdownConnectorDirective,
    selectors: [["", "tuiHostedDropdownHost", ""]]
  });
  return TuiHostedDropdownConnectorDirective;
})();
var TuiHostedDropdownComponent_1;
let TuiHostedDropdownComponent = TuiHostedDropdownComponent_1 = class TuiHostedDropdownComponent {
  constructor(elementRef, controller) {
    this.elementRef = elementRef;
    this.controller = controller;
    this.content = '';
    this.canOpen = true;
    this.open = false;
    this.openChange = new core_js_.EventEmitter();
    this.focusedChange = new core_js_.EventEmitter();
  }
  get host() {
    return this.dropdownHost ? this.dropdownHost.nativeElement : this.elementRef.nativeElement;
  }
  get dropdown() {
    return !this.dropdownDirective || this.dropdownDirective.dropdownBoxRef === null ? null : this.dropdownDirective.dropdownBoxRef.location.nativeElement;
  }
  get nativeFocusableElement() {
    return (0,taiga_ui_cdk_utils_focus/* isNativeKeyboardFocusable */.Wb)(this.host) ? this.host : (0,taiga_ui_cdk_utils_focus/* getClosestFocusable */.kA)(this.host, false, this.elementRef.nativeElement);
  }
  get contentContext() {
    return this.calculateContentContext(this.activeZone);
  }
  get focused() {
    return (0,taiga_ui_cdk_utils_focus/* isNativeFocusedIn */.KF)(this.host) || this.open && !!this.wrapper && (0,taiga_ui_cdk_utils_focus/* isNativeFocusedIn */.KF)(this.wrapper.nativeElement);
  }
  onFocusIn({
    target
  }) {
    const host = this.dropdownHost ? this.dropdownHost.nativeElement : this.nativeFocusableElement || this.elementRef.nativeElement;
    if (!host.contains(target)) {
      this.updateOpen(false);
    }
  }
  onClick({
    target
  }) {
    const host = this.nativeFocusableElement || this.host;
    const dropdownHost = this.dropdownHost ? this.dropdownHost.nativeElement : host;
    if (!this.hostEditable && target instanceof Node && dropdownHost.contains(target)) {
      this.updateOpen(!this.open);
    }
  }
  onKeyDownEsc(event) {
    if (!this.open) {
      return;
    }
    event.stopPropagation();
    this.closeDropdown();
  }
  onArrowDown(event) {
    this.focusDropdown(event, true);
  }
  onArrowUp(event) {
    this.focusDropdown(event, false);
  }
  onKeydown({
    key,
    target,
    defaultPrevented
  }) {
    if (!defaultPrevented && (0,taiga_ui_core_utils_miscellaneous/* isEditingKey */.Rb)(key) && this.hostEditable && target instanceof HTMLElement && !(0,taiga_ui_cdk_utils_miscellaneous/* isElementEditable */.rT)(target)) {
      this.focusHost();
    }
  }
  onActiveZone(active) {
    this.updateFocused(active);
    if (!active) {
      this.updateOpen(false);
    }
  }
  onHostObscured(obscured) {
    if (obscured) {
      this.closeDropdown();
    }
  }
  updateOpen(open) {
    if (open && !this.canOpen) {
      return;
    }
    this.open = open;
    this.openChange.emit(open);
  }
  get hostEditable() {
    const host = this.nativeFocusableElement || this.host;
    return host instanceof HTMLElement && (0,taiga_ui_cdk_utils_miscellaneous/* isElementEditable */.rT)(host);
  }
  calculateContentContext($implicit) {
    return {
      $implicit
    };
  }
  focusDropdown(event, first) {
    const host = this.nativeFocusableElement;
    if (!host || !(host instanceof HTMLElement) || !(event.target instanceof Node) || !host.contains(event.target)) {
      return;
    }
    if (!this.wrapper || !this.open || this.dropdown === null || !(this.wrapper.nativeElement.nextElementSibling instanceof HTMLElement)) {
      this.updateOpen(true);
      if (!(0,taiga_ui_cdk_utils_miscellaneous/* isElementEditable */.rT)(host)) {
        event.preventDefault();
      }
      return;
    }
    const initial = first ? this.wrapper.nativeElement : this.wrapper.nativeElement.nextElementSibling;
    const focusable = (0,taiga_ui_cdk_utils_focus/* getClosestFocusable */.kA)(initial, !first, this.wrapper.nativeElement);
    if (focusable === null) {
      return;
    }
    (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(focusable);
    event.preventDefault();
  }
  closeDropdown() {
    if (this.focused) {
      this.focusHost();
    }
    this.updateOpen(false);
  }
  focusHost() {
    const host = this.nativeFocusableElement;
    if (host !== null) {
      (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(host, true, true);
    }
  }
  updateFocused(focused) {
    this.focusedChange.emit(focused);
  }
};
TuiHostedDropdownComponent.ɵfac = function TuiHostedDropdownComponent_Factory(t) {
  return new (t || TuiHostedDropdownComponent)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](TUI_DROPDOWN_WATCHED_CONTROLLER));
};
TuiHostedDropdownComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiHostedDropdownComponent,
  selectors: [["tui-hosted-dropdown"]],
  contentQueries: function TuiHostedDropdownComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      core_js_["ɵɵcontentQuery"](dirIndex, TuiHostedDropdownConnectorDirective, 5, core_js_.ElementRef);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.dropdownHost = _t.first);
    }
  },
  viewQuery: function TuiHostedDropdownComponent_Query(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵviewQuery"](TuiActiveZoneDirective, 5);
      core_js_["ɵɵviewQuery"](taiga_ui_core_components_hosted_dropdown_c0, 5, core_js_.ElementRef);
      core_js_["ɵɵviewQuery"](TuiDropdownDirective, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.activeZone = _t.first);
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.wrapper = _t.first);
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.dropdownDirective = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function TuiHostedDropdownComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵlistener"]("focusin", function TuiHostedDropdownComponent_focusin_HostBindingHandler($event) {
        return ctx.onFocusIn($event);
      })("click", function TuiHostedDropdownComponent_click_HostBindingHandler($event) {
        return ctx.onClick($event);
      })("keydown.esc", function TuiHostedDropdownComponent_keydown_esc_HostBindingHandler($event) {
        return ctx.onKeyDownEsc($event);
      })("keydown.arrowDown", function TuiHostedDropdownComponent_keydown_arrowDown_HostBindingHandler($event) {
        return ctx.onArrowDown($event);
      })("keydown.arrowUp", function TuiHostedDropdownComponent_keydown_arrowUp_HostBindingHandler($event) {
        return ctx.onArrowUp($event);
      });
    }
    if (rf & 2) {
      core_js_["ɵɵclassProp"]("_hosted_dropdown_focused", ctx.focused);
    }
  },
  inputs: {
    content: "content",
    canOpen: "canOpen",
    open: "open"
  },
  outputs: {
    openChange: "openChange",
    focusedChange: "focusedChange"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ,
    useExisting: (0,core_js_.forwardRef)(() => TuiHostedDropdownComponent_1)
  }, DROPDOWN_CONTROLLER_PROVIDER])],
  ngContentSelectors: taiga_ui_core_components_hosted_dropdown_c1,
  decls: 4,
  vars: 10,
  consts: [[1, "wrapper", 3, "tuiDropdownAlign", "tuiDropdownDirection", "tuiDropdownHost", "tuiDropdownLimitWidth", "tuiDropdownMinHeight", "tuiDropdownMaxHeight", "tuiDropdownSided", "tuiDropdownContent", "tuiDropdown", "tuiObscuredEnabled", "tuiObscured", "tuiActiveZoneChange"], ["polymorpheus", ""], ["dropdown", "polymorpheus"], ["polymorpheus-outlet", "", 3, "content", "context", "keydown.esc", "keydown"], ["wrapper", ""]],
  template: function TuiHostedDropdownComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"]();
      core_js_["ɵɵelementStart"](0, "div", 0);
      core_js_["ɵɵlistener"]("tuiObscured", function TuiHostedDropdownComponent_Template_div_tuiObscured_0_listener($event) {
        return ctx.onHostObscured($event);
      })("tuiActiveZoneChange", function TuiHostedDropdownComponent_Template_div_tuiActiveZoneChange_0_listener($event) {
        return ctx.onActiveZone($event);
      });
      core_js_["ɵɵprojection"](1);
      core_js_["ɵɵtemplate"](2, TuiHostedDropdownComponent_ng_template_2_Template, 3, 2, "ng-template", 1, 2, core_js_["ɵɵtemplateRefExtractor"]);
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      const _r0 = core_js_["ɵɵreference"](3);
      core_js_["ɵɵproperty"]("tuiDropdownAlign", ctx.controller.align)("tuiDropdownDirection", ctx.controller.direction)("tuiDropdownHost", ctx.nativeFocusableElement)("tuiDropdownLimitWidth", ctx.controller.limitWidth)("tuiDropdownMinHeight", ctx.controller.minHeight)("tuiDropdownMaxHeight", ctx.controller.maxHeight)("tuiDropdownSided", ctx.controller.sided)("tuiDropdownContent", _r0)("tuiDropdown", ctx.open && ctx.canOpen)("tuiObscuredEnabled", ctx.open);
    }
  },
  directives: [TuiDropdownDirective, TuiObscuredDirective, TuiActiveZoneDirective, tinkoff_ng_polymorpheus/* PolymorpheusTemplate */.GL, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1],
  styles: ["[_nghost-%COMP%]{display:inline-flex}.wrapper[_ngcontent-%COMP%]{border-radius:inherit;height:inherit;flex:1 1 auto;width:100%}.content[_ngcontent-%COMP%]{display:flex;flex-direction:column;min-height:0}"],
  changeDetection: 0
});
TuiHostedDropdownComponent.ctorParameters = () => [{
  type: core_js_.ElementRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ElementRef]
  }]
}, {
  type: TuiDropdownControllerDirective,
  decorators: [{
    type: core_js_.Inject,
    args: [TUI_DROPDOWN_WATCHED_CONTROLLER]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHostedDropdownComponent.prototype, "content", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHostedDropdownComponent.prototype, "canOpen", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHostedDropdownComponent.prototype, "open", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiHostedDropdownComponent.prototype, "openChange", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiHostedDropdownComponent.prototype, "focusedChange", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)(TuiActiveZoneDirective)], TuiHostedDropdownComponent.prototype, "activeZone", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChild)(TuiHostedDropdownConnectorDirective, {
  read: core_js_.ElementRef
})], TuiHostedDropdownComponent.prototype, "dropdownHost", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('wrapper', {
  read: core_js_.ElementRef
})], TuiHostedDropdownComponent.prototype, "wrapper", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)(TuiDropdownDirective)], TuiHostedDropdownComponent.prototype, "dropdownDirective", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._hosted_dropdown_focused')], TuiHostedDropdownComponent.prototype, "focused", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('focusin', ['$event'])], TuiHostedDropdownComponent.prototype, "onFocusIn", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('click', ['$event'])], TuiHostedDropdownComponent.prototype, "onClick", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('keydown.esc', ['$event'])], TuiHostedDropdownComponent.prototype, "onKeyDownEsc", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('keydown.arrowDown', ['$event'])], TuiHostedDropdownComponent.prototype, "onArrowDown", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('keydown.arrowUp', ['$event'])], TuiHostedDropdownComponent.prototype, "onArrowUp", null);
(0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiHostedDropdownComponent.prototype, "calculateContentContext", null);
TuiHostedDropdownComponent = TuiHostedDropdownComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_DROPDOWN_WATCHED_CONTROLLER))], TuiHostedDropdownComponent);
let TuiHostedDropdownModule = /*#__PURE__*/(() => {
  let TuiHostedDropdownModule = class TuiHostedDropdownModule {};
  TuiHostedDropdownModule.ɵfac = function TuiHostedDropdownModule_Factory(t) {
    return new (t || TuiHostedDropdownModule)();
  };
  TuiHostedDropdownModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiHostedDropdownModule
  });
  TuiHostedDropdownModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, TuiObscuredModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiActiveZoneModule, TuiDropdownModule]]
  });
  return TuiHostedDropdownModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiHostedDropdownModule, {
    declarations: function () {
      return [TuiHostedDropdownComponent, TuiHostedDropdownConnectorDirective];
    },
    imports: function () {
      return [common_js_.CommonModule, TuiObscuredModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiActiveZoneModule, TuiDropdownModule];
    },
    exports: function () {
      return [TuiHostedDropdownComponent, TuiHostedDropdownConnectorDirective];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-hosted-dropdown.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-arrow.js








let TuiArrowComponent = /*#__PURE__*/(() => {
  let TuiArrowComponent = class TuiArrowComponent {
    constructor(dropdown, textfieldSize) {
      this.dropdown = dropdown;
      this.textfieldSize = textfieldSize;
    }
    get arrowIcon() {
      return (0,taiga_ui_core_utils_miscellaneous/* sizeBigger */.Bb)(this.textfieldSize.size) ? 'tuiIconChevronDownLarge' : 'tuiIconChevronDown';
    }
  };
  TuiArrowComponent.ɵfac = function TuiArrowComponent_Factory(t) {
    return new (t || TuiArrowComponent)(core_js_["ɵɵdirectiveInject"](TuiHostedDropdownComponent), core_js_["ɵɵdirectiveInject"](TUI_TEXTFIELD_SIZE));
  };
  TuiArrowComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiArrowComponent,
    selectors: [["tui-arrow"]],
    decls: 2,
    vars: 5,
    consts: [[1, "icon", 3, "src"]],
    template: function TuiArrowComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵelementStart"](0, "tui-svg", 0);
        core_js_["ɵɵpipe"](1, "async");
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("icon_rotated", core_js_["ɵɵpipeBind1"](1, 3, ctx.dropdown.openChange));
        core_js_["ɵɵproperty"]("src", ctx.arrowIcon);
      }
    },
    directives: [taiga_ui_core_components_svg/* TuiSvgComponent */.P],
    pipes: [common_js_.AsyncPipe],
    styles: [".icon[_ngcontent-%COMP%]{transition-property:transform;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;cursor:pointer}.icon_rotated[_ngcontent-%COMP%]{transform:rotate(180deg)}"],
    changeDetection: 0
  });
  TuiArrowComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TuiHostedDropdownComponent)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_TEXTFIELD_SIZE))], TuiArrowComponent);
  return TuiArrowComponent;
})();
const TUI_ARROW = new tinkoff_ng_polymorpheus/* PolymorpheusComponent */.Al(TuiArrowComponent);
let TuiArrowModule = /*#__PURE__*/(() => {
  let TuiArrowModule = class TuiArrowModule {};
  TuiArrowModule.ɵfac = function TuiArrowModule_Factory(t) {
    return new (t || TuiArrowModule)();
  };
  TuiArrowModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiArrowModule
  });
  TuiArrowModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, taiga_ui_core_components_svg/* TuiSvgModule */.E]]
  });
  return TuiArrowModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiArrowModule, {
    declarations: function () {
      return [TuiArrowComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, taiga_ui_core_components_svg/* TuiSvgModule */.E];
    },
    exports: function () {
      return [TuiArrowComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-arrow.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-directives-scroll-into-view.js








/**
 * Directive scrolls element into view inside tui-scrollbar
 */
// @dynamic


let TuiScrollIntoViewDirective = /*#__PURE__*/(() => {
  let TuiScrollIntoViewDirective = class TuiScrollIntoViewDirective {
    constructor(elementRef, documentRef, destroy$) {
      this.elementRef = elementRef;
      this.documentRef = documentRef;
      this.destroy$ = destroy$;
    }
    set tuiScrollIntoView(scroll) {
      if (!scroll) {
        return;
      }
      // Timeout is necessary in order to give element render cycle to get into its final spot
      // (for example if it is inside dropdown box which has to be positioned first)
      (0,timer/* timer */.H)(0).pipe((0,takeUntil/* takeUntil */.R)(this.destroy$)).subscribe(() => {
        this.elementRef.nativeElement.dispatchEvent((0,taiga_ui_cdk_utils_dom/* tuiCustomEvent */.hO)(taiga_ui_core_constants/* TUI_SCROLL_INTO_VIEW */.fe, {
          bubbles: true,
          detail: this.elementRef.nativeElement
        }, this.documentRef));
      });
    }
  };
  TuiScrollIntoViewDirective.ɵfac = function TuiScrollIntoViewDirective_Factory(t) {
    return new (t || TuiScrollIntoViewDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](common_js_.DOCUMENT), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3));
  };
  TuiScrollIntoViewDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiScrollIntoViewDirective,
    selectors: [["", "tuiScrollIntoView", ""]],
    inputs: {
      tuiScrollIntoView: "tuiScrollIntoView"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiRequiredSetter */.NH)()], TuiScrollIntoViewDirective.prototype, "tuiScrollIntoView", null);
  TuiScrollIntoViewDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(common_js_.DOCUMENT)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3))], TuiScrollIntoViewDirective);
  return TuiScrollIntoViewDirective;
})();
let TuiScrollIntoViewModule = /*#__PURE__*/(() => {
  let TuiScrollIntoViewModule = class TuiScrollIntoViewModule {};
  TuiScrollIntoViewModule.ɵfac = function TuiScrollIntoViewModule_Factory(t) {
    return new (t || TuiScrollIntoViewModule)();
  };
  TuiScrollIntoViewModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiScrollIntoViewModule
  });
  TuiScrollIntoViewModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiScrollIntoViewModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiScrollIntoViewModule, {
    declarations: [TuiScrollIntoViewDirective],
    exports: [TuiScrollIntoViewDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-directives-scroll-into-view.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-select-option.js












function TuiSelectOptionComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0);
  }
}
function TuiSelectOptionComponent_tui_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 3);
  }
  if (rf & 2) {
    core_js_["ɵɵproperty"]("tuiScrollIntoView", true);
  }
}
function TuiSelectOptionComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "span", 4);
  }
}
let TuiSelectOptionComponent = /*#__PURE__*/(() => {
  let TuiSelectOptionComponent = class TuiSelectOptionComponent {
    constructor(context, host, option, control) {
      this.context = context;
      this.host = host;
      this.option = option;
      this.control = control;
      this.selected$ = (0,taiga_ui_cdk_observables/* tuiReplayedValueChangesFrom */.Gx)(this.control).pipe((0,map/* map */.U)(value => (0,taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN)(this.option.value) && (0,taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN)(value) && this.matcher(value, this.option.value)));
    }
    get matcher() {
      return this.host.identityMatcher || taiga_ui_cdk_constants/* TUI_DEFAULT_IDENTITY_MATCHER */.bg;
    }
    ngOnInit() {
      if ((0,taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN)(this.option.value) && this.host.checkOption) {
        this.host.checkOption(this.option.value);
      }
    }
  };
  TuiSelectOptionComponent.ɵfac = function TuiSelectOptionComponent_Factory(t) {
    return new (t || TuiSelectOptionComponent)(core_js_["ɵɵdirectiveInject"](tinkoff_ng_polymorpheus/* POLYMORPHEUS_CONTEXT */.yf), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_DATA_LIST_HOST */.N1), core_js_["ɵɵdirectiveInject"](TuiOptionComponent), core_js_["ɵɵdirectiveInject"](fesm2015_forms.NgControl));
  };
  TuiSelectOptionComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiSelectOptionComponent,
    selectors: [["tui-select-option"]],
    decls: 5,
    vars: 5,
    consts: [[4, "ngTemplateOutlet"], ["automation-id", "tui-select-option__checkmark", "class", "checkmark", "src", "tuiIconCheckLarge", 3, "tuiScrollIntoView", 4, "ngIf", "ngIfElse"], ["dummy", ""], ["automation-id", "tui-select-option__checkmark", "src", "tuiIconCheckLarge", 1, "checkmark", 3, "tuiScrollIntoView"], [1, "dummy"]],
    template: function TuiSelectOptionComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵtemplate"](0, TuiSelectOptionComponent_ng_container_0_Template, 1, 0, "ng-container", 0);
        core_js_["ɵɵtemplate"](1, TuiSelectOptionComponent_tui_svg_1_Template, 1, 1, "tui-svg", 1);
        core_js_["ɵɵpipe"](2, "async");
        core_js_["ɵɵtemplate"](3, TuiSelectOptionComponent_ng_template_3_Template, 1, 0, "ng-template", null, 2, core_js_["ɵɵtemplateRefExtractor"]);
      }
      if (rf & 2) {
        const _r2 = core_js_["ɵɵreference"](4);
        core_js_["ɵɵproperty"]("ngTemplateOutlet", ctx.context.$implicit);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", core_js_["ɵɵpipeBind1"](2, 3, ctx.selected$))("ngIfElse", _r2);
      }
    },
    directives: [common_js_.NgTemplateOutlet, common_js_.NgIf, taiga_ui_core_components_svg/* TuiSvgComponent */.P, TuiScrollIntoViewDirective],
    pipes: [common_js_.AsyncPipe],
    styles: ["[_nghost-%COMP%]{display:flex;flex:1;align-items:center}.checkmark[_ngcontent-%COMP%]{margin:0 -6px 0 auto;border-left:5px solid transparent}.dummy[_ngcontent-%COMP%]{width:24px}"],
    changeDetection: 0
  });
  TuiSelectOptionComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(tinkoff_ng_polymorpheus/* POLYMORPHEUS_CONTEXT */.yf)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_DATA_LIST_HOST */.N1)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(TuiOptionComponent)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(fesm2015_forms.NgControl))], TuiSelectOptionComponent);
  return TuiSelectOptionComponent;
})();
const TUI_SELECT_OPTION = new tinkoff_ng_polymorpheus/* PolymorpheusComponent */.Al(TuiSelectOptionComponent);
let TuiSelectOptionModule = /*#__PURE__*/(() => {
  let TuiSelectOptionModule = class TuiSelectOptionModule {};
  TuiSelectOptionModule.ɵfac = function TuiSelectOptionModule_Factory(t) {
    return new (t || TuiSelectOptionModule)();
  };
  TuiSelectOptionModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiSelectOptionModule
  });
  TuiSelectOptionModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiScrollIntoViewModule]]
  });
  return TuiSelectOptionModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiSelectOptionModule, {
    declarations: function () {
      return [TuiSelectOptionComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiScrollIntoViewModule];
    },
    exports: function () {
      return [TuiSelectOptionComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-select-option.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-providers.js





function fixedDropdownControllerFactory(directive) {
  directive = directive || new TuiDropdownControllerDirective();
  directive.limitWidth = "fixed" /* Fixed */;
  return directive;
}
const FIXED_DROPDOWN_CONTROLLER_PROVIDER = [{
  provide: TUI_DROPDOWN_CONTROLLER,
  deps: [[new core_js_.Optional(), TuiDropdownControllerDirective]],
  useFactory: fixedDropdownControllerFactory
}];
function leftAlignedDropdownControllerFactory(directive) {
  directive = directive || new TuiDropdownControllerDirective();
  directive.align = 'left';
  return directive;
}
const LEFT_ALIGNED_DROPDOWN_CONTROLLER_PROVIDER = [{
  provide: TUI_DROPDOWN_CONTROLLER,
  deps: [[new core_js_.Optional(), TuiDropdownControllerDirective]],
  useFactory: leftAlignedDropdownControllerFactory
}];
const IDENTITY = taiga_ui_cdk_utils_miscellaneous/* identity */.yR;
const TUI_VALUE_ACCESSOR_PROVIDER = {
  provide: taiga_ui_core_tokens/* TUI_VALUE_ACCESSOR */.sE,
  deps: [[new core_js_.Optional(), new core_js_.Self(), fesm2015_forms.NG_VALUE_ACCESSOR]],
  useFactory: IDENTITY
};

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-providers.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-select.js
















function TuiSelectComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "div", 3);
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("content", ctx_r0.computedContent)("context", ctx_r0.computeContext(ctx_r0.value, ctx_r0.computedFocused));
  }
}
const taiga_ui_kit_components_select_c0 = ["*"];
var TuiSelectComponent_1;
// TODO: remove in ivy compilation
const SELECT_OPTION = TUI_SELECT_OPTION;
let TuiSelectComponent = TuiSelectComponent_1 = class TuiSelectComponent extends taiga_ui_cdk_abstract/* AbstractTuiNullableControl */.F9 {
  constructor(control, changeDetectorRef, textfieldCleaner) {
    super(control, changeDetectorRef);
    this.textfieldCleaner = textfieldCleaner;
    this.identityMatcher = taiga_ui_cdk_constants/* TUI_DEFAULT_IDENTITY_MATCHER */.bg;
    this.valueContent = '';
    this.arrow = TUI_ARROW;
    this.datalist = '';
  }
  get nativeFocusableElement() {
    return this.textfield ? this.textfield.nativeFocusableElement : null;
  }
  get focused() {
    return (0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(this.nativeFocusableElement) || !!this.hostedDropdown && this.hostedDropdown.focused;
  }
  get computedValue() {
    return this.value === null ? '' : String(this.value) || ' ';
  }
  get computedContent() {
    return this.valueContent || this.computedValue;
  }
  get canOpen() {
    return !this.computedDisabled && !this.readOnly;
  }
  onValueChange(value) {
    if (!value) {
      this.updateValue(null);
    }
  }
  onActiveZone(active) {
    this.updateFocused(active);
  }
  onHovered(hovered) {
    this.updateHovered(hovered);
  }
  onKeyDownDelete() {
    if (this.textfieldCleaner.cleaner) {
      this.updateValue(null);
    }
  }
  handleOption(option) {
    this.focusInput();
    this.updateValue(option);
    if (this.hostedDropdown) {
      this.hostedDropdown.updateOpen(false);
    }
  }
  computeContext($implicit, active) {
    return {
      $implicit,
      active
    };
  }
  focusInput(preventScroll = false) {
    if (this.nativeFocusableElement) {
      (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(this.nativeFocusableElement, true, preventScroll);
    }
  }
};
TuiSelectComponent.ɵfac = function TuiSelectComponent_Factory(t) {
  return new (t || TuiSelectComponent)(core_js_["ɵɵdirectiveInject"](fesm2015_forms.NgControl, 10), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](TUI_TEXTFIELD_CLEANER));
};
TuiSelectComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiSelectComponent,
  selectors: [["tui-select"]],
  contentQueries: function TuiSelectComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      core_js_["ɵɵcontentQuery"](dirIndex, TuiDataListDirective, 5, core_js_.TemplateRef);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.datalist = _t.first);
    }
  },
  viewQuery: function TuiSelectComponent_Query(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵviewQuery"](TuiPrimitiveTextfieldComponent, 5);
      core_js_["ɵɵviewQuery"](TuiHostedDropdownComponent, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.textfield = _t.first);
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.hostedDropdown = _t.first);
    }
  },
  inputs: {
    identityMatcher: "identityMatcher",
    valueContent: "valueContent"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ,
    useExisting: (0,core_js_.forwardRef)(() => TuiSelectComponent_1)
  }, {
    provide: taiga_ui_core_tokens/* TUI_DATA_LIST_HOST */.N1,
    useExisting: (0,core_js_.forwardRef)(() => TuiSelectComponent_1)
  }, {
    provide: taiga_ui_core_tokens/* TUI_OPTION_CONTENT */.IQ,
    useValue: SELECT_OPTION
  }, FIXED_DROPDOWN_CONTROLLER_PROVIDER]), core_js_["ɵɵInheritDefinitionFeature"]],
  ngContentSelectors: taiga_ui_kit_components_select_c0,
  decls: 4,
  vars: 13,
  consts: [[1, "hosted", 3, "canOpen", "content", "tuiActiveZoneChange"], ["automation-id", "tui-select__textfield", 1, "textfield", 3, "editable", "pseudoFocused", "pseudoHovered", "invalid", "nativeId", "readOnly", "iconContent", "disabled", "focusable", "value", "valueChange", "hoveredChange", "keydown.delete.prevent", "keydown.backspace.prevent"], ["polymorpheus-outlet", "", "class", "value", "automation-id", "tui-select__value", 3, "content", "context", 4, "ngIf"], ["polymorpheus-outlet", "", "automation-id", "tui-select__value", 1, "value", 3, "content", "context"]],
  template: function TuiSelectComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"]();
      core_js_["ɵɵelementStart"](0, "tui-hosted-dropdown", 0);
      core_js_["ɵɵlistener"]("tuiActiveZoneChange", function TuiSelectComponent_Template_tui_hosted_dropdown_tuiActiveZoneChange_0_listener($event) {
        return ctx.onActiveZone($event);
      });
      core_js_["ɵɵelementStart"](1, "tui-primitive-textfield", 1);
      core_js_["ɵɵlistener"]("valueChange", function TuiSelectComponent_Template_tui_primitive_textfield_valueChange_1_listener($event) {
        return ctx.onValueChange($event);
      })("hoveredChange", function TuiSelectComponent_Template_tui_primitive_textfield_hoveredChange_1_listener($event) {
        return ctx.onHovered($event);
      })("keydown.delete.prevent", function TuiSelectComponent_Template_tui_primitive_textfield_keydown_delete_prevent_1_listener() {
        return ctx.onKeyDownDelete();
      })("keydown.backspace.prevent", function TuiSelectComponent_Template_tui_primitive_textfield_keydown_backspace_prevent_1_listener() {
        return ctx.onKeyDownDelete();
      });
      core_js_["ɵɵprojection"](2);
      core_js_["ɵɵtemplate"](3, TuiSelectComponent_div_3_Template, 1, 2, "div", 2);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      core_js_["ɵɵproperty"]("canOpen", ctx.canOpen)("content", ctx.datalist || "");
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵproperty"]("editable", false)("pseudoFocused", ctx.computedFocused)("pseudoHovered", ctx.computedHovered)("invalid", ctx.computedInvalid)("nativeId", ctx.nativeId)("readOnly", ctx.readOnly)("iconContent", ctx.arrow)("disabled", ctx.computedDisabled)("focusable", ctx.computedFocusable)("value", ctx.computedValue);
      core_js_["ɵɵadvance"](2);
      core_js_["ɵɵproperty"]("ngIf", ctx.value !== null);
    }
  },
  directives: [TuiHostedDropdownComponent, TuiActiveZoneDirective, TuiPrimitiveTextfieldComponent, common_js_.NgIf, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1],
  styles: ["[_nghost-%COMP%]{display:block;border-radius:var(--tui-radius-m)}[_nghost-%COMP%]:not(._readonly)     input:not(:disabled){cursor:pointer}._readonly[_nghost-%COMP%]     input{cursor:default}.hosted[_ngcontent-%COMP%]{display:block;border-radius:inherit}.textfield[_ngcontent-%COMP%]{border-radius:inherit}.value[_ngcontent-%COMP%]{display:flex;width:100%;align-items:center}"],
  changeDetection: 0
});
TuiSelectComponent.ctorParameters = () => [{
  type: fesm2015_forms.NgControl,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.Self
  }, {
    type: core_js_.Inject,
    args: [fesm2015_forms.NgControl]
  }]
}, {
  type: core_js_.ChangeDetectorRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ChangeDetectorRef]
  }]
}, {
  type: TuiTextfieldCleanerDirective,
  decorators: [{
    type: core_js_.Inject,
    args: [TUI_TEXTFIELD_CLEANER]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiSelectComponent.prototype, "identityMatcher", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiSelectComponent.prototype, "valueContent", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChild)(TuiDataListDirective, {
  read: core_js_.TemplateRef
})], TuiSelectComponent.prototype, "datalist", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)(TuiPrimitiveTextfieldComponent)], TuiSelectComponent.prototype, "textfield", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)(TuiHostedDropdownComponent)], TuiSelectComponent.prototype, "hostedDropdown", void 0);
(0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiSelectComponent.prototype, "computeContext", null);
TuiSelectComponent = TuiSelectComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(fesm2015_forms.NgControl)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(TUI_TEXTFIELD_CLEANER))], TuiSelectComponent);
let TuiSelectModule = /*#__PURE__*/(() => {
  let TuiSelectModule = class TuiSelectModule {};
  TuiSelectModule.ɵfac = function TuiSelectModule_Factory(t) {
    return new (t || TuiSelectModule)();
  };
  TuiSelectModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiSelectModule
  });
  TuiSelectModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiActiveZoneModule, TuiPrimitiveTextfieldModule, TuiHostedDropdownModule, TuiSelectOptionModule, TuiArrowModule]]
  });
  return TuiSelectModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiSelectModule, {
    declarations: function () {
      return [TuiSelectComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiActiveZoneModule, TuiPrimitiveTextfieldModule, TuiHostedDropdownModule, TuiSelectOptionModule, TuiArrowModule];
    },
    exports: function () {
      return [TuiSelectComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-select.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-pressed.js




let TuiPressedDirective = /*#__PURE__*/(() => {
  let TuiPressedDirective = class TuiPressedDirective {
    constructor(elementRef) {
      this.elementRef = elementRef;
      this.tuiPressedChange = (0,taiga_ui_cdk_observables/* pressedObservable */._d)(this.elementRef.nativeElement);
    }
  };
  TuiPressedDirective.ɵfac = function TuiPressedDirective_Factory(t) {
    return new (t || TuiPressedDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef));
  };
  TuiPressedDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiPressedDirective,
    selectors: [["", "tuiPressedChange", ""]],
    outputs: {
      tuiPressedChange: "tuiPressedChange"
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiPressedDirective.prototype, "tuiPressedChange", void 0);
  TuiPressedDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef))], TuiPressedDirective);
  return TuiPressedDirective;
})();
let TuiPressedModule = /*#__PURE__*/(() => {
  let TuiPressedModule = class TuiPressedModule {};
  TuiPressedModule.ɵfac = function TuiPressedModule_Factory(t) {
    return new (t || TuiPressedModule)();
  };
  TuiPressedModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiPressedModule
  });
  TuiPressedModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiPressedModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiPressedModule, {
    declarations: [TuiPressedDirective],
    exports: [TuiPressedDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-pressed.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-checked.js



let TuiCheckedDirective = /*#__PURE__*/(() => {
  let TuiCheckedDirective = class TuiCheckedDirective {
    constructor(element, renderer) {
      this.element = element;
      this.renderer = renderer;
      this.tuiCheckedChange = new core_js_.EventEmitter();
      this.updateProperty('checked', false);
    }
    set tuiChecked(checked) {
      this.updateProperty('checked', checked || false);
      this.updateProperty('indeterminate', checked === null);
    }
    onChange({
      checked
    }) {
      this.updateProperty('indeterminate', false);
      this.tuiCheckedChange.emit(checked);
    }
    updateProperty(property, value) {
      this.renderer.setProperty(this.element.nativeElement, property, value);
    }
  };
  TuiCheckedDirective.ɵfac = function TuiCheckedDirective_Factory(t) {
    return new (t || TuiCheckedDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.Renderer2));
  };
  TuiCheckedDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiCheckedDirective,
    selectors: [["input", "tuiChecked", ""], ["input", "tuiCheckedChange", ""]],
    hostBindings: function TuiCheckedDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("change", function TuiCheckedDirective_change_HostBindingHandler($event) {
          return ctx.onChange($event.target);
        });
      }
    },
    inputs: {
      tuiChecked: "tuiChecked"
    },
    outputs: {
      tuiCheckedChange: "tuiCheckedChange"
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiCheckedDirective.prototype, "tuiChecked", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiCheckedDirective.prototype, "tuiCheckedChange", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('change', ['$event.target'])], TuiCheckedDirective.prototype, "onChange", null);
  TuiCheckedDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.Renderer2))], TuiCheckedDirective);
  return TuiCheckedDirective;
})();
let TuiCheckedModule = /*#__PURE__*/(() => {
  let TuiCheckedModule = class TuiCheckedModule {};
  TuiCheckedModule.ɵfac = function TuiCheckedModule_Factory(t) {
    return new (t || TuiCheckedModule)();
  };
  TuiCheckedModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiCheckedModule
  });
  TuiCheckedModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiCheckedModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiCheckedModule, {
    declarations: [TuiCheckedDirective],
    exports: [TuiCheckedDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-checked.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-focus-visible.js





/**
 * Directive to imitate :focus-visible
 * (https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible)
 * in browsers that do not support it
 * @dynamic
 */


let TuiFocusVisibleDirective = /*#__PURE__*/(() => {
  let TuiFocusVisibleDirective = class TuiFocusVisibleDirective {
    constructor(tuiFocusVisibleChange) {
      this.tuiFocusVisibleChange = tuiFocusVisibleChange;
    }
  };
  TuiFocusVisibleDirective.ɵfac = function TuiFocusVisibleDirective_Factory(t) {
    return new (t || TuiFocusVisibleDirective)(core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiFocusVisibleService */.ku));
  };
  TuiFocusVisibleDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiFocusVisibleDirective,
    selectors: [["", "tuiFocusVisibleChange", ""]],
    outputs: {
      tuiFocusVisibleChange: "tuiFocusVisibleChange"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3, taiga_ui_cdk_services/* TuiFocusVisibleService */.ku])]
  });
  TuiFocusVisibleDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiFocusVisibleService */.ku))], TuiFocusVisibleDirective);
  return TuiFocusVisibleDirective;
})();
let TuiFocusVisibleModule = /*#__PURE__*/(() => {
  let TuiFocusVisibleModule = class TuiFocusVisibleModule {};
  TuiFocusVisibleModule.ɵfac = function TuiFocusVisibleModule_Factory(t) {
    return new (t || TuiFocusVisibleModule)();
  };
  TuiFocusVisibleModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiFocusVisibleModule
  });
  TuiFocusVisibleModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiFocusVisibleModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiFocusVisibleModule, {
    declarations: [TuiFocusVisibleDirective],
    exports: [TuiFocusVisibleDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-focus-visible.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-radio-group.js




const taiga_ui_kit_components_radio_group_c0 = ["*"];
var TuiRadioGroupComponent_1;
let TuiRadioGroupComponent = TuiRadioGroupComponent_1 = class TuiRadioGroupComponent {
  constructor() {
    this.name = `tui-radio-group-${TuiRadioGroupComponent_1.index++}`;
  }
};
TuiRadioGroupComponent.ɵfac = function TuiRadioGroupComponent_Factory(t) {
  return new (t || TuiRadioGroupComponent)();
};
TuiRadioGroupComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiRadioGroupComponent,
  selectors: [["tui-radio-group"]],
  inputs: {
    name: "name"
  },
  ngContentSelectors: taiga_ui_kit_components_radio_group_c0,
  decls: 1,
  vars: 0,
  template: function TuiRadioGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"]();
      core_js_["ɵɵprojection"](0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
TuiRadioGroupComponent.index = 0;
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiRadioGroupComponent.prototype, "name", void 0);
let TuiRadioGroupModule = /*#__PURE__*/(() => {
  let TuiRadioGroupModule = class TuiRadioGroupModule {};
  TuiRadioGroupModule.ɵfac = function TuiRadioGroupModule_Factory(t) {
    return new (t || TuiRadioGroupModule)();
  };
  TuiRadioGroupModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiRadioGroupModule
  });
  TuiRadioGroupModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiRadioGroupModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiRadioGroupModule, {
    declarations: [TuiRadioGroupComponent],
    exports: [TuiRadioGroupComponent]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-radio-group.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-radio.js








/** Default values for the checkbox options. */






const taiga_ui_kit_components_radio_c0 = ["focusableElement"];
function TuiRadioComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "div", 4);
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("@tuiScaleIn", ctx_r0.animation);
  }
}
const TUI_RADIO_DEFAULT_OPTIONS = {
  size: 'm',
  appearances: {
    unchecked: "outline" /* Outline */,
    checked: "primary" /* Primary */
  }
};

const TUI_RADIO_OPTIONS = new core_js_.InjectionToken('Default parameters for radio component', {
  factory: () => TUI_RADIO_DEFAULT_OPTIONS
});
var TuiRadioComponent_1;
// @dynamic
let TuiRadioComponent = TuiRadioComponent_1 = class TuiRadioComponent extends taiga_ui_cdk_abstract/* AbstractTuiNullableControl */.F9 {
  constructor(control, changeDetectorRef, animationOptions, options, radioGroup) {
    super(control, changeDetectorRef);
    this.animationOptions = animationOptions;
    this.options = options;
    this.radioGroup = radioGroup;
    this.identityMatcher = taiga_ui_cdk_constants/* TUI_DEFAULT_IDENTITY_MATCHER */.bg;
    this.name = null;
    this.size = this.options.size;
    this.pseudoDisabled = false;
    this.animation = Object.assign({
      value: ''
    }, this.animationOptions);
  }
  get appearance() {
    return this.checked ? this.options.appearances.checked : this.options.appearances.unchecked;
  }
  get computedDisabled() {
    return this.disabled || this.pseudoDisabled;
  }
  get nativeFocusableElement() {
    return !this.focusableElement || this.computedDisabled ? null : this.focusableElement.nativeElement;
  }
  get focused() {
    return (0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(this.nativeFocusableElement);
  }
  get checked() {
    return this.value === null ? this.item === null : this.item !== undefined && this.identityMatcher(this.value, this.item);
  }
  get computedName() {
    return this.name || this.radioGroupName || this.controlName || null;
  }
  get isFocusable() {
    return !this.readOnly && this.computedFocusable;
  }
  onChecked(checked) {
    if (checked) {
      this.updateValue(this.item !== undefined ? this.item : this.fallbackValue);
    }
  }
  onFocused(focused) {
    this.updateFocused(focused);
  }
  onHovered(hovered) {
    this.updateHovered(hovered);
  }
  onPressed(pressed) {
    this.updatePressed(pressed);
  }
  onFocusVisible(focusVisible) {
    this.updateFocusVisible(focusVisible);
  }
  get radioGroupName() {
    return this.radioGroup === null ? null : this.radioGroup.name;
  }
};
TuiRadioComponent.ɵfac = function TuiRadioComponent_Factory(t) {
  return new (t || TuiRadioComponent)(core_js_["ɵɵdirectiveInject"](fesm2015_forms.NgControl, 10), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw), core_js_["ɵɵdirectiveInject"](TUI_RADIO_OPTIONS), core_js_["ɵɵdirectiveInject"](TuiRadioGroupComponent, 8));
};
TuiRadioComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiRadioComponent,
  selectors: [["tui-radio"]],
  viewQuery: function TuiRadioComponent_Query(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵviewQuery"](taiga_ui_kit_components_radio_c0, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.focusableElement = _t.first);
    }
  },
  hostVars: 3,
  hostBindings: function TuiRadioComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      core_js_["ɵɵattribute"]("data-tui-host-size", ctx.size);
      core_js_["ɵɵclassProp"]("_disabled", ctx.computedDisabled);
    }
  },
  inputs: {
    identityMatcher: "identityMatcher",
    name: "name",
    size: "size",
    pseudoDisabled: "pseudoDisabled",
    item: "item"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ,
    useExisting: (0,core_js_.forwardRef)(() => TuiRadioComponent_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]],
  decls: 4,
  vars: 12,
  consts: [[3, "appearance", "disabled", "focused", "hovered", "pressed", "invalid"], ["class", "mark", 4, "ngIf"], ["type", "radio", 1, "native", 3, "id", "disabled", "tuiChecked", "tuiFocusable", "tuiFocusedChange", "tuiHoveredChange", "tuiPressedChange", "tuiCheckedChange", "tuiFocusVisibleChange"], ["focusableElement", ""], [1, "mark"]],
  template: function TuiRadioComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵelementStart"](0, "tui-wrapper", 0);
      core_js_["ɵɵtemplate"](1, TuiRadioComponent_div_1_Template, 1, 1, "div", 1);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementStart"](2, "input", 2, 3);
      core_js_["ɵɵlistener"]("tuiFocusedChange", function TuiRadioComponent_Template_input_tuiFocusedChange_2_listener($event) {
        return ctx.onFocused($event);
      })("tuiHoveredChange", function TuiRadioComponent_Template_input_tuiHoveredChange_2_listener($event) {
        return ctx.onHovered($event);
      })("tuiPressedChange", function TuiRadioComponent_Template_input_tuiPressedChange_2_listener($event) {
        return ctx.onPressed($event);
      })("tuiCheckedChange", function TuiRadioComponent_Template_input_tuiCheckedChange_2_listener($event) {
        return ctx.onChecked($event);
      })("tuiFocusVisibleChange", function TuiRadioComponent_Template_input_tuiFocusVisibleChange_2_listener($event) {
        return ctx.onFocusVisible($event);
      });
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      core_js_["ɵɵproperty"]("appearance", ctx.appearance)("disabled", ctx.computedDisabled)("focused", ctx.computedFocusVisible)("hovered", ctx.computedHovered)("pressed", ctx.computedPressed)("invalid", ctx.computedInvalid);
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵproperty"]("ngIf", ctx.checked);
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵproperty"]("id", ctx.id)("disabled", ctx.computedDisabled)("tuiChecked", ctx.checked)("tuiFocusable", ctx.isFocusable);
      core_js_["ɵɵattribute"]("name", ctx.computedName);
    }
  },
  directives: [taiga_ui_core_components_wrapper/* TuiWrapperComponent */.Q, common_js_.NgIf, TuiCheckedDirective, TuiFocusableDirective, TuiFocusedDirective, TuiHoveredDirective, TuiPressedDirective, TuiFocusVisibleDirective],
  styles: ["[_nghost-%COMP%]{font:var(--tui-font-text-s);color:var(--tui-text-01);position:relative;display:block;flex-shrink:0;border-radius:100%}[data-tui-host-size='m'][_nghost-%COMP%]{width:16px;height:16px}[data-tui-host-size='l'][_nghost-%COMP%]{width:24px;height:24px}._readonly[_nghost-%COMP%]{pointer-events:none}.mark[_ngcontent-%COMP%]{position:absolute;background-color:currentColor;border-radius:100%}[data-tui-host-size='m'][_nghost-%COMP%]   .mark[_ngcontent-%COMP%]{margin:4px;width:8px;height:8px}[data-tui-host-size='l'][_nghost-%COMP%]   .mark[_ngcontent-%COMP%]{margin:7px;width:10px;height:10px}.native[_ngcontent-%COMP%]{padding:0;border:0;border-radius:inherit;background:0 0;font-size:inherit;line-height:inherit;font-weight:inherit;color:inherit;caret-color:currentColor;outline:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;word-break:keep-all;-webkit-text-fill-color:currentColor;position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;cursor:pointer}.native[_ngcontent-%COMP%]:-webkit-autofill, .native[_ngcontent-%COMP%]:-webkit-autofill:focus, .native[_ngcontent-%COMP%]:-webkit-autofill:hover{border-radius:inherit;-webkit-text-fill-color:inherit!important;color:inherit!important;background-color:transparent!important;-webkit-box-shadow:0 0 0 1000px var(--tui-autofill) inset!important}._disabled[_nghost-%COMP%]   .native[_ngcontent-%COMP%]{cursor:default}"],
  data: {
    animation: [tuiScaleIn]
  },
  changeDetection: 0
});
TuiRadioComponent.ctorParameters = () => [{
  type: fesm2015_forms.NgControl,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.Self
  }, {
    type: core_js_.Inject,
    args: [fesm2015_forms.NgControl]
  }]
}, {
  type: core_js_.ChangeDetectorRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ChangeDetectorRef]
  }]
}, {
  type: undefined,
  decorators: [{
    type: core_js_.Inject,
    args: [taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw]
  }]
}, {
  type: undefined,
  decorators: [{
    type: core_js_.Inject,
    args: [TUI_RADIO_OPTIONS]
  }]
}, {
  type: TuiRadioGroupComponent,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.Inject,
    args: [TuiRadioGroupComponent]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiRadioComponent.prototype, "item", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiRadioComponent.prototype, "identityMatcher", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiRadioComponent.prototype, "name", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-tui-host-size'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiRadioComponent.prototype, "size", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiRadioComponent.prototype, "pseudoDisabled", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('focusableElement')], TuiRadioComponent.prototype, "focusableElement", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._disabled')], TuiRadioComponent.prototype, "computedDisabled", null);
TuiRadioComponent = TuiRadioComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(fesm2015_forms.NgControl)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TUI_RADIO_OPTIONS)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(TuiRadioGroupComponent))], TuiRadioComponent);
let TuiRadioModule = /*#__PURE__*/(() => {
  let TuiRadioModule = class TuiRadioModule {};
  TuiRadioModule.ɵfac = function TuiRadioModule_Factory(t) {
    return new (t || TuiRadioModule)();
  };
  TuiRadioModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiRadioModule
  });
  TuiRadioModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, TuiCheckedModule, TuiFocusableModule, TuiFocusedModule, TuiHoveredModule, TuiPressedModule, TuiFocusVisibleModule, taiga_ui_core_components_wrapper/* TuiWrapperModule */.W]]
  });
  return TuiRadioModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiRadioModule, {
    declarations: function () {
      return [TuiRadioComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, TuiCheckedModule, TuiFocusableModule, TuiFocusedModule, TuiHoveredModule, TuiPressedModule, TuiFocusVisibleModule, taiga_ui_core_components_wrapper/* TuiWrapperModule */.W];
    },
    exports: function () {
      return [TuiRadioComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-radio.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-radio-block.js











const taiga_ui_kit_components_radio_block_c0 = ["*"];
var TuiRadioBlockComponent_1;
let TuiRadioBlockComponent = TuiRadioBlockComponent_1 = class TuiRadioBlockComponent extends taiga_ui_cdk_abstract/* AbstractTuiNullableControl */.F9 {
  constructor(control, changeDetectorRef, modeDirective) {
    super(control, changeDetectorRef);
    this.modeDirective = modeDirective;
    this.identityMatcher = taiga_ui_cdk_constants/* TUI_DEFAULT_IDENTITY_MATCHER */.bg;
    this.contentAlign = 'right';
    this.size = 'l';
    this.hideRadio = false;
    this.pseudoDisabled = false;
  }
  get nativeFocusableElement() {
    return this.radio ? this.radio.nativeFocusableElement : null;
  }
  get focused() {
    return !!this.radio && this.radio.focused;
  }
  get computedDisabled() {
    return this.disabled || this.pseudoDisabled;
  }
  get checked() {
    return this.value === this.item && this.hideRadio;
  }
  get checkboxSize() {
    return this.size === 'l' ? 'l' : 'm';
  }
  get appearance() {
    if (!this.modeDirective || !this.modeDirective.mode) {
      return this.checked ? "whiteblock-active" /* WhiteblockActive */ : "whiteblock" /* Whiteblock */;
    }

    return this.checked ? "primary" /* Primary */ : "secondary" /* Secondary */;
  }

  onFocused(focused) {
    this.updateFocused(focused);
  }
  onHovered(hovered) {
    this.updateHovered(hovered);
  }
  onPressed(pressed) {
    this.updatePressed(pressed);
  }
  onFocusVisible(focusVisible) {
    this.updateFocusVisible(focusVisible);
  }
  onModelChange(value) {
    this.updateValue(value);
  }
};
TuiRadioBlockComponent.ɵfac = function TuiRadioBlockComponent_Factory(t) {
  return new (t || TuiRadioBlockComponent)(core_js_["ɵɵdirectiveInject"](fesm2015_forms.NgControl, 10), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_directives_mode/* TuiModeDirective */.w, 8));
};
TuiRadioBlockComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiRadioBlockComponent,
  selectors: [["tui-radio-block"]],
  viewQuery: function TuiRadioBlockComponent_Query(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵviewQuery"](TuiRadioComponent, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.radio = _t.first);
    }
  },
  hostVars: 8,
  hostBindings: function TuiRadioBlockComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      core_js_["ɵɵattribute"]("data-tui-host-align", ctx.contentAlign)("data-tui-host-size", ctx.size);
      core_js_["ɵɵclassProp"]("_hidden_radio", ctx.hideRadio)("_disabled", ctx.computedDisabled)("_active", ctx.checked);
    }
  },
  inputs: {
    identityMatcher: "identityMatcher",
    contentAlign: "contentAlign",
    size: "size",
    hideRadio: "hideRadio",
    pseudoDisabled: "pseudoDisabled",
    item: "item"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ,
    useExisting: (0,core_js_.forwardRef)(() => TuiRadioBlockComponent_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]],
  ngContentSelectors: taiga_ui_kit_components_radio_block_c0,
  decls: 7,
  vars: 19,
  consts: [[1, "wrapper", 3, "tuiHoveredChange", "tuiPressedChange"], [3, "appearance", "disabled", "focused", "hovered", "pressed", "invalid"], [1, "content-wrapper"], [1, "content"], [1, "view", 3, "focusable", "identityMatcher", "item", "name", "nativeId", "readOnly", "pseudoDisabled", "pseudoInvalid", "pseudoFocused", "pseudoHovered", "pseudoPressed", "size", "ngModel", "ngModelChange", "focusedChange", "focusVisibleChange"], [1, "label"]],
  template: function TuiRadioBlockComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"]();
      core_js_["ɵɵelementStart"](0, "label", 0);
      core_js_["ɵɵlistener"]("tuiHoveredChange", function TuiRadioBlockComponent_Template_label_tuiHoveredChange_0_listener($event) {
        return ctx.onHovered($event);
      })("tuiPressedChange", function TuiRadioBlockComponent_Template_label_tuiPressedChange_0_listener($event) {
        return ctx.onPressed($event);
      });
      core_js_["ɵɵelementStart"](1, "tui-wrapper", 1);
      core_js_["ɵɵelementStart"](2, "div", 2);
      core_js_["ɵɵelementStart"](3, "div", 3);
      core_js_["ɵɵelementStart"](4, "tui-radio", 4);
      core_js_["ɵɵlistener"]("ngModelChange", function TuiRadioBlockComponent_Template_tui_radio_ngModelChange_4_listener($event) {
        return ctx.onModelChange($event);
      })("focusedChange", function TuiRadioBlockComponent_Template_tui_radio_focusedChange_4_listener($event) {
        return ctx.onFocused($event);
      })("focusVisibleChange", function TuiRadioBlockComponent_Template_tui_radio_focusVisibleChange_4_listener($event) {
        return ctx.onFocusVisible($event);
      });
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementStart"](5, "div", 5);
      core_js_["ɵɵprojection"](6);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵproperty"]("appearance", ctx.appearance)("disabled", ctx.computedDisabled)("focused", ctx.computedFocusVisible)("hovered", ctx.computedHovered)("pressed", ctx.computedPressed)("invalid", ctx.computedInvalid);
      core_js_["ɵɵadvance"](3);
      core_js_["ɵɵproperty"]("focusable", ctx.focusable)("identityMatcher", ctx.identityMatcher)("item", ctx.item)("name", ctx.computedName)("nativeId", ctx.nativeId)("readOnly", ctx.readOnly)("pseudoDisabled", ctx.computedDisabled)("pseudoInvalid", ctx.computedInvalid)("pseudoFocused", false)("pseudoHovered", ctx.computedHovered)("pseudoPressed", ctx.computedPressed)("size", ctx.checkboxSize)("ngModel", ctx.value);
    }
  },
  directives: [TuiHoveredDirective, TuiPressedDirective, taiga_ui_core_components_wrapper/* TuiWrapperComponent */.Q, TuiRadioComponent, fesm2015_forms.NgControlStatus, fesm2015_forms.NgModel],
  styles: ["[_nghost-%COMP%]{font:var(--tui-font-text-s);color:var(--tui-text-01);display:inline-block;vertical-align:top;border-radius:var(--tui-radius-m)}[data-tui-host-size='l'][_nghost-%COMP%], [data-tui-host-size='m'][_nghost-%COMP%]{font:var(--tui-font-text-m)}._readonly[_nghost-%COMP%]{pointer-events:none}.wrapper[_ngcontent-%COMP%]{position:relative;border-radius:inherit;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}._disabled[_nghost-%COMP%]   .wrapper[_ngcontent-%COMP%]{cursor:default}.content-wrapper[_ngcontent-%COMP%]{display:flex;flex-direction:column}[data-tui-host-size='s'][_nghost-%COMP%]   .content-wrapper[_ngcontent-%COMP%]{min-height:var(--tui-height-s)}[data-tui-host-size='m'][_nghost-%COMP%]   .content-wrapper[_ngcontent-%COMP%]{min-height:var(--tui-height-m)}[data-tui-host-size='l'][_nghost-%COMP%]   .content-wrapper[_ngcontent-%COMP%]{min-height:var(--tui-height-l)}.content[_ngcontent-%COMP%]{display:flex;align-items:center;min-height:inherit}[data-tui-host-align=right][_nghost-%COMP%]   .content[_ngcontent-%COMP%]{flex-direction:row-reverse}[data-tui-host-size='s'][_nghost-%COMP%]   .content[_ngcontent-%COMP%]{padding:0 16px 0 8px}[data-tui-host-size='s'][data-tui-host-align=right][_nghost-%COMP%]   .content[_ngcontent-%COMP%]{padding:0 8px 0 16px}[data-tui-host-size='s']._hidden_radio[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{padding:0 16px}[data-tui-host-size='m'][_nghost-%COMP%]   .content[_ngcontent-%COMP%]{padding:0 16px 0 12px}[data-tui-host-size='m'][data-tui-host-align=right][_nghost-%COMP%]   .content[_ngcontent-%COMP%]{padding:0 12px 0 16px}[data-tui-host-size='m']._hidden_radio[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{padding:0 24px}[data-tui-host-size='l'][_nghost-%COMP%]   .content[_ngcontent-%COMP%]{padding:0 16px}[data-tui-host-size='l']._hidden_radio[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{padding:0 36px}.view[_ngcontent-%COMP%]{margin-top:12px;margin-right:12px;align-self:flex-start}[data-tui-host-align=right][_nghost-%COMP%]   .view[_ngcontent-%COMP%]{margin-left:12px;margin-right:0}[data-tui-host-size='s'][_nghost-%COMP%]   .view[_ngcontent-%COMP%]{margin-top:8px;margin-right:8px}[data-tui-host-size='s'][data-tui-host-align=right][_nghost-%COMP%]   .view[_ngcontent-%COMP%]{margin-left:8px}[data-tui-host-size='m'][_nghost-%COMP%]   .view[_ngcontent-%COMP%]{margin-top:14px}[data-tui-host-size='l'][_nghost-%COMP%]   .view[_ngcontent-%COMP%]{margin-top:16px}[data-tui-host-size='l'][data-tui-host-align=right][_nghost-%COMP%]   .view[_ngcontent-%COMP%]{margin-left:16px;margin-right:0}._hidden_radio[_nghost-%COMP%]   .view[_ngcontent-%COMP%]{position:absolute;height:1px;width:1px;margin:-1px;border:0;padding:0;overflow:hidden;clip:rect(0,0,0,0);-webkit-clip-path:inset(0);clip-path:inset(0)}.label[_ngcontent-%COMP%]{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;flex-grow:1}._hidden_radio[_nghost-%COMP%]   .label[_ngcontent-%COMP%]{text-align:center}"],
  changeDetection: 0
});
TuiRadioBlockComponent.ctorParameters = () => [{
  type: fesm2015_forms.NgControl,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.Self
  }, {
    type: core_js_.Inject,
    args: [fesm2015_forms.NgControl]
  }]
}, {
  type: core_js_.ChangeDetectorRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ChangeDetectorRef]
  }]
}, {
  type: taiga_ui_core_directives_mode/* TuiModeDirective */.w,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.Inject,
    args: [taiga_ui_core_directives_mode/* TuiModeDirective */.w]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiRadioBlockComponent.prototype, "item", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiRadioBlockComponent.prototype, "identityMatcher", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-tui-host-align'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiRadioBlockComponent.prototype, "contentAlign", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-tui-host-size'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiRadioBlockComponent.prototype, "size", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._hidden_radio'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiRadioBlockComponent.prototype, "hideRadio", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiRadioBlockComponent.prototype, "pseudoDisabled", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)(TuiRadioComponent)], TuiRadioBlockComponent.prototype, "radio", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._disabled')], TuiRadioBlockComponent.prototype, "computedDisabled", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._active')], TuiRadioBlockComponent.prototype, "checked", null);
TuiRadioBlockComponent = TuiRadioBlockComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(fesm2015_forms.NgControl)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_core_directives_mode/* TuiModeDirective */.w))], TuiRadioBlockComponent);
let TuiRadioBlockModule = /*#__PURE__*/(() => {
  let TuiRadioBlockModule = class TuiRadioBlockModule {};
  TuiRadioBlockModule.ɵfac = function TuiRadioBlockModule_Factory(t) {
    return new (t || TuiRadioBlockModule)();
  };
  TuiRadioBlockModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiRadioBlockModule
  });
  TuiRadioBlockModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[fesm2015_forms.FormsModule, TuiHoveredModule, TuiPressedModule, TuiRadioModule, taiga_ui_core_components_wrapper/* TuiWrapperModule */.W]]
  });
  return TuiRadioBlockModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiRadioBlockModule, {
    declarations: function () {
      return [TuiRadioBlockComponent];
    },
    imports: function () {
      return [fesm2015_forms.FormsModule, TuiHoveredModule, TuiPressedModule, TuiRadioModule, taiga_ui_core_components_wrapper/* TuiWrapperModule */.W];
    },
    exports: function () {
      return [TuiRadioBlockComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-radio-block.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-primitive-checkbox.js







/** Default values for the checkbox options. */




function TuiPrimitiveCheckboxComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 2);
  }
  if (rf & 2) {
    const icon_r1 = ctx.$implicit;
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵclassProp"]("mark_on", !ctx_r0.empty);
    core_js_["ɵɵproperty"]("src", icon_r1);
  }
}
const TUI_CHECKBOX_DEFAULT_OPTIONS = {
  size: 'm',
  appearances: {
    unchecked: "outline" /* Outline */,
    checked: "primary" /* Primary */,
    indeterminate: "primary" /* Primary */
  },

  icons: {
    checked({
      $implicit
    }) {
      return $implicit === 'm' ? 'tuiIconCheck' : 'tuiIconCheckLarge';
    },
    indeterminate({
      $implicit
    }) {
      return $implicit === 'm' ? 'tuiIconMinus' : 'tuiIconMinusLarge';
    }
  }
};
const TUI_CHECKBOX_OPTIONS = new core_js_.InjectionToken('Default parameters for checkbox component', {
  factory: () => TUI_CHECKBOX_DEFAULT_OPTIONS
});

// @dynamic
let TuiPrimitiveCheckboxComponent = /*#__PURE__*/(() => {
  let TuiPrimitiveCheckboxComponent = class TuiPrimitiveCheckboxComponent {
    constructor(options) {
      this.options = options;
      this.size = this.options.size;
      this.disabled = false;
      this.focused = false;
      this.hovered = false;
      this.pressed = false;
      this.invalid = false;
      this.value = false;
    }
    get appearance() {
      switch (this.value) {
        case false:
          return this.options.appearances.unchecked;
        case true:
          return this.options.appearances.checked;
        default:
          return this.options.appearances.indeterminate;
      }
    }
    get empty() {
      return this.value === false;
    }
    get icon() {
      return this.value === null ? this.options.icons.indeterminate : this.options.icons.checked;
    }
    get context() {
      return this.getContext(this.size);
    }
    getContext($implicit) {
      return {
        $implicit
      };
    }
  };
  TuiPrimitiveCheckboxComponent.ɵfac = function TuiPrimitiveCheckboxComponent_Factory(t) {
    return new (t || TuiPrimitiveCheckboxComponent)(core_js_["ɵɵdirectiveInject"](TUI_CHECKBOX_OPTIONS));
  };
  TuiPrimitiveCheckboxComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiPrimitiveCheckboxComponent,
    selectors: [["tui-primitive-checkbox"]],
    hostVars: 1,
    hostBindings: function TuiPrimitiveCheckboxComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("data-tui-host-size", ctx.size);
      }
    },
    inputs: {
      size: "size",
      disabled: "disabled",
      focused: "focused",
      hovered: "hovered",
      pressed: "pressed",
      invalid: "invalid",
      value: "value"
    },
    decls: 3,
    vars: 8,
    consts: [[3, "appearance", "disabled", "focused", "hovered", "pressed", "invalid"], ["polymorpheus-outlet", "", 3, "content", "context"], [1, "mark", 3, "src"]],
    template: function TuiPrimitiveCheckboxComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵelementStart"](0, "tui-wrapper", 0);
        core_js_["ɵɵelementStart"](1, "span", 1);
        core_js_["ɵɵtemplate"](2, TuiPrimitiveCheckboxComponent_ng_template_2_Template, 1, 3, "ng-template");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("appearance", ctx.appearance)("disabled", ctx.disabled)("focused", ctx.focused)("hovered", ctx.hovered)("pressed", ctx.pressed)("invalid", ctx.invalid);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("content", ctx.icon)("context", ctx.context);
      }
    },
    directives: [taiga_ui_core_components_wrapper/* TuiWrapperComponent */.Q, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, taiga_ui_core_components_svg/* TuiSvgComponent */.P],
    styles: ["[_nghost-%COMP%]{display:block;font-size:0}[data-tui-host-size='m'][_nghost-%COMP%]{width:16px;height:16px;border-radius:var(--tui-radius-xs)}[data-tui-host-size='l'][_nghost-%COMP%]{width:24px;height:24px;border-radius:var(--tui-radius-s)}.mark[_ngcontent-%COMP%]{transition-property:transform;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;display:block;width:100%;height:100%;transform:scale(0)}.mark_on[_ngcontent-%COMP%]{transform:scale(1)}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-tui-host-size'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveCheckboxComponent.prototype, "size", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveCheckboxComponent.prototype, "disabled", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveCheckboxComponent.prototype, "focused", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveCheckboxComponent.prototype, "hovered", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveCheckboxComponent.prototype, "pressed", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveCheckboxComponent.prototype, "invalid", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveCheckboxComponent.prototype, "value", void 0);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiPrimitiveCheckboxComponent.prototype, "getContext", null);
  TuiPrimitiveCheckboxComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TUI_CHECKBOX_OPTIONS))], TuiPrimitiveCheckboxComponent);
  return TuiPrimitiveCheckboxComponent;
})();
let TuiPrimitiveCheckboxModule = /*#__PURE__*/(() => {
  let TuiPrimitiveCheckboxModule = class TuiPrimitiveCheckboxModule {};
  TuiPrimitiveCheckboxModule.ɵfac = function TuiPrimitiveCheckboxModule_Factory(t) {
    return new (t || TuiPrimitiveCheckboxModule)();
  };
  TuiPrimitiveCheckboxModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiPrimitiveCheckboxModule
  });
  TuiPrimitiveCheckboxModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[taiga_ui_core_components_svg/* TuiSvgModule */.E, taiga_ui_core_components_wrapper/* TuiWrapperModule */.W, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq]]
  });
  return TuiPrimitiveCheckboxModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiPrimitiveCheckboxModule, {
    declarations: function () {
      return [TuiPrimitiveCheckboxComponent];
    },
    imports: function () {
      return [taiga_ui_core_components_svg/* TuiSvgModule */.E, taiga_ui_core_components_wrapper/* TuiWrapperModule */.W, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq];
    },
    exports: function () {
      return [TuiPrimitiveCheckboxComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-primitive-checkbox.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-checkbox.js










const taiga_ui_kit_components_checkbox_c0 = ["focusableElement"];
var TuiCheckboxComponent_1;
let TuiCheckboxComponent = TuiCheckboxComponent_1 = class TuiCheckboxComponent extends taiga_ui_cdk_abstract/* AbstractTuiNullableControl */.F9 {
  constructor(control, options, changeDetectorRef) {
    super(control, changeDetectorRef);
    this.options = options;
    this.size = this.options.size;
  }
  get nativeFocusableElement() {
    return !this.focusableElement || this.computedDisabled ? null : this.focusableElement.nativeElement;
  }
  get focused() {
    return (0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(this.nativeFocusableElement);
  }
  get computedFocusable() {
    return !this.computedDisabled && !this.readOnly && this.focusable;
  }
  onChecked(checked) {
    this.updateValue(checked);
  }
  onFocused(focused) {
    this.updateFocused(focused);
  }
  onHovered(hovered) {
    this.updateHovered(hovered);
  }
  onPressed(pressed) {
    this.updatePressed(pressed);
  }
  onFocusVisible(focusVisible) {
    this.updateFocusVisible(focusVisible);
  }
};
TuiCheckboxComponent.ɵfac = function TuiCheckboxComponent_Factory(t) {
  return new (t || TuiCheckboxComponent)(core_js_["ɵɵdirectiveInject"](fesm2015_forms.NgControl, 10), core_js_["ɵɵdirectiveInject"](TUI_CHECKBOX_OPTIONS), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef));
};
TuiCheckboxComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiCheckboxComponent,
  selectors: [["tui-checkbox"]],
  viewQuery: function TuiCheckboxComponent_Query(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵviewQuery"](taiga_ui_kit_components_checkbox_c0, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.focusableElement = _t.first);
    }
  },
  hostVars: 1,
  hostBindings: function TuiCheckboxComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      core_js_["ɵɵattribute"]("data-tui-host-size", ctx.size);
    }
  },
  inputs: {
    size: "size"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ,
    useExisting: (0,core_js_.forwardRef)(() => TuiCheckboxComponent_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]],
  decls: 3,
  vars: 11,
  consts: [[3, "size", "disabled", "focused", "hovered", "pressed", "invalid", "value"], ["type", "checkbox", "automation-id", "tui-checkbox__native", 1, "native", 3, "disabled", "id", "tuiChecked", "tuiFocusable", "tuiFocusedChange", "tuiHoveredChange", "tuiPressedChange", "tuiCheckedChange", "tuiFocusVisibleChange"], ["focusableElement", ""]],
  template: function TuiCheckboxComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵelement"](0, "tui-primitive-checkbox", 0);
      core_js_["ɵɵelementStart"](1, "input", 1, 2);
      core_js_["ɵɵlistener"]("tuiFocusedChange", function TuiCheckboxComponent_Template_input_tuiFocusedChange_1_listener($event) {
        return ctx.onFocused($event);
      })("tuiHoveredChange", function TuiCheckboxComponent_Template_input_tuiHoveredChange_1_listener($event) {
        return ctx.onHovered($event);
      })("tuiPressedChange", function TuiCheckboxComponent_Template_input_tuiPressedChange_1_listener($event) {
        return ctx.onPressed($event);
      })("tuiCheckedChange", function TuiCheckboxComponent_Template_input_tuiCheckedChange_1_listener($event) {
        return ctx.onChecked($event);
      })("tuiFocusVisibleChange", function TuiCheckboxComponent_Template_input_tuiFocusVisibleChange_1_listener($event) {
        return ctx.onFocusVisible($event);
      });
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      core_js_["ɵɵproperty"]("size", ctx.size)("disabled", ctx.disabled)("focused", ctx.computedFocusVisible)("hovered", ctx.computedHovered)("pressed", ctx.computedPressed)("invalid", ctx.computedInvalid)("value", ctx.value);
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵproperty"]("disabled", ctx.disabled)("id", ctx.id)("tuiChecked", ctx.value)("tuiFocusable", ctx.computedFocusable);
    }
  },
  directives: [TuiPrimitiveCheckboxComponent, TuiCheckedDirective, TuiFocusableDirective, TuiFocusedDirective, TuiHoveredDirective, TuiPressedDirective, TuiFocusVisibleDirective],
  styles: ["[_nghost-%COMP%]{font:var(--tui-font-text-s);color:var(--tui-text-01);position:relative;display:block;flex-shrink:0}[data-tui-host-size='m'][_nghost-%COMP%]{width:16px;height:16px}[data-tui-host-size='l'][_nghost-%COMP%]{width:24px;height:24px}.native[_ngcontent-%COMP%]{padding:0;border:0;border-radius:inherit;background:0 0;font-size:inherit;line-height:inherit;font-weight:inherit;color:inherit;caret-color:currentColor;outline:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;word-break:keep-all;-webkit-text-fill-color:currentColor;position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;cursor:pointer}.native[_ngcontent-%COMP%]:-webkit-autofill, .native[_ngcontent-%COMP%]:-webkit-autofill:focus, .native[_ngcontent-%COMP%]:-webkit-autofill:hover{border-radius:inherit;-webkit-text-fill-color:inherit!important;color:inherit!important;background-color:transparent!important;-webkit-box-shadow:0 0 0 1000px var(--tui-autofill) inset!important}._disabled[_nghost-%COMP%]   .native[_ngcontent-%COMP%], ._readonly[_nghost-%COMP%]   .native[_ngcontent-%COMP%]{pointer-events:none}"],
  changeDetection: 0
});
TuiCheckboxComponent.ctorParameters = () => [{
  type: fesm2015_forms.NgControl,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.Self
  }, {
    type: core_js_.Inject,
    args: [fesm2015_forms.NgControl]
  }]
}, {
  type: undefined,
  decorators: [{
    type: core_js_.Inject,
    args: [TUI_CHECKBOX_OPTIONS]
  }]
}, {
  type: core_js_.ChangeDetectorRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ChangeDetectorRef]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-tui-host-size'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiCheckboxComponent.prototype, "size", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('focusableElement')], TuiCheckboxComponent.prototype, "focusableElement", void 0);
TuiCheckboxComponent = TuiCheckboxComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(fesm2015_forms.NgControl)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_CHECKBOX_OPTIONS)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.ChangeDetectorRef))], TuiCheckboxComponent);
let TuiCheckboxModule = /*#__PURE__*/(() => {
  let TuiCheckboxModule = class TuiCheckboxModule {};
  TuiCheckboxModule.ɵfac = function TuiCheckboxModule_Factory(t) {
    return new (t || TuiCheckboxModule)();
  };
  TuiCheckboxModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiCheckboxModule
  });
  TuiCheckboxModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, TuiCheckedModule, TuiFocusableModule, TuiFocusedModule, TuiHoveredModule, TuiPressedModule, TuiFocusVisibleModule, TuiPrimitiveCheckboxModule]]
  });
  return TuiCheckboxModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiCheckboxModule, {
    declarations: function () {
      return [TuiCheckboxComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, TuiCheckedModule, TuiFocusableModule, TuiFocusedModule, TuiHoveredModule, TuiPressedModule, TuiFocusVisibleModule, TuiPrimitiveCheckboxModule];
    },
    exports: function () {
      return [TuiCheckboxComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-checkbox.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-checkbox-labeled.js












const taiga_ui_kit_components_checkbox_labeled_c0 = ["*"];
var TuiCheckboxLabeledComponent_1;
let TuiCheckboxLabeledComponent = TuiCheckboxLabeledComponent_1 = class TuiCheckboxLabeledComponent extends taiga_ui_cdk_abstract/* AbstractTuiNullableControl */.F9 {
  constructor(control, changeDetectorRef, modeDirective) {
    super(control, changeDetectorRef);
    this.modeDirective = modeDirective;
    this.size = 'm';
  }
  get focused() {
    return (0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(this.nativeFocusableElement);
  }
  get nativeFocusableElement() {
    return this.checkbox ? this.checkbox.nativeFocusableElement : null;
  }
  get hostMode() {
    return this.modeDirective ? this.modeDirective.mode : null;
  }
  onFocused(focused) {
    this.updateFocused(focused);
  }
  onHovered(hovered) {
    this.updateHovered(hovered);
  }
  onPressed(pressed) {
    this.updatePressed(pressed);
  }
  onModelChange(value) {
    this.updateValue(value);
  }
};
TuiCheckboxLabeledComponent.ɵfac = function TuiCheckboxLabeledComponent_Factory(t) {
  return new (t || TuiCheckboxLabeledComponent)(core_js_["ɵɵdirectiveInject"](fesm2015_forms.NgControl, 10), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_directives_mode/* TuiModeDirective */.w, 8));
};
TuiCheckboxLabeledComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiCheckboxLabeledComponent,
  selectors: [["tui-checkbox-labeled"]],
  viewQuery: function TuiCheckboxLabeledComponent_Query(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵviewQuery"](TuiCheckboxComponent, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.checkbox = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function TuiCheckboxLabeledComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      core_js_["ɵɵattribute"]("data-tui-host-size", ctx.size)("data-mode", ctx.hostMode);
    }
  },
  inputs: {
    size: "size"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ,
    useExisting: (0,core_js_.forwardRef)(() => TuiCheckboxLabeledComponent_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]],
  ngContentSelectors: taiga_ui_kit_components_checkbox_labeled_c0,
  decls: 4,
  vars: 12,
  consts: [[1, "wrapper", 3, "tuiHoveredChange", "tuiPressedChange"], [3, "disabled", "readOnly", "focusable", "nativeId", "pseudoInvalid", "pseudoFocused", "pseudoHovered", "pseudoPressed", "size", "ngModel", "ngModelChange", "focusedChange"], [1, "content"]],
  template: function TuiCheckboxLabeledComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"]();
      core_js_["ɵɵelementStart"](0, "label", 0);
      core_js_["ɵɵlistener"]("tuiHoveredChange", function TuiCheckboxLabeledComponent_Template_label_tuiHoveredChange_0_listener($event) {
        return ctx.onHovered($event);
      })("tuiPressedChange", function TuiCheckboxLabeledComponent_Template_label_tuiPressedChange_0_listener($event) {
        return ctx.onPressed($event);
      });
      core_js_["ɵɵelementStart"](1, "tui-checkbox", 1);
      core_js_["ɵɵlistener"]("ngModelChange", function TuiCheckboxLabeledComponent_Template_tui_checkbox_ngModelChange_1_listener($event) {
        return ctx.onModelChange($event);
      })("focusedChange", function TuiCheckboxLabeledComponent_Template_tui_checkbox_focusedChange_1_listener($event) {
        return ctx.onFocused($event);
      });
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementStart"](2, "div", 2);
      core_js_["ɵɵprojection"](3);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵproperty"]("disabled", ctx.computedDisabled)("readOnly", ctx.readOnly)("focusable", ctx.focusable)("nativeId", ctx.nativeId)("pseudoInvalid", ctx.computedInvalid)("pseudoFocused", ctx.pseudoFocused)("pseudoHovered", ctx.computedHovered)("pseudoPressed", ctx.computedPressed)("size", ctx.size)("ngModel", ctx.value);
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵclassProp"]("content_disabled", ctx.computedDisabled);
    }
  },
  directives: [TuiHoveredDirective, TuiPressedDirective, TuiCheckboxComponent, fesm2015_forms.NgControlStatus, fesm2015_forms.NgModel],
  styles: ["[_nghost-%COMP%]{position:relative;display:block;line-height:0}._disabled[_nghost-%COMP%], ._readonly[_nghost-%COMP%]{pointer-events:none}.wrapper[_ngcontent-%COMP%]{display:inline-flex;max-width:100%;cursor:pointer}._disabled[_nghost-%COMP%]   .wrapper[_ngcontent-%COMP%]{cursor:default}[data-mode=onDark][_nghost-%COMP%]   .wrapper[_ngcontent-%COMP%]{color:var(--tui-base-01)}.content[_ngcontent-%COMP%]{font:var(--tui-font-text-s);line-height:16px;word-wrap:break-word;min-width:0}.content_disabled[_ngcontent-%COMP%]{opacity:var(--tui-disabled-opacity)}[data-tui-host-size='m'][_nghost-%COMP%]   .content[_ngcontent-%COMP%]{margin-left:8px}[data-tui-host-size='l'][_nghost-%COMP%]   .content[_ngcontent-%COMP%]{font:var(--tui-font-text-m);margin-left:12px}"],
  changeDetection: 0
});
TuiCheckboxLabeledComponent.ctorParameters = () => [{
  type: fesm2015_forms.NgControl,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.Self
  }, {
    type: core_js_.Inject,
    args: [fesm2015_forms.NgControl]
  }]
}, {
  type: core_js_.ChangeDetectorRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ChangeDetectorRef]
  }]
}, {
  type: taiga_ui_core_directives_mode/* TuiModeDirective */.w,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.Inject,
    args: [taiga_ui_core_directives_mode/* TuiModeDirective */.w]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-tui-host-size'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiCheckboxLabeledComponent.prototype, "size", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)(TuiCheckboxComponent)], TuiCheckboxLabeledComponent.prototype, "checkbox", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('attr.data-mode')], TuiCheckboxLabeledComponent.prototype, "hostMode", null);
TuiCheckboxLabeledComponent = TuiCheckboxLabeledComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(fesm2015_forms.NgControl)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_core_directives_mode/* TuiModeDirective */.w))], TuiCheckboxLabeledComponent);
let TuiCheckboxLabeledModule = /*#__PURE__*/(() => {
  let TuiCheckboxLabeledModule = class TuiCheckboxLabeledModule {};
  TuiCheckboxLabeledModule.ɵfac = function TuiCheckboxLabeledModule_Factory(t) {
    return new (t || TuiCheckboxLabeledModule)();
  };
  TuiCheckboxLabeledModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiCheckboxLabeledModule
  });
  TuiCheckboxLabeledModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, fesm2015_forms.FormsModule, TuiHoveredModule, TuiPressedModule, TuiCheckboxModule]]
  });
  return TuiCheckboxLabeledModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiCheckboxLabeledModule, {
    declarations: function () {
      return [TuiCheckboxLabeledComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, fesm2015_forms.FormsModule, TuiHoveredModule, TuiPressedModule, TuiCheckboxModule];
    },
    exports: function () {
      return [TuiCheckboxLabeledComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-checkbox-labeled.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-element.js



let TuiElementDirective = /*#__PURE__*/(() => {
  let TuiElementDirective = class TuiElementDirective extends core_js_.ElementRef {
    constructor({
      nativeElement
    }) {
      super(nativeElement);
    }
  };
  TuiElementDirective.ɵfac = function TuiElementDirective_Factory(t) {
    return new (t || TuiElementDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef));
  };
  TuiElementDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiElementDirective,
    selectors: [["", "tuiElement", ""]],
    exportAs: ["elementRef"],
    features: [core_js_["ɵɵInheritDefinitionFeature"]]
  });
  TuiElementDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef))], TuiElementDirective);
  return TuiElementDirective;
})();
let TuiElementModule = /*#__PURE__*/(() => {
  let TuiElementModule = class TuiElementModule {};
  TuiElementModule.ɵfac = function TuiElementModule_Factory(t) {
    return new (t || TuiElementModule)();
  };
  TuiElementModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiElementModule
  });
  TuiElementModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiElementModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiElementModule, {
    declarations: [TuiElementDirective],
    exports: [TuiElementDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-element.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-loader.js
var taiga_ui_core_components_loader = __webpack_require__(719);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-data-list-wrapper.js











function TuiDataListWrapperComponent_tui_data_list_0_button_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "button", 4, 5);
    core_js_["ɵɵelement"](2, "span", 6);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const item_r4 = ctx.$implicit;
    const _r5 = core_js_["ɵɵreference"](1);
    const ctx_r3 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵproperty"]("size", ctx_r3.size)("value", item_r4)("disabled", ctx_r3.disabledItemHandler(item_r4));
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵproperty"]("content", ctx_r3.itemContent)("context", ctx_r3.getContext(item_r4, _r5));
  }
}
function TuiDataListWrapperComponent_tui_data_list_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "tui-data-list", 2);
    core_js_["ɵɵtemplate"](1, TuiDataListWrapperComponent_tui_data_list_0_button_1_Template, 3, 5, "button", 3);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("emptyContent", ctx_r0.emptyContent);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", ctx_r0.items);
  }
}
function TuiDataListWrapperComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-loader", 7);
  }
}
const taiga_ui_kit_components_data_list_wrapper_c0 = ["labels", ""];
function TuiDataListGroupWrapperComponent_tui_data_list_0_tui_opt_group_1_button_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "button", 6, 7);
    core_js_["ɵɵelement"](2, "span", 8);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const item_r7 = ctx.$implicit;
    const _r8 = core_js_["ɵɵreference"](1);
    const ctx_r6 = core_js_["ɵɵnextContext"](3);
    core_js_["ɵɵproperty"]("size", ctx_r6.size)("value", item_r7)("disabled", ctx_r6.disabledItemHandler(item_r7));
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵproperty"]("content", ctx_r6.itemContent)("context", ctx_r6.getContext(item_r7, _r8));
  }
}
function TuiDataListGroupWrapperComponent_tui_data_list_0_tui_opt_group_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "tui-opt-group", 4);
    core_js_["ɵɵtemplate"](1, TuiDataListGroupWrapperComponent_tui_data_list_0_tui_opt_group_1_button_1_Template, 3, 5, "button", 5);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const group_r4 = ctx.$implicit;
    const index_r5 = ctx.index;
    const ctx_r3 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵproperty"]("label", ctx_r3.labels[index_r5]);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", group_r4);
  }
}
function TuiDataListGroupWrapperComponent_tui_data_list_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "tui-data-list", 2);
    core_js_["ɵɵtemplate"](1, TuiDataListGroupWrapperComponent_tui_data_list_0_tui_opt_group_1_Template, 2, 2, "tui-opt-group", 3);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("emptyContent", ctx_r0.emptyContent);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", ctx_r0.items);
  }
}
function TuiDataListGroupWrapperComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-loader", 9);
  }
}
const taiga_ui_kit_components_data_list_wrapper_c1 = "[_nghost-%COMP%]{display:block}.content[_ngcontent-%COMP%]{flex:1}";
var TuiDataListWrapperComponent_1;
let TuiDataListWrapperComponent = TuiDataListWrapperComponent_1 = class TuiDataListWrapperComponent {
  constructor() {
    this.items = [];
    this.disabledItemHandler = taiga_ui_cdk_constants/* ALWAYS_FALSE_HANDLER */.Iy;
    this.emptyContent = '';
    this.itemContent = ({
      $implicit
    }) => (0,taiga_ui_cdk_constants/* TUI_DEFAULT_STRINGIFY */.yZ)($implicit);
    this.size = 'm';
    this.options = taiga_ui_cdk_constants/* EMPTY_QUERY */.Mm;
  }
  getContext($implicit, {
    nativeElement
  }) {
    return {
      $implicit,
      active: (0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(nativeElement)
    };
  }
  getOptions(includeDisabled = false) {
    return this.options.toArray().filter(({
      disabled
    }) => includeDisabled || !disabled).map(({
      value
    }) => value).filter(taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN);
  }
};
TuiDataListWrapperComponent.ɵfac = function TuiDataListWrapperComponent_Factory(t) {
  return new (t || TuiDataListWrapperComponent)();
};
TuiDataListWrapperComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiDataListWrapperComponent,
  selectors: [["tui-data-list-wrapper", 3, "labels", ""]],
  viewQuery: function TuiDataListWrapperComponent_Query(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵviewQuery"](TuiOptionComponent, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.options = _t);
    }
  },
  inputs: {
    items: "items",
    disabledItemHandler: "disabledItemHandler",
    emptyContent: "emptyContent",
    itemContent: "itemContent",
    size: "size"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_core_tokens/* TUI_DATA_LIST_ACCESSOR */.Cc,
    useExisting: (0,core_js_.forwardRef)(() => TuiDataListWrapperComponent_1)
  }])],
  decls: 3,
  vars: 2,
  consts: [[3, "emptyContent", 4, "ngIf", "ngIfElse"], ["loading", ""], [3, "emptyContent"], ["tuiElement", "", "tuiOption", "", "automation-id", "tui-data-list-wrapper__option", 3, "size", "value", "disabled", 4, "ngFor", "ngForOf"], ["tuiElement", "", "tuiOption", "", "automation-id", "tui-data-list-wrapper__option", 3, "size", "value", "disabled"], ["elementRef", "elementRef"], ["polymorpheus-outlet", "", 1, "content", 3, "content", "context"], ["automation-id", "tui-data-list-wrapper__loader", 1, "tui-space_vertical-3"]],
  template: function TuiDataListWrapperComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵtemplate"](0, TuiDataListWrapperComponent_tui_data_list_0_Template, 2, 2, "tui-data-list", 0);
      core_js_["ɵɵtemplate"](1, TuiDataListWrapperComponent_ng_template_1_Template, 1, 0, "ng-template", null, 1, core_js_["ɵɵtemplateRefExtractor"]);
    }
    if (rf & 2) {
      const _r1 = core_js_["ɵɵreference"](2);
      core_js_["ɵɵproperty"]("ngIf", ctx.items)("ngIfElse", _r1);
    }
  },
  directives: [common_js_.NgIf, TuiDataListComponent, common_js_.NgForOf, TuiOptionComponent, TuiElementDirective, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, taiga_ui_core_components_loader/* TuiLoaderComponent */.kM],
  styles: [taiga_ui_kit_components_data_list_wrapper_c1],
  changeDetection: 0
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDataListWrapperComponent.prototype, "items", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDataListWrapperComponent.prototype, "disabledItemHandler", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDataListWrapperComponent.prototype, "emptyContent", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDataListWrapperComponent.prototype, "itemContent", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDataListWrapperComponent.prototype, "size", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChildren)((0,core_js_.forwardRef)(() => TuiOptionComponent))], TuiDataListWrapperComponent.prototype, "options", void 0);
var TuiDataListGroupWrapperComponent_1;
let TuiDataListGroupWrapperComponent = TuiDataListGroupWrapperComponent_1 = class TuiDataListGroupWrapperComponent extends TuiDataListWrapperComponent {
  constructor() {
    super(...arguments);
    this.items = [];
    this.labels = [];
  }
};
TuiDataListGroupWrapperComponent.ɵfac = /*@__PURE__*/function () {
  let ɵTuiDataListGroupWrapperComponent_BaseFactory;
  return function TuiDataListGroupWrapperComponent_Factory(t) {
    return (ɵTuiDataListGroupWrapperComponent_BaseFactory || (ɵTuiDataListGroupWrapperComponent_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiDataListGroupWrapperComponent)))(t || TuiDataListGroupWrapperComponent);
  };
}();
TuiDataListGroupWrapperComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiDataListGroupWrapperComponent,
  selectors: [["tui-data-list-wrapper", "labels", ""]],
  inputs: {
    items: "items",
    labels: "labels"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_core_tokens/* TUI_DATA_LIST_ACCESSOR */.Cc,
    useExisting: (0,core_js_.forwardRef)(() => TuiDataListGroupWrapperComponent_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]],
  attrs: taiga_ui_kit_components_data_list_wrapper_c0,
  decls: 3,
  vars: 2,
  consts: [[3, "emptyContent", 4, "ngIf", "ngIfElse"], ["loading", ""], [3, "emptyContent"], [3, "label", 4, "ngFor", "ngForOf"], [3, "label"], ["tuiElement", "", "tuiOption", "", "automation-id", "tui-data-list-wrapper__option", 3, "size", "value", "disabled", 4, "ngFor", "ngForOf"], ["tuiElement", "", "tuiOption", "", "automation-id", "tui-data-list-wrapper__option", 3, "size", "value", "disabled"], ["elementRef", "elementRef"], ["polymorpheus-outlet", "", 1, "content", 3, "content", "context"], [1, "tui-space_vertical-3"]],
  template: function TuiDataListGroupWrapperComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵtemplate"](0, TuiDataListGroupWrapperComponent_tui_data_list_0_Template, 2, 2, "tui-data-list", 0);
      core_js_["ɵɵtemplate"](1, TuiDataListGroupWrapperComponent_ng_template_1_Template, 1, 0, "ng-template", null, 1, core_js_["ɵɵtemplateRefExtractor"]);
    }
    if (rf & 2) {
      const _r1 = core_js_["ɵɵreference"](2);
      core_js_["ɵɵproperty"]("ngIf", ctx.items)("ngIfElse", _r1);
    }
  },
  directives: [common_js_.NgIf, TuiDataListComponent, common_js_.NgForOf, TuiOptGroupDirective, TuiOptionComponent, TuiElementDirective, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, taiga_ui_core_components_loader/* TuiLoaderComponent */.kM],
  styles: [taiga_ui_kit_components_data_list_wrapper_c1],
  changeDetection: 0
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDataListGroupWrapperComponent.prototype, "items", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDataListGroupWrapperComponent.prototype, "labels", void 0);
let TuiDataListWrapperModule = /*#__PURE__*/(() => {
  let TuiDataListWrapperModule = class TuiDataListWrapperModule {};
  TuiDataListWrapperModule.ɵfac = function TuiDataListWrapperModule_Factory(t) {
    return new (t || TuiDataListWrapperModule)();
  };
  TuiDataListWrapperModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDataListWrapperModule
  });
  TuiDataListWrapperModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiElementModule, TuiDataListModule, taiga_ui_core_components_loader/* TuiLoaderModule */.dS]]
  });
  return TuiDataListWrapperModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDataListWrapperModule, {
    declarations: function () {
      return [TuiDataListWrapperComponent, TuiDataListGroupWrapperComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiElementModule, TuiDataListModule, taiga_ui_core_components_loader/* TuiLoaderModule */.dS];
    },
    exports: function () {
      return [TuiDataListWrapperComponent, TuiDataListGroupWrapperComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-data-list-wrapper.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/pairwise.js
var pairwise = __webpack_require__(9328);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-group.js





const taiga_ui_core_components_group_c0 = ["*"];
let TuiGroupDirective = /*#__PURE__*/(() => {
  let TuiGroupDirective = class TuiGroupDirective {
    constructor() {
      this.orientation = "horizontal" /* Horizontal */;
      this.adaptive = false;
      this.collapsed = false;
      this.rounded = true;
      this.size = 'm';
    }
    get orientationHorizontal() {
      return this.orientation === "horizontal" /* Horizontal */;
    }

    get orientationVertical() {
      return this.orientation === "vertical" /* Vertical */;
    }

    get sizeLarge() {
      return this.size === 'l';
    }
  };
  TuiGroupDirective.ɵfac = function TuiGroupDirective_Factory(t) {
    return new (t || TuiGroupDirective)();
  };
  TuiGroupDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiGroupDirective,
    selectors: [["", "tuiGroup", "", 5, "ng-container"]],
    hostAttrs: ["role", "group", 1, "tui-group"],
    hostVars: 12,
    hostBindings: function TuiGroupDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("tui-group_adaptive", ctx.adaptive)("tui-group_collapsed", ctx.collapsed)("tui-group_rounded", ctx.rounded)("tui-group_orientation_horizontal", ctx.orientationHorizontal)("tui-group_orientation_vertical", ctx.orientationVertical)("tui-group_radius_large", ctx.sizeLarge);
      }
    },
    inputs: {
      orientation: "orientation",
      adaptive: "adaptive",
      collapsed: "collapsed",
      rounded: "rounded",
      size: "size"
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiGroupDirective.prototype, "orientation", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class.tui-group_adaptive'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiGroupDirective.prototype, "adaptive", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class.tui-group_collapsed'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiGroupDirective.prototype, "collapsed", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class.tui-group_rounded'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiGroupDirective.prototype, "rounded", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiGroupDirective.prototype, "size", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class.tui-group_orientation_horizontal')], TuiGroupDirective.prototype, "orientationHorizontal", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class.tui-group_orientation_vertical')], TuiGroupDirective.prototype, "orientationVertical", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class.tui-group_radius_large')], TuiGroupDirective.prototype, "sizeLarge", null);

  /** @deprecated */
  return TuiGroupDirective;
})();
let TuiGroupComponent = /*#__PURE__*/(() => {
  let TuiGroupComponent = class TuiGroupComponent extends TuiGroupDirective {};
  TuiGroupComponent.ɵfac = /*@__PURE__*/function () {
    let ɵTuiGroupComponent_BaseFactory;
    return function TuiGroupComponent_Factory(t) {
      return (ɵTuiGroupComponent_BaseFactory || (ɵTuiGroupComponent_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiGroupComponent)))(t || TuiGroupComponent);
    };
  }();
  TuiGroupComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiGroupComponent,
    selectors: [["tui-group"]],
    hostAttrs: ["role", "group", 1, "tui-group"],
    features: [core_js_["ɵɵInheritDefinitionFeature"]],
    ngContentSelectors: taiga_ui_core_components_group_c0,
    decls: 1,
    vars: 0,
    template: function TuiGroupComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
  return TuiGroupComponent;
})();
let TuiGroupModule = /*#__PURE__*/(() => {
  let TuiGroupModule = class TuiGroupModule {};
  TuiGroupModule.ɵfac = function TuiGroupModule_Factory(t) {
    return new (t || TuiGroupModule)();
  };
  TuiGroupModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiGroupModule
  });
  TuiGroupModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule]]
  });
  return TuiGroupModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiGroupModule, {
    declarations: function () {
      return [TuiGroupComponent, TuiGroupDirective];
    },
    imports: function () {
      return [common_js_.CommonModule];
    },
    exports: function () {
      return [TuiGroupComponent, TuiGroupDirective];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-group.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-expand.js







// @bad TODO Replace with PolymorpheusContent



const taiga_ui_core_components_expand_c0 = ["wrapper"];
function TuiExpandComponent_ng_container_2_tui_loader_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0);
  }
}
function TuiExpandComponent_ng_container_2_tui_loader_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "tui-loader", 4);
    core_js_["ɵɵtemplate"](1, TuiExpandComponent_ng_container_2_tui_loader_2_ng_container_1_Template, 1, 0, "ng-container", 5);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r2 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵproperty"]("overlay", true)("showLoader", ctx_r2.loading);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngTemplateOutlet", ctx_r2.content);
  }
}
function TuiExpandComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵprojection"](1);
    core_js_["ɵɵtemplate"](2, TuiExpandComponent_ng_container_2_tui_loader_2_Template, 2, 3, "tui-loader", 3);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵproperty"]("ngIf", ctx_r1.async)("ngIfElse", ctx_r1.content);
  }
}
const taiga_ui_core_components_expand_c1 = ["*"];
let TuiExpandContentDirective = /*#__PURE__*/(() => {
  let TuiExpandContentDirective = class TuiExpandContentDirective {};
  TuiExpandContentDirective.ɵfac = function TuiExpandContentDirective_Factory(t) {
    return new (t || TuiExpandContentDirective)();
  };
  TuiExpandContentDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiExpandContentDirective,
    selectors: [["", "tuiExpandContent", ""]]
  });
  return TuiExpandContentDirective;
})();
var State = /*#__PURE__*/(() => {
  (function (State) {
    State[State["Idle"] = 0] = "Idle";
    State[State["Loading"] = 1] = "Loading";
    State[State["Prepared"] = 2] = "Prepared";
    State[State["Animated"] = 3] = "Animated";
  })(State || (State = {}));
  return State;
})();
const LOADER_HEIGHT = 48;
let TuiExpandComponent = /*#__PURE__*/(() => {
  let TuiExpandComponent = class TuiExpandComponent {
    constructor(changeDetectorRef) {
      this.changeDetectorRef = changeDetectorRef;
      this.async = false;
      this.expanded = null;
      this.state = State.Idle;
    }
    set expandedSetter(expanded) {
      if (this.expanded === null) {
        this.expanded = expanded;
        return;
      }
      if (this.state !== State.Idle) {
        this.expanded = expanded;
        this.state = State.Animated;
        return;
      }
      this.expanded = expanded;
      this.retrigger(this.async && expanded ? State.Loading : State.Animated);
    }
    get overflow() {
      return this.state !== State.Idle;
    }
    get loading() {
      return !!this.expanded && this.async && this.state === State.Loading;
    }
    get height() {
      const {
        expanded,
        state,
        contentWrapper
      } = this;
      if (expanded && state === State.Prepared || !expanded && state === State.Animated) {
        return 0;
      }
      if (contentWrapper && (!expanded && state === State.Prepared || expanded && state === State.Animated)) {
        return contentWrapper.nativeElement.offsetHeight;
      }
      if (contentWrapper && expanded && state === State.Loading) {
        return Math.max(contentWrapper.nativeElement.offsetHeight, LOADER_HEIGHT);
      }
      return null;
    }
    get contentVisible() {
      return this.expanded || this.state !== State.Idle;
    }
    onTransitionEnd(event) {
      if ((0,taiga_ui_cdk_utils_dom/* isCurrentTarget */.Xr)(event) && event.propertyName === 'opacity' && this.state === State.Animated) {
        this.state = State.Idle;
      }
    }
    onExpandLoaded(event) {
      event.stopPropagation();
      if (this.state === State.Loading) {
        this.retrigger(State.Animated);
      }
    }
    retrigger(state) {
      this.state = State.Prepared;
      // We need delay to retrigger CSS height transition from the correct number
      setTimeout(() => {
        if (this.state !== State.Prepared) {
          return;
        }
        this.state = state;
        this.changeDetectorRef.markForCheck();
      });
    }
  };
  TuiExpandComponent.ɵfac = function TuiExpandComponent_Factory(t) {
    return new (t || TuiExpandComponent)(core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef));
  };
  TuiExpandComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiExpandComponent,
    selectors: [["tui-expand"]],
    contentQueries: function TuiExpandComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        core_js_["ɵɵcontentQuery"](dirIndex, TuiExpandContentDirective, 5, core_js_.TemplateRef);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.content = _t.first);
      }
    },
    viewQuery: function TuiExpandComponent_Query(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵviewQuery"](taiga_ui_core_components_expand_c0, 5);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.contentWrapper = _t.first);
      }
    },
    hostVars: 8,
    hostBindings: function TuiExpandComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("transitionend", function TuiExpandComponent_transitionend_HostBindingHandler($event) {
          return ctx.onTransitionEnd($event);
        })("tui-expand-loaded", function TuiExpandComponent_tui_expand_loaded_HostBindingHandler($event) {
          return ctx.onExpandLoaded($event);
        });
      }
      if (rf & 2) {
        core_js_["ɵɵstyleProp"]("height", ctx.height, "px");
        core_js_["ɵɵclassProp"]("_expanded", ctx.expanded)("_overflow", ctx.overflow)("_loading", ctx.loading);
      }
    },
    inputs: {
      async: "async",
      expandedSetter: ["expanded", "expandedSetter"]
    },
    ngContentSelectors: taiga_ui_core_components_expand_c1,
    decls: 3,
    vars: 1,
    consts: [[1, "wrapper"], ["wrapper", ""], [4, "ngIf"], ["size", "l", 3, "overlay", "showLoader", 4, "ngIf", "ngIfElse"], ["size", "l", 3, "overlay", "showLoader"], [4, "ngTemplateOutlet"]],
    template: function TuiExpandComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵelementStart"](0, "div", 0, 1);
        core_js_["ɵɵtemplate"](2, TuiExpandComponent_ng_container_2_Template, 3, 2, "ng-container", 2);
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵproperty"]("ngIf", ctx.contentVisible);
      }
    },
    directives: [common_js_.NgIf, taiga_ui_core_components_loader/* TuiLoaderComponent */.kM, common_js_.NgTemplateOutlet],
    styles: ["[_nghost-%COMP%]{display:block;transition-property:opacity,height,visibility;transition-duration:var(--tui-duration,300ms);opacity:0}._overflow[_nghost-%COMP%]{overflow:hidden}._expanded[_nghost-%COMP%]{opacity:1;transform:translate3d(0,0,0)}._loading[_nghost-%COMP%]{opacity:.99}.wrapper[_ngcontent-%COMP%]:after, .wrapper[_ngcontent-%COMP%]:before{content:'';display:table}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiExpandComponent.prototype, "async", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('expanded'), (0,taiga_ui_cdk_decorators/* tuiRequiredSetter */.NH)()], TuiExpandComponent.prototype, "expandedSetter", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChild)(TuiExpandContentDirective, {
    read: core_js_.TemplateRef
  })], TuiExpandComponent.prototype, "content", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._expanded')], TuiExpandComponent.prototype, "expanded", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('wrapper')], TuiExpandComponent.prototype, "contentWrapper", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._overflow')], TuiExpandComponent.prototype, "overflow", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._loading')], TuiExpandComponent.prototype, "loading", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('style.height.px')], TuiExpandComponent.prototype, "height", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('transitionend', ['$event'])], TuiExpandComponent.prototype, "onTransitionEnd", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)(taiga_ui_core_constants/* TUI_EXPAND_LOADED */.P8, ['$event'])], TuiExpandComponent.prototype, "onExpandLoaded", null);
  TuiExpandComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ChangeDetectorRef))], TuiExpandComponent);
  return TuiExpandComponent;
})();
let TuiExpandModule = /*#__PURE__*/(() => {
  let TuiExpandModule = class TuiExpandModule {};
  TuiExpandModule.ɵfac = function TuiExpandModule_Factory(t) {
    return new (t || TuiExpandModule)();
  };
  TuiExpandModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiExpandModule
  });
  TuiExpandModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, taiga_ui_core_components_loader/* TuiLoaderModule */.dS]]
  });
  return TuiExpandModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiExpandModule, {
    declarations: function () {
      return [TuiExpandComponent, TuiExpandContentDirective];
    },
    imports: function () {
      return [common_js_.CommonModule, taiga_ui_core_components_loader/* TuiLoaderModule */.dS];
    },
    exports: function () {
      return [TuiExpandComponent, TuiExpandContentDirective];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-expand.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-accordion.js









// TODO: do not rebuild the template, think about "lazy" flag






const taiga_ui_kit_components_accordion_c0 = ["focusableElement"];
function TuiAccordionItemComponent_tui_svg_5_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 7);
  }
  if (rf & 2) {
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵclassProp"]("icon_open", ctx_r1.open);
  }
}
function TuiAccordionItemComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "div", 8);
  }
  if (rf & 2) {
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("content", ctx_r2.content);
  }
}
const taiga_ui_kit_components_accordion_c1 = ["*"];
const taiga_ui_kit_components_accordion_c2 = [[["tui-accordion-item"]]];
const _c3 = ["tui-accordion-item"];
let TuiAccordionItemContentDirective = /*#__PURE__*/(() => {
  let TuiAccordionItemContentDirective = class TuiAccordionItemContentDirective extends tinkoff_ng_polymorpheus/* PolymorpheusTemplate */.GL {
    constructor(templateRef, changeDetectorRef) {
      super(templateRef, changeDetectorRef);
    }
  };
  TuiAccordionItemContentDirective.ɵfac = function TuiAccordionItemContentDirective_Factory(t) {
    return new (t || TuiAccordionItemContentDirective)(core_js_["ɵɵdirectiveInject"](core_js_.TemplateRef, 2), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef));
  };
  TuiAccordionItemContentDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiAccordionItemContentDirective,
    selectors: [["", "tuiAccordionItemContent", ""]],
    features: [core_js_["ɵɵInheritDefinitionFeature"]]
  });
  TuiAccordionItemContentDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.TemplateRef)), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ChangeDetectorRef))], TuiAccordionItemContentDirective);
  return TuiAccordionItemContentDirective;
})();
var TuiAccordionItemComponent_1;
let TuiAccordionItemComponent = TuiAccordionItemComponent_1 = class TuiAccordionItemComponent extends taiga_ui_cdk_abstract/* AbstractTuiInteractive */.Xn {
  constructor(changeDetectorRef, mode$) {
    super();
    this.changeDetectorRef = changeDetectorRef;
    this.mode$ = mode$;
    this.noPadding = false;
    this.showArrow = true;
    this.borders = "all" /* All */;
    this.size = 'm';
    this.disabled = false;
    this.disableHover = false;
    this.open = false;
    this.async = false;
    this.openChange = new core_js_.EventEmitter();
  }
  get nativeFocusableElement() {
    return this.disabled || !this.focusableElement ? null : this.focusableElement.nativeElement;
  }
  get focused() {
    return (0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(this.nativeFocusableElement);
  }
  onHovered(hovered) {
    if (!this.disableHover) {
      this.updateHovered(hovered);
    }
  }
  onFocused(focused) {
    this.updateFocused(focused);
  }
  onFocusVisible(focusVisible) {
    this.updateFocusVisible(focusVisible);
  }
  onRowToggle() {
    if (this.disabled) {
      return;
    }
    this.updateOpen(!this.open);
  }
  onItemKeyDownEsc(event) {
    if (!this.focused || !this.open) {
      return;
    }
    event.stopPropagation();
    this.updateOpen(false);
  }
  onItemKeyDownSpace(event) {
    if (!this.focused) {
      return;
    }
    event.preventDefault();
    this.onRowToggle();
  }
  close() {
    this.updateOpen(false);
    this.changeDetectorRef.markForCheck();
  }
  updateOpen(open) {
    if (this.open === open) {
      return;
    }
    this.open = open;
    this.openChange.emit(open);
  }
};
TuiAccordionItemComponent.ɵfac = function TuiAccordionItemComponent_Factory(t) {
  return new (t || TuiAccordionItemComponent)(core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_MODE */.Au));
};
TuiAccordionItemComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiAccordionItemComponent,
  selectors: [["tui-accordion-item"]],
  contentQueries: function TuiAccordionItemComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      core_js_["ɵɵcontentQuery"](dirIndex, TuiAccordionItemContentDirective, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.content = _t.first);
    }
  },
  viewQuery: function TuiAccordionItemComponent_Query(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵviewQuery"](taiga_ui_kit_components_accordion_c0, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.focusableElement = _t.first);
    }
  },
  hostVars: 8,
  hostBindings: function TuiAccordionItemComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵlistener"]("$.data-mode.attr", function TuiAccordionItemComponent___data_mode_attr_HostBindingHandler() {
        return ctx.mode$;
      });
    }
    if (rf & 2) {
      core_js_["ɵɵattribute"]("data-tui-host-borders", ctx.borders)("data-tui-host-size", ctx.size);
      core_js_["ɵɵclassProp"]("_no-padding", ctx.noPadding)("_has-arrow", ctx.showArrow)("_disabled", ctx.disabled);
    }
  },
  inputs: {
    noPadding: "noPadding",
    showArrow: "showArrow",
    borders: "borders",
    size: "size",
    disabled: "disabled",
    disableHover: "disableHover",
    open: "open",
    async: "async"
  },
  outputs: {
    openChange: "openChange"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ,
    useExisting: (0,core_js_.forwardRef)(() => TuiAccordionItemComponent_1)
  }, taiga_ui_core_providers/* MODE_PROVIDER */.CV]), core_js_["ɵɵInheritDefinitionFeature"]],
  ngContentSelectors: taiga_ui_kit_components_accordion_c1,
  decls: 8,
  vars: 6,
  consts: [["automation-id", "tui-accordion__item-wrapper", 1, "wrapper", 3, "tuiFocusable", "tuiFocusVisibleChange", "tuiFocusedChange", "keydown.space", "keydown.enter", "keydown.esc"], ["focusableElement", ""], ["automation-id", "tui-accordion__item-header", 1, "header", 3, "tuiHoveredChange", "click"], ["automation-id", "tui-accordion__item-title", 1, "title"], ["automation-id", "tui-accordion__item-arrow", "class", "icon", "src", "tuiIconChevronDownLarge", 3, "icon_open", 4, "ngIf"], [3, "async", "expanded"], ["tuiExpandContent", ""], ["automation-id", "tui-accordion__item-arrow", "src", "tuiIconChevronDownLarge", 1, "icon"], ["polymorpheus-outlet", "", "automation-id", "tui-accordion__item-content", 1, "content", 3, "content"]],
  template: function TuiAccordionItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"]();
      core_js_["ɵɵelementStart"](0, "div", 0, 1);
      core_js_["ɵɵlistener"]("tuiFocusVisibleChange", function TuiAccordionItemComponent_Template_div_tuiFocusVisibleChange_0_listener($event) {
        return ctx.onFocusVisible($event);
      })("tuiFocusedChange", function TuiAccordionItemComponent_Template_div_tuiFocusedChange_0_listener($event) {
        return ctx.onFocused($event);
      })("keydown.space", function TuiAccordionItemComponent_Template_div_keydown_space_0_listener($event) {
        return ctx.onItemKeyDownSpace($event);
      })("keydown.enter", function TuiAccordionItemComponent_Template_div_keydown_enter_0_listener($event) {
        return ctx.onItemKeyDownSpace($event);
      })("keydown.esc", function TuiAccordionItemComponent_Template_div_keydown_esc_0_listener($event) {
        return ctx.onItemKeyDownEsc($event);
      });
      core_js_["ɵɵelementStart"](2, "div", 2);
      core_js_["ɵɵlistener"]("tuiHoveredChange", function TuiAccordionItemComponent_Template_div_tuiHoveredChange_2_listener($event) {
        return ctx.onHovered($event);
      })("click", function TuiAccordionItemComponent_Template_div_click_2_listener() {
        return ctx.onRowToggle();
      });
      core_js_["ɵɵelementStart"](3, "div", 3);
      core_js_["ɵɵprojection"](4);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵtemplate"](5, TuiAccordionItemComponent_tui_svg_5_Template, 1, 2, "tui-svg", 4);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementStart"](6, "tui-expand", 5);
      core_js_["ɵɵtemplate"](7, TuiAccordionItemComponent_ng_template_7_Template, 1, 1, "ng-template", 6);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      core_js_["ɵɵproperty"]("tuiFocusable", ctx.computedFocusable);
      core_js_["ɵɵadvance"](2);
      core_js_["ɵɵclassProp"]("header_open", ctx.open);
      core_js_["ɵɵadvance"](3);
      core_js_["ɵɵproperty"]("ngIf", ctx.showArrow);
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵproperty"]("async", ctx.async)("expanded", ctx.open);
    }
  },
  directives: [TuiFocusableDirective, TuiFocusVisibleDirective, TuiFocusedDirective, TuiHoveredDirective, common_js_.NgIf, TuiExpandComponent, TuiExpandContentDirective, taiga_ui_core_components_svg/* TuiSvgComponent */.P, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1],
  styles: ["[_nghost-%COMP%]{position:relative;display:block;overflow:hidden;border-radius:var(--tui-radius-l)}[data-tui-host-borders=top-bottom][_nghost-%COMP%]{border-radius:0!important}.wrapper[_ngcontent-%COMP%]{position:relative;border-radius:inherit}.wrapper[_ngcontent-%COMP%]:focus{outline:0}.wrapper[_ngcontent-%COMP%]:after{position:absolute;top:0;left:0;width:100%;height:100%;content:'';box-sizing:border-box;border-radius:inherit;border:1px solid var(--tui-base-04);pointer-events:none}[_nghost-%COMP%]:not([data-tui-host-borders])   .wrapper[_ngcontent-%COMP%]:after{border-width:0}[data-tui-host-borders=all][_nghost-%COMP%]   .wrapper[_ngcontent-%COMP%]:after{border-width:1px}[data-tui-host-borders=top-bottom][_nghost-%COMP%]   .wrapper[_ngcontent-%COMP%]:after{border-left-width:0;border-right-width:0}[data-tui-host-borders=top][_nghost-%COMP%]   .wrapper[_ngcontent-%COMP%]:after{border-left-width:0;border-right-width:0;border-bottom-width:0}[data-tui-host-borders=bottom][_nghost-%COMP%]   .wrapper[_ngcontent-%COMP%]:after{border-left-width:0;border-right-width:0;border-top-width:0}[data-mode=onDark][_nghost-%COMP%]   .wrapper[_ngcontent-%COMP%]:after{border-color:var(--tui-base-03)}[data-mode=onLight][_nghost-%COMP%]   .wrapper[_ngcontent-%COMP%]:after{border-color:var(--tui-text-01)}._focus-visible[_nghost-%COMP%]   .wrapper[_ngcontent-%COMP%]:after{border:2px solid var(--tui-focus)}[_nghost-%COMP%]:not([data-mode])   .wrapper[_ngcontent-%COMP%]{background:var(--tui-base-01)}.header[_ngcontent-%COMP%]{font:var(--tui-font-text-l);transition-property:background;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;display:flex;align-items:center;box-sizing:border-box;border-bottom:1px solid var(--tui-base-04);min-height:var(--tui-height-l);padding:12px 20px;color:var(--tui-text-01);cursor:pointer}[data-mode=onDark][_nghost-%COMP%]   .header[_ngcontent-%COMP%]{color:var(--tui-text-01-night);border-color:var(--tui-base-03)}[data-mode=onLight][_nghost-%COMP%]   .header[_ngcontent-%COMP%]{border-color:var(--tui-text-01)}[_nghost-%COMP%]:not([data-tui-host-borders])   .header[_ngcontent-%COMP%]{border-bottom-width:0;box-shadow:none}._has-arrow[_nghost-%COMP%]   .header[_ngcontent-%COMP%]{padding-right:12px}._hovered[_nghost-%COMP%]:not([data-mode])   .header[_ngcontent-%COMP%]{background:var(--tui-base-02)}._hovered[data-mode=onDark][_nghost-%COMP%]   .header[_ngcontent-%COMP%], [data-mode=onDark][_nghost-%COMP%]   .header_open[_ngcontent-%COMP%]{background:var(--tui-clear-inverse)}._hovered[data-mode=onLight][_nghost-%COMP%]   .header[_ngcontent-%COMP%], [data-mode=onLight][_nghost-%COMP%]   .header_open[_ngcontent-%COMP%]{background:var(--tui-clear)}[data-tui-host-size='s'][_nghost-%COMP%]   .header[_ngcontent-%COMP%]{font:var(--tui-font-text-m);min-height:var(--tui-height-m);padding:10px 12px 10px 16px}._no-padding[_nghost-%COMP%]   .header[_ngcontent-%COMP%]{padding-left:0;padding-right:0}._disabled[_nghost-%COMP%]   .header[_ngcontent-%COMP%]{cursor:default}.title[_ngcontent-%COMP%]{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;margin-right:0;flex-grow:1}._has-arrow[_nghost-%COMP%]   .title[_ngcontent-%COMP%]{margin-right:8px}.icon[_ngcontent-%COMP%]{transition-property:transform,color;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;width:24px;height:24px;margin-left:auto;color:var(--tui-base-06)}.icon_open[_ngcontent-%COMP%]{transform:rotate(180deg)}[data-mode][_nghost-%COMP%]   .icon[_ngcontent-%COMP%]{opacity:var(--tui-disabled-opacity)}._hovered[data-mode][_nghost-%COMP%]   .icon[_ngcontent-%COMP%]{opacity:.8}[data-mode=onDark][_nghost-%COMP%]   .icon[_ngcontent-%COMP%]{color:var(--tui-text-01-night)}[data-mode=onLight][_nghost-%COMP%]   .icon[_ngcontent-%COMP%]{color:var(--tui-text-01)}._hovered[_nghost-%COMP%]:not([data-mode])   .icon[_ngcontent-%COMP%]{color:var(--tui-base-07)}.content[_ngcontent-%COMP%]{font:var(--tui-font-text-m);padding:20px;word-wrap:break-word}[data-tui-host-size='s'][_nghost-%COMP%]   .content[_ngcontent-%COMP%]{font:var(--tui-font-text-s);padding:16px}"],
  changeDetection: 0
});
TuiAccordionItemComponent.ctorParameters = () => [{
  type: core_js_.ChangeDetectorRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ChangeDetectorRef]
  }]
}, {
  type: Observable/* Observable */.y,
  decorators: [{
    type: core_js_.Inject,
    args: [taiga_ui_core_tokens/* TUI_MODE */.Au]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._no-padding'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiAccordionItemComponent.prototype, "noPadding", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._has-arrow'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiAccordionItemComponent.prototype, "showArrow", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-tui-host-borders'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiAccordionItemComponent.prototype, "borders", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-tui-host-size'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiAccordionItemComponent.prototype, "size", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._disabled'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiAccordionItemComponent.prototype, "disabled", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiAccordionItemComponent.prototype, "disableHover", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiAccordionItemComponent.prototype, "open", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiAccordionItemComponent.prototype, "async", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiAccordionItemComponent.prototype, "openChange", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChild)(TuiAccordionItemContentDirective)], TuiAccordionItemComponent.prototype, "content", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('focusableElement')], TuiAccordionItemComponent.prototype, "focusableElement", void 0);
TuiAccordionItemComponent = TuiAccordionItemComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_MODE */.Au))], TuiAccordionItemComponent);
let TuiAccordionComponent = /*#__PURE__*/(() => {
  let TuiAccordionComponent = class TuiAccordionComponent {
    constructor(destroy$) {
      this.destroy$ = destroy$;
      this.closeOthers = true;
      this.rounded = true;
      this.accordionItems = taiga_ui_cdk_constants/* EMPTY_QUERY */.Mm;
    }
    ngAfterContentInit() {
      const {
        accordionItems
      } = this;
      const rows$ = (0,taiga_ui_cdk_observables/* itemsQueryListObservable */.Fp)(accordionItems);
      const newOpenRow$ = rows$.pipe((0,pairwise/* pairwise */.G)(), (0,map/* map */.U)(([previous, current]) => current.find(item => previous.indexOf(item) === -1 && item.open)), (0,filter/* filter */.h)(taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN));
      const rowsOpen$ = (0,merge/* merge */.T)(rows$.pipe((0,switchMap/* switchMap */.w)(rows => (0,merge/* merge */.T)(...rows.map(row => row.openChange.pipe((0,filter/* filter */.h)(taiga_ui_cdk_utils_miscellaneous/* identity */.yR), (0,mapTo/* mapTo */.h)(row)))))), newOpenRow$).pipe((0,filter/* filter */.h)(() => this.closeOthers), (0,takeUntil/* takeUntil */.R)(this.destroy$));
      rowsOpen$.subscribe(currentRow => {
        accordionItems.forEach(row => {
          if (currentRow !== row) {
            row.close();
          }
        });
      });
    }
  };
  TuiAccordionComponent.ɵfac = function TuiAccordionComponent_Factory(t) {
    return new (t || TuiAccordionComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3));
  };
  TuiAccordionComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiAccordionComponent,
    selectors: [["tui-accordion"]],
    contentQueries: function TuiAccordionComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        core_js_["ɵɵcontentQuery"](dirIndex, TuiAccordionItemComponent, 4);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.accordionItems = _t);
      }
    },
    inputs: {
      closeOthers: "closeOthers",
      rounded: "rounded"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])],
    ngContentSelectors: _c3,
    decls: 2,
    vars: 2,
    consts: [["tuiGroup", "", "automation-id", "tui-accordion__group", "orientation", "vertical", "size", "l", 1, "group", 3, "collapsed", "rounded"]],
    template: function TuiAccordionComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"](taiga_ui_kit_components_accordion_c2);
        core_js_["ɵɵelementStart"](0, "div", 0);
        core_js_["ɵɵprojection"](1);
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("collapsed", true)("rounded", ctx.rounded);
      }
    },
    directives: [TuiGroupDirective],
    styles: ["[_nghost-%COMP%]{display:block}.group[_ngcontent-%COMP%]{display:flex}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiAccordionComponent.prototype, "closeOthers", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiAccordionComponent.prototype, "rounded", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChildren)(TuiAccordionItemComponent)], TuiAccordionComponent.prototype, "accordionItems", void 0);
  TuiAccordionComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3))], TuiAccordionComponent);
  return TuiAccordionComponent;
})();
let TuiAccordionModule = /*#__PURE__*/(() => {
  let TuiAccordionModule = class TuiAccordionModule {};
  TuiAccordionModule.ɵfac = function TuiAccordionModule_Factory(t) {
    return new (t || TuiAccordionModule)();
  };
  TuiAccordionModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiAccordionModule
  });
  TuiAccordionModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, TuiFocusedModule, TuiFocusVisibleModule, TuiFocusableModule, TuiHoveredModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiGroupModule, TuiExpandModule]]
  });
  return TuiAccordionModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiAccordionModule, {
    declarations: function () {
      return [TuiAccordionComponent, TuiAccordionItemComponent, TuiAccordionItemContentDirective];
    },
    imports: function () {
      return [common_js_.CommonModule, TuiFocusedModule, TuiFocusVisibleModule, TuiFocusableModule, TuiHoveredModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiGroupModule, TuiExpandModule];
    },
    exports: function () {
      return [TuiAccordionComponent, TuiAccordionItemComponent, TuiAccordionItemContentDirective];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-accordion.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-badge.js








const taiga_ui_kit_components_badge_c0 = ["*"];
let TuiBadgeComponent = /*#__PURE__*/(() => {
  let TuiBadgeComponent = class TuiBadgeComponent {
    constructor(mode$) {
      this.mode$ = mode$;
      this.value = '';
      this.size = 'm';
      this.status = "default" /* Default */;
      this.hoverable = false;
    }
    get padding() {
      if (this.isEmpty) {
        return 'none';
      }
      return (0,taiga_ui_cdk_utils_miscellaneous/* isNumber */.hj)(this.value.valueOf()) ? 'm' : 'l';
    }
    get outputValue() {
      if ((0,taiga_ui_cdk_utils_miscellaneous/* isNumber */.hj)(this.value.valueOf()) && this.value.valueOf() > 99) {
        return '99+';
      } else {
        return String(this.value);
      }
    }
    get isEmpty() {
      return this.value === '';
    }
  };
  TuiBadgeComponent.ɵfac = function TuiBadgeComponent_Factory(t) {
    return new (t || TuiBadgeComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_MODE */.Au));
  };
  TuiBadgeComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiBadgeComponent,
    selectors: [["tui-badge"]],
    hostVars: 7,
    hostBindings: function TuiBadgeComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("$.data-mode.attr", function TuiBadgeComponent___data_mode_attr_HostBindingHandler() {
          return ctx.mode$;
        });
      }
      if (rf & 2) {
        core_js_["ɵɵattribute"]("data-tui-host-size", ctx.size)("data-tui-host-status", ctx.status)("data-tui-host-padding", ctx.padding);
        core_js_["ɵɵclassProp"]("_hoverable", ctx.hoverable)("_empty-value", ctx.isEmpty);
      }
    },
    inputs: {
      value: "value",
      size: "size",
      status: "status",
      hoverable: "hoverable"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_core_providers/* MODE_PROVIDER */.CV])],
    ngContentSelectors: taiga_ui_kit_components_badge_c0,
    decls: 3,
    vars: 1,
    consts: [[1, "left-content"]],
    template: function TuiBadgeComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵelementStart"](0, "span", 0);
        core_js_["ɵɵprojection"](1);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtext"](2);
      }
      if (rf & 2) {
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵtextInterpolate1"]("", ctx.outputValue, "\n");
      }
    },
    styles: ["[_nghost-%COMP%]{font:var(--tui-font-text-s);transition-property:background-color;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;color:var(--tui-base-01);border-radius:100px;white-space:nowrap;overflow:hidden;vertical-align:middle;--left-content-color:currentColor}[_nghost-%COMP%]:after{transition-property:background;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;position:absolute;top:0;left:0;width:100%;height:100%;content:'';box-sizing:border-box;border-radius:inherit;pointer-events:none}._hoverable[_nghost-%COMP%]:active[data-tui-host-status=custom]:after, ._hoverable[_nghost-%COMP%]:hover[data-tui-host-status=custom]:after{background-color:var(--tui-clear)}[data-tui-host-status=primary][_nghost-%COMP%]{background-color:var(--tui-primary);color:var(--tui-primary-text)}[data-tui-host-status=primary]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-primary-hover)}[data-tui-host-status=primary]._hoverable[_nghost-%COMP%]:active{background-color:var(--tui-primary-active)}[data-tui-host-status=error][_nghost-%COMP%]{background-color:var(--tui-error-bg);color:var(--tui-text-01);--left-content-color:var(--tui-error-fill)}[data-tui-host-status=error]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=error]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-error-bg-hover)}[data-tui-host-status=error][data-mode=onDark][_nghost-%COMP%]{background-color:var(--tui-error-bg-night);color:var(--tui-text-01-night)}[data-tui-host-status=error][data-mode=onDark]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=error][data-mode=onDark]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-error-bg-night-hover)}[data-tui-host-status=success][_nghost-%COMP%]{background-color:var(--tui-success-bg);color:var(--tui-text-01);--left-content-color:var(--tui-success-fill)}[data-tui-host-status=success]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=success]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-success-bg-hover)}[data-tui-host-status=success][data-mode=onDark][_nghost-%COMP%]{background-color:var(--tui-success-bg-night);color:var(--tui-text-01-night)}[data-tui-host-status=success][data-mode=onDark]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=success][data-mode=onDark]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-success-bg-night-hover)}[data-tui-host-status=warning][_nghost-%COMP%]{background-color:var(--tui-warning-bg);color:var(--tui-text-01);--left-content-color:var(--tui-warning-fill)}[data-tui-host-status=warning]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=warning]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-warning-bg-hover)}[data-tui-host-status=warning][data-mode=onDark][_nghost-%COMP%]{background-color:var(--tui-warning-bg-night);color:var(--tui-text-01-night)}[data-tui-host-status=warning][data-mode=onDark]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=warning][data-mode=onDark]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-warning-bg-night-hover)}[data-tui-host-status=default][_nghost-%COMP%]{background-color:var(--tui-base-06)}[data-tui-host-status=default][_nghost-%COMP%]:not([data-mode])._hoverable:hover{background-color:var(--tui-base-07)}[data-tui-host-status=default][_nghost-%COMP%]:not([data-mode])._hoverable:active{background-color:var(--tui-base-08)}[data-tui-host-status=default][data-mode=onDark][_nghost-%COMP%]{background-color:var(--tui-clear-inverse-hover)}[data-tui-host-status=default][data-mode=onDark]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-clear-inverse-active)}[data-tui-host-status=default][data-mode=onDark]._hoverable[_nghost-%COMP%]:active{background-color:var(--tui-clear-inverse-active)}[data-tui-host-status=default][data-mode=onDark][_nghost-%COMP%]:focus:after{border:2px solid var(--tui-base-01)}[data-tui-host-status=default][data-mode=onLight][_nghost-%COMP%]{background-color:var(--tui-clear);color:var(--tui-text-01)}[data-tui-host-status=default][data-mode=onLight]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-clear-hover)}[data-tui-host-status=default][data-mode=onLight]._hoverable[_nghost-%COMP%]:active{background-color:var(--tui-clear-active)}._hoverable[_nghost-%COMP%]{cursor:pointer}[data-tui-host-padding='m'][_nghost-%COMP%]{padding:0 8px}[data-tui-host-padding='m'][data-tui-host-size='s'][_nghost-%COMP%]{padding:0 6px}[data-tui-host-padding='m'][data-tui-host-size='l'][_nghost-%COMP%]{padding:0 10px}[data-tui-host-padding='l'][_nghost-%COMP%]{padding:0 10px}[data-tui-host-padding='l'][data-tui-host-size='s'][_nghost-%COMP%]{padding:0 8px}[data-tui-host-padding='l'][data-tui-host-size='l'][_nghost-%COMP%]{padding:0 12px}[data-tui-host-size='s'][_nghost-%COMP%]{font:var(--tui-font-text-xs);height:20px;min-width:20px}[data-tui-host-size='s'][_nghost-%COMP%]   .left-content[_ngcontent-%COMP%]:before{width:4px;height:4px}[data-tui-host-size='m'][_nghost-%COMP%]{height:var(--tui-height-xs);line-height:var(--tui-height-xs);min-width:var(--tui-height-xs)}[data-tui-host-size='l'][_nghost-%COMP%]{height:var(--tui-height-s);line-height:var(--tui-height-s);min-width:var(--tui-height-s)}[data-tui-host-size='l'][_nghost-%COMP%]   .left-content[_ngcontent-%COMP%]:before{margin:0 8px 0 0;width:8px;height:8px}._empty-value[_nghost-%COMP%]   .left-content[_ngcontent-%COMP%]{margin:0 -4px}._empty-value[_nghost-%COMP%]   .left-content[_ngcontent-%COMP%]:before{margin:0}.left-content[_ngcontent-%COMP%]{display:none;color:var(--left-content-color);line-height:0}.left-content[_ngcontent-%COMP%]:not(:empty){display:block;margin-left:-4px}.left-content[_ngcontent-%COMP%]:not(:empty):before{content:none}[data-tui-host-status=error][_nghost-%COMP%]   .left-content[_ngcontent-%COMP%], [data-tui-host-status=success][_nghost-%COMP%]   .left-content[_ngcontent-%COMP%], [data-tui-host-status=warning][_nghost-%COMP%]   .left-content[_ngcontent-%COMP%]{display:block}.left-content[_ngcontent-%COMP%]:before{display:block;background:currentColor;margin:0 6px 0 0;width:6px;height:6px;border-radius:100%;content:''}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiBadgeComponent.prototype, "value", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-tui-host-size'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiBadgeComponent.prototype, "size", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-tui-host-status'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiBadgeComponent.prototype, "status", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._hoverable'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiBadgeComponent.prototype, "hoverable", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('attr.data-tui-host-padding')], TuiBadgeComponent.prototype, "padding", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._empty-value')], TuiBadgeComponent.prototype, "isEmpty", null);
  TuiBadgeComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_MODE */.Au))], TuiBadgeComponent);
  return TuiBadgeComponent;
})();
let TuiBadgeModule = /*#__PURE__*/(() => {
  let TuiBadgeModule = class TuiBadgeModule {};
  TuiBadgeModule.ɵfac = function TuiBadgeModule_Factory(t) {
    return new (t || TuiBadgeModule)();
  };
  TuiBadgeModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiBadgeModule
  });
  TuiBadgeModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule]]
  });
  return TuiBadgeModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiBadgeModule, {
    declarations: function () {
      return [TuiBadgeComponent];
    },
    imports: function () {
      return [common_js_.CommonModule];
    },
    exports: function () {
      return [TuiBadgeComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-badge.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-toggle.js











const taiga_ui_kit_components_toggle_c0 = ["focusableElement"];
function TuiToggleComponent_tui_loader_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-loader", 8);
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("size", ctx_r0.loaderSize)("inheritColor", true)("showLoader", ctx_r0.checked);
  }
}
function TuiToggleComponent_tui_svg_3_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 9);
  }
  if (rf & 2) {
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("src", ctx_r1.iconOn);
  }
}
function TuiToggleComponent_tui_loader_5_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-loader", 8);
  }
  if (rf & 2) {
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("size", ctx_r2.loaderSize)("inheritColor", true)("showLoader", !ctx_r2.checked);
  }
}
function TuiToggleComponent_tui_svg_6_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 10);
  }
  if (rf & 2) {
    const ctx_r3 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("src", ctx_r3.iconOff);
  }
}
var TuiToggleComponent_1;
let TuiToggleComponent = TuiToggleComponent_1 = class TuiToggleComponent extends taiga_ui_cdk_abstract/* AbstractTuiControl */.M$ {
  constructor(control, changeDetectorRef, modeDirective) {
    super(control, changeDetectorRef);
    this.modeDirective = modeDirective;
    this.singleColor = false;
    this.showIcons = false;
    this.showLoader = false;
    this.size = 'm';
  }
  get nativeFocusableElement() {
    return this.focusableElement ? this.focusableElement.nativeElement : null;
  }
  get focused() {
    return (0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(this.nativeFocusableElement);
  }
  get appearance() {
    return this.singleColor || this.checked ? "primary" /* Primary */ : "secondary" /* Secondary */;
  }

  get sizeM() {
    return this.size === 'm';
  }
  get checked() {
    return this.value;
  }
  get iconOn() {
    return this.sizeM ? 'tuiIconToggleOn' : 'tuiIconToggleOnLarge';
  }
  get iconOff() {
    return this.sizeM ? 'tuiIconToggleOff' : 'tuiIconToggleOffLarge';
  }
  get loaderSize() {
    return this.sizeM ? 'xs' : 's';
  }
  get hostMode() {
    return this.modeDirective ? this.modeDirective.mode : null;
  }
  onChecked(checked) {
    this.updateValue(checked);
  }
  onFocused(focused) {
    this.updateFocused(focused);
  }
  onHovered(hovered) {
    this.updateHovered(hovered);
  }
  onPressed(pressed) {
    this.updatePressed(pressed);
  }
  onFocusVisible(focusVisible) {
    this.updateFocusVisible(focusVisible);
  }
  getFallbackValue() {
    return false;
  }
};
TuiToggleComponent.ɵfac = function TuiToggleComponent_Factory(t) {
  return new (t || TuiToggleComponent)(core_js_["ɵɵdirectiveInject"](fesm2015_forms.NgControl, 10), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_directives_mode/* TuiModeDirective */.w, 8));
};
TuiToggleComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiToggleComponent,
  selectors: [["tui-toggle"]],
  viewQuery: function TuiToggleComponent_Query(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵviewQuery"](taiga_ui_kit_components_toggle_c0, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.focusableElement = _t.first);
    }
  },
  hostVars: 4,
  hostBindings: function TuiToggleComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      core_js_["ɵɵattribute"]("data-tui-host-size", ctx.size)("data-mode", ctx.hostMode);
      core_js_["ɵɵclassProp"]("_checked", ctx.checked);
    }
  },
  inputs: {
    singleColor: "singleColor",
    showIcons: "showIcons",
    showLoader: "showLoader",
    size: "size"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ,
    useExisting: (0,core_js_.forwardRef)(() => TuiToggleComponent_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]],
  decls: 9,
  vars: 15,
  consts: [[3, "appearance", "disabled", "focused", "hovered", "pressed", "invalid"], [1, "toggle"], ["class", "loader", 3, "size", "inheritColor", "showLoader", 4, "ngIf"], ["class", "icon", "automation-id", "tui-toggle__check-icon", 3, "src", 4, "ngIf"], [1, "circle"], ["class", "icon icon_off", "automation-id", "tui-toggle__cancel-icon", 3, "src", 4, "ngIf"], ["type", "checkbox", "role", "switch", "automation-id", "tui-toggle__checkbox", 1, "checkbox", 3, "id", "disabled", "tuiChecked", "tuiFocusable", "tuiCheckedChange", "tuiFocusedChange", "tuiHoveredChange", "tuiPressedChange", "tuiFocusVisibleChange"], ["focusableElement", ""], [1, "loader", 3, "size", "inheritColor", "showLoader"], ["automation-id", "tui-toggle__check-icon", 1, "icon", 3, "src"], ["automation-id", "tui-toggle__cancel-icon", 1, "icon", "icon_off", 3, "src"]],
  template: function TuiToggleComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵelementStart"](0, "tui-wrapper", 0);
      core_js_["ɵɵelementStart"](1, "div", 1);
      core_js_["ɵɵtemplate"](2, TuiToggleComponent_tui_loader_2_Template, 1, 3, "tui-loader", 2);
      core_js_["ɵɵtemplate"](3, TuiToggleComponent_tui_svg_3_Template, 1, 1, "tui-svg", 3);
      core_js_["ɵɵelement"](4, "div", 4);
      core_js_["ɵɵtemplate"](5, TuiToggleComponent_tui_loader_5_Template, 1, 3, "tui-loader", 2);
      core_js_["ɵɵtemplate"](6, TuiToggleComponent_tui_svg_6_Template, 1, 1, "tui-svg", 5);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementStart"](7, "input", 6, 7);
      core_js_["ɵɵlistener"]("tuiCheckedChange", function TuiToggleComponent_Template_input_tuiCheckedChange_7_listener($event) {
        return ctx.onChecked($event);
      })("tuiFocusedChange", function TuiToggleComponent_Template_input_tuiFocusedChange_7_listener($event) {
        return ctx.onFocused($event);
      })("tuiHoveredChange", function TuiToggleComponent_Template_input_tuiHoveredChange_7_listener($event) {
        return ctx.onHovered($event);
      })("tuiPressedChange", function TuiToggleComponent_Template_input_tuiPressedChange_7_listener($event) {
        return ctx.onPressed($event);
      })("tuiFocusVisibleChange", function TuiToggleComponent_Template_input_tuiFocusVisibleChange_7_listener($event) {
        return ctx.onFocusVisible($event);
      });
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      core_js_["ɵɵproperty"]("appearance", ctx.appearance)("disabled", ctx.disabled)("focused", ctx.computedFocusVisible)("hovered", ctx.computedHovered)("pressed", ctx.computedPressed)("invalid", ctx.computedInvalid);
      core_js_["ɵɵadvance"](2);
      core_js_["ɵɵproperty"]("ngIf", ctx.showLoader);
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵproperty"]("ngIf", ctx.showIcons && !ctx.showLoader);
      core_js_["ɵɵadvance"](2);
      core_js_["ɵɵproperty"]("ngIf", ctx.showLoader);
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵproperty"]("ngIf", ctx.showIcons && !ctx.showLoader);
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵproperty"]("id", ctx.id)("disabled", ctx.disabled)("tuiChecked", ctx.checked)("tuiFocusable", ctx.focusable);
      core_js_["ɵɵattribute"]("aria-checked", ctx.value);
    }
  },
  directives: [taiga_ui_core_components_wrapper/* TuiWrapperComponent */.Q, common_js_.NgIf, TuiCheckedDirective, TuiFocusableDirective, TuiFocusedDirective, TuiHoveredDirective, TuiPressedDirective, TuiFocusVisibleDirective, taiga_ui_core_components_loader/* TuiLoaderComponent */.kM, taiga_ui_core_components_svg/* TuiSvgComponent */.P],
  styles: ["[_nghost-%COMP%]{position:relative;display:inline-block;vertical-align:middle;overflow:hidden;border-radius:100px}[data-tui-host-size='m'][_nghost-%COMP%]{width:32px;height:16px}[data-tui-host-size='l'][_nghost-%COMP%]{width:48px;height:24px}.checkbox[_ngcontent-%COMP%]{padding:0;border:0;border-radius:inherit;background:0 0;font-size:inherit;line-height:inherit;font-weight:inherit;color:inherit;caret-color:currentColor;outline:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;word-break:keep-all;-webkit-text-fill-color:currentColor;position:absolute;top:0;left:0;height:100%;width:100%;opacity:0;cursor:pointer}.checkbox[_ngcontent-%COMP%]:-webkit-autofill, .checkbox[_ngcontent-%COMP%]:-webkit-autofill:focus, .checkbox[_ngcontent-%COMP%]:-webkit-autofill:hover{border-radius:inherit;-webkit-text-fill-color:inherit!important;color:inherit!important;background-color:transparent!important;-webkit-box-shadow:0 0 0 1000px var(--tui-autofill) inset!important}._disabled[_nghost-%COMP%]   .checkbox[_ngcontent-%COMP%]{pointer-events:none;cursor:default}.toggle[_ngcontent-%COMP%]{transition-property:transform;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;display:flex;align-items:center;justify-content:center}[data-tui-host-size='m'][_nghost-%COMP%]   .toggle[_ngcontent-%COMP%]{width:48px;height:16px;transform:translateX(-16px)}[data-tui-host-size='l'][_nghost-%COMP%]   .toggle[_ngcontent-%COMP%]{width:72px;height:24px;transform:translateX(-24px)}._checked[_nghost-%COMP%]   .toggle[_ngcontent-%COMP%]{transform:translateX(0)}.circle[_ngcontent-%COMP%]{margin:2px 0;flex-shrink:0;border-radius:100%;background-color:var(--tui-base-01)}._disabled[_nghost-%COMP%]   .circle_light[_ngcontent-%COMP%]{opacity:.24}[data-tui-host-size='m'][_nghost-%COMP%]   .circle[_ngcontent-%COMP%]{width:12px;height:12px}[data-tui-host-size='l'][_nghost-%COMP%]   .circle[_ngcontent-%COMP%]{width:16px;height:16px}._disabled[_nghost-%COMP%]   .circle[_ngcontent-%COMP%]{background-color:var(--tui-base-01)}[_nghost-%COMP%]:not(._checked)   .loader[_ngcontent-%COMP%]{color:var(--tui-base-06)}[_nghost-%COMP%]:not(._checked)._disabled   .loader[_ngcontent-%COMP%]{color:var(--tui-base-05)}[_nghost-%COMP%]:not(._checked)[data-mode=onDark]   .loader[_ngcontent-%COMP%]{color:var(--tui-text-03-night)}[_nghost-%COMP%]:not(._checked)[data-mode=onDark]._disabled   .loader[_ngcontent-%COMP%]{color:var(--tui-clear-inverse-active)}[_nghost-%COMP%]:not(._checked)[data-mode=onLight]   .loader[_ngcontent-%COMP%]{color:var(--tui-text-03)}[_nghost-%COMP%]:not(._checked)[data-mode=onLight]._disabled   .loader[_ngcontent-%COMP%]{color:var(--tui-clear-active)}[data-tui-host-size='m'][_nghost-%COMP%]   .loader[_ngcontent-%COMP%]{width:12px;margin:0 2px;transform:scale(.75)}[data-tui-host-size='l'][_nghost-%COMP%]   .loader[_ngcontent-%COMP%]{width:16px;margin:0 6px}.icon[_ngcontent-%COMP%]{opacity:.8}.icon_off[_ngcontent-%COMP%]{color:var(--tui-base-06)}._disabled[_nghost-%COMP%]   .icon_off[_ngcontent-%COMP%]{color:var(--tui-base-05)}[data-mode=onDark][_nghost-%COMP%]   .icon_off[_ngcontent-%COMP%]{color:var(--tui-text-03-night)}[data-mode=onDark]._disabled[_nghost-%COMP%]   .icon_off[_ngcontent-%COMP%]{color:var(--tui-clear-inverse-active)}[data-mode=onLight][_nghost-%COMP%]   .icon_off[_ngcontent-%COMP%]{color:var(--tui-text-03)}[data-mode=onLight]._disabled[_nghost-%COMP%]   .icon_off[_ngcontent-%COMP%]{color:var(--tui-clear-active)}[data-tui-host-size='m'][_nghost-%COMP%]   .icon[_ngcontent-%COMP%]{width:16px;height:16px;transform:scale(.75)}[data-tui-host-size='l'][_nghost-%COMP%]   .icon[_ngcontent-%COMP%]{margin:0 2px;width:24px;height:24px}._hovered[_nghost-%COMP%]   .icon[_ngcontent-%COMP%]{opacity:1}"],
  changeDetection: 0
});
TuiToggleComponent.ctorParameters = () => [{
  type: fesm2015_forms.NgControl,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.Self
  }, {
    type: core_js_.Inject,
    args: [fesm2015_forms.NgControl]
  }]
}, {
  type: core_js_.ChangeDetectorRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ChangeDetectorRef]
  }]
}, {
  type: taiga_ui_core_directives_mode/* TuiModeDirective */.w,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.Inject,
    args: [taiga_ui_core_directives_mode/* TuiModeDirective */.w]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiToggleComponent.prototype, "singleColor", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiToggleComponent.prototype, "showIcons", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiToggleComponent.prototype, "showLoader", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-tui-host-size'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiToggleComponent.prototype, "size", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('focusableElement')], TuiToggleComponent.prototype, "focusableElement", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._checked')], TuiToggleComponent.prototype, "checked", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('attr.data-mode')], TuiToggleComponent.prototype, "hostMode", null);
TuiToggleComponent = TuiToggleComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(fesm2015_forms.NgControl)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_core_directives_mode/* TuiModeDirective */.w))], TuiToggleComponent);
let TuiToggleModule = /*#__PURE__*/(() => {
  let TuiToggleModule = class TuiToggleModule {};
  TuiToggleModule.ɵfac = function TuiToggleModule_Factory(t) {
    return new (t || TuiToggleModule)();
  };
  TuiToggleModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiToggleModule
  });
  TuiToggleModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, TuiFocusedModule, TuiFocusableModule, TuiHoveredModule, TuiPressedModule, TuiFocusVisibleModule, TuiCheckedModule, taiga_ui_core_components_wrapper/* TuiWrapperModule */.W, taiga_ui_core_components_svg/* TuiSvgModule */.E, taiga_ui_core_components_loader/* TuiLoaderModule */.dS]]
  });
  return TuiToggleModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiToggleModule, {
    declarations: function () {
      return [TuiToggleComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, TuiFocusedModule, TuiFocusableModule, TuiHoveredModule, TuiPressedModule, TuiFocusVisibleModule, TuiCheckedModule, taiga_ui_core_components_wrapper/* TuiWrapperModule */.W, taiga_ui_core_components_svg/* TuiSvgModule */.E, taiga_ui_core_components_loader/* TuiLoaderModule */.dS];
    },
    exports: function () {
      return [TuiToggleComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-toggle.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-utils-format.js


/**
 * Capitalizes a given string, replacing it with a lowercase string and making
 * the first letter of each word uppercase.
 *
 * @param value the input string
 * @return the capitalized string
 */
function capitalize(value) {
  return value.toLowerCase().replace(/(?:^|\s)\S/g, char => char.toUpperCase());
}

/**
 * Formats number adding thousand separators and correct decimal separator
 * padding decimal part with zeroes to given length
 *
 * @param value the input number
 * @param decimalLimit number of digits of decimal part, null to keep untouched
 * @param decimalSeparator separator between the integer and the decimal part
 * @param thousandSeparator separator between thousands
 * @return the formatted string
 */
function formatNumber(value, decimalLimit = null, decimalSeparator = ',', thousandSeparator = taiga_ui_cdk_constants/* CHAR_NO_BREAK_SPACE */.f$) {
  const integerPartString = Math.floor(Math.abs(value)).toString();
  const fractionPartString = value.toString().split('.')[1] || '';
  const fractionPartPadded = decimalLimit === null ? fractionPartString : fractionPartString.substr(0, decimalLimit) + '0'.repeat(Math.max(decimalLimit - fractionPartString.length, 0));
  const remainder = integerPartString.length % 3;
  const sign = value < 0 ? '-' : '';
  let result = sign + integerPartString.charAt(0);
  for (let i = 1; i < integerPartString.length; i++) {
    if (i % 3 === remainder && integerPartString.length > 3) {
      result += thousandSeparator;
    }
    result += integerPartString.charAt(i);
  }
  return !!fractionPartPadded || decimalLimit ? result + decimalSeparator + fractionPartPadded : result;
}

/**
 * Formats a string with the phone format +7XXXXXXXXXXXX or XXXXXXXXXXXX,
 * adding parentheses and hyphens.
 *
 * @param value the input string
 * @param countryCode a country code
 * @param phoneMask a phone number mask
 * @return the formatted phone string of the form +7 XXX XXX-XX-XX
 */
function formatPhone(value, countryCode, phoneMask) {
  if (!value) {
    return '';
  }
  let result = countryCode;
  if (!value.startsWith(countryCode)) {
    value = countryCode + value.replace('+', '');
  }
  const splitPhoneMask = phoneMask.split('');
  const splitValue = value.slice(countryCode.length).split('');
  result += ' ';
  if (splitValue.length === 0) {
    return result;
  }
  for (let i = 0; i < splitPhoneMask.length; i++) {
    if (splitValue.length === 0) {
      break;
    }
    if (splitPhoneMask[i] === '#') {
      result += splitValue[0] || '';
      splitValue.splice(0, 1);
    } else {
      result += splitPhoneMask[i];
    }
  }
  return result;
}
function otherDecimalSymbol(symbol) {
  return symbol === '.' ? ',' : '.';
}

/**
 * Selects the correct plural form to display.
 *
 * @param value the input number
 * @param args an array of three plural forms, e.g. ['год', 'года', 'лет']
 * @deprecated This implementation targets Russian.
 * Use https://angular.io/api/common/NgPlural for your implementations.
 */
function pluralize(value, [one, few, many]) {
  const ten = value % 10;
  const hundred = value % 100;
  // 1, 21, 101, 121, но не 11, 111, 211...
  if (ten === 1 && hundred !== 11) {
    return one;
  }
  // 2, 3, 4, 22, 33, 44, 152, 163, 174, но не 12, 13, 14, 112, 213, 314...
  if (ten >= 2 && ten <= 4 && (hundred < 10 || hundred >= 20)) {
    return few;
  }
  return many;
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-utils-format.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-utils-mask.js




/**
 * Used to finish a number with zeros to a given precision
 */
function tuiCreateAutoCorrectedNumberPipe(decimalLimit = 0, decimalSymbol = ',', nativeInput) {
  tuiAssert.assert(Number.isInteger(decimalLimit));
  tuiAssert.assert(decimalLimit >= 0);
  // Guess for which browser I need this :)
  let previousCaret = -1;
  const unlucky = !!nativeInput && isSafari(nativeInput);
  if (nativeInput && unlucky) {
    nativeInput.addEventListener('beforeinput', () => {
      previousCaret = nativeInput.selectionStart || 0;
    });
  }
  return (conformedValue, config) => {
    // remove these hacks after text mask library has changed
    if (nativeInput && unlucky && isNativeFocused(nativeInput)) {
      const caret = calculateSafariCaret(config.previousConformedValue, conformedValue, previousCaret);
      setTimeout(() => {
        nativeInput.setSelectionRange(caret, caret);
      });
    }
    if (nativeInput && nativeInput.ownerDocument !== getDocumentOrShadowRoot(nativeInput) && isNativeFocused(nativeInput) && config.currentCaretPosition) {
      const realCaretPosition = config.currentCaretPosition + calculateCaretGap(config.previousConformedValue, conformedValue);
      setTimeout(() => {
        nativeInput.setSelectionRange(realCaretPosition, realCaretPosition);
      });
    }
    if (conformedValue === '' || !decimalLimit) {
      return {
        value: conformedValue
      };
    }
    const withDecimalSymbol = addDecimalSymbolIfNeeded(conformedValue, decimalSymbol);
    const decimalPart = withDecimalSymbol.split(decimalSymbol)[1];
    const zeroPaddingSize = decimalLimit - decimalPart.length;
    return {
      value: withDecimalSymbol + '0'.repeat(zeroPaddingSize)
    };
  };
}
function addDecimalSymbolIfNeeded(value, decimalSymbol = ',') {
  return value.indexOf(decimalSymbol) === -1 ? value + decimalSymbol : value;
}
function calculateSafariCaret(previousValue = '', current, previousCaret, decimalSymbol = ',') {
  const tailRegex = new RegExp(`${decimalSymbol}.+`);
  const previousWithoutTail = previousValue.replace(tailRegex, '');
  const currentWithoutTail = current.replace(tailRegex, '');
  const pasteOrCutOperation = Math.abs(previousWithoutTail.length - currentWithoutTail.length) > 2;
  if (pasteOrCutOperation) {
    return current.length;
  }
  if (previousValue.length === current.length) {
    if (previousValue.indexOf(decimalSymbol) <= previousCaret) {
      return calculateChangedTailIndex(previousValue, current);
    }
    return previousWithoutTail === currentWithoutTail ? previousCaret - 1 : previousCaret + 1;
  }
  if (previousValue.length === 0) {
    return 1;
  }
  const changeLength = current.length - previousValue.length;
  return previousCaret + changeLength;
}
function calculateChangedTailIndex(previous, current) {
  for (let i = 0; i < current.length; i++) {
    if (previous[i] !== current[i]) {
      return current[i] === '0' ? i : i + 1;
    }
  }
  return current.length;
}
function calculateCaretGap(previousValue = '', current) {
  const pasteOrCutOperation = Math.abs(previousValue.length - current.length) > 2;
  if (pasteOrCutOperation) {
    return 0;
  }
  const wereSpaces = previousValue.split(CHAR_NO_BREAK_SPACE).length;
  const nowSpaces = current.split(CHAR_NO_BREAK_SPACE).length;
  return nowSpaces - wereSpaces;
}
const ASSERTION = 'Correction function must return single char or null';
function tuiCreateCorrectionMask(allowed, correctionHandler) {
  return rawValue => {
    const mask = rawValue.split('').reduce((result, char, index) => {
      const corrected = correctionHandler(char, index);
      tuiAssert.assert(corrected === null || corrected.length === 1, ASSERTION);
      if (!allowed.test(char) && !corrected) {
        return result;
      }
      if (allowed.test(char)) {
        return [...result, allowed];
      }
      if (corrected) {
        return [...result, corrected, MASK_CARET_TRAP];
      }
      return result;
    }, []);
    const lastIndex = mask.lastIndexOf(MASK_CARET_TRAP);
    const filtered = mask.filter((item, index) => item !== MASK_CARET_TRAP || index === lastIndex);
    return filtered.some(item => item !== allowed) ? [...filtered, allowed] : filtered;
  };
}
const NON_ZERO_DIGIT = /[1-9]/;
/**
 * Adaptation for {@link https://github.com/text-mask/text-mask/tree/master/addons#createnumbermask `createNumberMask`}
 */
function tuiCreateNumberMask({
  allowDecimal = false,
  decimalSymbol = ',',
  autoCorrectDecimalSymbol = true,
  decimalLimit = 2,
  requireDecimal = false,
  allowNegative = false,
  integerLimit = 0
} = {}) {
  taiga_ui_cdk_classes/* tuiAssert */.z.assert(Number.isInteger(decimalLimit));
  taiga_ui_cdk_classes/* tuiAssert */.z.assert(decimalLimit > 0);
  taiga_ui_cdk_classes/* tuiAssert */.z.assert(Number.isInteger(integerLimit));
  taiga_ui_cdk_classes/* tuiAssert */.z.assert(integerLimit >= 0);
  return (rawValue, {
    previousConformedValue
  }) => {
    if (previousConformedValue && requireDecimal) {
      const conformedWithoutSeparator = rawValue.split(taiga_ui_cdk_constants/* CHAR_NO_BREAK_SPACE */.f$).join('');
      const previousConformedValueWithoutDecimalSymbolAndSeparator = previousConformedValue.split(taiga_ui_cdk_constants/* CHAR_NO_BREAK_SPACE */.f$).join('').split(',').join('');
      // Forbid removal of decimal separator if decimal part is required
      if (conformedWithoutSeparator === previousConformedValueWithoutDecimalSymbolAndSeparator) {
        rawValue = previousConformedValue;
      }
    }
    const isNegative = (rawValue[0] === '-' || rawValue[0] === taiga_ui_cdk_constants/* CHAR_EN_DASH */.F) && allowNegative;
    if (isDecimalSymbol(rawValue, decimalSymbol, autoCorrectDecimalSymbol) && allowDecimal) {
      return ['0', decimalSymbol, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW];
    }
    if (isNegative) {
      rawValue = rawValue.substr(1);
    }
    const decimalIndex = getDecimalSymbolIndex(rawValue, decimalSymbol, autoCorrectDecimalSymbol);
    const hasDecimal = decimalIndex !== -1;
    const integer = hasDecimal ? rawValue.slice(0, decimalIndex) : rawValue;
    const thousandSeparators = integer.match(new RegExp(taiga_ui_cdk_constants/* CHAR_NO_BREAK_SPACE */.f$, 'g')) || [];
    const integerCapped = integerLimit ? integer.slice(0, integerLimit + thousandSeparators.length) : integer;
    const integerCappedClean = integerCapped.replace(taiga_ui_core_constants/* TUI_NON_DIGITS_REGEXP */.R3, '').replace(/^0+(?!\.|$)/, '0');
    const withSeparator = addThousandsSeparator(integerCappedClean);
    const mask = convertToMask(withSeparator);
    if (hasDecimal && allowDecimal || requireDecimal) {
      const fraction = hasDecimal ? convertToMask(rawValue.slice(decimalIndex + 1).replace(taiga_ui_core_constants/* TUI_NON_DIGITS_REGEXP */.R3, '')) : [];
      const fractionCapped = decimalLimit ? fraction.slice(0, decimalLimit) : fraction;
      if (rawValue[decimalIndex] !== otherDecimalSymbol(decimalSymbol)) {
        mask.push(taiga_ui_core_constants/* MASK_CARET_TRAP */.v1);
      }
      mask.push(decimalSymbol, taiga_ui_core_constants/* MASK_CARET_TRAP */.v1, ...fractionCapped);
      for (let i = 0; i < decimalLimit - fractionCapped.length; i++) {
        mask.push(taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW);
      }
    }
    if (isNegative) {
      if (mask.length === 0) {
        mask.push(taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW);
      }
      mask.unshift('-');
    }
    return preventLeadingZeroes(mask);
  };
}
function preventLeadingZeroes(mask) {
  const firstDigitIndex = mask.indexOf(taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW);
  if (firstDigitIndex !== -1 && mask[firstDigitIndex + 1] === taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW) {
    mask[firstDigitIndex] = NON_ZERO_DIGIT;
  }
  return mask;
}
function getDecimalSymbolIndex(str, decimalSymbol, autoCorrectDecimalSymbol) {
  if (!autoCorrectDecimalSymbol) {
    return str.lastIndexOf(decimalSymbol);
  }
  return Math.max(str.lastIndexOf(decimalSymbol), str.lastIndexOf(otherDecimalSymbol(decimalSymbol)));
}
function isDecimalSymbol(str, decimalSymbol, autoCorrectDecimalSymbol) {
  if (autoCorrectDecimalSymbol) {
    return /^[,.]$/.test(str);
  }
  return str === decimalSymbol;
}
function convertToMask(strNumber) {
  return strNumber.split('').map(char => taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW.test(char) ? taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW : char);
}
function addThousandsSeparator(strNumber) {
  return strNumber.length > 3 ? strNumber.replace(/\B(?=(\d{3})+(?!\d))/g, taiga_ui_cdk_constants/* CHAR_NO_BREAK_SPACE */.f$) : strNumber;
}
function maskedMoneyValueIsEmpty(value) {
  switch (value) {
    case '':
    case '-':
    case ',':
    case '-,':
      return true;
    default:
      return false;
  }
}
function maskedNumberStringToNumber(value) {
  return parseFloat(value.split(CHAR_NO_BREAK_SPACE).join('').split(',').join('.'));
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-utils-mask.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-button.js
var taiga_ui_core_components_button = __webpack_require__(2628);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-directives-value-accessor.js




let TuiValueAccessorDirective = /*#__PURE__*/(() => {
  let TuiValueAccessorDirective = class TuiValueAccessorDirective {};
  TuiValueAccessorDirective.ɵfac = function TuiValueAccessorDirective_Factory(t) {
    return new (t || TuiValueAccessorDirective)();
  };
  TuiValueAccessorDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiValueAccessorDirective,
    selectors: [["", "tuiValueAccessor", ""]],
    features: [core_js_["ɵɵProvidersFeature"]([TUI_VALUE_ACCESSOR_PROVIDER])]
  });
  return TuiValueAccessorDirective;
})();
let TuiValueAccessorModule = /*#__PURE__*/(() => {
  let TuiValueAccessorModule = class TuiValueAccessorModule {};
  TuiValueAccessorModule.ɵfac = function TuiValueAccessorModule_Factory(t) {
    return new (t || TuiValueAccessorModule)();
  };
  TuiValueAccessorModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiValueAccessorModule
  });
  TuiValueAccessorModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiValueAccessorModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiValueAccessorModule, {
    declarations: [TuiValueAccessorDirective],
    exports: [TuiValueAccessorDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-directives-value-accessor.js.map
// EXTERNAL MODULE: ./node_modules/angular2-text-mask/dist/angular2TextMask.js
var angular2TextMask = __webpack_require__(1120);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-input-count.js

















function TuiInputCountComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵelementStart"](1, "section", 2);
    core_js_["ɵɵelementStart"](2, "button", 3);
    core_js_["ɵɵlistener"]("mousedown", function TuiInputCountComponent_ng_container_2_Template_button_mousedown_2_listener($event) {
      core_js_["ɵɵrestoreView"](_r3);
      const ctx_r2 = core_js_["ɵɵnextContext"]();
      return ctx_r2.onButtonMouseDown($event, ctx_r2.plusButtonDisabled);
    })("click", function TuiInputCountComponent_ng_container_2_Template_button_click_2_listener() {
      core_js_["ɵɵrestoreView"](_r3);
      const ctx_r4 = core_js_["ɵɵnextContext"]();
      return ctx_r4.increaseValue();
    });
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementStart"](3, "button", 4);
    core_js_["ɵɵlistener"]("mousedown", function TuiInputCountComponent_ng_container_2_Template_button_mousedown_3_listener($event) {
      core_js_["ɵɵrestoreView"](_r3);
      const ctx_r5 = core_js_["ɵɵnextContext"]();
      return ctx_r5.onButtonMouseDown($event, ctx_r5.minusButtonDisabled);
    })("click", function TuiInputCountComponent_ng_container_2_Template_button_click_3_listener() {
      core_js_["ɵɵrestoreView"](_r3);
      const ctx_r6 = core_js_["ɵɵnextContext"]();
      return ctx_r6.decreaseValue();
    });
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const texts_r1 = ctx.ngIf;
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵproperty"]("title", texts_r1[0])("disabled", ctx_r0.plusButtonDisabled)("focusable", false);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("disabled", ctx_r0.minusButtonDisabled)("focusable", false)("title", texts_r1[1]);
  }
}
const taiga_ui_kit_components_input_count_c0 = ["*"];
var TuiInputCountComponent_1;
// @dynamic
let TuiInputCountComponent = TuiInputCountComponent_1 = class TuiInputCountComponent extends taiga_ui_cdk_abstract/* AbstractTuiControl */.M$ {
  constructor(control, changeDetectorRef, appearance, textfieldSize, minusTexts$, isMobile) {
    super(control, changeDetectorRef);
    this.appearance = appearance;
    this.textfieldSize = textfieldSize;
    this.minusTexts$ = minusTexts$;
    this.isMobile = isMobile;
    this.step = 1;
    this.min = 0;
    this.max = Infinity;
    this.hideButtons = false;
    this.postfix = '';
  }
  getMask(allowNegative) {
    return {
      mask: tuiCreateNumberMask({
        allowNegative
      }),
      guide: false
    };
  }
  get nativeFocusableElement() {
    return !this.primitiveTextfield || this.computedDisabled ? null : this.primitiveTextfield.nativeFocusableElement;
  }
  get size() {
    return this.textfieldSize.size;
  }
  get focused() {
    return (0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(this.nativeFocusableElement);
  }
  get hasButtons() {
    return !this.hideButtons && this.appearance !== "table" /* Table */;
  }

  get exampleText() {
    return String(this.min);
  }
  get computedValue() {
    return formatNumber(this.value);
  }
  get minusButtonDisabled() {
    return this.disabled || this.readOnly || (0,taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN)(this.value) && this.value <= this.min;
  }
  get plusButtonDisabled() {
    return this.disabled || this.readOnly || (0,taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN)(this.value) && this.value >= this.max;
  }
  onButtonMouseDown(event, disabled = false) {
    if (disabled || !this.nativeFocusableElement || this.isMobile) {
      return;
    }
    event.preventDefault();
    (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(this.nativeFocusableElement);
  }
  onFocused(focused) {
    if (!focused) {
      this.onBlur();
    }
    this.updateFocused(focused);
  }
  onHovered(hovered) {
    this.updateHovered(hovered);
  }
  onPressed(pressed) {
    this.updatePressed(pressed);
  }
  onValueChange() {
    const capped = this.capValue(this.nativeNumberValue);
    if (capped === null || isNaN(capped)) {
      return;
    }
    const newValue = formatNumber(capped);
    if (this.nativeValue !== newValue) {
      this.nativeValue = newValue;
    }
    this.updateValue(capped);
  }
  decreaseValue() {
    if (this.readOnly) {
      return;
    }
    const newValue = (this.value || 0) - this.step;
    this.safeUpdateValue(newValue);
  }
  increaseValue() {
    if (this.readOnly) {
      return;
    }
    const newValue = (this.value || 0) + this.step;
    this.safeUpdateValue(newValue);
  }
  onKeydown(event) {
    switch (event.key) {
      case 'ArrowUp':
      case 'Up':
        this.increaseValue();
        event.preventDefault();
        break;
      case 'ArrowDown':
      case 'Down':
        this.decreaseValue();
        event.preventDefault();
        break;
      default:
        break;
    }
  }
  getFallbackValue() {
    return 0;
  }
  get nativeNumberValue() {
    return parseInt(this.nativeValue.split(taiga_ui_cdk_constants/* CHAR_NO_BREAK_SPACE */.f$).join(''), 10);
  }
  get nativeValue() {
    return this.nativeFocusableElement ? this.nativeFocusableElement.value : '';
  }
  set nativeValue(value) {
    if (!this.nativeFocusableElement) {
      return;
    }
    this.nativeFocusableElement.value = value;
  }
  safeUpdateValue(newValue) {
    const value = (0,taiga_ui_cdk_utils_math/* clamp */.uZ)(newValue, this.min, this.max);
    this.updateValue(value);
    this.nativeValue = formatNumber(value);
  }
  capValue(value) {
    const capped = Math.min(value, this.max);
    return isNaN(capped) || capped < this.min ? null : capped;
  }
  onBlur() {
    const value = Math.max(this.nativeNumberValue || 0, this.min);
    const formattedValue = formatNumber(value);
    this.nativeValue = formattedValue;
    this.updateValue(value);
    if (this.primitiveTextfield) {
      this.primitiveTextfield.value = formattedValue;
    }
  }
};
TuiInputCountComponent.ɵfac = function TuiInputCountComponent_Factory(t) {
  return new (t || TuiInputCountComponent)(core_js_["ɵɵdirectiveInject"](fesm2015_forms.NgControl, 10), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_TEXTFIELD_APPEARANCE */.jt), core_js_["ɵɵdirectiveInject"](TUI_TEXTFIELD_SIZE), core_js_["ɵɵdirectiveInject"](TUI_PLUS_MINUS_TEXTS), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL));
};
TuiInputCountComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiInputCountComponent,
  selectors: [["tui-input-count"]],
  viewQuery: function TuiInputCountComponent_Query(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵviewQuery"](TuiPrimitiveTextfieldComponent, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.primitiveTextfield = _t.first);
    }
  },
  hostVars: 3,
  hostBindings: function TuiInputCountComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      core_js_["ɵɵattribute"]("data-tui-host-size", ctx.size);
      core_js_["ɵɵclassProp"]("_has-buttons", ctx.hasButtons);
    }
  },
  inputs: {
    step: "step",
    min: "min",
    max: "max",
    hideButtons: "hideButtons",
    postfix: "postfix"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ,
    useExisting: (0,core_js_.forwardRef)(() => TuiInputCountComponent_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]],
  ngContentSelectors: taiga_ui_kit_components_input_count_c0,
  decls: 4,
  vars: 15,
  consts: [["tuiValueAccessor", "", "tuiTextfieldAutocomplete", "off", "tuiTextfieldInputMode", "numeric", 1, "textfield", 3, "tuiTextfieldMaxLength", "pseudoFocused", "pseudoHovered", "pseudoPressed", "focusable", "nativeId", "postfix", "disabled", "readOnly", "textMask", "invalid", "value", "valueChange", "keydown", "focusedChange", "hoveredChange", "pressedChange"], [4, "ngIf"], [1, "buttons"], ["tuiIconButton", "", "type", "button", "automation-id", "tui-input-count__plus-button", "size", "s", "icon", "tuiIconPlus", "appearance", "textfield", 1, "button", "button_plus", 3, "title", "disabled", "focusable", "mousedown", "click"], ["tuiIconButton", "", "type", "button", "automation-id", "tui-input-count__minus-button", "size", "s", "icon", "tuiIconMinus", "appearance", "textfield", 1, "button", "button_minus", 3, "disabled", "focusable", "title", "mousedown", "click"]],
  template: function TuiInputCountComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"]();
      core_js_["ɵɵelementStart"](0, "tui-primitive-textfield", 0);
      core_js_["ɵɵlistener"]("valueChange", function TuiInputCountComponent_Template_tui_primitive_textfield_valueChange_0_listener() {
        return ctx.onValueChange();
      })("keydown", function TuiInputCountComponent_Template_tui_primitive_textfield_keydown_0_listener($event) {
        return ctx.onKeydown($event);
      })("focusedChange", function TuiInputCountComponent_Template_tui_primitive_textfield_focusedChange_0_listener($event) {
        return ctx.onFocused($event);
      })("hoveredChange", function TuiInputCountComponent_Template_tui_primitive_textfield_hoveredChange_0_listener($event) {
        return ctx.onHovered($event);
      })("pressedChange", function TuiInputCountComponent_Template_tui_primitive_textfield_pressedChange_0_listener($event) {
        return ctx.onPressed($event);
      });
      core_js_["ɵɵprojection"](1);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵtemplate"](2, TuiInputCountComponent_ng_container_2_Template, 4, 6, "ng-container", 1);
      core_js_["ɵɵpipe"](3, "async");
    }
    if (rf & 2) {
      core_js_["ɵɵproperty"]("tuiTextfieldMaxLength", 18)("pseudoFocused", ctx.pseudoFocused)("pseudoHovered", ctx.pseudoHovered)("pseudoPressed", ctx.pseudoPressed)("focusable", ctx.focusable)("nativeId", ctx.nativeId)("postfix", ctx.postfix)("disabled", ctx.disabled)("readOnly", ctx.readOnly)("textMask", ctx.getMask(ctx.min < 0))("invalid", ctx.computedInvalid)("value", ctx.computedValue);
      core_js_["ɵɵadvance"](2);
      core_js_["ɵɵproperty"]("ngIf", ctx.hasButtons && core_js_["ɵɵpipeBind1"](3, 13, ctx.minusTexts$));
    }
  },
  directives: [TuiPrimitiveTextfieldComponent, TuiValueAccessorDirective, TuiTextfieldAutocompleteDirective, TuiTextfieldInputModeDirective, TuiTextfieldMaxLengthDirective, angular2TextMask/* MaskedInputDirective */.hd, common_js_.NgIf, taiga_ui_core_components_button/* TuiButtonComponent */.v],
  pipes: [common_js_.AsyncPipe],
  styles: ["[_nghost-%COMP%]{font:var(--tui-font-text-s);display:flex;border-radius:var(--tui-radius-m);height:var(--tui-height-m);color:var(--tui-text-01)}._disabled[_nghost-%COMP%]{pointer-events:none}[data-tui-host-size='l'][_nghost-%COMP%]{font:var(--tui-font-text-m);height:var(--tui-height-l)}.textfield[_ngcontent-%COMP%]{position:relative;border-radius:inherit;width:100%}._has-buttons[_nghost-%COMP%]   .textfield[_ngcontent-%COMP%]{border-top-right-radius:0;border-bottom-right-radius:0}.buttons[_ngcontent-%COMP%]{display:flex;flex-direction:column;margin-left:2px;height:100%}.button.button[_ngcontent-%COMP%]{display:flex;width:calc(var(--tui-height-m) * .75);height:calc(50% - 1px)}.button.button_plus[_ngcontent-%COMP%]{margin-bottom:2px;border-radius:0 var(--tui-radius-m) 0 0}.button.button_minus[_ngcontent-%COMP%]{border-radius:0 0 var(--tui-radius-m)}[data-tui-host-size='l'][_nghost-%COMP%]   .button.button[_ngcontent-%COMP%]{width:calc(var(--tui-height-l) * .75)}"],
  changeDetection: 0
});
TuiInputCountComponent.ctorParameters = () => [{
  type: fesm2015_forms.NgControl,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.Self
  }, {
    type: core_js_.Inject,
    args: [fesm2015_forms.NgControl]
  }]
}, {
  type: core_js_.ChangeDetectorRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ChangeDetectorRef]
  }]
}, {
  type: String,
  decorators: [{
    type: core_js_.Inject,
    args: [taiga_ui_core_tokens/* TUI_TEXTFIELD_APPEARANCE */.jt]
  }]
}, {
  type: TuiTextfieldSizeDirective,
  decorators: [{
    type: core_js_.Inject,
    args: [TUI_TEXTFIELD_SIZE]
  }]
}, {
  type: Observable/* Observable */.y,
  decorators: [{
    type: core_js_.Inject,
    args: [TUI_PLUS_MINUS_TEXTS]
  }]
}, {
  type: Boolean,
  decorators: [{
    type: core_js_.Inject,
    args: [taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiInputCountComponent.prototype, "step", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiInputCountComponent.prototype, "min", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiInputCountComponent.prototype, "max", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiInputCountComponent.prototype, "hideButtons", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiInputCountComponent.prototype, "postfix", void 0);
(0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiInputCountComponent.prototype, "getMask", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)(TuiPrimitiveTextfieldComponent)], TuiInputCountComponent.prototype, "primitiveTextfield", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('attr.data-tui-host-size')], TuiInputCountComponent.prototype, "size", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._has-buttons')], TuiInputCountComponent.prototype, "hasButtons", null);
TuiInputCountComponent = TuiInputCountComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(fesm2015_forms.NgControl)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_TEXTFIELD_APPEARANCE */.jt)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TUI_TEXTFIELD_SIZE)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(TUI_PLUS_MINUS_TEXTS)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL))], TuiInputCountComponent);
let TuiInputCountModule = /*#__PURE__*/(() => {
  let TuiInputCountModule = class TuiInputCountModule {};
  TuiInputCountModule.ɵfac = function TuiInputCountModule_Factory(t) {
    return new (t || TuiInputCountModule)();
  };
  TuiInputCountModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiInputCountModule
  });
  TuiInputCountModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, angular2TextMask/* TextMaskModule */.QA, taiga_ui_core_components_button/* TuiButtonModule */.f, TuiPrimitiveTextfieldModule, TuiTextfieldControllerModule, TuiValueAccessorModule]]
  });
  return TuiInputCountModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiInputCountModule, {
    declarations: function () {
      return [TuiInputCountComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, angular2TextMask/* TextMaskModule */.QA, taiga_ui_core_components_button/* TuiButtonModule */.f, TuiPrimitiveTextfieldModule, TuiTextfieldControllerModule, TuiValueAccessorModule];
    },
    exports: function () {
      return [TuiInputCountComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-input-count.js.map
// EXTERNAL MODULE: consume shared module (default) @angular/router@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/router/fesm2015/router.js)
var router_js_ = __webpack_require__(2541);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/ReplaySubject.js + 4 modules
var ReplaySubject = __webpack_require__(2298);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/share.js + 1 modules
var share = __webpack_require__(8819);
;// CONCATENATED MODULE: ./node_modules/@ng-web-apis/mutation-observer/fesm2015/ng-web-apis-mutation-observer.js



/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */

const MUTATION_OBSERVER_INIT = new core_js_.InjectionToken('MutationObserver config');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} element
 * @param {?} attribute
 * @return {?}
 */
function booleanAttribute(element, attribute) {
  return element.getAttribute(attribute) !== null || undefined;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} __0
 * @return {?}
 */
function mutationObserverInitFactory({
  nativeElement
}) {
  /** @type {?} */
  const attributeFilterAttr = nativeElement.getAttribute('attributeFilter');
  /** @type {?} */
  const attributeFilter = attributeFilterAttr ? attributeFilterAttr.split(',').map(attr => attr.trim()) : undefined;
  return {
    attributeFilter,
    attributeOldValue: booleanAttribute(nativeElement, 'attributeOldValue'),
    attributes: booleanAttribute(nativeElement, 'attributes'),
    characterData: booleanAttribute(nativeElement, 'characterData'),
    characterDataOldValue: booleanAttribute(nativeElement, 'characterDataOldValue'),
    childList: booleanAttribute(nativeElement, 'childList'),
    subtree: booleanAttribute(nativeElement, 'subtree')
  };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0 = mutationObserverInitFactory;
// @dynamic
let MutationObserverDirective = /*#__PURE__*/(() => {
  class MutationObserverDirective extends MutationObserver {
    /**
     * @param {?} __0
     * @param {?} config
     * @param {?} _1
     * @param {?} _2
     * @param {?} _3
     * @param {?} _4
     * @param {?} _5
     * @param {?} _6
     * @param {?} _7
     */
    constructor({
      nativeElement
    }, config, _1, _2, _3, _4, _5, _6, _7) {
      super(records => {
        this.waMutationObserver.emit(records);
      });
      this.waMutationObserver = new core_js_.EventEmitter();
      this.observe(nativeElement, config);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
      this.disconnect();
    }
  }
  MutationObserverDirective.ɵfac = function MutationObserverDirective_Factory(t) {
    return new (t || MutationObserverDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](MUTATION_OBSERVER_INIT), core_js_["ɵɵinjectAttribute"]('attributeFilter'), core_js_["ɵɵinjectAttribute"]('attributeOldValue'), core_js_["ɵɵinjectAttribute"]('attributes'), core_js_["ɵɵinjectAttribute"]('characterData'), core_js_["ɵɵinjectAttribute"]('characterDataOldValue'), core_js_["ɵɵinjectAttribute"]('childList'), core_js_["ɵɵinjectAttribute"]('subtree'));
  };
  MutationObserverDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: MutationObserverDirective,
    selectors: [["", "waMutationObserver", ""]],
    outputs: {
      waMutationObserver: "waMutationObserver"
    },
    exportAs: ["MutationObserver"],
    features: [core_js_["ɵɵProvidersFeature"]([{
      provide: MUTATION_OBSERVER_INIT,
      deps: [core_js_.ElementRef],
      useFactory: ɵ0
    }]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  /** @nocollapse */
  return MutationObserverDirective;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @dynamic
let MutationObserverService = /*#__PURE__*/(() => {
  class MutationObserverService extends Observable/* Observable */.y {
    /**
     * @param {?} __0
     * @param {?} config
     */
    constructor({
      nativeElement
    }, config) {
      super(subscriber => {
        /** @type {?} */
        const observer = new MutationObserver(records => {
          subscriber.next(records);
        });
        observer.observe(nativeElement, config);
        return () => {
          observer.disconnect();
        };
      });
    }
  }
  MutationObserverService.ɵfac = function MutationObserverService_Factory(t) {
    return new (t || MutationObserverService)(core_js_["ɵɵinject"](core_js_.ElementRef), core_js_["ɵɵinject"](MUTATION_OBSERVER_INIT));
  };
  MutationObserverService.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: MutationObserverService,
    factory: MutationObserverService.ɵfac
  });
  /** @nocollapse */
  return MutationObserverService;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
let MutationObserverModule = /*#__PURE__*/(() => {
  class MutationObserverModule {}
  MutationObserverModule.ɵfac = function MutationObserverModule_Factory(t) {
    return new (t || MutationObserverModule)();
  };
  MutationObserverModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: MutationObserverModule
  });
  MutationObserverModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return MutationObserverModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](MutationObserverModule, {
    declarations: [MutationObserverDirective],
    exports: [MutationObserverDirective]
  });
})();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */



//# sourceMappingURL=ng-web-apis-mutation-observer.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-tabs.js




















const taiga_ui_kit_components_tabs_c0 = ["tuiTab", ""];
function TuiTabComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0);
  }
}
const taiga_ui_kit_components_tabs_c1 = ["*"];
function TuiTabsComponent_tui_underline_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-underline", 1);
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("element", ctx_r0.activeElement);
  }
}
function TuiTabsWithMoreComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0);
  }
}
function TuiTabsWithMoreComponent_ng_container_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0, 12);
  }
  if (rf & 2) {
    const item_r7 = core_js_["ɵɵnextContext"]().$implicit;
    core_js_["ɵɵproperty"]("ngTemplateOutlet", item_r7);
  }
}
function TuiTabsWithMoreComponent_ng_container_4_ng_template_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0);
  }
}
function TuiTabsWithMoreComponent_ng_container_4_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 13);
    core_js_["ɵɵtemplate"](1, TuiTabsWithMoreComponent_ng_container_4_ng_template_2_ng_container_1_Template, 1, 0, "ng-container", 14);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r14 = core_js_["ɵɵnextContext"]();
    const index_r8 = ctx_r14.index;
    const item_r7 = ctx_r14.$implicit;
    const ctx_r11 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵclassProp"]("overflown_hidden", index_r8 !== ctx_r11.activeItemIndex);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngTemplateOutlet", item_r7);
  }
}
function TuiTabsWithMoreComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiTabsWithMoreComponent_ng_container_4_ng_container_1_Template, 1, 1, "ng-container", 10);
    core_js_["ɵɵtemplate"](2, TuiTabsWithMoreComponent_ng_container_4_ng_template_2_Template, 2, 3, "ng-template", null, 11, core_js_["ɵɵtemplateRefExtractor"]);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const index_r8 = ctx.index;
    const _r10 = core_js_["ɵɵreference"](3);
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", index_r8 <= ctx_r1.lastVisibleIndex)("ngIfElse", _r10);
  }
}
function TuiTabsWithMoreComponent_ng_template_8_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵtext"](0);
    core_js_["ɵɵpipe"](1, "async");
    core_js_["ɵɵelement"](2, "tui-svg", 15);
  }
  if (rf & 2) {
    const ctx_r3 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵtextInterpolate1"](" ", core_js_["ɵɵpipeBind1"](1, 3, ctx_r3.moreWord$), " ");
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵclassProp"]("icon_rotated", ctx_r3.open);
  }
}
function TuiTabsWithMoreComponent_ng_template_10_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0, 12);
  }
  if (rf & 2) {
    const item_r17 = core_js_["ɵɵnextContext"]().$implicit;
    core_js_["ɵɵproperty"]("ngTemplateOutlet", item_r17);
  }
}
function TuiTabsWithMoreComponent_ng_template_10_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r22 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "div", 19);
    core_js_["ɵɵlistener"]("tui-tab-activate", function TuiTabsWithMoreComponent_ng_template_10_div_2_Template_div_tui_tab_activate_0_listener() {
      const restoredCtx = core_js_["ɵɵrestoreView"](_r22);
      const index_r18 = restoredCtx.index;
      const ctx_r21 = core_js_["ɵɵnextContext"](2);
      return ctx_r21.onClick(index_r18);
    });
    core_js_["ɵɵtemplate"](1, TuiTabsWithMoreComponent_ng_template_10_div_2_ng_container_1_Template, 1, 1, "ng-container", 20);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const index_r18 = ctx.index;
    const ctx_r16 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", index_r18 > ctx_r16.lastVisibleIndex && index_r18 !== ctx_r16.activeItemIndex);
  }
}
function TuiTabsWithMoreComponent_ng_template_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r24 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "div", 16, 17);
    core_js_["ɵɵlistener"]("keydown.arrowUp.prevent", function TuiTabsWithMoreComponent_ng_template_10_Template_div_keydown_arrowUp_prevent_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r24);
      const _r15 = core_js_["ɵɵreference"](1);
      const ctx_r23 = core_js_["ɵɵnextContext"]();
      return ctx_r23.onWrapperArrow($event.target, _r15, true);
    })("keydown.arrowDown.prevent", function TuiTabsWithMoreComponent_ng_template_10_Template_div_keydown_arrowDown_prevent_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r24);
      const _r15 = core_js_["ɵɵreference"](1);
      const ctx_r25 = core_js_["ɵɵnextContext"]();
      return ctx_r25.onWrapperArrow($event.target, _r15, false);
    });
    core_js_["ɵɵtemplate"](2, TuiTabsWithMoreComponent_ng_template_10_div_2_Template, 2, 1, "div", 18);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r5 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵproperty"]("ngForOf", ctx_r5.items);
  }
}
function TuiTabsWithMoreComponent_tui_underline_12_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-underline", 21);
  }
  if (rf & 2) {
    const ctx_r6 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("element", ctx_r6.activeElement);
  }
}
let TuiTabDirective = /*#__PURE__*/(() => {
  let TuiTabDirective = class TuiTabDirective {
    constructor(template) {
      this.template = template;
    }
  };
  TuiTabDirective.ɵfac = function TuiTabDirective_Factory(t) {
    return new (t || TuiTabDirective)(core_js_["ɵɵdirectiveInject"](core_js_.TemplateRef));
  };
  TuiTabDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiTabDirective,
    selectors: [["ng-template", "tuiTab", ""]]
  });
  TuiTabDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.TemplateRef))], TuiTabDirective);
  return TuiTabDirective;
})();
const TUI_TAB_ACTIVATE = 'tui-tab-activate';
const TUI_TAB_EVENT = new core_js_.InjectionToken('Stream of tab activation events');
const TUI_TAB_PROVIDERS = [taiga_ui_cdk_services/* TuiDestroyService */.a3, taiga_ui_cdk_services/* TuiFocusVisibleService */.ku, taiga_ui_core_services/* TuiRouterLinkActiveService */.Ok, {
  provide: TUI_TAB_EVENT,
  deps: [core_js_.ElementRef, common_js_.DOCUMENT, taiga_ui_core_services/* TuiRouterLinkActiveService */.Ok],
  useFactory: tabActiveFactory
}, taiga_ui_core_providers/* MODE_PROVIDER */.CV];
function tabActiveFactory({
  nativeElement
}, documentRef, routerLinkActiveService) {
  return (0,merge/* merge */.T)(routerLinkActiveService.pipe((0,filter/* filter */.h)(taiga_ui_cdk_utils_miscellaneous/* identity */.yR)), nativeElement.matches('button') ? (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, 'click') : empty/* EMPTY */.E).pipe((0,map/* map */.U)(() => nativeElement.dispatchEvent((0,taiga_ui_cdk_utils_dom/* tuiCustomEvent */.hO)(TUI_TAB_ACTIVATE, {
    bubbles: true
  }, documentRef))));
}
let TuiTabComponent = /*#__PURE__*/(() => {
  let TuiTabComponent = class TuiTabComponent {
    constructor(routerLinkActive, mode$, event$, mobileAware, isIos, isAndroid, focusVisible$) {
      this.routerLinkActive = routerLinkActive;
      this.mode$ = mode$;
      this.event$ = event$;
      this.focusVisible = false;
      this.isIos = mobileAware && isIos;
      this.isAndroid = mobileAware && isAndroid;
      focusVisible$.subscribe(visible => {
        this.focusVisible = visible;
      });
    }
    get isActive() {
      return !!this.routerLinkActive && this.routerLinkActive.isActive;
    }
  };
  TuiTabComponent.ɵfac = function TuiTabComponent_Factory(t) {
    return new (t || TuiTabComponent)(core_js_["ɵɵdirectiveInject"](router_js_.RouterLinkActive, 8), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_MODE */.Au), core_js_["ɵɵdirectiveInject"](TUI_TAB_EVENT), core_js_["ɵɵdirectiveInject"](TUI_MOBILE_AWARE), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_IOS */.FA), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_ANDROID */.XG), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiFocusVisibleService */.ku));
  };
  TuiTabComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiTabComponent,
    selectors: [["a", "tuiTab", "", 3, "routerLink", ""], ["a", "tuiTab", "", "routerLink", "", "routerLinkActive", ""], ["button", "tuiTab", ""]],
    hostAttrs: ["type", "button"],
    hostVars: 8,
    hostBindings: function TuiTabComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("$.data-mode.attr", function TuiTabComponent___data_mode_attr_HostBindingHandler() {
          return ctx.mode$;
        });
      }
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("_focus-visible", ctx.focusVisible)("_ios", ctx.isIos)("_android", ctx.isAndroid)("_active", ctx.isActive);
      }
    },
    features: [core_js_["ɵɵProvidersFeature"](TUI_TAB_PROVIDERS)],
    attrs: taiga_ui_kit_components_tabs_c0,
    ngContentSelectors: taiga_ui_kit_components_tabs_c1,
    decls: 4,
    vars: 3,
    consts: [[4, "ngIf"], [1, "highlight"]],
    template: function TuiTabComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵtemplate"](0, TuiTabComponent_ng_container_0_Template, 1, 0, "ng-container", 0);
        core_js_["ɵɵpipe"](1, "async");
        core_js_["ɵɵelementStart"](2, "span", 1);
        core_js_["ɵɵprojection"](3);
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngIf", core_js_["ɵɵpipeBind1"](1, 1, ctx.event$));
      }
    },
    directives: [common_js_.NgIf],
    pipes: [common_js_.AsyncPipe],
    styles: ["._underline[_nghost-%COMP%]:hover, ._underline   [_nghost-%COMP%]:hover{box-shadow:inset 0 -2px var(--tui-base-03)}[_nghost-%COMP%]{transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:0;border:0;background:0 0;font-size:inherit;line-height:inherit;position:relative;display:flex;flex-shrink:0;height:100%;box-sizing:border-box;justify-content:space-between;align-items:center;white-space:nowrap;cursor:pointer;outline:0;text-decoration:none;color:inherit;transition-property:color,box-shadow,opacity}[_nghost-%COMP%]:not(:last-child){margin-right:24px}[_nghost-%COMP%]:hover{color:var(--tui-text-01)}[_nghost-%COMP%]:disabled{opacity:var(--tui-disabled-opacity);pointer-events:none}[_nghost-%COMP%]:not([data-mode])._active{opacity:1;color:var(--tui-text-01);box-shadow:none}[data-mode=onDark][_nghost-%COMP%]{color:rgba(255,255,255,.72)}[data-mode=onDark]._active[_nghost-%COMP%], [data-mode=onDark][_nghost-%COMP%]:hover{color:#fff}[data-mode=onDark]._focus-visible[_nghost-%COMP%]   .highlight[_ngcontent-%COMP%]{background:var(--tui-clear-inverse);color:var(--tui-text-01)}[data-mode=onLight][_nghost-%COMP%]{color:rgba(0,0,0,.56)}[data-mode=onLight]._active[_nghost-%COMP%], [data-mode=onLight][_nghost-%COMP%]:hover{color:var(--tui-text-01)}[data-mode=onLight]._focus-visible[_nghost-%COMP%]   .highlight[_ngcontent-%COMP%]{background:var(--tui-text-01);color:#fff}._focus-visible[_nghost-%COMP%]   .highlight[_ngcontent-%COMP%]{background:var(--tui-selection)}._android[_nghost-%COMP%]{transition-property:opacity;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;height:48px;flex:1;flex-shrink:0;justify-content:center;margin:0;text-transform:uppercase;color:var(--tui-base-09);opacity:.5;font-size:14px;font-weight:500;letter-spacing:-.13px;font-family:-apple-system,BlinkMacSystemFont,Roboto,'Helvetica Neue',sans-serif}._android[_nghost-%COMP%]:hover{box-shadow:none}._android._active[_nghost-%COMP%]{opacity:1;color:var(--tui-base-09)}._android[_nghost-%COMP%]   .highlight[_ngcontent-%COMP%]{width:auto}._ios[_nghost-%COMP%]{height:28px;flex:1;flex-shrink:0;justify-content:center;margin:0;color:var(--tui-base-01);opacity:1;font-size:13px;font-weight:500;letter-spacing:-.08px;font-family:-apple-system,BlinkMacSystemFont,Roboto,'Helvetica Neue',sans-serif}._ios[_nghost-%COMP%]:hover{box-shadow:none}._ios._active[_nghost-%COMP%]{font-size:14px;font-weight:600;color:var(--tui-link)}._ios[_nghost-%COMP%]   .highlight[_ngcontent-%COMP%]{width:auto}.highlight[_ngcontent-%COMP%]{display:inline-flex;width:100%;align-items:center;justify-content:inherit}.highlight[_ngcontent-%COMP%]    >*{flex-shrink:0}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._ios')], TuiTabComponent.prototype, "isIos", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._android')], TuiTabComponent.prototype, "isAndroid", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._focus-visible')], TuiTabComponent.prototype, "focusVisible", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._active')], TuiTabComponent.prototype, "isActive", null);
  TuiTabComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(router_js_.RouterLinkActive)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_MODE */.Au)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(TUI_TAB_EVENT)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TUI_MOBILE_AWARE)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_IOS */.FA)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_ANDROID */.XG)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiFocusVisibleService */.ku))], TuiTabComponent);
  return TuiTabComponent;
})();
const TAB_ACTIVE_CLASS = '_active';
const TAB_MARGIN = 24;

// @dynamic
let TuiTabsComponent = /*#__PURE__*/(() => {
  let TuiTabsComponent = class TuiTabsComponent {
    constructor(elementRef, renderer, changeDetectorRef, resize$, isIos, isAndroid, mobileAware) {
      this.elementRef = elementRef;
      this.renderer = renderer;
      this.underline = true;
      this.activeItemIndexChange = new core_js_.EventEmitter();
      this.children = taiga_ui_cdk_constants/* EMPTY_QUERY */.Mm;
      this.activeItemIndex = 0;
      this.isIos = mobileAware && isIos;
      this.isAndroid = mobileAware && isAndroid;
      resize$.pipe((0,filter/* filter */.h)(() => this.underline)).subscribe(() => {
        changeDetectorRef.detectChanges();
      });
    }
    set activeItemIndexSetter(index) {
      this.activeItemIndex = index;
      this.scrollTo(this.tabs[index]);
    }
    get refresh$() {
      return (0,taiga_ui_cdk_observables/* itemsQueryListObservable */.Fp)(this.children).pipe((0,mapTo/* mapTo */.h)(true));
    }
    get tabs() {
      const tabs = Array.from(this.elementRef.nativeElement.querySelectorAll('[tuiTab]'));
      return tabs;
    }
    get activeElement() {
      return this.tabs[this.activeItemIndex] || null;
    }
    ngAfterViewChecked() {
      const {
        tabs,
        activeElement
      } = this;
      tabs.forEach(nativeElement => {
        this.renderer.removeClass(nativeElement, TAB_ACTIVE_CLASS);
        this.renderer.setAttribute(nativeElement, 'tabIndex', '-1');
      });
      if (activeElement) {
        this.renderer.addClass(activeElement, TAB_ACTIVE_CLASS);
        this.renderer.setAttribute(activeElement, 'tabIndex', '0');
      }
    }
    onActivate(element) {
      const index = this.tabs.findIndex(tab => tab === element);
      if (index === this.activeItemIndex) {
        return;
      }
      this.activeItemIndexSetter = index;
      this.activeItemIndexChange.emit(index);
    }
    onKeyDownArrow(current, step) {
      const {
        tabs
      } = this;
      (0,taiga_ui_cdk_utils_focus/* moveFocus */.pr)(tabs.indexOf(current), tabs, step);
    }
    scrollTo(element) {
      if (!element) {
        return;
      }
      const {
        offsetLeft,
        offsetWidth
      } = element;
      const {
        nativeElement
      } = this.elementRef;
      if (offsetLeft < nativeElement.scrollLeft) {
        nativeElement.scrollLeft = offsetLeft;
      }
      if (offsetLeft + offsetWidth > nativeElement.scrollLeft + nativeElement.offsetWidth) {
        nativeElement.scrollLeft = offsetLeft + offsetWidth - nativeElement.offsetWidth;
      }
    }
  };
  TuiTabsComponent.ɵfac = function TuiTabsComponent_Factory(t) {
    return new (t || TuiTabsComponent)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.Renderer2), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiResizeService */.tl), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_IOS */.FA), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_ANDROID */.XG), core_js_["ɵɵdirectiveInject"](TUI_MOBILE_AWARE));
  };
  TuiTabsComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiTabsComponent,
    selectors: [["tui-tabs"], ["nav", "tuiTabs", ""]],
    contentQueries: function TuiTabsComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        core_js_["ɵɵcontentQuery"](dirIndex, TuiTabComponent, 4);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.children = _t);
      }
    },
    hostAttrs: [1, "tui-zero-scrollbar"],
    hostVars: 6,
    hostBindings: function TuiTabsComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("tui-tab-activate.stop", function TuiTabsComponent_tui_tab_activate_stop_HostBindingHandler($event) {
          return ctx.onActivate($event.target);
        })("keydown.arrowRight.prevent", function TuiTabsComponent_keydown_arrowRight_prevent_HostBindingHandler($event) {
          return ctx.onKeyDownArrow($event.target, 1);
        })("keydown.arrowLeft.prevent", function TuiTabsComponent_keydown_arrowLeft_prevent_HostBindingHandler($event) {
          return ctx.onKeyDownArrow($event.target, -1);
        });
      }
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("_underline", ctx.underline)("_ios", ctx.isIos)("_android", ctx.isAndroid);
      }
    },
    inputs: {
      underline: "underline",
      activeItemIndexSetter: ["activeItemIndex", "activeItemIndexSetter"]
    },
    outputs: {
      activeItemIndexChange: "activeItemIndexChange"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3, taiga_ui_cdk_services/* TuiResizeService */.tl])],
    ngContentSelectors: taiga_ui_kit_components_tabs_c1,
    decls: 3,
    vars: 3,
    consts: [[3, "element", 4, "ngIf"], [3, "element"]],
    template: function TuiTabsComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵtemplate"](0, TuiTabsComponent_tui_underline_0_Template, 1, 1, "tui-underline", 0);
        core_js_["ɵɵpipe"](1, "async");
        core_js_["ɵɵprojection"](2);
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngIf", ctx.underline && core_js_["ɵɵpipeBind1"](1, 1, ctx.refresh$));
      }
    },
    directives: function () {
      return [common_js_.NgIf, TuiUnderlineComponent];
    },
    pipes: function () {
      return [common_js_.AsyncPipe];
    },
    styles: ["[_nghost-%COMP%]{font:var(--tui-font-text-m);position:relative;display:flex;height:var(--tui-height-l);color:var(--tui-text-02);box-shadow:inset 0 -1px var(--tui-base-03);overflow:auto}._android[_nghost-%COMP%]{height:auto}._ios[_nghost-%COMP%]{height:auto;border:2px solid transparent;border-radius:9px;background:var(--tui-link);box-shadow:none}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._underline'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTabsComponent.prototype, "underline", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('activeItemIndex')], TuiTabsComponent.prototype, "activeItemIndexSetter", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiTabsComponent.prototype, "activeItemIndexChange", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._ios')], TuiTabsComponent.prototype, "isIos", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._android')], TuiTabsComponent.prototype, "isAndroid", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChildren)((0,core_js_.forwardRef)(() => TuiTabComponent))], TuiTabsComponent.prototype, "children", void 0);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiTabsComponent.prototype, "refresh$", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)(`${TUI_TAB_ACTIVATE}.stop`, ['$event.target'])], TuiTabsComponent.prototype, "onActivate", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('keydown.arrowRight.prevent', ['$event.target', '1']), (0,core_js_.HostListener)('keydown.arrowLeft.prevent', ['$event.target', '-1'])], TuiTabsComponent.prototype, "onKeyDownArrow", null);
  TuiTabsComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.Renderer2)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiResizeService */.tl)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_IOS */.FA)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_ANDROID */.XG)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(TUI_MOBILE_AWARE))], TuiTabsComponent);
  return TuiTabsComponent;
})();
function tabsRefreshFactory(resize$, mutations$, destroy$, {
  body
}, {
  nativeElement
}, changeDetectorRef) {
  return (0,merge/* merge */.T)(resize$, mutations$.pipe((0,tap/* tap */.b)(() => changeDetectorRef.detectChanges()))).pipe(
  // Ignoring cases when host is detached from DOM
  (0,filter/* filter */.h)(() => body.contains(nativeElement)), (0,debounceTime/* debounceTime */.b)(0), (0,startWith/* startWith */.O)(null), (0,takeUntil/* takeUntil */.R)(destroy$));
}
// TODO: remove in ivy compilation
const MUTATION_CONFIG = {
  childList: true,
  subtree: true
};
const TABS_REFRESH = new core_js_.InjectionToken('Refresh stream');
const TABS_PROVIDERS = [taiga_ui_cdk_services/* TuiResizeService */.tl, taiga_ui_cdk_services/* TuiDestroyService */.a3, MutationObserverService, {
  provide: MUTATION_OBSERVER_INIT,
  useValue: MUTATION_CONFIG
}, {
  provide: TABS_REFRESH,
  deps: [taiga_ui_cdk_services/* TuiResizeService */.tl, MutationObserverService, taiga_ui_cdk_services/* TuiDestroyService */.a3, common_js_.DOCUMENT, core_js_.ElementRef, core_js_.ChangeDetectorRef],
  useFactory: tabsRefreshFactory
}];

// @dynamic
let TuiTabsWithMoreComponent = /*#__PURE__*/(() => {
  let TuiTabsWithMoreComponent = class TuiTabsWithMoreComponent {
    constructor(refresh$, elementRef, changeDetectorRef, moreWord$) {
      this.refresh$ = refresh$;
      this.elementRef = elementRef;
      this.changeDetectorRef = changeDetectorRef;
      this.moreWord$ = moreWord$;
      this.moreContent = '';
      this.underline = true;
      this.activeItemIndex = 0;
      this.itemsLimit = Infinity;
      this.activeItemIndexChange = new core_js_.EventEmitter();
      this.items = taiga_ui_cdk_constants/* EMPTY_QUERY */.Mm;
      this.open = false;
      this.maxIndex = Infinity;
    }
    get tabs() {
      return Array.from(this.elementRef.nativeElement.querySelectorAll('[tuiTab]'));
    }
    get activeElement() {
      return this.tabs[this.activeItemIndex] || null;
    }
    get isMoreVisible() {
      return this.lastVisibleIndex < this.items.length - 1;
    }
    get isMoreFocusable() {
      return !!this.moreButton && (0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(this.moreButton.nativeElement);
    }
    get lastVisibleIndex() {
      if (this.itemsLimit + 1 >= this.items.length) {
        return this.maxIndex;
      }
      const offset = this.itemsLimit - 1 > this.activeItemIndex ? 1 : 2;
      return Math.min(this.itemsLimit - offset, this.maxIndex);
    }
    ngAfterViewInit() {
      this.refresh$.pipe((0,map/* map */.U)(() => this.getMaxIndex()), (0,filter/* filter */.h)(maxIndex => this.maxIndex !== maxIndex)).subscribe(maxIndex => {
        this.maxIndex = maxIndex;
        this.changeDetectorRef.detectChanges();
      });
    }
    onActiveItemIndexChange(activeItemIndex) {
      this.updateActiveItemIndex(activeItemIndex);
    }
    onClick(index) {
      this.open = false;
      this.focusMore();
      this.updateActiveItemIndex(index);
    }
    onArrowRight(element) {
      if ((0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(element)) {
        this.focusMore();
      }
    }
    onArrowLeft() {
      const {
        tabs
      } = this;
      let index = tabs.length - 2;
      while (index >= 0) {
        (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(tabs[index]);
        if ((0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(tabs[index])) {
          return;
        }
        index--;
      }
    }
    onWrapperArrow(button, wrapper, prev) {
      const target = (0,taiga_ui_cdk_utils_focus/* getClosestFocusable */.kA)(button, prev, wrapper);
      if (target) {
        (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(target);
      }
    }
    focusMore() {
      if (this.moreButton) {
        (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(this.moreButton.nativeElement);
      }
    }
    getMaxIndex() {
      const {
        tabs,
        activeItemIndex
      } = this;
      if (tabs.length < 2) {
        return 0;
      }
      const {
        clientWidth
      } = this.elementRef.nativeElement;
      const activeWidth = tabs[activeItemIndex] ? tabs[activeItemIndex].scrollWidth : 0;
      const moreWidth = tabs[tabs.length - 1].scrollWidth;
      let maxIndex = tabs.length - 2;
      let total = tabs.reduce((acc, tab) => acc + tab.scrollWidth, 0) + maxIndex * TAB_MARGIN - moreWidth;
      if (total <= clientWidth) {
        return Infinity;
      }
      while (maxIndex) {
        total -= tabs[maxIndex].scrollWidth + TAB_MARGIN;
        maxIndex--;
        const activeOffset = activeItemIndex > maxIndex ? activeWidth + TAB_MARGIN : 0;
        if (total + activeOffset + moreWidth + TAB_MARGIN < clientWidth) {
          return maxIndex;
        }
      }
      return 0;
    }
    updateActiveItemIndex(activeItemIndex) {
      if (this.activeItemIndex === activeItemIndex) {
        return;
      }
      this.activeItemIndex = activeItemIndex;
      this.activeItemIndexChange.emit(activeItemIndex);
      this.maxIndex = this.getMaxIndex();
    }
  };
  TuiTabsWithMoreComponent.ɵfac = function TuiTabsWithMoreComponent_Factory(t) {
    return new (t || TuiTabsWithMoreComponent)(core_js_["ɵɵdirectiveInject"](TABS_REFRESH), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](TUI_MORE_WORD));
  };
  TuiTabsWithMoreComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiTabsWithMoreComponent,
    selectors: [["tui-tabs-with-more"], ["nav", "tuiTabsWithMore", ""]],
    contentQueries: function TuiTabsWithMoreComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        core_js_["ɵɵcontentQuery"](dirIndex, TuiTabDirective, 4, core_js_.TemplateRef);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.items = _t);
      }
    },
    viewQuery: function TuiTabsWithMoreComponent_Query(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵviewQuery"](TuiTabComponent, 5, core_js_.ElementRef);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.moreButton = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function TuiTabsWithMoreComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("_underline", ctx.underline);
      }
    },
    inputs: {
      moreContent: "moreContent",
      underline: "underline",
      activeItemIndex: "activeItemIndex",
      itemsLimit: "itemsLimit"
    },
    outputs: {
      activeItemIndexChange: "activeItemIndexChange"
    },
    features: [core_js_["ɵɵProvidersFeature"](TABS_PROVIDERS)],
    decls: 13,
    vars: 15,
    consts: [[4, "ngIf"], [1, "wrapper"], [1, "tabs", 3, "underline", "activeItemIndex", "activeItemIndexChange", "keydown.arrowRight"], [4, "ngFor", "ngForOf"], [1, "more_wrapper", 3, "content", "open", "openChange"], ["tuiTab", "", 1, "more", 3, "tuiFocusable", "keydown.arrowLeft.prevent"], ["polymorpheus-outlet", "", 3, "content"], ["more", ""], ["dropdown", ""], [3, "element", 4, "ngIf"], [3, "ngTemplateOutlet", 4, "ngIf", "ngIfElse"], ["hidden", ""], [3, "ngTemplateOutlet"], [1, "overflown"], [4, "ngTemplateOutlet"], ["src", "tuiIconChevronDown", 1, "icon"], [1, "dropdown", 3, "keydown.arrowUp.prevent", "keydown.arrowDown.prevent"], ["element", ""], [3, "tui-tab-activate", 4, "ngFor", "ngForOf"], [3, "tui-tab-activate"], [3, "ngTemplateOutlet", 4, "ngIf"], [3, "element"]],
    template: function TuiTabsWithMoreComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵtemplate"](0, TuiTabsWithMoreComponent_ng_container_0_Template, 1, 0, "ng-container", 0);
        core_js_["ɵɵpipe"](1, "async");
        core_js_["ɵɵelementStart"](2, "div", 1);
        core_js_["ɵɵelementStart"](3, "tui-tabs", 2);
        core_js_["ɵɵlistener"]("activeItemIndexChange", function TuiTabsWithMoreComponent_Template_tui_tabs_activeItemIndexChange_3_listener($event) {
          return ctx.onActiveItemIndexChange($event);
        })("keydown.arrowRight", function TuiTabsWithMoreComponent_Template_tui_tabs_keydown_arrowRight_3_listener($event) {
          return ctx.onArrowRight($event.target);
        });
        core_js_["ɵɵtemplate"](4, TuiTabsWithMoreComponent_ng_container_4_Template, 4, 2, "ng-container", 3);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](5, "tui-hosted-dropdown", 4);
        core_js_["ɵɵlistener"]("openChange", function TuiTabsWithMoreComponent_Template_tui_hosted_dropdown_openChange_5_listener($event) {
          return ctx.open = $event;
        });
        core_js_["ɵɵelementStart"](6, "button", 5);
        core_js_["ɵɵlistener"]("keydown.arrowLeft.prevent", function TuiTabsWithMoreComponent_Template_button_keydown_arrowLeft_prevent_6_listener() {
          return ctx.onArrowLeft();
        });
        core_js_["ɵɵelement"](7, "span", 6);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](8, TuiTabsWithMoreComponent_ng_template_8_Template, 3, 5, "ng-template", null, 7, core_js_["ɵɵtemplateRefExtractor"]);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](10, TuiTabsWithMoreComponent_ng_template_10_Template, 3, 1, "ng-template", null, 8, core_js_["ɵɵtemplateRefExtractor"]);
        core_js_["ɵɵtemplate"](12, TuiTabsWithMoreComponent_tui_underline_12_Template, 1, 1, "tui-underline", 9);
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        const _r2 = core_js_["ɵɵreference"](9);
        const _r4 = core_js_["ɵɵreference"](11);
        core_js_["ɵɵproperty"]("ngIf", core_js_["ɵɵpipeBind1"](1, 13, ctx.items.changes));
        core_js_["ɵɵadvance"](3);
        core_js_["ɵɵproperty"]("underline", false)("activeItemIndex", ctx.activeItemIndex);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngForOf", ctx.items);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵclassProp"]("overflown_hidden", !ctx.isMoreVisible);
        core_js_["ɵɵproperty"]("content", _r4)("open", ctx.open);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵclassProp"]("_active", ctx.open);
        core_js_["ɵɵproperty"]("tuiFocusable", ctx.isMoreFocusable);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("content", ctx.moreContent || _r2);
        core_js_["ɵɵadvance"](5);
        core_js_["ɵɵproperty"]("ngIf", ctx.underline);
      }
    },
    directives: function () {
      return [common_js_.NgIf, TuiTabsComponent, common_js_.NgForOf, TuiHostedDropdownComponent, TuiTabComponent, TuiFocusableDirective, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, common_js_.NgTemplateOutlet, taiga_ui_core_components_svg/* TuiSvgComponent */.P, TuiUnderlineComponent];
    },
    pipes: function () {
      return [common_js_.AsyncPipe];
    },
    styles: ["[_nghost-%COMP%]{font:var(--tui-font-text-m);position:relative;display:flex;height:var(--tui-height-l);box-sizing:border-box;color:var(--tui-text-02);box-shadow:inset 0 -1px var(--tui-base-03);overflow:hidden}.wrapper[_ngcontent-%COMP%]{position:relative;display:flex}.tabs[_ngcontent-%COMP%]{height:inherit;font-size:inherit;font-weight:inherit;overflow:visible;box-shadow:none;color:inherit}.overflown[_ngcontent-%COMP%]{margin-right:24px}.overflown_hidden[_ngcontent-%COMP%]{margin:0;width:0;max-width:0;overflow:hidden;visibility:hidden}.more_wrapper[_ngcontent-%COMP%]{height:100%}.icon[_ngcontent-%COMP%]{transition-property:transform;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;margin-right:-4px;vertical-align:bottom}.icon_rotated[_ngcontent-%COMP%]{transform:rotate(180deg)}.dropdown[_ngcontent-%COMP%]{padding:8px 0}.dropdown[_ngcontent-%COMP%]     [tuiTab]{width:100%;height:44px;justify-content:flex-start;margin:0;padding:0 16px;color:var(--tui-text-02)}.dropdown[_ngcontent-%COMP%]     [tuiTab]:before{display:none}.dropdown[_ngcontent-%COMP%]     [tuiTab]._active, .dropdown[_ngcontent-%COMP%]     [tuiTab]:focus, .dropdown[_ngcontent-%COMP%]     [tuiTab]:hover{box-shadow:none;color:var(--tui-base-08);background:var(--tui-base-02)}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTabsWithMoreComponent.prototype, "moreContent", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._underline'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTabsWithMoreComponent.prototype, "underline", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTabsWithMoreComponent.prototype, "activeItemIndex", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTabsWithMoreComponent.prototype, "itemsLimit", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiTabsWithMoreComponent.prototype, "activeItemIndexChange", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChildren)(TuiTabDirective, {
    read: core_js_.TemplateRef
  })], TuiTabsWithMoreComponent.prototype, "items", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)(TuiTabComponent, {
    read: core_js_.ElementRef
  })], TuiTabsWithMoreComponent.prototype, "moreButton", void 0);
  TuiTabsWithMoreComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TABS_REFRESH)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TUI_MORE_WORD))], TuiTabsWithMoreComponent);
  return TuiTabsWithMoreComponent;
})();
let TuiUnderlineComponent = /*#__PURE__*/(() => {
  let TuiUnderlineComponent = class TuiUnderlineComponent {
    constructor({
      nativeElement
    }, ngZone, animationFrame$, mobileAware, ios, android, mode$) {
      this.ngZone = ngZone;
      this.animationFrame$ = animationFrame$;
      this.mobileAware = mobileAware;
      this.ios = ios;
      this.android = android;
      this.mode$ = mode$;
      this.isIos = this.mobileAware && this.ios;
      this.isAndroid = this.mobileAware && this.android;
      this.element$ = new ReplaySubject/* ReplaySubject */.t(1);
      this.refresh$ = this.element$.pipe((0,switchMap/* switchMap */.w)(element => element ? this.animationFrame$.pipe((0,mapTo/* mapTo */.h)(element), (0,taiga_ui_cdk_observables/* tuiZonefree */.fL)(this.ngZone)) : (0,of.of)(null)), (0,share/* share */.B)());
      this.transition$ = asCallable(this.element$.pipe((0,map/* map */.U)(element => element && 'all'), (0,debounceTime/* debounceTime */.b)(50)));
      this.transform$ = asCallable(this.refresh$.pipe((0,map/* map */.U)(element => element ? `translate3d(${px(element.offsetLeft)}, 0, 0)` : null)));
      this.width$ = asCallable(this.refresh$.pipe((0,map/* map */.U)(element => element ? element.clientWidth : 0)));
      nativeElement['$.style.transitionProperty'] = this.transition$;
      nativeElement['$.style.transform'] = this.transform$;
      nativeElement['$.style.width.px'] = this.width$;
    }
    set element(element) {
      this.element$.next(element);
    }
  };
  TuiUnderlineComponent.ɵfac = function TuiUnderlineComponent_Factory(t) {
    return new (t || TuiUnderlineComponent)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.NgZone), core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* ANIMATION_FRAME */.L1), core_js_["ɵɵdirectiveInject"](TUI_MOBILE_AWARE), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_IOS */.FA), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_ANDROID */.XG), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_MODE */.Au));
  };
  TuiUnderlineComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiUnderlineComponent,
    selectors: [["tui-underline"]],
    hostVars: 4,
    hostBindings: function TuiUnderlineComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("$.data-mode.attr", function TuiUnderlineComponent___data_mode_attr_HostBindingHandler() {
          return ctx.mode$;
        })("$.style.transitionProperty", function TuiUnderlineComponent___style_transitionProperty_HostBindingHandler() {
          return ctx.transition$();
        })("$.style.transform", function TuiUnderlineComponent___style_transform_HostBindingHandler() {
          return ctx.transform$();
        })("$.style.width.px", function TuiUnderlineComponent___style_width_px_HostBindingHandler() {
          return ctx.width$();
        });
      }
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("_ios", ctx.isIos)("_android", ctx.isAndroid);
      }
    },
    inputs: {
      element: "element"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_core_providers/* MODE_PROVIDER */.CV])],
    decls: 0,
    vars: 0,
    template: function TuiUnderlineComponent_Template(rf, ctx) {},
    styles: ["[_nghost-%COMP%]{transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;position:absolute;left:0;height:100%;color:var(--tui-primary);transform:scale(0);box-shadow:inset 0 -3px 0 -1px;transition-property:none;pointer-events:none}._ios[_nghost-%COMP%]{border-radius:7px;background:var(--tui-base-01);box-shadow:0 3px 1px rgba(0,0,0,.04),0 3px 8px rgba(0,0,0,.12)}._android[_nghost-%COMP%]{box-shadow:inset 0 -3px var(--tui-link)}[data-mode=onDark][_nghost-%COMP%]{color:var(--tui-text-01-night)}[data-mode=onLight][_nghost-%COMP%]{color:var(--tui-text-01)}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiUnderlineComponent.prototype, "element", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._ios')], TuiUnderlineComponent.prototype, "isIos", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._android')], TuiUnderlineComponent.prototype, "isAndroid", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('$.style.transitionProperty')], TuiUnderlineComponent.prototype, "transition$", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('$.style.transform')], TuiUnderlineComponent.prototype, "transform$", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('$.style.width.px')], TuiUnderlineComponent.prototype, "width$", void 0);
  TuiUnderlineComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.NgZone)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(ng_web_apis_common/* ANIMATION_FRAME */.L1)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TUI_MOBILE_AWARE)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_IOS */.FA)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_ANDROID */.XG)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_MODE */.Au))], TuiUnderlineComponent);
  return TuiUnderlineComponent;
})();
let TuiTabsModule = /*#__PURE__*/(() => {
  let TuiTabsModule = class TuiTabsModule {};
  TuiTabsModule.ɵfac = function TuiTabsModule_Factory(t) {
    return new (t || TuiTabsModule)();
  };
  TuiTabsModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiTabsModule
  });
  TuiTabsModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, TuiHostedDropdownModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiFocusableModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq]]
  });
  return TuiTabsModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiTabsModule, {
    declarations: function () {
      return [TuiTabsWithMoreComponent, TuiTabsComponent, TuiTabComponent, TuiUnderlineComponent, TuiTabDirective];
    },
    imports: function () {
      return [common_js_.CommonModule, TuiHostedDropdownModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiFocusableModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq];
    },
    exports: function () {
      return [TuiTabsWithMoreComponent, TuiTabsComponent, TuiTabComponent, TuiTabDirective];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-tabs.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-utils-format.js
/**
 * Converts a string to an HSL color
 * @param value string to convert
 * @return HSL color string
 */
// @bad TODO: convert stringHashToHsl to stringHashToRgb
function stringHashToHsl(value) {
  if (value === '') {
    return '';
  }
  let hash = 0;
  for (let i = 0; i < value.length; i++) {
    /* tslint:disable: no-bitwise */
    hash = value.charCodeAt(i) + ((hash << 5) - hash);
    hash = hash & hash;
    /* tslint:enable: no-bitwise */
  }

  const hue = hash % 360;
  const saturation = 60 + hash % 5;
  const lightness = 80 + hash % 5;
  return `hsl(${hue},${saturation}%,${lightness}%)`;
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-utils-format.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-tag.js
















const taiga_ui_kit_components_tag_c0 = ["input"];
function TuiTagComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "div", 6);
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("content", ctx_r0.leftContent);
  }
}
function TuiTagComponent_tui_loader_4_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-loader", 7);
  }
  if (rf & 2) {
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("inheritColor", true)("size", ctx_r1.loaderSize);
  }
}
function TuiTagComponent_tui_svg_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "tui-svg", 8);
    core_js_["ɵɵlistener"]("click", function TuiTagComponent_tui_svg_5_Template_tui_svg_click_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r5);
      const ctx_r4 = core_js_["ɵɵnextContext"]();
      return ctx_r4.remove($event);
    });
    core_js_["ɵɵelementEnd"]();
  }
}
function TuiTagComponent_input_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "input", 9, 10);
    core_js_["ɵɵlistener"]("ngModelChange", function TuiTagComponent_input_6_Template_input_ngModelChange_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r8);
      const ctx_r7 = core_js_["ɵɵnextContext"]();
      return ctx_r7.onInput($event);
    })("blur", function TuiTagComponent_input_6_Template_input_blur_0_listener() {
      core_js_["ɵɵrestoreView"](_r8);
      const ctx_r9 = core_js_["ɵɵnextContext"]();
      return ctx_r9.onBlur();
    })("keydown", function TuiTagComponent_input_6_Template_input_keydown_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r8);
      const ctx_r10 = core_js_["ɵɵnextContext"]();
      return ctx_r10.onKeyDown($event);
    });
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r3 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("ngModel", ctx_r3.editedText);
    core_js_["ɵɵattribute"]("maxLength", ctx_r3.maxLength);
  }
}
const ALLOWED_SPACE_REGEXP = new RegExp(`\,|[\\s]`);
let TuiTagComponent = /*#__PURE__*/(() => {
  let TuiTagComponent = class TuiTagComponent {
    constructor(elementRef, mode$) {
      this.elementRef = elementRef;
      this.mode$ = mode$;
      // TODO: Possibly implement standard focus mechanisms and outline
      this.value = '';
      this.editable = false;
      this.allowSpaces = true;
      this.maxLength = null;
      this.size = 'm';
      this.showLoader = false;
      this.status = "default" /* Default */;
      this.hoverable = false;
      this.removable = false;
      this.disabled = false;
      this.autoColor = false;
      this.leftContent = null;
      this.edited = new core_js_.EventEmitter();
      this.editing = false;
      this.editedText = null;
    }
    set input(input) {
      if (input) {
        (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(input.nativeElement);
      }
    }
    get backgroundColor() {
      return this.autoColor ? stringHashToHsl(this.value) : null;
    }
    get canRemove() {
      return this.removable && !this.disabled && !this.showLoader;
    }
    get displayText() {
      return this.editedText === null ? this.value : this.editedText;
    }
    get loaderSize() {
      return (0,taiga_ui_core_utils_miscellaneous/* sizeBigger */.Bb)(this.size) ? 's' : 'xs';
    }
    get hasIcon() {
      return this.showLoader || this.removable;
    }
    edit(event) {
      if (!this.canEdit) {
        return;
      }
      event.preventDefault();
      this.editing = true;
      this.editedText = this.value;
    }
    remove(event) {
      if (!this.canRemove) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      this.edited.emit('');
    }
    onInput(value) {
      const newTags = this.allowSpaces ? value.split(',') : value.split(ALLOWED_SPACE_REGEXP);
      if (newTags.length > 1) {
        this.save(newTags.toString());
        return;
      }
      this.editedText = value;
    }
    onKeyDown(event) {
      event.stopPropagation();
      switch (event.key.toLowerCase()) {
        case 'enter':
          event.preventDefault();
          this.save(this.editedText || '');
          break;
        case 'escape':
        case 'esc':
          event.preventDefault();
          this.stopEditing();
          (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(this.elementRef.nativeElement);
          break;
        default:
          break;
      }
    }
    onBlur() {
      if (this.editedText !== null) {
        this.save(this.editedText);
      }
    }
    get canEdit() {
      return this.editable && !this.disabled && !this.showLoader;
    }
    stopEditing() {
      this.editing = false;
      this.editedText = null;
    }
    save(value) {
      this.stopEditing();
      this.edited.emit(value.trim());
    }
  };
  TuiTagComponent.ɵfac = function TuiTagComponent_Factory(t) {
    return new (t || TuiTagComponent)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_MODE */.Au));
  };
  TuiTagComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiTagComponent,
    selectors: [["tui-tag"], ["a", "tuiTag", ""]],
    viewQuery: function TuiTagComponent_Query(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵviewQuery"](taiga_ui_kit_components_tag_c0, 5, core_js_.ElementRef);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.input = _t.first);
      }
    },
    hostVars: 12,
    hostBindings: function TuiTagComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("$.data-mode.attr", function TuiTagComponent___data_mode_attr_HostBindingHandler() {
          return ctx.mode$;
        })("keydown.enter", function TuiTagComponent_keydown_enter_HostBindingHandler($event) {
          return ctx.edit($event);
        })("keydown.delete", function TuiTagComponent_keydown_delete_HostBindingHandler($event) {
          return ctx.remove($event);
        })("keydown.backspace", function TuiTagComponent_keydown_backspace_HostBindingHandler($event) {
          return ctx.remove($event);
        });
      }
      if (rf & 2) {
        core_js_["ɵɵattribute"]("data-tui-host-size", ctx.size)("data-tui-host-status", ctx.status);
        core_js_["ɵɵclassProp"]("_hoverable", ctx.hoverable)("_disabled", ctx.disabled)("_autocolor", ctx.autoColor)("_editing", ctx.editing)("_has-icon", ctx.hasIcon);
      }
    },
    inputs: {
      value: "value",
      editable: "editable",
      allowSpaces: "allowSpaces",
      maxLength: "maxLength",
      size: "size",
      showLoader: "showLoader",
      status: "status",
      hoverable: "hoverable",
      removable: "removable",
      disabled: "disabled",
      autoColor: "autoColor",
      leftContent: "leftContent"
    },
    outputs: {
      edited: "edited"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_core_providers/* MODE_PROVIDER */.CV])],
    decls: 7,
    vars: 7,
    consts: [[1, "tag", 3, "dblclick"], ["polymorpheus-outlet", "", "class", "left-content", 3, "content", 4, "ngIf"], ["automation-id", "tui-tag__text", 1, "text"], ["class", "icon icon_loader", 3, "inheritColor", "size", 4, "ngIf"], ["tuiPreventDefault", "mousedown", "automation-id", "tui-tag__remove", "class", "icon", "src", "tuiIconCloseLarge", 3, "click", 4, "ngIf"], ["automation-id", "tui-tag__edit", "class", "edit", "type", "text", 3, "ngModel", "ngModelChange", "blur", "keydown", 4, "ngIf"], ["polymorpheus-outlet", "", 1, "left-content", 3, "content"], [1, "icon", "icon_loader", 3, "inheritColor", "size"], ["tuiPreventDefault", "mousedown", "automation-id", "tui-tag__remove", "src", "tuiIconCloseLarge", 1, "icon", 3, "click"], ["automation-id", "tui-tag__edit", "type", "text", 1, "edit", 3, "ngModel", "ngModelChange", "blur", "keydown"], ["input", ""]],
    template: function TuiTagComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵelementStart"](0, "div", 0);
        core_js_["ɵɵlistener"]("dblclick", function TuiTagComponent_Template_div_dblclick_0_listener($event) {
          return ctx.edit($event);
        });
        core_js_["ɵɵtemplate"](1, TuiTagComponent_div_1_Template, 1, 1, "div", 1);
        core_js_["ɵɵelementStart"](2, "span", 2);
        core_js_["ɵɵtext"](3);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](4, TuiTagComponent_tui_loader_4_Template, 1, 2, "tui-loader", 3);
        core_js_["ɵɵtemplate"](5, TuiTagComponent_tui_svg_5_Template, 1, 0, "tui-svg", 4);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](6, TuiTagComponent_input_6_Template, 2, 2, "input", 5);
      }
      if (rf & 2) {
        core_js_["ɵɵstyleProp"]("background-color", ctx.backgroundColor);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.leftContent);
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵtextInterpolate"](ctx.displayText);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.showLoader);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.canRemove);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.editing);
      }
    },
    directives: [common_js_.NgIf, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, taiga_ui_core_components_loader/* TuiLoaderComponent */.kM, taiga_ui_core_components_svg/* TuiSvgComponent */.P, TuiPreventDefaultDirective, fesm2015_forms.DefaultValueAccessor, fesm2015_forms.NgControlStatus, fesm2015_forms.NgModel],
    styles: ["[_nghost-%COMP%]{transition-property:background;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;font:var(--tui-font-text-s);position:relative;display:inline-block;border-radius:var(--tui-radius-s);max-width:100%;cursor:default;outline:0;text-decoration:none}[_nghost-%COMP%]:after{transition-property:background;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;position:absolute;top:0;left:0;width:100%;height:100%;content:'';box-sizing:border-box;border-radius:inherit;pointer-events:none}._hoverable[_nghost-%COMP%]:active[data-tui-host-status=custom]:after, ._hoverable[_nghost-%COMP%]:hover[data-tui-host-status=custom]:after{background-color:var(--tui-clear)}[_nghost-%COMP%]:focus:after{border:2px solid var(--tui-focus)}[data-tui-host-status=primary][_nghost-%COMP%]{background-color:var(--tui-primary);color:var(--tui-primary-text)}[data-tui-host-status=primary]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-primary-hover)}[data-tui-host-status=primary]._hoverable[_nghost-%COMP%]:active{background-color:var(--tui-primary-active)}[data-tui-host-status=error][_nghost-%COMP%]{background-color:var(--tui-error-bg);color:var(--tui-text-01)}[data-tui-host-status=error]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=error]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-error-bg-hover)}[data-tui-host-status=error][data-mode=onDark][_nghost-%COMP%]{background-color:var(--tui-error-bg-night);color:var(--tui-text-01-night)}[data-tui-host-status=error][data-mode=onDark]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=error][data-mode=onDark]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-error-bg-night-hover)}[data-tui-host-status=success][_nghost-%COMP%]{background-color:var(--tui-success-bg);color:var(--tui-text-01)}[data-tui-host-status=success]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=success]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-success-bg-hover)}[data-tui-host-status=success][data-mode=onDark][_nghost-%COMP%]{background-color:var(--tui-success-bg-night);color:var(--tui-text-01-night)}[data-tui-host-status=success][data-mode=onDark]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=success][data-mode=onDark]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-success-bg-night-hover)}[data-tui-host-status=warning][_nghost-%COMP%]{background-color:var(--tui-warning-bg);color:var(--tui-text-01)}[data-tui-host-status=warning]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=warning]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-warning-bg-hover)}[data-tui-host-status=warning][data-mode=onDark][_nghost-%COMP%]{background-color:var(--tui-warning-bg-night);color:var(--tui-text-01-night)}[data-tui-host-status=warning][data-mode=onDark]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=warning][data-mode=onDark]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-warning-bg-night-hover)}[data-tui-host-status=default][_nghost-%COMP%]{color:var(--tui-text-01-night);background-color:var(--tui-base-06)}[data-tui-host-status=default][_nghost-%COMP%]:not([data-mode])._hoverable:hover{background-color:var(--tui-base-07)}[data-tui-host-status=default][_nghost-%COMP%]:not([data-mode])._hoverable:active{background-color:var(--tui-base-08)}[data-tui-host-status=default][data-mode=onDark][_nghost-%COMP%]{color:var(--tui-text-01-night);background-color:var(--tui-clear-inverse)}[data-tui-host-status=default][data-mode=onDark]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-clear-inverse-hover)}[data-tui-host-status=default][data-mode=onDark]._hoverable[_nghost-%COMP%]:active{background-color:var(--tui-clear-inverse-active)}[data-tui-host-status=default][data-mode=onDark][_nghost-%COMP%]:focus:after{border:2px solid var(--tui-base-01)}[data-tui-host-status=default][data-mode=onLight][_nghost-%COMP%]{background-color:var(--tui-clear);color:var(--tui-text-01)}[data-tui-host-status=default][data-mode=onLight]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-clear-hover)}[data-tui-host-status=default][data-mode=onLight]._hoverable[_nghost-%COMP%]:active{background-color:var(--tui-clear-active)}._editing[_nghost-%COMP%]{background:0 0!important}._disabled[_nghost-%COMP%]{pointer-events:none;opacity:var(--tui-disabled-opacity)}._hoverable[_nghost-%COMP%]{cursor:pointer}._autocolor[_nghost-%COMP%]{color:var(--tui-text-01)}.text[_ngcontent-%COMP%]{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;padding-right:.02em}.tag[_ngcontent-%COMP%]{position:relative;display:flex;align-items:center;border-radius:inherit;white-space:pre}[data-tui-host-size='s'][_nghost-%COMP%]   .tag[_ngcontent-%COMP%]{font:var(--tui-font-text-xs);height:20px;padding:0 8px}[data-tui-host-size='m'][_nghost-%COMP%]   .tag[_ngcontent-%COMP%]{height:var(--tui-height-xs);padding:0 8px}[data-tui-host-size='l'][_nghost-%COMP%]   .tag[_ngcontent-%COMP%]{height:var(--tui-height-s);padding:0 12px}._has-icon[data-tui-host-size='s'][_nghost-%COMP%]   .tag[_ngcontent-%COMP%]{padding-right:2px}._has-icon[data-tui-host-size='m'][_nghost-%COMP%]   .tag[_ngcontent-%COMP%]{padding-right:0}._has-icon[data-tui-host-size='l'][_nghost-%COMP%]   .tag[_ngcontent-%COMP%]{padding-right:4px}._editing[_nghost-%COMP%]   .tag[_ngcontent-%COMP%]{visibility:hidden}._disabled._has-icon[data-tui-host-size='m'][_nghost-%COMP%]   .tag[_ngcontent-%COMP%], ._disabled._has-icon[data-tui-host-size='s'][_nghost-%COMP%]   .tag[_ngcontent-%COMP%]{padding-right:8px}._disabled._has-icon[data-tui-host-size='l'][_nghost-%COMP%]   .tag[_ngcontent-%COMP%]{padding-right:12px}.edit[_ngcontent-%COMP%]{font:var(--tui-font-text-s);padding:0;border:0;border-radius:inherit;background:0 0;font-size:inherit;line-height:inherit;font-weight:inherit;color:inherit;caret-color:currentColor;outline:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;word-break:keep-all;-webkit-text-fill-color:currentColor;position:absolute;top:0;left:0;width:100%;box-sizing:border-box}.edit[_ngcontent-%COMP%]:-webkit-autofill, .edit[_ngcontent-%COMP%]:-webkit-autofill:focus, .edit[_ngcontent-%COMP%]:-webkit-autofill:hover{border-radius:inherit;-webkit-text-fill-color:inherit!important;color:inherit!important;background-color:transparent!important;-webkit-box-shadow:0 0 0 1000px var(--tui-autofill) inset!important}[data-tui-host-size='s'][_nghost-%COMP%]   .edit[_ngcontent-%COMP%]{height:20px;line-height:20px;padding-left:8px}[data-tui-host-size='m'][_nghost-%COMP%]   .edit[_ngcontent-%COMP%]{height:var(--tui-height-xs);line-height:var(--tui-height-xs);padding-left:8px}[data-tui-host-size='l'][_nghost-%COMP%]   .edit[_ngcontent-%COMP%]{height:var(--tui-height-s);line-height:var(--tui-height-s);padding-left:12px}.icon[_ngcontent-%COMP%]{margin-left:4px;height:100%}.icon[_ngcontent-%COMP%]:not(.icon_loader){cursor:pointer;pointer-events:all;opacity:var(--tui-disabled-opacity)}.icon[_ngcontent-%COMP%]:hover{opacity:1}.icon_loader[_ngcontent-%COMP%]{width:16px;height:16px;margin:0 4px}[data-tui-host-size='s'][_nghost-%COMP%]   .icon_loader[_ngcontent-%COMP%]{margin:0 6px 0 12px;width:8px;height:8px}[data-tui-host-size='l'][_nghost-%COMP%]   .icon_loader[_ngcontent-%COMP%]{margin:0 4px 0 8px}.left-content[_ngcontent-%COMP%]{margin-right:4px;width:16px;height:16px}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "value", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "editable", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "allowSpaces", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "maxLength", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-tui-host-size'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "size", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "showLoader", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-tui-host-status'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "status", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._hoverable'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "hoverable", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "removable", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._disabled'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "disabled", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._autocolor'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "autoColor", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "leftContent", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiTagComponent.prototype, "edited", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._editing')], TuiTagComponent.prototype, "editing", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('input', {
    read: core_js_.ElementRef
  })], TuiTagComponent.prototype, "input", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._has-icon')], TuiTagComponent.prototype, "hasIcon", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('keydown.enter', ['$event'])], TuiTagComponent.prototype, "edit", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('keydown.delete', ['$event']), (0,core_js_.HostListener)('keydown.backspace', ['$event'])], TuiTagComponent.prototype, "remove", null);
  TuiTagComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_MODE */.Au))], TuiTagComponent);
  return TuiTagComponent;
})();
let TuiTagModule = /*#__PURE__*/(() => {
  let TuiTagModule = class TuiTagModule {};
  TuiTagModule.ɵfac = function TuiTagModule_Factory(t) {
    return new (t || TuiTagModule)();
  };
  TuiTagModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiTagModule
  });
  TuiTagModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, fesm2015_forms.FormsModule, TuiPreventDefaultModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, taiga_ui_core_components_loader/* TuiLoaderModule */.dS, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq]]
  });
  return TuiTagModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiTagModule, {
    declarations: function () {
      return [TuiTagComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, fesm2015_forms.FormsModule, TuiPreventDefaultModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, taiga_ui_core_components_loader/* TuiLoaderModule */.dS, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq];
    },
    exports: function () {
      return [TuiTagComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-tag.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/mergeMap.js
var mergeMap = __webpack_require__(9773);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-link.js
var taiga_ui_core_components_link = __webpack_require__(2847);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/BehaviorSubject.js
var BehaviorSubject = __webpack_require__(6215);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/repeatWhen.js
var repeatWhen = __webpack_require__(2361);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-notification.js
var taiga_ui_core_components_notification = __webpack_require__(885);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-modules-notifications.js















function TuiNotificationAlertComponent_tui_notification_0_label_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "label", 5);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r3 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", ctx_r3.safeItem.label, " ");
  }
}
function TuiNotificationAlertComponent_tui_notification_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "tui-notification", 2);
    core_js_["ɵɵlistener"]("close", function TuiNotificationAlertComponent_tui_notification_0_Template_tui_notification_close_0_listener() {
      core_js_["ɵɵrestoreView"](_r5);
      const ctx_r4 = core_js_["ɵɵnextContext"]();
      return ctx_r4.closeNotification();
    });
    core_js_["ɵɵtemplate"](1, TuiNotificationAlertComponent_tui_notification_0_label_1_Template, 2, 1, "label", 3);
    core_js_["ɵɵelement"](2, "div", 4);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("status", ctx_r0.safeItem.status)("hasIcon", ctx_r0.safeItem.hasIcon);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", ctx_r0.safeItem.label);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("content", ctx_r0.safeItem.content)("context", ctx_r0.context);
  }
}
function TuiNotificationAlertComponent_ng_template_1_label_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "label", 5);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r6 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", ctx_r6.safeItem.label, " ");
  }
}
function TuiNotificationAlertComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "tui-notification", 6);
    core_js_["ɵɵtemplate"](1, TuiNotificationAlertComponent_ng_template_1_label_1_Template, 2, 1, "label", 3);
    core_js_["ɵɵelement"](2, "div", 4);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("status", ctx_r2.safeItem.status)("hasIcon", ctx_r2.safeItem.hasIcon);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", ctx_r2.safeItem.label);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("content", ctx_r2.safeItem.content)("context", ctx_r2.context);
  }
}
function TuiNotificationsHostComponent_ng_container_0_div_1_tui_notification_alert_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-notification-alert", 4);
  }
  if (rf & 2) {
    const item_r4 = ctx.$implicit;
    core_js_["ɵɵproperty"]("item", item_r4);
  }
}
function TuiNotificationsHostComponent_ng_container_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 2);
    core_js_["ɵɵtemplate"](1, TuiNotificationsHostComponent_ng_container_0_div_1_tui_notification_alert_1_Template, 1, 1, "tui-notification-alert", 3);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const items_r1 = core_js_["ɵɵnextContext"]().tuiLet;
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("@tuiFadeInList", ctx_r2.getAnimation(items_r1.length))("@tuiHeightCollapseList", ctx_r2.getAnimation(items_r1.length))("@tuiSlideInRightList", ctx_r2.getAnimation(items_r1.length));
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", items_r1);
  }
}
function TuiNotificationsHostComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiNotificationsHostComponent_ng_container_0_div_1_Template, 2, 4, "div", 1);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const items_r1 = ctx.tuiLet;
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", items_r1.length);
  }
}
const ALERT_AUTOCLOSE_TIMEOUT = 3000;
let TuiNotificationAlertComponent = /*#__PURE__*/(() => {
  let TuiNotificationAlertComponent = class TuiNotificationAlertComponent {
    constructor({
      nativeElement
    }, destroy$) {
      (0,timer/* timer */.H)(ALERT_AUTOCLOSE_TIMEOUT).pipe((0,takeUntil/* takeUntil */.R)((0,fromEvent/* fromEvent */.R)(nativeElement, 'mouseenter')), (0,repeatWhen/* repeatWhen */.a)(() => (0,fromEvent/* fromEvent */.R)(nativeElement, 'mouseleave')), (0,takeUntil/* takeUntil */.R)(destroy$), (0,filter/* filter */.h)(() => this.safeItem.autoClose)).subscribe(() => this.closeNotification());
    }
    get safeItem() {
      if (!this.item) {
        throw new Error('Notification was created as undefined');
      }
      return this.item;
    }
    get context() {
      return this.calculateContext(this.safeItem);
    }
    closeNotification() {
      this.safeItem.observer.complete();
    }
    calculateContext({
      status,
      data,
      label,
      observer
    }) {
      return {
        $implicit: status,
        data: data,
        label: label,
        closeHook: () => {
          observer.complete();
        },
        emitHook: data => {
          observer.next(data);
        },
        emitAndCloseHook: data => {
          observer.next(data);
          observer.complete();
        }
      };
    }
  };
  TuiNotificationAlertComponent.ɵfac = function TuiNotificationAlertComponent_Factory(t) {
    return new (t || TuiNotificationAlertComponent)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3));
  };
  TuiNotificationAlertComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiNotificationAlertComponent,
    selectors: [["tui-notification-alert"]],
    inputs: {
      item: "item"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])],
    decls: 3,
    vars: 2,
    consts: [[3, "status", "hasIcon", "close", 4, "ngIf", "ngIfElse"], ["noClose", ""], [3, "status", "hasIcon", "close"], ["automation-id", "tui-notification-alert__heading", "class", "heading", 4, "ngIf"], ["polymorpheus-outlet", "", "automation-id", "tui-notification-alert__content", 1, "content", 3, "content", "context"], ["automation-id", "tui-notification-alert__heading", 1, "heading"], [3, "status", "hasIcon"]],
    template: function TuiNotificationAlertComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵtemplate"](0, TuiNotificationAlertComponent_tui_notification_0_Template, 3, 5, "tui-notification", 0);
        core_js_["ɵɵtemplate"](1, TuiNotificationAlertComponent_ng_template_1_Template, 3, 5, "ng-template", null, 1, core_js_["ɵɵtemplateRefExtractor"]);
      }
      if (rf & 2) {
        const _r1 = core_js_["ɵɵreference"](2);
        core_js_["ɵɵproperty"]("ngIf", ctx.safeItem.hasCloseButton)("ngIfElse", _r1);
      }
    },
    directives: [common_js_.NgIf, taiga_ui_core_components_notification/* TuiNotificationComponent */.Ls, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1],
    styles: ["[_nghost-%COMP%]{box-shadow:0 8px 16px rgba(51,51,51,.2);display:block;border-radius:var(--tui-radius-m)}.heading[_ngcontent-%COMP%]{font:var(--tui-font-text-m);line-height:20px;font-weight:700;margin:0}.content[_ngcontent-%COMP%]{color:var(--tui-text-01);word-wrap:break-word}.content[_ngcontent-%COMP%]:empty{display:none}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiNotificationAlertComponent.prototype, "item", void 0);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiNotificationAlertComponent.prototype, "calculateContext", null);
  TuiNotificationAlertComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3))], TuiNotificationAlertComponent);
  return TuiNotificationAlertComponent;
})();
let TuiNotificationAlertModule = /*#__PURE__*/(() => {
  let TuiNotificationAlertModule = class TuiNotificationAlertModule {};
  TuiNotificationAlertModule.ɵfac = function TuiNotificationAlertModule_Factory(t) {
    return new (t || TuiNotificationAlertModule)();
  };
  TuiNotificationAlertModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiNotificationAlertModule
  });
  TuiNotificationAlertModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_notification/* TuiNotificationModule */.Hi]]
  });
  return TuiNotificationAlertModule;
})();
class NotificationAlert {
  constructor(observer, content, options) {
    const {
      label = '',
      status = "info" /* Info */,
      hasIcon = true,
      autoClose = true,
      hasCloseButton = true
    } = options;
    this.observer = observer;
    this.content = content;
    this.label = label;
    this.status = status;
    this.hasIcon = hasIcon;
    this.autoClose = autoClose;
    this.hasCloseButton = hasCloseButton;
    if (options && this.withData(options)) {
      this.data = options.data;
    }
  }
  withData(options) {
    return 'data' in options;
  }
}
const taiga_ui_core_modules_notifications_NO_HOST = 'Notifications are disabled, enable support by adding TuiNotificationsModule to your main app module';
let TuiNotificationsService = /*#__PURE__*/(() => {
  let TuiNotificationsService = class TuiNotificationsService {
    constructor() {
      /** @internal */
      this.items$ = new BehaviorSubject/* BehaviorSubject */.X([]);
    }
    show(content, options = {}) {
      return new Observable/* Observable */.y(observer => {
        taiga_ui_cdk_classes/* tuiAssert */.z.assert(!!this.items$.observers.length, taiga_ui_core_modules_notifications_NO_HOST);
        const notification = new NotificationAlert(observer, content, options);
        this.items$.next([...this.items$.value, notification]);
        return () => {
          this.items$.next(this.items$.value.filter(item => item !== notification));
        };
      });
    }
  };
  TuiNotificationsService.ɵfac = function TuiNotificationsService_Factory(t) {
    return new (t || TuiNotificationsService)();
  };
  TuiNotificationsService.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function TuiNotificationsService_Factory() {
      return new TuiNotificationsService();
    },
    token: TuiNotificationsService,
    providedIn: "root"
  });
  return TuiNotificationsService;
})();
let TuiNotificationsHostComponent = /*#__PURE__*/(() => {
  let TuiNotificationsHostComponent = class TuiNotificationsHostComponent {
    constructor(options, service) {
      this.options = options;
      this.service = service;
    }
    getAnimation(value) {
      return Object.assign({
        value: String(value)
      }, this.options);
    }
  };
  TuiNotificationsHostComponent.ɵfac = function TuiNotificationsHostComponent_Factory(t) {
    return new (t || TuiNotificationsHostComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw), core_js_["ɵɵdirectiveInject"](TuiNotificationsService));
  };
  TuiNotificationsHostComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiNotificationsHostComponent,
    selectors: [["tui-notifications-host"]],
    decls: 2,
    vars: 3,
    consts: [[4, "tuiLet"], ["class", "wrapper", 4, "ngIf"], [1, "wrapper"], ["class", "alert", "role", "alert", 3, "item", 4, "ngFor", "ngForOf"], ["role", "alert", 1, "alert", 3, "item"]],
    template: function TuiNotificationsHostComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵtemplate"](0, TuiNotificationsHostComponent_ng_container_0_Template, 2, 1, "ng-container", 0);
        core_js_["ɵɵpipe"](1, "async");
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("tuiLet", core_js_["ɵɵpipeBind1"](1, 1, ctx.service.items$));
      }
    },
    directives: [taiga_ui_cdk_directives_let/* TuiLetDirective */.Ls, common_js_.NgIf, common_js_.NgForOf, TuiNotificationAlertComponent],
    pipes: [common_js_.AsyncPipe],
    styles: ["[_nghost-%COMP%]{position:fixed;top:0;left:0;width:100%;height:0}.wrapper[_ngcontent-%COMP%]{width:288px;margin-left:auto;padding:32px 48px 0 0}@media screen and (max-width:1023px){.wrapper[_ngcontent-%COMP%]{padding:16px 16px 0 0}}@media screen and (min-width:1360px){.wrapper[_ngcontent-%COMP%]{width:368px}}.alert[_ngcontent-%COMP%]:not(:first-child){margin-top:12px}"],
    data: {
      animation: [tuiFadeInList, tuiSlideInRightList, tuiHeightCollapseList]
    },
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiNotificationsHostComponent.prototype, "getAnimation", null);
  TuiNotificationsHostComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TuiNotificationsService))], TuiNotificationsHostComponent);

  // TODO: remove in ivy compilation
  return TuiNotificationsHostComponent;
})();
const NOTIFICATIONS_HOST = TuiNotificationsHostComponent;
let TuiNotificationsModule = /*#__PURE__*/(() => {
  let TuiNotificationsModule = class TuiNotificationsModule {};
  TuiNotificationsModule.ɵfac = function TuiNotificationsModule_Factory(t) {
    return new (t || TuiNotificationsModule)();
  };
  TuiNotificationsModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiNotificationsModule
  });
  TuiNotificationsModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    providers: [{
      provide: TuiNotificationsHostComponent,
      useValue: NOTIFICATIONS_HOST
    }],
    imports: [[common_js_.CommonModule, TuiNotificationAlertModule, taiga_ui_cdk_directives_let/* TuiLetModule */.WD]]
  });
  return TuiNotificationsModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiNotificationAlertModule, {
    declarations: function () {
      return [TuiNotificationAlertComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_notification/* TuiNotificationModule */.Hi];
    },
    exports: function () {
      return [TuiNotificationAlertComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiNotificationsModule, {
    declarations: function () {
      return [TuiNotificationsHostComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, TuiNotificationAlertModule, taiga_ui_cdk_directives_let/* TuiLetModule */.WD];
    },
    exports: function () {
      return [TuiNotificationsHostComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-modules-notifications.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-theme-night.js





// @dynamic

let TuiThemeNightComponent = /*#__PURE__*/(() => {
  let TuiThemeNightComponent = class TuiThemeNightComponent extends taiga_ui_cdk_abstract/* AbstractTuiThemeSwitcher */.GM {
    constructor(documentRef) {
      super(documentRef);
    }
  };
  TuiThemeNightComponent.ɵfac = function TuiThemeNightComponent_Factory(t) {
    return new (t || TuiThemeNightComponent)(core_js_["ɵɵdirectiveInject"](common_js_.DOCUMENT));
  };
  TuiThemeNightComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiThemeNightComponent,
    selectors: [["tui-theme-night"]],
    features: [core_js_["ɵɵInheritDefinitionFeature"]],
    decls: 0,
    vars: 0,
    template: function TuiThemeNightComponent_Template(rf, ctx) {},
    styles: [":root{--tui-base-01:#222;--tui-base-02:#333;--tui-base-03:#808080;--tui-base-04:#959595;--tui-base-05:#b0b0b0;--tui-base-06:#d7d7d7;--tui-base-07:#ededed;--tui-base-08:#f6f6f6;--tui-base-09:#fff;--tui-focus:rgba(51, 51, 51, 0.64);--tui-secondary:rgba(255, 255, 255, 0.16);--tui-secondary-hover:rgba(255, 255, 255, 0.24);--tui-secondary-active:rgba(255, 255, 255, 0.4);--tui-clear:rgba(255, 255, 255, 0.16);--tui-clear-disabled:rgba(255, 255, 255, 0.08);--tui-clear-hover:rgba(255, 255, 255, 0.24);--tui-clear-active:rgba(255, 255, 255, 0.4);--tui-error-fill:#ff8c67;--tui-error-bg:rgba(244, 87, 37, 0.32);--tui-error-bg-hover:rgba(244, 87, 37, 0.4);--tui-success-fill:#4ac99b;--tui-success-bg:rgba(74, 201, 155, 0.32);--tui-success-bg-hover:rgba(74, 201, 155, 0.4);--tui-warning-fill:#ffc700;--tui-warning-bg:rgba(255, 199, 0, 0.32);--tui-warning-bg-hover:rgba(255, 199, 0, 0.4);--tui-info-fill:#70b6f6;--tui-info-bg:rgba(112, 182, 246, 0.32);--tui-info-bg-hover:rgba(112, 182, 246, 0.4);--tui-neutral-fill:#959ba4;--tui-neutral-bg:#959ba4;--tui-neutral-bg-hover:#959ba4;--tui-text-01:#ffffff;--tui-text-02:rgba(255, 255, 255, 0.72);--tui-text-03:rgba(255, 255, 255, 0.6);--tui-link:#6788ff;--tui-link-hover:#526ed3;--tui-positive:#44c596;--tui-positive-hover:#3aa981;--tui-negative:#ff8c67;--tui-negative-hover:#bb593a}"],
    encapsulation: 2
  });
  TuiThemeNightComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(common_js_.DOCUMENT))], TuiThemeNightComponent);
  return TuiThemeNightComponent;
})();
let TuiThemeNightModule = /*#__PURE__*/(() => {
  let TuiThemeNightModule = class TuiThemeNightModule {};
  TuiThemeNightModule.ɵfac = function TuiThemeNightModule_Factory(t) {
    return new (t || TuiThemeNightModule)();
  };
  TuiThemeNightModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiThemeNightModule
  });
  TuiThemeNightModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiThemeNightModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiThemeNightModule, {
    declarations: [TuiThemeNightComponent],
    exports: [TuiThemeNightComponent]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-theme-night.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-focus-trap.js






// @dynamic

let TuiFocusTrapDirective = /*#__PURE__*/(() => {
  let TuiFocusTrapDirective = class TuiFocusTrapDirective {
    constructor(documentRef, elementRef, renderer) {
      this.documentRef = documentRef;
      this.elementRef = elementRef;
      this.renderer = renderer;
      this.activeElement = (0,taiga_ui_cdk_utils_focus/* getNativeFocused */.dO)(this.documentRef);
      /**
       * This would cause currently focused element to lose focus
       * but it might cause ExpressionChanged error due to potential HostBinding.
       * Microtask keeps it in the same frame but allows change detection to run
       */
      Promise.resolve().then(() => {
        (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(this.elementRef.nativeElement);
      });
    }
    onBlur() {
      this.renderer.removeAttribute(this.elementRef.nativeElement, 'tabIndex');
    }
    onFocusIn(node) {
      if ((0,taiga_ui_cdk_utils_dom/* containsOrAfter */.vV)(this.elementRef.nativeElement, node)) {
        return;
      }
      const focusable = (0,taiga_ui_cdk_utils_focus/* getClosestFocusable */.kA)(this.elementRef.nativeElement, false, this.elementRef.nativeElement);
      if (focusable) {
        (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(focusable);
      }
    }
    ngOnDestroy() {
      (0,taiga_ui_cdk_utils_focus/* blurNativeFocused */.PO)(this.documentRef);
      /**
       * HostListeners are triggered even after ngOnDestroy
       * {@link https://github.com/angular/angular/issues/38100}
       * so we need to delay it but stay in the same sync cycle,
       * therefore using Promise instead of setTimeout
       */
      Promise.resolve().then(() => {
        if (this.activeElement instanceof HTMLElement) {
          (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(this.activeElement);
        }
      });
    }
  };
  TuiFocusTrapDirective.ɵfac = function TuiFocusTrapDirective_Factory(t) {
    return new (t || TuiFocusTrapDirective)(core_js_["ɵɵdirectiveInject"](common_js_.DOCUMENT), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.Renderer2));
  };
  TuiFocusTrapDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiFocusTrapDirective,
    selectors: [["", "tuiFocusTrap", ""]],
    hostAttrs: ["tabIndex", "0"],
    hostBindings: function TuiFocusTrapDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("blur", function TuiFocusTrapDirective_blur_HostBindingHandler() {
          return ctx.onBlur();
        })("focusin.silent", function TuiFocusTrapDirective_focusin_silent_HostBindingHandler($event) {
          return ctx.onFocusIn($event.target);
        }, false, core_js_["ɵɵresolveWindow"]);
      }
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('blur')], TuiFocusTrapDirective.prototype, "onBlur", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('window:focusin.silent', ['$event.target'])], TuiFocusTrapDirective.prototype, "onFocusIn", null);
  TuiFocusTrapDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(common_js_.DOCUMENT)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.Renderer2))], TuiFocusTrapDirective);
  return TuiFocusTrapDirective;
})();
let TuiFocusTrapModule = /*#__PURE__*/(() => {
  let TuiFocusTrapModule = class TuiFocusTrapModule {};
  TuiFocusTrapModule.ɵfac = function TuiFocusTrapModule_Factory(t) {
    return new (t || TuiFocusTrapModule)();
  };
  TuiFocusTrapModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiFocusTrapModule
  });
  TuiFocusTrapModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiFocusTrapModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiFocusTrapModule, {
    declarations: [TuiFocusTrapDirective],
    exports: [TuiFocusTrapDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-focus-trap.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-components-dialog-host.js










// @dynamic





function TuiDialogHostComponent_ng_container_0_section_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "section", 3);
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    core_js_["ɵɵproperty"]("content", item_r3.component)("context", item_r3)("@tuiParentAnimation", undefined);
    core_js_["ɵɵattribute"]("aria-labelledby", item_r3.id);
  }
}
function TuiDialogHostComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiDialogHostComponent_ng_container_0_section_1_Template, 1, 4, "section", 1);
    core_js_["ɵɵelement"](2, "div", 2);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const dialogs_r1 = ctx.ngIf;
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", dialogs_r1);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵclassProp"]("overlay_visible", dialogs_r1.length);
  }
}
let TuiDialogHostComponent = /*#__PURE__*/(() => {
  let TuiDialogHostComponent = class TuiDialogHostComponent {
    constructor(dialogs) {
      this.dialogs = dialogs;
      this.dialogs$ = (0,merge/* merge */.T)(...this.dialogs);
    }
  };
  TuiDialogHostComponent.ɵfac = function TuiDialogHostComponent_Factory(t) {
    return new (t || TuiDialogHostComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_DIALOGS */.qY));
  };
  TuiDialogHostComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDialogHostComponent,
    selectors: [["tui-dialog-host"]],
    decls: 2,
    vars: 3,
    consts: [[4, "ngIf"], ["polymorpheus-outlet", "", "tuiFocusTrap", "", "tuiOverscroll", "all", "class", "dialog", "role", "dialog", "aria-modal", "true", 3, "content", "context", 4, "ngFor", "ngForOf"], [1, "overlay"], ["polymorpheus-outlet", "", "tuiFocusTrap", "", "tuiOverscroll", "all", "role", "dialog", "aria-modal", "true", 1, "dialog", 3, "content", "context"]],
    template: function TuiDialogHostComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵtemplate"](0, TuiDialogHostComponent_ng_container_0_Template, 3, 3, "ng-container", 0);
        core_js_["ɵɵpipe"](1, "async");
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngIf", core_js_["ɵɵpipeBind1"](1, 1, ctx.dialogs$));
      }
    },
    directives: [common_js_.NgIf, common_js_.NgForOf, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, TuiFocusTrapDirective, TuiOverscrollDirective],
    pipes: [common_js_.AsyncPipe],
    styles: ["[_nghost-%COMP%]{position:fixed;left:0;bottom:0;width:100%;height:0}.dialog[_ngcontent-%COMP%], .overlay[_ngcontent-%COMP%]{position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:flex-start;outline:0;overflow:auto;overflow:overlay}.overlay[_ngcontent-%COMP%]{pointer-events:none;opacity:0;transition:opacity var(--tui-duration);background:rgba(0,0,0,.5)}.overlay_visible[_ngcontent-%COMP%]{opacity:1}.dialog[_ngcontent-%COMP%]:last-of-type{z-index:1}"],
    data: {
      animation: [taiga_ui_cdk_constants/* TUI_PARENT_ANIMATION */.Kx]
    },
    changeDetection: 0
  });
  TuiDialogHostComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_DIALOGS */.qY))], TuiDialogHostComponent);
  return TuiDialogHostComponent;
})();
let TuiDialogHostModule = /*#__PURE__*/(() => {
  let TuiDialogHostModule = class TuiDialogHostModule {};
  TuiDialogHostModule.ɵfac = function TuiDialogHostModule_Factory(t) {
    return new (t || TuiDialogHostModule)();
  };
  TuiDialogHostModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDialogHostModule
  });
  TuiDialogHostModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiOverscrollModule, TuiFocusTrapModule]]
  });
  return TuiDialogHostModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDialogHostModule, {
    declarations: function () {
      return [TuiDialogHostComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiOverscrollModule, TuiFocusTrapModule];
    },
    exports: function () {
      return [TuiDialogHostComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-components-dialog-host.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-directives-pointer-hint.js










let TuiPointerHintDirective = /*#__PURE__*/(() => {
  let TuiPointerHintDirective = class TuiPointerHintDirective extends AbstractTuiHint {
    constructor(elementRef, hintService, destroy$, hoveredService) {
      super(elementRef, hintService);
      this.destroy$ = destroy$;
      this.tuiHintShowDelay = 0;
      this.tuiHintHideDelay = 0;
      this.content = '';
      this.currentMouseRect = this.mousePositionToClientRect();
      const hint$ = hoveredService.createHovered$(this.elementRef.nativeElement).pipe((0,filter/* filter */.h)(() => !!this.content), (0,startWith/* startWith */.O)(false), (0,distinctUntilChanged/* distinctUntilChanged */.x)());
      hint$.pipe((0,switchMap/* switchMap */.w)(visible => (0,of.of)(visible).pipe((0,delay/* delay */.g)(visible ? this.tuiHintShowDelay : this.tuiHintHideDelay))), (0,takeUntil/* takeUntil */.R)(destroy$)).subscribe({
        next: visible => {
          if (visible) {
            this.showTooltip();
          } else {
            this.hideTooltip();
          }
        },
        complete: () => {
          this.hideTooltip();
        }
      });
      this.initMouseMoveSubscription();
    }
    set tuiPointerHint(value) {
      if (!value) {
        this.hideTooltip();
        this.content = '';
        return;
      }
      this.content = value;
    }
    getElementClientRect() {
      return this.currentMouseRect;
    }
    initMouseMoveSubscription() {
      const mouseMove$ = (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(this.elementRef.nativeElement, 'mousemove');
      mouseMove$.pipe((0,takeUntil/* takeUntil */.R)(this.destroy$)).subscribe(({
        clientX,
        clientY
      }) => {
        this.currentMouseRect = this.mousePositionToClientRect(clientX, clientY);
      });
    }
    mousePositionToClientRect(x = 0, y = 0) {
      return {
        left: x,
        right: x,
        top: y,
        bottom: y,
        width: 0,
        height: 0
      };
    }
  };
  TuiPointerHintDirective.ɵfac = function TuiPointerHintDirective_Factory(t) {
    return new (t || TuiPointerHintDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_services/* TuiHintService */.BN), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiHoveredService */.gs));
  };
  TuiPointerHintDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiPointerHintDirective,
    selectors: [["", "tuiPointerHint", "", 5, "ng-container"]],
    inputs: {
      tuiHintShowDelay: "tuiHintShowDelay",
      tuiHintHideDelay: "tuiHintHideDelay",
      tuiPointerHint: "tuiPointerHint"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPointerHintDirective.prototype, "tuiHintShowDelay", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPointerHintDirective.prototype, "tuiHintHideDelay", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiRequiredSetter */.NH)()], TuiPointerHintDirective.prototype, "tuiPointerHint", null);
  TuiPointerHintDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_core_services/* TuiHintService */.BN)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiHoveredService */.gs))], TuiPointerHintDirective);
  return TuiPointerHintDirective;
})();
let TuiPointerHintModule = /*#__PURE__*/(() => {
  let TuiPointerHintModule = class TuiPointerHintModule {};
  TuiPointerHintModule.ɵfac = function TuiPointerHintModule_Factory(t) {
    return new (t || TuiPointerHintModule)();
  };
  TuiPointerHintModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiPointerHintModule
  });
  TuiPointerHintModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiPointerHintModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiPointerHintModule, {
    declarations: [TuiPointerHintDirective],
    exports: [TuiPointerHintDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-directives-pointer-hint.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-hints-host.js



















function TuiHintsHostComponent_tui_hint_box_0_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "span", 3);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const text_r3 = ctx.$implicit;
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate"](text_r3);
  }
}
function TuiHintsHostComponent_tui_hint_box_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "tui-hint-box", 1);
    core_js_["ɵɵlistener"]("tuiHoveredChange", function TuiHintsHostComponent_tui_hint_box_0_Template_tui_hint_box_tuiHoveredChange_0_listener($event) {
      const restoredCtx = core_js_["ɵɵrestoreView"](_r5);
      const hint_r1 = restoredCtx.$implicit;
      const ctx_r4 = core_js_["ɵɵnextContext"]();
      return ctx_r4.onHovered($event, hint_r1);
    });
    core_js_["ɵɵelementStart"](1, "div", 2);
    core_js_["ɵɵtemplate"](2, TuiHintsHostComponent_tui_hint_box_0_ng_template_2_Template, 2, 1, "ng-template");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const hint_r1 = ctx.$implicit;
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("@tuiFadeIn", ctx_r0.animation)("mode", hint_r1.mode)("direction", hint_r1.direction)("hint", hint_r1);
    core_js_["ɵɵattribute"]("id", hint_r1.id);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("content", hint_r1.content);
  }
}
const taiga_ui_core_components_hints_host_c0 = ["arrow"];
function TuiHintBoxComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "div", 2, 3);
  }
}
const taiga_ui_core_components_hints_host_c1 = ["*"];
let TuiHintsHostComponent = /*#__PURE__*/(() => {
  let TuiHintsHostComponent = class TuiHintsHostComponent {
    constructor(options, elementRef, hints$) {
      this.options = options;
      this.elementRef = elementRef;
      this.hints$ = hints$;
      this.animation = Object.assign({
        value: ''
      }, this.options);
    }
    get clientRect() {
      return this.elementRef.nativeElement.getBoundingClientRect();
    }
    onHovered(hovered, directive) {
      if (directive instanceof TuiHintDirective) {
        directive.componentHovered$.next(hovered);
      }
    }
  };
  TuiHintsHostComponent.ɵfac = function TuiHintsHostComponent_Factory(t) {
    return new (t || TuiHintsHostComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_services/* TuiHintService */.BN));
  };
  TuiHintsHostComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiHintsHostComponent,
    selectors: [["tui-hints-host"]],
    hostAttrs: ["aria-live", "polite"],
    decls: 2,
    vars: 3,
    consts: [["role", "tooltip", 3, "mode", "direction", "hint", "tuiHoveredChange", 4, "ngFor", "ngForOf"], ["role", "tooltip", 3, "mode", "direction", "hint", "tuiHoveredChange"], ["polymorpheus-outlet", "", 3, "content"], [1, "text"]],
    template: function TuiHintsHostComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵtemplate"](0, TuiHintsHostComponent_tui_hint_box_0_Template, 3, 6, "tui-hint-box", 0);
        core_js_["ɵɵpipe"](1, "async");
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngForOf", core_js_["ɵɵpipeBind1"](1, 1, ctx.hints$));
      }
    },
    directives: function () {
      return [common_js_.NgForOf, TuiHintBoxComponent, TuiHoveredDirective, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1];
    },
    pipes: function () {
      return [common_js_.AsyncPipe];
    },
    styles: ["[_nghost-%COMP%]{position:fixed;bottom:0;left:0;width:100%;height:0}.text[_ngcontent-%COMP%]{white-space:pre-wrap}"],
    data: {
      animation: [tuiFadeIn]
    },
    changeDetection: 0
  });
  TuiHintsHostComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_core_services/* TuiHintService */.BN))], TuiHintsHostComponent);
  return TuiHintsHostComponent;
})();
const SPACE = 8;
const BORDER_WIDTH = 1;
const LEFT_PADDING = 16;
const TOP_PADDING = 12;
const ARROW_SIZE = 8;
const ARROW_OFFSET = 16;
const ARROWHEAD_OFFSET = ARROW_OFFSET + ARROW_SIZE * Math.sqrt(2) / 2;
const reverseDirectionsVertical = {
  'top-left': 'bottom-left',
  'top-right': 'bottom-right',
  'bottom-left': 'top-left',
  'bottom-right': 'top-right',
  left: 'right',
  right: 'left'
};
const reverseDirectionsHorizontal = {
  'top-left': 'top-right',
  'top-right': 'top-left',
  'bottom-left': 'bottom-right',
  'bottom-right': 'bottom-left',
  left: 'right',
  right: 'left'
};
// TODO: consider abstracting UI and move to CDK
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
let TuiHintBoxComponent = /*#__PURE__*/(() => {
  let TuiHintBoxComponent = class TuiHintBoxComponent {
    constructor(animationFrame$, destroy$, ngZone, elementRef, windowRef, isMobile, hintsHost) {
      this.elementRef = elementRef;
      this.windowRef = windowRef;
      this.isMobile = isMobile;
      this.hintsHost = hintsHost;
      this.direction = 'bottom-left';
      this.mode = null;
      animationFrame$.pipe((0,taiga_ui_cdk_observables/* tuiZonefree */.fL)(ngZone), (0,takeUntil/* takeUntil */.R)(destroy$)).subscribe(() => {
        this.calculatePosition();
      });
    }
    get isUntouchable() {
      return this.hint instanceof TuiPointerHintDirective;
    }
    /**
     * Calculates wrapper position.
     * Styles are set directly to avoid visual shake of element
     */
    calculatePosition() {
      if (this.mode !== "overflow" /* Overflow */) {
        this.calculateCoordinates();
      } else {
        this.setOverflowStyles();
      }
    }
    calculateCoordinates() {
      if (this.isMobile) {
        this.calculateMobileCoordinates();
        return;
      }
      if (!this.hint) {
        return;
      }
      const hostRect = this.hint.getElementClientRect();
      const portalRect = this.hintsHost.clientRect;
      const tooltip = this.elementRef.nativeElement;
      const {
        style
      } = tooltip;
      const tooltipRect = tooltip.getBoundingClientRect();
      const isHostLong = hostRect.width > ARROWHEAD_OFFSET * 2;
      const directions = ['left', 'right', 'bottom-left', 'bottom-right', 'top-left', 'top-right'];
      let top = 0;
      let left = 0;
      let {
        direction
      } = this;
      const horizontalTop = hostRect.top + hostRect.height / 2 - tooltipRect.height / 2 - portalRect.top;
      const horizontalLeft = hostRect.left - tooltipRect.width - SPACE - portalRect.left;
      const horizontalRight = hostRect.left + hostRect.width + SPACE - portalRect.left;
      const verticalBottom = hostRect.bottom + SPACE - portalRect.top;
      const verticalTop = hostRect.top - tooltipRect.height - SPACE - portalRect.top;
      const verticalRight = isHostLong ? hostRect.left - portalRect.left : hostRect.left + hostRect.width / 2 - ARROWHEAD_OFFSET - portalRect.left;
      const verticalLeft = isHostLong ? hostRect.left - tooltipRect.width + hostRect.width - portalRect.left : hostRect.left - tooltipRect.width + hostRect.width / 2 + ARROWHEAD_OFFSET - portalRect.left;
      directions.splice(directions.indexOf(direction), 1);
      while (true) {
        switch (direction) {
          case 'left':
            top = horizontalTop;
            left = horizontalLeft;
            break;
          case 'right':
            top = horizontalTop;
            left = horizontalRight;
            break;
          case 'top-right':
            top = verticalTop;
            left = verticalRight;
            break;
          case 'top-left':
            top = verticalTop;
            left = verticalLeft;
            break;
          case 'bottom-right':
            top = verticalBottom;
            left = verticalRight;
            break;
          case 'bottom-left':
            top = verticalBottom;
            left = verticalLeft;
            break;
        }
        const verticalFit = top + portalRect.top > SPACE && top + tooltipRect.height + SPACE + portalRect.top < this.windowRef.innerHeight;
        const horizontalFit = left > SPACE && left + tooltipRect.width + SPACE + portalRect.left < portalRect.width;
        if (directions.length === 0 || verticalFit && horizontalFit) {
          break;
        }
        direction = verticalFit ? reverseDirectionsHorizontal[direction] : reverseDirectionsVertical[direction];
        direction = directions.splice(directions.indexOf(direction), 1)[0] || direction;
      }
      style.top = px(top);
      style.left = px(left);
      tooltip.setAttribute('data-tui-host-direction', direction);
    }
    calculateMobileCoordinates() {
      if (!this.hint) {
        throw new Error('Hint directive is missing');
      }
      const hostRect = this.hint.getElementClientRect();
      const portalRect = this.hintsHost.clientRect;
      const tooltip = this.elementRef.nativeElement;
      const {
        style
      } = tooltip;
      const tooltipRect = tooltip.getBoundingClientRect();
      const verticalTop = hostRect.top - tooltipRect.height - SPACE - portalRect.top;
      const verticalBottom = hostRect.bottom + SPACE - portalRect.top;
      const verticalTopFit = verticalTop + portalRect.top > SPACE && hostRect.top < this.windowRef.innerHeight;
      const verticalBottomFit = hostRect.bottom > 0 && hostRect.bottom + 2 * SPACE + tooltipRect.height < this.windowRef.innerHeight;
      const direction = this.direction.includes('top') && verticalTopFit || !verticalBottomFit ? 'top' : 'bottom';
      const attemptedLeft = portalRect.left + hostRect.left + hostRect.width / 2 - tooltipRect.width / 2;
      const left = Math.max(attemptedLeft + tooltipRect.width + SPACE > portalRect.right ? portalRect.right - SPACE - tooltipRect.width : attemptedLeft, SPACE * 2);
      style.left = px(left);
      style.top = direction === 'top' ? px(verticalTop) : px(verticalBottom);
      if (this.arrow) {
        this.arrow.nativeElement.style.left = px(hostRect.left <= SPACE * 2 && hostRect.width > ARROW_OFFSET * 2 ? ARROW_OFFSET : hostRect.left + hostRect.width / 2 - left - ARROW_SIZE / 2);
      }
      tooltip.setAttribute('data-tui-host-direction', direction);
    }
    setOverflowStyles() {
      if (!this.hint) {
        throw new Error('Hint directive is missing');
      }
      const hostRect = this.hint.getElementClientRect();
      const {
        style
      } = this.elementRef.nativeElement;
      style.top = px(hostRect.top - window.innerHeight - TOP_PADDING - BORDER_WIDTH);
      style.left = px(hostRect.left - LEFT_PADDING - BORDER_WIDTH);
      style.width = px(hostRect.width + LEFT_PADDING * 2 + BORDER_WIDTH * 2);
    }
  };
  TuiHintBoxComponent.ɵfac = function TuiHintBoxComponent_Factory(t) {
    return new (t || TuiHintBoxComponent)(core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* ANIMATION_FRAME */.L1), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3), core_js_["ɵɵdirectiveInject"](core_js_.NgZone), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* WINDOW */.m9), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL), core_js_["ɵɵdirectiveInject"](TuiHintsHostComponent));
  };
  TuiHintBoxComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiHintBoxComponent,
    selectors: [["tui-hint-box"]],
    viewQuery: function TuiHintBoxComponent_Query(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵviewQuery"](taiga_ui_core_components_hints_host_c0, 5);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.arrow = _t.first);
      }
    },
    hostVars: 3,
    hostBindings: function TuiHintBoxComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("data-mode", ctx.mode);
        core_js_["ɵɵclassProp"]("_untouchable", ctx.isUntouchable);
      }
    },
    inputs: {
      direction: "direction",
      mode: "mode",
      hint: "hint"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])],
    ngContentSelectors: taiga_ui_core_components_hints_host_c1,
    decls: 3,
    vars: 1,
    consts: [["class", "arrow", 4, "ngIf"], ["automation-id", "tui-hint-box__tooltip", 1, "tooltip"], [1, "arrow"], ["arrow", ""]],
    template: function TuiHintBoxComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵtemplate"](0, TuiHintBoxComponent_div_0_Template, 2, 0, "div", 0);
        core_js_["ɵɵelementStart"](1, "div", 1);
        core_js_["ɵɵprojection"](2);
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngIf", ctx.isMobile);
      }
    },
    directives: [common_js_.NgIf],
    styles: ["[_nghost-%COMP%]{position:absolute;top:0;left:0;max-width:288px;min-height:var(--tui-height-m);padding:12px 16px;background:var(--tui-primary);border-radius:var(--tui-radius-l);color:var(--tui-primary-text);box-sizing:border-box}[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [_nghost-%COMP%]:not([data-mode=overflow]):before{content:'';position:absolute;width:8px;height:8px;border-radius:2px;box-sizing:border-box;background-color:inherit;transform:rotate(45deg)}[data-tui-host-direction=top][_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{bottom:-4px}[data-tui-host-direction=bottom][_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:-4px}[data-tui-host-direction=bottom][_nghost-%COMP%]:before, [data-tui-host-direction=top][_nghost-%COMP%]:before{display:none}[data-tui-host-direction=top-left][_nghost-%COMP%]:before, [data-tui-host-direction=top-right][_nghost-%COMP%]:before{bottom:-4px}[data-tui-host-direction=bottom-left][_nghost-%COMP%]:before, [data-tui-host-direction=bottom-right][_nghost-%COMP%]:before{top:-4px}[data-tui-host-direction=bottom-left][_nghost-%COMP%]:before, [data-tui-host-direction=top-left][_nghost-%COMP%]:before{right:17.2px}[data-tui-host-direction=bottom-right][_nghost-%COMP%]:before, [data-tui-host-direction=top-right][_nghost-%COMP%]:before{left:17.2px}[data-tui-host-direction=left][_nghost-%COMP%]:before, [data-tui-host-direction=right][_nghost-%COMP%]:before{top:50%;margin-top:-4px}[data-tui-host-direction=left][_nghost-%COMP%]:before{right:-4px}[data-tui-host-direction=right][_nghost-%COMP%]:before{left:-4px}[data-mode=error][_nghost-%COMP%]{background-color:var(--tui-error-fill)}[data-mode=onDark][_nghost-%COMP%], [data-mode=overflow][_nghost-%COMP%]{box-shadow:0 8px 16px rgba(51,51,51,.2);border:1px solid var(--tui-base-03);background-color:var(--tui-base-01);color:var(--tui-text-01)}[data-mode=onDark][_nghost-%COMP%]:before, [data-mode=overflow][_nghost-%COMP%]:before{border:1px solid var(--tui-base-03)}[data-mode=onDark][data-tui-host-direction=left][_nghost-%COMP%]:before, [data-mode=overflow][data-tui-host-direction=left][_nghost-%COMP%]:before{border-left-color:transparent;border-bottom-color:transparent}[data-mode=onDark][data-tui-host-direction=right][_nghost-%COMP%]:before, [data-mode=overflow][data-tui-host-direction=right][_nghost-%COMP%]:before{border-right-color:transparent;border-top-color:transparent}[data-mode=onDark][data-tui-host-direction=top-left][_nghost-%COMP%]:before, [data-mode=onDark][data-tui-host-direction=top-right][_nghost-%COMP%]:before, [data-mode=overflow][data-tui-host-direction=top-left][_nghost-%COMP%]:before, [data-mode=overflow][data-tui-host-direction=top-right][_nghost-%COMP%]:before{border-left-color:transparent;border-top-color:transparent}[data-mode=onDark][data-tui-host-direction=bottom-left][_nghost-%COMP%]:before, [data-mode=onDark][data-tui-host-direction=bottom-right][_nghost-%COMP%]:before, [data-mode=overflow][data-tui-host-direction=bottom-left][_nghost-%COMP%]:before, [data-mode=overflow][data-tui-host-direction=bottom-right][_nghost-%COMP%]:before{border-right-color:transparent;border-bottom-color:transparent}[data-mode=overflow][_nghost-%COMP%]{max-width:none}._untouchable[_nghost-%COMP%]{pointer-events:none}.tooltip[_ngcontent-%COMP%]{font:var(--tui-font-text-s);word-wrap:break-word}[data-mode=overflow][_nghost-%COMP%]   .tooltip[_ngcontent-%COMP%]{font:inherit}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiHintBoxComponent.prototype, "hint", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHintBoxComponent.prototype, "direction", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-mode'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHintBoxComponent.prototype, "mode", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('arrow')], TuiHintBoxComponent.prototype, "arrow", void 0);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM, (0,core_js_.HostBinding)('class._untouchable')], TuiHintBoxComponent.prototype, "isUntouchable", null);
  TuiHintBoxComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(ng_web_apis_common/* ANIMATION_FRAME */.L1)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.NgZone)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(ng_web_apis_common/* WINDOW */.m9)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(TuiHintsHostComponent))], TuiHintBoxComponent);
  return TuiHintBoxComponent;
})();
let TuiHintBoxModule = /*#__PURE__*/(() => {
  let TuiHintBoxModule = class TuiHintBoxModule {};
  TuiHintBoxModule.ɵfac = function TuiHintBoxModule_Factory(t) {
    return new (t || TuiHintBoxModule)();
  };
  TuiHintBoxModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiHintBoxModule
  });
  TuiHintBoxModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule]]
  });
  return TuiHintBoxModule;
})();
let TuiHintsHostModule = /*#__PURE__*/(() => {
  let TuiHintsHostModule = class TuiHintsHostModule {};
  TuiHintsHostModule.ɵfac = function TuiHintsHostModule_Factory(t) {
    return new (t || TuiHintsHostModule)();
  };
  TuiHintsHostModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiHintsHostModule
  });
  TuiHintsHostModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiHoveredModule, TuiHintBoxModule]]
  });
  return TuiHintsHostModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiHintBoxModule, {
    declarations: function () {
      return [TuiHintBoxComponent];
    },
    imports: function () {
      return [common_js_.CommonModule];
    },
    exports: function () {
      return [TuiHintBoxComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiHintsHostModule, {
    declarations: function () {
      return [TuiHintsHostComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiHoveredModule, TuiHintBoxModule];
    },
    exports: function () {
      return [TuiHintsHostComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-hints-host.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-utils-polyfills.js
/**
 * @internal
 */
function innerHTML(documentRef) {
  const svg = documentRef.createElementNS('http://www.w3.org/2000/svg', 'svg');
  if (svg.innerHTML !== undefined) {
    return;
  }
  const serializer = new XMLSerializer();
  const parser = new DOMParser();
  Object.defineProperty(SVGElement.prototype, 'innerHTML', {
    get: function () {
      const result = [];
      let childNode = this.firstChild;
      while (childNode) {
        result.push(serializer.serializeToString(childNode));
        childNode = childNode.nextSibling;
      }
      return result.join('');
    },
    set: function (text) {
      while (this.firstChild) {
        this.removeChild(this.firstChild);
      }
      try {
        const svgDocElement = parser.parseFromString(text, 'image/svg+xml').documentElement;
        if (this.ownerDocument) {
          this.appendChild(this.ownerDocument.importNode(svgDocElement, true));
        }
      } catch (e) {
        throw new Error('Error parsing XML string');
      }
    }
  });
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-utils-polyfills.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-internal-svg-defs-host.js








// @dynamic




function TuiSvgDefsHostComponent__svg_ng_container_1__svg_defs_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵnamespaceSVG"]();
    core_js_["ɵɵelement"](0, "defs", 4);
  }
  if (rf & 2) {
    const def_r4 = ctx.$implicit;
    core_js_["ɵɵproperty"]("innerHTML", def_r4, core_js_["ɵɵsanitizeHtml"]);
  }
}
function TuiSvgDefsHostComponent__svg_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵnamespaceSVG"]();
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiSvgDefsHostComponent__svg_ng_container_1__svg_defs_1_Template, 1, 1, "defs", 3);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", ctx_r0.items);
  }
}
function TuiSvgDefsHostComponent__svg_ng_template_2__svg_defs_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵnamespaceSVG"]();
    core_js_["ɵɵelementStart"](0, "defs");
    core_js_["ɵɵelement"](1, "svg", 6);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const def_r6 = ctx.$implicit;
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("outerHTML", def_r6, core_js_["ɵɵsanitizeHtml"]);
  }
}
function TuiSvgDefsHostComponent__svg_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵnamespaceSVG"]();
    core_js_["ɵɵtemplate"](0, TuiSvgDefsHostComponent__svg_ng_template_2__svg_defs_0_Template, 2, 1, "defs", 5);
  }
  if (rf & 2) {
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("ngForOf", ctx_r2.items);
  }
}
let TuiSvgDefsHostComponent = /*#__PURE__*/(() => {
  let TuiSvgDefsHostComponent = class TuiSvgDefsHostComponent {
    constructor(documentRef, svgService, changeDetectorRef, destroy$, platformId) {
      this.svgService = svgService;
      this.changeDetectorRef = changeDetectorRef;
      this.destroy$ = destroy$;
      this.isBrowser = true;
      this.isBrowser = !(0,common_js_.isPlatformServer)(platformId);
      innerHTML(documentRef);
    }
    // @bad TODO: Looks like it could be async piped but it was probably written like that for a reason
    ngOnInit() {
      this.svgService.items$.pipe((0,takeUntil/* takeUntil */.R)(this.destroy$)).subscribe(defsMap => {
        this.items = defsMap.values();
        this.changeDetectorRef.detectChanges();
      });
    }
  };
  TuiSvgDefsHostComponent.ɵfac = function TuiSvgDefsHostComponent_Factory(t) {
    return new (t || TuiSvgDefsHostComponent)(core_js_["ɵɵdirectiveInject"](common_js_.DOCUMENT), core_js_["ɵɵdirectiveInject"](taiga_ui_core_services/* TuiSvgService */.K5), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3), core_js_["ɵɵdirectiveInject"](core_js_.PLATFORM_ID));
  };
  TuiSvgDefsHostComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiSvgDefsHostComponent,
    selectors: [["tui-svg-defs-host"]],
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])],
    decls: 4,
    vars: 2,
    consts: [["version", "1.1", "xmlns", "http://www.w3.org/2000/svg", 0, "xmlns", "xlink", "http://www.w3.org/1999/xlink"], [4, "ngIf", "ngIfElse"], ["server", ""], [3, "innerHTML", 4, "ngFor", "ngForOf"], [3, "innerHTML"], [4, "ngFor", "ngForOf"], [3, "outerHTML"]],
    template: function TuiSvgDefsHostComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵnamespaceSVG"]();
        core_js_["ɵɵelementStart"](0, "svg", 0);
        core_js_["ɵɵtemplate"](1, TuiSvgDefsHostComponent__svg_ng_container_1_Template, 2, 1, "ng-container", 1);
        core_js_["ɵɵtemplate"](2, TuiSvgDefsHostComponent__svg_ng_template_2_Template, 1, 1, "ng-template", null, 2, core_js_["ɵɵtemplateRefExtractor"]);
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        const _r1 = core_js_["ɵɵreference"](3);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.isBrowser)("ngIfElse", _r1);
      }
    },
    directives: [common_js_.NgIf, common_js_.NgForOf],
    styles: ["[_nghost-%COMP%]{display:none}"],
    changeDetection: 0
  });
  TuiSvgDefsHostComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(common_js_.DOCUMENT)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_core_services/* TuiSvgService */.K5)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(core_js_.PLATFORM_ID))], TuiSvgDefsHostComponent);
  return TuiSvgDefsHostComponent;
})();
let TuiSvgDefsHostModule = /*#__PURE__*/(() => {
  let TuiSvgDefsHostModule = class TuiSvgDefsHostModule {};
  TuiSvgDefsHostModule.ɵfac = function TuiSvgDefsHostModule_Factory(t) {
    return new (t || TuiSvgDefsHostModule)();
  };
  TuiSvgDefsHostModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiSvgDefsHostModule
  });
  TuiSvgDefsHostModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, taiga_ui_cdk_directives_let/* TuiLetModule */.WD]]
  });
  return TuiSvgDefsHostModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiSvgDefsHostModule, {
    declarations: function () {
      return [TuiSvgDefsHostComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, taiga_ui_cdk_directives_let/* TuiLetModule */.WD];
    },
    exports: function () {
      return [TuiSvgDefsHostComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-internal-svg-defs-host.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-root.js















// @dynamic







function TuiRootComponent_tui_scroll_controls_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-scroll-controls", 4);
  }
}
function TuiRootComponent_tui_dialog_host_6_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-dialog-host");
  }
}
function TuiRootComponent_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0, 5);
  }
  if (rf & 2) {
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("ngComponentOutlet", ctx_r2.notificationsHost);
  }
}
const taiga_ui_core_components_root_c0 = ["*", [["tuiOverDialogs"]], [["tuiOverNotifications"]], [["tuiOverPortals"]], [["tuiOverHints"]]];
const taiga_ui_core_components_root_c1 = ["*", "tuiOverDialogs", "tuiOverNotifications", "tuiOverPortals", "tuiOverHints"];
let TuiRootComponent = /*#__PURE__*/(() => {
  let TuiRootComponent = class TuiRootComponent {
    constructor(duration, elementRef, dialogs, notificationsHost, isMobile, plugins, enabled) {
      this.duration = duration;
      this.elementRef = elementRef;
      this.dialogs = dialogs;
      this.notificationsHost = notificationsHost;
      this.isMobile = isMobile;
      this.scrollbars$ = this.dialogs && !this.isMobile ? (0,merge/* merge */.T)(...this.dialogs).pipe((0,map/* map */.U)(({
        length
      }) => !length)) : (0,of.of)(!this.isMobile);
      taiga_ui_cdk_classes/* tuiAssert */.z.enabled = enabled;
      taiga_ui_cdk_classes/* tuiAssert */.z.assert(!(plugins[0] instanceof SilentEventPlugin), 'PlatformBrowser or PlatformServer modules must come before TuiRootModule in your main module');
    }
  };
  TuiRootComponent.ɵfac = function TuiRootComponent_Factory(t) {
    return new (t || TuiRootComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_ANIMATIONS_DURATION */.dx), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_DIALOGS */.qY, 8), core_js_["ɵɵdirectiveInject"](TuiNotificationsHostComponent, 8), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL), core_js_["ɵɵdirectiveInject"](platform_browser.EVENT_MANAGER_PLUGINS), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_ASSERT_ENABLED */.uW));
  };
  TuiRootComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiRootComponent,
    selectors: [["tui-root"]],
    hostAttrs: ["data-tui-version", "2.10.1"],
    hostVars: 2,
    hostBindings: function TuiRootComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵstyleProp"]("--tui-duration", ctx.duration + "ms");
      }
    },
    ngContentSelectors: taiga_ui_core_components_root_c1,
    decls: 13,
    vars: 5,
    consts: [["class", "scrollbar", 4, "ngIf"], [1, "content"], [4, "ngIf"], [3, "ngComponentOutlet", 4, "ngIf"], [1, "scrollbar"], [3, "ngComponentOutlet"]],
    template: function TuiRootComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"](taiga_ui_core_components_root_c0);
        core_js_["ɵɵtemplate"](0, TuiRootComponent_tui_scroll_controls_0_Template, 1, 0, "tui-scroll-controls", 0);
        core_js_["ɵɵpipe"](1, "async");
        core_js_["ɵɵelement"](2, "tui-svg-defs-host");
        core_js_["ɵɵelementStart"](3, "tui-portal-host");
        core_js_["ɵɵelementStart"](4, "div", 1);
        core_js_["ɵɵprojection"](5);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](6, TuiRootComponent_tui_dialog_host_6_Template, 1, 0, "tui-dialog-host", 2);
        core_js_["ɵɵprojection"](7, 1);
        core_js_["ɵɵtemplate"](8, TuiRootComponent_ng_container_8_Template, 1, 1, "ng-container", 3);
        core_js_["ɵɵprojection"](9, 2);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵprojection"](10, 3);
        core_js_["ɵɵelement"](11, "tui-hints-host");
        core_js_["ɵɵprojection"](12, 4);
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngIf", core_js_["ɵɵpipeBind1"](1, 3, ctx.scrollbars$));
        core_js_["ɵɵadvance"](6);
        core_js_["ɵɵproperty"]("ngIf", ctx.dialogs && ctx.dialogs.length);
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵproperty"]("ngIf", ctx.notificationsHost);
      }
    },
    directives: [common_js_.NgIf, TuiSvgDefsHostComponent, TuiPortalHostComponent, TuiHintsHostComponent, TuiScrollControlsComponent, TuiDialogHostComponent, common_js_.NgComponentOutlet],
    pipes: [common_js_.AsyncPipe],
    styles: ["[_nghost-%COMP%]{position:relative;display:block;flex:1}.scrollbar[_ngcontent-%COMP%]{position:fixed;top:0;left:0;bottom:0;right:0;margin:0}.content[_ngcontent-%COMP%]{position:relative;z-index:0;height:100%}"],
    changeDetection: 0
  });
  TuiRootComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_ANIMATIONS_DURATION */.dx)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_DIALOGS */.qY)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TuiNotificationsHostComponent)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(platform_browser.EVENT_MANAGER_PLUGINS)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_ASSERT_ENABLED */.uW))], TuiRootComponent);
  return TuiRootComponent;
})();
let TuiRootModule = /*#__PURE__*/(() => {
  let TuiRootModule = class TuiRootModule {};
  TuiRootModule.ɵfac = function TuiRootModule_Factory(t) {
    return new (t || TuiRootModule)();
  };
  TuiRootModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiRootModule
  });
  TuiRootModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    providers: [NG_EVENT_PLUGINS],
    imports: [[common_js_.CommonModule, TuiDragModule, TuiPortalHostModule, TuiSvgDefsHostModule, TuiHintsHostModule, TuiDialogHostModule, TuiScrollControlsModule]]
  });
  return TuiRootModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiRootModule, {
    declarations: function () {
      return [TuiRootComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, TuiDragModule, TuiPortalHostModule, TuiSvgDefsHostModule, TuiHintsHostModule, TuiDialogHostModule, TuiScrollControlsModule];
    },
    exports: function () {
      return [TuiRootComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-root.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-dialog.js


















function TuiDialogComponent_header_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "header", 5);
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("content", ctx_r0.header)("context", ctx_r0.context);
  }
}
function TuiDialogComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵtext"](0);
    core_js_["ɵɵelementStart"](1, "div", 6);
    core_js_["ɵɵelementStart"](2, "button", 7);
    core_js_["ɵɵlistener"]("click", function TuiDialogComponent_ng_template_5_Template_button_click_2_listener() {
      core_js_["ɵɵrestoreView"](_r5);
      const ctx_r4 = core_js_["ɵɵnextContext"]();
      return ctx_r4.context.$implicit.complete();
    });
    core_js_["ɵɵtext"](3, " OK ");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const text_r3 = ctx.$implicit;
    core_js_["ɵɵtextInterpolate1"](" ", text_r3, " ");
  }
}
function TuiDialogComponent_div_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "div", 8);
    core_js_["ɵɵelementStart"](1, "button", 9);
    core_js_["ɵɵlistener"]("click", function TuiDialogComponent_div_6_Template_button_click_1_listener() {
      core_js_["ɵɵrestoreView"](_r7);
      const ctx_r6 = core_js_["ɵɵnextContext"]();
      return ctx_r6.close();
    });
    core_js_["ɵɵpipe"](2, "async");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("title", core_js_["ɵɵpipeBind1"](2, 1, ctx_r2.closeWord$));
  }
}
const TUI_DIALOGS_CLOSE = new core_js_.InjectionToken('A stream to close dialogs', {
  factory: () => empty/* EMPTY */.E
});
const SCROLLBAR_PLACEHOLDER = 17;
function dialogCloseStreamFactory(documentRef, windowRef, {
  nativeElement
}, close$, destroy$, {
  dismissible
}) {
  return dismissible ? (0,merge/* merge */.T)((0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, 'click').pipe((0,filter/* filter */.h)(taiga_ui_cdk_utils_dom/* isCurrentTarget */.Xr)), (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(documentRef, 'keydown').pipe((0,filter/* filter */.h)(({
    key,
    target
  }) => key === 'Escape' && target instanceof Element && (!(0,taiga_ui_cdk_utils_dom/* containsOrAfter */.vV)(nativeElement, target) || nativeElement.contains(target)))), (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(documentRef, 'mousedown').pipe((0,filter/* filter */.h)(({
    target,
    clientX
  }) => target instanceof Element && windowRef.innerWidth - clientX > SCROLLBAR_PLACEHOLDER && !(0,taiga_ui_cdk_utils_dom/* containsOrAfter */.vV)(nativeElement, target)), (0,switchMapTo/* switchMapTo */.c)((0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(documentRef, 'mouseup').pipe((0,take/* take */.q)(1), (0,filter/* filter */.h)(({
    target
  }) => target instanceof Element && !(0,taiga_ui_cdk_utils_dom/* containsOrAfter */.vV)(nativeElement, target))))), close$).pipe((0,takeUntil/* takeUntil */.R)(destroy$)) : close$;
}
const TUI_DIALOG_CLOSE_STREAM = new core_js_.InjectionToken('Dialogs closing stream');
const TUI_DIALOG_PROVIDERS = [taiga_ui_cdk_services/* TuiDestroyService */.a3, {
  provide: TUI_DIALOG_CLOSE_STREAM,
  deps: [common_js_.DOCUMENT, ng_web_apis_common/* WINDOW */.m9, core_js_.ElementRef, TUI_DIALOGS_CLOSE, taiga_ui_cdk_services/* TuiDestroyService */.a3, tinkoff_ng_polymorpheus/* POLYMORPHEUS_CONTEXT */.yf],
  useFactory: dialogCloseStreamFactory
}];
const REQUIRED_ERROR = new Error('Required dialog was dismissed');
// @dynamic
let TuiDialogComponent = /*#__PURE__*/(() => {
  let TuiDialogComponent = class TuiDialogComponent {
    constructor(duration, isMobile, context, close$, closeWord$) {
      this.duration = duration;
      this.isMobile = isMobile;
      this.context = context;
      this.closeWord$ = closeWord$;
      this.animation = {
        value: '',
        params: {
          start: '40px',
          duration: this.duration
        }
      };
      this.fullscreenAnimation = {
        value: '',
        params: {
          start: '100vh',
          duration: this.duration
        }
      };
      close$.subscribe(() => {
        this.close();
      });
    }
    get size() {
      return this.context.size;
    }
    get header() {
      return this.context.header;
    }
    get h() {
      if (this.isMobile) {
        return 'h5';
      }
      switch (this.size) {
        case 's':
          return 'h5';
        case 'm':
          return 'h4';
        default:
          return 'h3';
      }
    }
    get slideInTop() {
      return this.size === 'fullscreen' || this.size === 'page' || this.isMobile ? this.fullscreenAnimation : this.animation;
    }
    close() {
      if (this.context.required) {
        this.context.$implicit.error(REQUIRED_ERROR);
      } else {
        this.context.$implicit.complete();
      }
    }
  };
  TuiDialogComponent.ɵfac = function TuiDialogComponent_Factory(t) {
    return new (t || TuiDialogComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_ANIMATIONS_DURATION */.dx), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL), core_js_["ɵɵdirectiveInject"](tinkoff_ng_polymorpheus/* POLYMORPHEUS_CONTEXT */.yf), core_js_["ɵɵdirectiveInject"](TUI_DIALOG_CLOSE_STREAM), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_CLOSE_WORD */.U0));
  };
  TuiDialogComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDialogComponent,
    selectors: [["tui-dialog"]],
    hostVars: 5,
    hostBindings: function TuiDialogComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("data-size", ctx.size);
        core_js_["ɵɵsyntheticHostProperty"]("@tuiSlideInTop", ctx.slideInTop)("@tuiFadeIn", ctx.slideInTop);
        core_js_["ɵɵclassProp"]("_centered", ctx.header);
      }
    },
    features: [core_js_["ɵɵProvidersFeature"](TUI_DIALOG_PROVIDERS)],
    decls: 7,
    vars: 9,
    consts: [["polymorpheus-outlet", "", "class", "header", 3, "content", "context", 4, "ngIf"], [1, "content"], [3, "id"], ["polymorpheus-outlet", "", 3, "context", "content"], ["class", "wrapper", 4, "ngIf"], ["polymorpheus-outlet", "", 1, "header", 3, "content", "context"], [1, "buttons"], ["tuiButton", "", "size", "m", 3, "click"], [1, "wrapper"], ["tuiIconButton", "", "tuiPreventDefault", "mousedown", "automation-id", "tui-dialog__close", "size", "s", "appearance", "", "icon", "tuiIconCloseLarge", "shape", "rounded", 1, "close", 3, "title", "click"]],
    template: function TuiDialogComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵtemplate"](0, TuiDialogComponent_header_0_Template, 1, 2, "header", 0);
        core_js_["ɵɵelementStart"](1, "div", 1);
        core_js_["ɵɵelementStart"](2, "h2", 2);
        core_js_["ɵɵtext"](3);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](4, "section", 3);
        core_js_["ɵɵtemplate"](5, TuiDialogComponent_ng_template_5_Template, 4, 1, "ng-template");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](6, TuiDialogComponent_div_6_Template, 3, 3, "div", 4);
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngIf", ctx.header);
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵclassMapInterpolate1"]("heading tui-text_", ctx.h, "");
        core_js_["ɵɵproperty"]("id", ctx.context.id);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵtextInterpolate"](ctx.context.label);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("context", ctx.context)("content", ctx.context.content);
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵproperty"]("ngIf", ctx.context.closeable);
      }
    },
    directives: [common_js_.NgIf, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, taiga_ui_core_components_button/* TuiButtonComponent */.v, TuiPreventDefaultDirective],
    pipes: [common_js_.AsyncPipe],
    styles: ["[_nghost-%COMP%]{font:var(--tui-font-text-m);position:relative;display:flex;flex-direction:column;box-sizing:border-box;margin:auto;border-radius:16px;border:40px solid transparent}[_nghost-%COMP%]:after{position:absolute;top:0;left:0;width:100%;height:100%;box-shadow:0 18px 30px rgba(51,51,51,.52);content:'';border-radius:inherit;pointer-events:none}[data-size='s'][_nghost-%COMP%]{width:480px}[data-size='s'][_nghost-%COMP%]   .content[_ngcontent-%COMP%]{padding:24px}[data-size='s'][_nghost-%COMP%]   .heading[_ngcontent-%COMP%]{margin-bottom:8px}[data-size='m'][_nghost-%COMP%]{width:680px}[data-size='m'][_nghost-%COMP%]   .heading[_ngcontent-%COMP%]{margin-bottom:12px}[data-size='l'][_nghost-%COMP%]{width:880px}[data-size='l'][_nghost-%COMP%]   .heading[_ngcontent-%COMP%]{margin-bottom:16px}[data-size=fullscreen][_nghost-%COMP%], [data-size=page][_nghost-%COMP%]{width:100vw;min-height:100vh;border-radius:0;border:none;background:var(--tui-base-01)}[data-size=fullscreen][_nghost-%COMP%]   .content[_ngcontent-%COMP%], [data-size=page][_nghost-%COMP%]   .content[_ngcontent-%COMP%]{padding:48px calc(50vw - 720px / 2)}[data-size=fullscreen][_nghost-%COMP%]   .heading[_ngcontent-%COMP%], [data-size=page][_nghost-%COMP%]   .heading[_ngcontent-%COMP%]{margin-bottom:16px}[data-size=page][_nghost-%COMP%]   .content[_ngcontent-%COMP%]{padding:0}._centered[_nghost-%COMP%]{text-align:center}@media screen and (max-width:599px){[data-size][_nghost-%COMP%]{min-width:100vw;width:100vw;max-width:100vw;border-radius:0;border:none;margin:auto 0 0}[data-size][_nghost-%COMP%]   .content[_ngcontent-%COMP%]{padding:32px 24px}[data-size][_nghost-%COMP%]   .heading[_ngcontent-%COMP%]{margin-bottom:8px}[data-size=fullscreen][_nghost-%COMP%]   .header[_ngcontent-%COMP%]{flex:1}}.heading[_ngcontent-%COMP%]{margin:0;word-wrap:break-word}.heading[_ngcontent-%COMP%]:empty{display:none}.header[_ngcontent-%COMP%]{display:flex;border-top-left-radius:inherit;border-top-right-radius:inherit;overflow:hidden}.content[_ngcontent-%COMP%]{border-radius:inherit;padding:32px;background:var(--tui-base-01)}.content[_ngcontent-%COMP%]:not(:first-child){border-top-left-radius:0;border-top-right-radius:0}.wrapper[_ngcontent-%COMP%]{position:-webkit-sticky;position:sticky;top:0;order:-1}.close[_ngcontent-%COMP%]{transition-property:background;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;position:absolute;top:0;right:0;color:var(--tui-base-01)}@media screen and (max-width:599px){.close[_ngcontent-%COMP%]{background:0 0;color:var(--tui-base-06)}.close[_ngcontent-%COMP%]:hover{color:var(--tui-base-07)}}@media screen and (min-width:600px){.close[_ngcontent-%COMP%]{position:fixed;top:24px;right:24px;background:rgba(104,104,104,.96)}.close[_ngcontent-%COMP%]:hover{background:rgba(159,159,159,.86)}[_nghost-%COMP%]:not([data-size=fullscreen])   .close[_ngcontent-%COMP%]{-webkit-animation:tuiFadeIn var(--tui-duration);animation:tuiFadeIn var(--tui-duration)}[_nghost-%COMP%]:not([data-size=fullscreen]).ng-animating   .close[_ngcontent-%COMP%]{display:none}}.buttons[_ngcontent-%COMP%]{margin-top:20px;text-align:right}"],
    data: {
      animation: [tuiSlideInTop, tuiFadeIn]
    },
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('attr.data-size')], TuiDialogComponent.prototype, "size", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._centered')], TuiDialogComponent.prototype, "header", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('@tuiSlideInTop'), (0,core_js_.HostBinding)('@tuiFadeIn')], TuiDialogComponent.prototype, "slideInTop", null);
  TuiDialogComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_ANIMATIONS_DURATION */.dx)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(tinkoff_ng_polymorpheus/* POLYMORPHEUS_CONTEXT */.yf)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TUI_DIALOG_CLOSE_STREAM)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_CLOSE_WORD */.U0))], TuiDialogComponent);
  return TuiDialogComponent;
})();
const DIALOG = new tinkoff_ng_polymorpheus/* PolymorpheusComponent */.Al(TuiDialogComponent);
const DEFAULT_OPTIONS = {
  size: 'm',
  required: false,
  closeable: true,
  dismissible: true,
  label: '',
  header: ''
};
let TuiDialogService = /*#__PURE__*/(() => {
  let TuiDialogService = class TuiDialogService extends taiga_ui_cdk_abstract/* AbstractTuiDialogService */.d5 {
    constructor() {
      super(...arguments);
      this.component = DIALOG;
      this.defaultOptions = DEFAULT_OPTIONS;
    }
  };
  TuiDialogService.ɵfac = /*@__PURE__*/function () {
    let ɵTuiDialogService_BaseFactory;
    return function TuiDialogService_Factory(t) {
      return (ɵTuiDialogService_BaseFactory || (ɵTuiDialogService_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiDialogService)))(t || TuiDialogService);
    };
  }();
  TuiDialogService.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function TuiDialogService_Factory() {
      return new TuiDialogService((0,core_js_["ɵɵinject"])(taiga_ui_cdk_services/* TuiIdService */.ll));
    },
    token: TuiDialogService,
    providedIn: "root"
  });
  return TuiDialogService;
})();
let TuiDialogModule = /*#__PURE__*/(() => {
  let TuiDialogModule = class TuiDialogModule {};
  TuiDialogModule.ɵfac = function TuiDialogModule_Factory(t) {
    return new (t || TuiDialogModule)();
  };
  TuiDialogModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDialogModule
  });
  TuiDialogModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    providers: [{
      provide: taiga_ui_cdk_tokens/* TUI_DIALOGS */.qY,
      useExisting: TuiDialogService,
      multi: true
    }],
    imports: [[tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_button/* TuiButtonModule */.f, common_js_.CommonModule, TuiPreventDefaultModule]]
  });
  return TuiDialogModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDialogModule, {
    declarations: function () {
      return [TuiDialogComponent];
    },
    imports: function () {
      return [tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_button/* TuiButtonModule */.f, common_js_.CommonModule, TuiPreventDefaultModule];
    },
    exports: function () {
      return [TuiDialogComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-dialog.js.map
;// CONCATENATED MODULE: ./node_modules/@angular/cdk/fesm2015/clipboard.js





/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A pending copy-to-clipboard operation.
 *
 * The implementation of copying text to the clipboard modifies the DOM and
 * forces a relayout. This relayout can take too long if the string is large,
 * causing the execCommand('copy') to happen too long after the user clicked.
 * This results in the browser refusing to copy. This object lets the
 * relayout happen in a separate tick from copying by providing a copy function
 * that can be called later.
 *
 * Destroy must be called when no longer in use, regardless of whether `copy` is
 * called.
 */

class PendingCopy {
  constructor(text, _document) {
    this._document = _document;
    const textarea = this._textarea = this._document.createElement('textarea');
    const styles = textarea.style;
    // Hide the element for display and accessibility. Set a fixed position so the page layout
    // isn't affected. We use `fixed` with `top: 0`, because focus is moved into the textarea
    // for a split second and if it's off-screen, some browsers will attempt to scroll it into view.
    styles.position = 'fixed';
    styles.top = styles.opacity = '0';
    styles.left = '-999em';
    textarea.setAttribute('aria-hidden', 'true');
    textarea.value = text;
    this._document.body.appendChild(textarea);
  }
  /** Finishes copying the text. */
  copy() {
    const textarea = this._textarea;
    let successful = false;
    try {
      // Older browsers could throw if copy is not supported.
      if (textarea) {
        const currentFocus = this._document.activeElement;
        textarea.select();
        textarea.setSelectionRange(0, textarea.value.length);
        successful = this._document.execCommand('copy');
        if (currentFocus) {
          currentFocus.focus();
        }
      }
    } catch (_a) {
      // Discard error.
      // Initial setting of {@code successful} will represent failure here.
    }
    return successful;
  }
  /** Cleans up DOM changes used to perform the copy operation. */
  destroy() {
    const textarea = this._textarea;
    if (textarea) {
      if (textarea.parentNode) {
        textarea.parentNode.removeChild(textarea);
      }
      this._textarea = undefined;
    }
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A service for copying text to the clipboard.
 */
let Clipboard = /*#__PURE__*/(() => {
  class Clipboard {
    constructor(document) {
      this._document = document;
    }
    /**
     * Copies the provided text into the user's clipboard.
     *
     * @param text The string to copy.
     * @returns Whether the operation was successful.
     */
    copy(text) {
      const pendingCopy = this.beginCopy(text);
      const successful = pendingCopy.copy();
      pendingCopy.destroy();
      return successful;
    }
    /**
     * Prepares a string to be copied later. This is useful for large strings
     * which take too long to successfully render and be copied in the same tick.
     *
     * The caller must call `destroy` on the returned `PendingCopy`.
     *
     * @param text The string to copy.
     * @returns the pending copy operation.
     */
    beginCopy(text) {
      return new PendingCopy(text, this._document);
    }
  }
  Clipboard.ɵfac = function Clipboard_Factory(t) {
    return new (t || Clipboard)(core_js_["ɵɵinject"](common_js_.DOCUMENT));
  };
  Clipboard.ɵprov = core_js_["ɵɵdefineInjectable"]({
    factory: function Clipboard_Factory() {
      return new Clipboard(core_js_["ɵɵinject"](common_js_.DOCUMENT));
    },
    token: Clipboard,
    providedIn: "root"
  });
  return Clipboard;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/** Injection token that can be used to provide the default options to `CdkCopyToClipboard`. */
const CDK_COPY_TO_CLIPBOARD_CONFIG = /*#__PURE__*/new core_js_.InjectionToken('CDK_COPY_TO_CLIPBOARD_CONFIG');
/**
 * @deprecated Use `CDK_COPY_TO_CLIPBOARD_CONFIG` instead.
 * @breaking-change 13.0.0
 */
const CKD_COPY_TO_CLIPBOARD_CONFIG = CDK_COPY_TO_CLIPBOARD_CONFIG;
/**
 * Provides behavior for a button that when clicked copies content into user's
 * clipboard.
 */
let CdkCopyToClipboard = /*#__PURE__*/(() => {
  class CdkCopyToClipboard {
    constructor(_clipboard, _ngZone, config) {
      this._clipboard = _clipboard;
      this._ngZone = _ngZone;
      /** Content to be copied. */
      this.text = '';
      /**
       * How many times to attempt to copy the text. This may be necessary for longer text, because
       * the browser needs time to fill an intermediate textarea element and copy the content.
       */
      this.attempts = 1;
      /**
       * Emits when some text is copied to the clipboard. The
       * emitted value indicates whether copying was successful.
       */
      this.copied = new core_js_.EventEmitter();
      /** Copies that are currently being attempted. */
      this._pending = new Set();
      if (config && config.attempts != null) {
        this.attempts = config.attempts;
      }
    }
    /** Copies the current text to the clipboard. */
    copy(attempts = this.attempts) {
      if (attempts > 1) {
        let remainingAttempts = attempts;
        const pending = this._clipboard.beginCopy(this.text);
        this._pending.add(pending);
        const attempt = () => {
          const successful = pending.copy();
          if (!successful && --remainingAttempts && !this._destroyed) {
            // We use 1 for the timeout since it's more predictable when flushing in unit tests.
            this._currentTimeout = this._ngZone.runOutsideAngular(() => setTimeout(attempt, 1));
          } else {
            this._currentTimeout = null;
            this._pending.delete(pending);
            pending.destroy();
            this.copied.emit(successful);
          }
        };
        attempt();
      } else {
        this.copied.emit(this._clipboard.copy(this.text));
      }
    }
    ngOnDestroy() {
      if (this._currentTimeout) {
        clearTimeout(this._currentTimeout);
      }
      this._pending.forEach(copy => copy.destroy());
      this._pending.clear();
      this._destroyed = true;
    }
  }
  CdkCopyToClipboard.ɵfac = function CdkCopyToClipboard_Factory(t) {
    return new (t || CdkCopyToClipboard)(core_js_["ɵɵdirectiveInject"](Clipboard), core_js_["ɵɵdirectiveInject"](core_js_.NgZone), core_js_["ɵɵdirectiveInject"](CKD_COPY_TO_CLIPBOARD_CONFIG, 8));
  };
  CdkCopyToClipboard.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: CdkCopyToClipboard,
    selectors: [["", "cdkCopyToClipboard", ""]],
    hostBindings: function CdkCopyToClipboard_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("click", function CdkCopyToClipboard_click_HostBindingHandler() {
          return ctx.copy();
        });
      }
    },
    inputs: {
      text: ["cdkCopyToClipboard", "text"],
      attempts: ["cdkCopyToClipboardAttempts", "attempts"]
    },
    outputs: {
      copied: "cdkCopyToClipboardCopied"
    }
  });
  return CdkCopyToClipboard;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
let ClipboardModule = /*#__PURE__*/(() => {
  class ClipboardModule {}
  ClipboardModule.ɵfac = function ClipboardModule_Factory(t) {
    return new (t || ClipboardModule)();
  };
  ClipboardModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: ClipboardModule
  });
  ClipboardModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return ClipboardModule;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/*#__PURE__*/(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](ClipboardModule, {
    declarations: [CdkCopyToClipboard],
    exports: [CdkCopyToClipboard]
  });
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=clipboard.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-mobile/fesm2015/taiga-ui-addon-mobile-directives-sidebar.js








const taiga_ui_addon_mobile_directives_sidebar_c0 = ["tuiSidebar", ""];
let TuiSidebarDirective = /*#__PURE__*/(() => {
  let TuiSidebarDirective = class TuiSidebarDirective {
    constructor(content, injector, componentFactoryResolver, portalService) {
      this.content = content;
      this.injector = injector;
      this.componentFactoryResolver = componentFactoryResolver;
      this.portalService = portalService;
      this.direction = 'left';
      this.autoWidth = false;
      this.sidebarRef = null;
    }
    set tuiSidebar(open) {
      if (open) {
        this.show();
      } else {
        this.hide();
      }
    }
    ngOnDestroy() {
      this.hide();
    }
    show() {
      if (this.sidebarRef !== null) {
        return;
      }
      const componentFactory = this.componentFactoryResolver.resolveComponentFactory(TuiSidebarComponent);
      this.sidebarRef = this.portalService.add(componentFactory, this.injector);
      this.sidebarRef.changeDetectorRef.detectChanges();
    }
    hide() {
      if (this.sidebarRef === null) {
        return;
      }
      this.portalService.remove(this.sidebarRef);
      this.sidebarRef = null;
    }
  };
  TuiSidebarDirective.ɵfac = function TuiSidebarDirective_Factory(t) {
    return new (t || TuiSidebarDirective)(core_js_["ɵɵdirectiveInject"](core_js_.TemplateRef), core_js_["ɵɵdirectiveInject"](core_js_.Injector), core_js_["ɵɵdirectiveInject"](core_js_.ComponentFactoryResolver), core_js_["ɵɵdirectiveInject"](TuiPortalService));
  };
  TuiSidebarDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiSidebarDirective,
    selectors: [["", "tuiSidebar", ""]],
    inputs: {
      direction: ["tuiSidebarDirection", "direction"],
      autoWidth: ["tuiSidebarAutoWidth", "autoWidth"],
      tuiSidebar: "tuiSidebar"
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiSidebarDirection')], TuiSidebarDirective.prototype, "direction", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiSidebarAutoWidth')], TuiSidebarDirective.prototype, "autoWidth", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiSidebarDirective.prototype, "tuiSidebar", null);
  TuiSidebarDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.TemplateRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.Injector)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.ComponentFactoryResolver)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TuiPortalService))], TuiSidebarDirective);

  // @dynamic
  return TuiSidebarDirective;
})();
let TuiSidebarComponent = /*#__PURE__*/(() => {
  let TuiSidebarComponent = class TuiSidebarComponent {
    constructor(options, directive) {
      this.options = options;
      this.directive = directive;
      this.left = Object.assign({
        value: 'left'
      }, this.options);
      this.right = Object.assign({
        value: 'right'
      }, this.options);
    }
    get animation() {
      return this.direction === 'left' ? this.left : this.right;
    }
    get direction() {
      return this.directive.direction;
    }
    get content() {
      return this.directive.content;
    }
    get autoWidth() {
      return this.directive.autoWidth;
    }
  };
  TuiSidebarComponent.ɵfac = function TuiSidebarComponent_Factory(t) {
    return new (t || TuiSidebarComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw), core_js_["ɵɵdirectiveInject"](TuiSidebarDirective));
  };
  TuiSidebarComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiSidebarComponent,
    selectors: [["aside", "tuiSidebar", ""]],
    hostVars: 3,
    hostBindings: function TuiSidebarComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵsyntheticHostProperty"]("@tuiSlideIn", ctx.animation);
        core_js_["ɵɵclassMap"](ctx.direction);
      }
    },
    attrs: taiga_ui_addon_mobile_directives_sidebar_c0,
    decls: 1,
    vars: 3,
    consts: [["polymorpheus-outlet", "", "tuiActiveZone", "", 1, "wrapper", 3, "content"]],
    template: function TuiSidebarComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵelement"](0, "div", 0);
      }
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("wrapper_auto-width", ctx.autoWidth);
        core_js_["ɵɵproperty"]("content", ctx.content);
      }
    },
    directives: [tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, TuiActiveZoneDirective],
    styles: ["[_nghost-%COMP%]{position:fixed;top:0;left:0;width:100%;height:100%;display:flex}[_nghost-%COMP%]:after, [_nghost-%COMP%]:before{position:absolute;top:0;left:0;width:100%;height:100%;content:'';background:rgba(0,0,0,.38);-webkit-animation:tuiFadeIn var(--tui-duration);animation:tuiFadeIn var(--tui-duration)}[_nghost-%COMP%]:before{left:-100%;width:200%}[_nghost-%COMP%]:after{left:100%}.ng-animating[_nghost-%COMP%]:after, .ng-animating[_nghost-%COMP%]:before{opacity:0;transition:opacity var(--tui-duration)}.right[_nghost-%COMP%]{justify-content:flex-end}.left[_nghost-%COMP%]{justify-content:flex-start}.wrapper[_ngcontent-%COMP%]{position:relative;display:flex;flex-direction:column;background:var(--tui-base-01);width:276px}.wrapper_auto-width[_ngcontent-%COMP%]{width:auto}"],
    data: {
      animation: [tuiSlideIn]
    },
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('@tuiSlideIn')], TuiSidebarComponent.prototype, "animation", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class')], TuiSidebarComponent.prototype, "direction", null);
  TuiSidebarComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TuiSidebarDirective))], TuiSidebarComponent);
  return TuiSidebarComponent;
})();
let TuiSidebarModule = /*#__PURE__*/(() => {
  let TuiSidebarModule = class TuiSidebarModule {};
  TuiSidebarModule.ɵfac = function TuiSidebarModule_Factory(t) {
    return new (t || TuiSidebarModule)();
  };
  TuiSidebarModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiSidebarModule
  });
  TuiSidebarModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[TuiActiveZoneModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq]]
  });
  return TuiSidebarModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiSidebarModule, {
    declarations: function () {
      return [TuiSidebarDirective, TuiSidebarComponent];
    },
    imports: function () {
      return [TuiActiveZoneModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq];
    },
    exports: function () {
      return [TuiSidebarDirective];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-addon-mobile-directives-sidebar.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/fesm2015/taiga-ui-addon-doc.js





























function TuiDocCodeComponent_p_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "p", 3);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate"](ctx_r0.filename);
  }
}
function TuiDocCopyComponent_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "button", 1);
    core_js_["ɵɵlistener"]("click", function TuiDocCopyComponent_button_0_Template_button_click_0_listener() {
      core_js_["ɵɵrestoreView"](_r3);
      const ctx_r2 = core_js_["ɵɵnextContext"]();
      return ctx_r2.onClick();
    });
    core_js_["ɵɵelementStart"](1, "span", 2);
    core_js_["ɵɵpipe"](2, "async");
    core_js_["ɵɵelementStart"](3, "span", 3);
    core_js_["ɵɵprojection"](4);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵtext"](5);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const texts_r1 = ctx.ngIf;
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("title", texts_r1[0]);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵclassProp"]("content_moved", core_js_["ɵɵpipeBind1"](2, 5, ctx_r0.copied$));
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵattribute"]("data-text", texts_r1[0]);
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵtextInterpolate1"](" ", texts_r1[1], " ");
  }
}
const taiga_ui_addon_doc_c0 = ["*"];
const taiga_ui_addon_doc_c1 = ["content"];
const taiga_ui_addon_doc_c2 = ["wrapper"];
const taiga_ui_addon_doc_c3 = ["resizerText"];
function TuiDocDemoComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵtext"](0);
    core_js_["ɵɵelementStart"](1, "a", 13);
    core_js_["ɵɵelementStart"](2, "code");
    core_js_["ɵɵtext"](3, "tuiMode");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵtextInterpolate1"](" ", ctx_r1.texts[0], " ");
  }
}
function TuiDocDemoComponent_ng_container_3_tui_data_list_wrapper_3_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-data-list-wrapper", 16);
  }
  if (rf & 2) {
    const ctx_r9 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵproperty"]("items", ctx_r9.items);
  }
}
function TuiDocDemoComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵelementStart"](1, "tui-select", 14);
    core_js_["ɵɵtext"](2, " tuiMode ");
    core_js_["ɵɵtemplate"](3, TuiDocDemoComponent_ng_container_3_tui_data_list_wrapper_3_Template, 1, 1, "tui-data-list-wrapper", 15);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    const _r0 = core_js_["ɵɵreference"](2);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("tuiTextfieldCleaner", true)("tuiHintContent", _r0)("formControl", ctx_r2.modeControl);
  }
}
function TuiDocDemoComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵtext"](0, " tuiMode: ");
    core_js_["ɵɵelement"](1, "tui-tooltip", 17);
    core_js_["ɵɵelementStart"](2, "div", 18);
    core_js_["ɵɵelementStart"](3, "tui-radio-block", 19);
    core_js_["ɵɵtext"](4, " null ");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementStart"](5, "tui-radio-block", 20);
    core_js_["ɵɵtext"](6, " onDark ");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementStart"](7, "tui-radio-block", 21);
    core_js_["ɵɵtext"](8, " onLight ");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r4 = core_js_["ɵɵnextContext"]();
    const _r0 = core_js_["ɵɵreference"](2);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("content", _r0);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("collapsed", true);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("item", null)("hideRadio", true)("formControl", ctx_r4.modeControl);
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵproperty"]("hideRadio", true)("formControl", ctx_r4.modeControl);
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵproperty"]("hideRadio", true)("formControl", ctx_r4.modeControl);
  }
}
function TuiDocDemoComponent_form_12_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0);
  }
}
function TuiDocDemoComponent_form_12_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 29);
  }
  if (rf & 2) {
    const ctx_r12 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵclassProp"]("icon_rotated", ctx_r12.expanded);
  }
}
function TuiDocDemoComponent_form_12_ng_template_8_tui_data_list_wrapper_6_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-data-list-wrapper", 16);
  }
  if (rf & 2) {
    const ctx_r14 = core_js_["ɵɵnextContext"](3);
    core_js_["ɵɵproperty"]("items", ctx_r14.updateOnVariants);
  }
}
const _c4 = function () {
  return {
    standalone: true
  };
};
function TuiDocDemoComponent_form_12_ng_template_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r16 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "pre", 30);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵpipe"](2, "json");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementStart"](3, "div", 31);
    core_js_["ɵɵelementStart"](4, "tui-select", 32);
    core_js_["ɵɵlistener"]("ngModelChange", function TuiDocDemoComponent_form_12_ng_template_8_Template_tui_select_ngModelChange_4_listener($event) {
      core_js_["ɵɵrestoreView"](_r16);
      const ctx_r15 = core_js_["ɵɵnextContext"](2);
      return ctx_r15.updateOnChange($event);
    });
    core_js_["ɵɵtext"](5, " updateOn ");
    core_js_["ɵɵtemplate"](6, TuiDocDemoComponent_form_12_ng_template_8_tui_data_list_wrapper_6_Template, 1, 1, "tui-data-list-wrapper", 15);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementStart"](7, "button", 33);
    core_js_["ɵɵtext"](8, " Reset ");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementStart"](9, "button", 34);
    core_js_["ɵɵtext"](10, " Submit ");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r13 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"]("Form data: ", core_js_["ɵɵpipeBind1"](2, 3, ctx_r13.testForm.value), "");
    core_js_["ɵɵadvance"](3);
    core_js_["ɵɵproperty"]("ngModel", ctx_r13.updateOn)("ngModelOptions", core_js_["ɵɵpureFunction0"](5, _c4));
  }
}
function TuiDocDemoComponent_form_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "form", 22);
    core_js_["ɵɵelementStart"](1, "div", 23);
    core_js_["ɵɵtemplate"](2, TuiDocDemoComponent_form_12_ng_container_2_Template, 1, 0, "ng-container", 24);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementStart"](3, "button", 25);
    core_js_["ɵɵlistener"]("click", function TuiDocDemoComponent_form_12_Template_button_click_3_listener() {
      core_js_["ɵɵrestoreView"](_r18);
      const ctx_r17 = core_js_["ɵɵnextContext"]();
      return ctx_r17.toggleDetails();
    });
    core_js_["ɵɵtext"](4);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵtemplate"](5, TuiDocDemoComponent_form_12_ng_template_5_Template, 1, 2, "ng-template", null, 26, core_js_["ɵɵtemplateRefExtractor"]);
    core_js_["ɵɵelementStart"](7, "tui-expand", 27);
    core_js_["ɵɵtemplate"](8, TuiDocDemoComponent_form_12_ng_template_8_Template, 11, 6, "ng-template", 28);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const _r11 = core_js_["ɵɵreference"](6);
    const ctx_r7 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("formGroup", ctx_r7.testForm);
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵproperty"]("ngTemplateOutlet", ctx_r7.template);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("iconRight", _r11);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", ctx_r7.texts[2], " ");
    core_js_["ɵɵadvance"](3);
    core_js_["ɵɵproperty"]("expanded", ctx_r7.expanded);
  }
}
function TuiDocNavigationComponent_tui_hosted_dropdown_0_ng_template_3_tui_opt_group_1_a_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "a", 11);
    core_js_["ɵɵlistener"]("click", function TuiDocNavigationComponent_tui_hosted_dropdown_0_ng_template_3_tui_opt_group_1_a_1_Template_a_click_0_listener() {
      core_js_["ɵɵrestoreView"](_r12);
      const ctx_r11 = core_js_["ɵɵnextContext"](4);
      return ctx_r11.onClick();
    });
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const item_r10 = ctx.$implicit;
    core_js_["ɵɵproperty"]("routerLink", item_r10.route);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", item_r10.title, " ");
  }
}
function TuiDocNavigationComponent_tui_hosted_dropdown_0_ng_template_3_tui_opt_group_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "tui-opt-group", 9);
    core_js_["ɵɵtemplate"](1, TuiDocNavigationComponent_tui_hosted_dropdown_0_ng_template_3_tui_opt_group_1_a_1_Template, 2, 2, "a", 10);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const group_r7 = ctx.$implicit;
    const index_r8 = ctx.index;
    const ctx_r6 = core_js_["ɵɵnextContext"](3);
    core_js_["ɵɵproperty"]("label", ctx_r6.labels[index_r8]);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", group_r7);
  }
}
function TuiDocNavigationComponent_tui_hosted_dropdown_0_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "tui-data-list");
    core_js_["ɵɵtemplate"](1, TuiDocNavigationComponent_tui_hosted_dropdown_0_ng_template_3_tui_opt_group_1_Template, 2, 2, "tui-opt-group", 8);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const filtered_r2 = core_js_["ɵɵnextContext"]().tuiLet;
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", filtered_r2);
  }
}
function TuiDocNavigationComponent_tui_hosted_dropdown_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r15 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "tui-hosted-dropdown", 5);
    core_js_["ɵɵlistener"]("openChange", function TuiDocNavigationComponent_tui_hosted_dropdown_0_Template_tui_hosted_dropdown_openChange_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r15);
      const ctx_r14 = core_js_["ɵɵnextContext"]();
      return ctx_r14.open = $event;
    });
    core_js_["ɵɵelementStart"](1, "tui-primitive-textfield", 6);
    core_js_["ɵɵlistener"]("valueChange", function TuiDocNavigationComponent_tui_hosted_dropdown_0_Template_tui_primitive_textfield_valueChange_1_listener($event) {
      core_js_["ɵɵrestoreView"](_r15);
      const ctx_r16 = core_js_["ɵɵnextContext"]();
      return ctx_r16.onSearchChange($event);
    });
    core_js_["ɵɵtext"](2);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵtemplate"](3, TuiDocNavigationComponent_tui_hosted_dropdown_0_ng_template_3_Template, 2, 1, "ng-template", null, 7, core_js_["ɵɵtemplateRefExtractor"]);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const _r3 = core_js_["ɵɵreference"](4);
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("content", _r3)("canOpen", ctx_r0.canOpen)("open", ctx_r0.open);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("pseudoFocused", ctx_r0.open || null)("tuiTextfieldCleaner", true)("tuiTextfieldLabelOutside", true)("value", ctx_r0.search);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", ctx_r0.searchText, " ");
  }
}
function TuiDocNavigationComponent_tui_accordion_item_5_ng_template_4_ng_container_1_a_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r27 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "a", 19);
    core_js_["ɵɵlistener"]("click", function TuiDocNavigationComponent_tui_accordion_item_5_ng_template_4_ng_container_1_a_1_Template_a_click_0_listener() {
      core_js_["ɵɵrestoreView"](_r27);
      const ctx_r26 = core_js_["ɵɵnextContext"](4);
      return ctx_r26.toggleMenu();
    });
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const item_r21 = core_js_["ɵɵnextContext"]().$implicit;
    core_js_["ɵɵproperty"]("routerLink", item_r21.route);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", item_r21.title, " ");
  }
}
function TuiDocNavigationComponent_tui_accordion_item_5_ng_template_4_ng_container_1_ng_template_2_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r33 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "button", 25);
    core_js_["ɵɵlistener"]("click", function TuiDocNavigationComponent_tui_accordion_item_5_ng_template_4_ng_container_1_ng_template_2_button_1_Template_button_click_0_listener() {
      core_js_["ɵɵrestoreView"](_r33);
      const index_r22 = core_js_["ɵɵnextContext"](2).index;
      const ctx_r31 = core_js_["ɵɵnextContext"](3);
      return ctx_r31.onGroupClick(index_r22);
    });
    core_js_["ɵɵelement"](1, "tui-svg", 26);
    core_js_["ɵɵtext"](2);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r34 = core_js_["ɵɵnextContext"](2);
    const index_r22 = ctx_r34.index;
    const item_r21 = ctx_r34.$implicit;
    const ctx_r29 = core_js_["ɵɵnextContext"](3);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵclassProp"]("chevron_active", !!ctx_r29.openGroupsArr[index_r22]);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", item_r21.title, " ");
  }
}
function TuiDocNavigationComponent_tui_accordion_item_5_ng_template_4_ng_container_1_ng_template_2_a_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r37 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "a", 27);
    core_js_["ɵɵlistener"]("click", function TuiDocNavigationComponent_tui_accordion_item_5_ng_template_4_ng_container_1_ng_template_2_a_4_Template_a_click_0_listener() {
      core_js_["ɵɵrestoreView"](_r37);
      const ctx_r36 = core_js_["ɵɵnextContext"](5);
      return ctx_r36.toggleMenu();
    });
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const subPage_r35 = ctx.$implicit;
    core_js_["ɵɵproperty"]("routerLink", subPage_r35.route);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", subPage_r35.title, " ");
  }
}
const _c5 = function () {
  return {
    exact: false
  };
};
function TuiDocNavigationComponent_tui_accordion_item_5_ng_template_4_ng_container_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 20);
    core_js_["ɵɵtemplate"](1, TuiDocNavigationComponent_tui_accordion_item_5_ng_template_4_ng_container_1_ng_template_2_button_1_Template, 3, 3, "button", 21);
    core_js_["ɵɵelementStart"](2, "tui-expand", 22);
    core_js_["ɵɵelementStart"](3, "div", 23);
    core_js_["ɵɵtemplate"](4, TuiDocNavigationComponent_tui_accordion_item_5_ng_template_4_ng_container_1_ng_template_2_a_4_Template, 2, 2, "a", 24);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r38 = core_js_["ɵɵnextContext"]();
    const item_r21 = ctx_r38.$implicit;
    const index_r22 = ctx_r38.index;
    const ctx_r25 = core_js_["ɵɵnextContext"](3);
    core_js_["ɵɵproperty"]("routerLinkActiveOptions", core_js_["ɵɵpureFunction0"](4, _c5));
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", item_r21.subPages);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("expanded", !!ctx_r25.openGroupsArr[index_r22]);
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵproperty"]("ngForOf", item_r21.subPages);
  }
}
function TuiDocNavigationComponent_tui_accordion_item_5_ng_template_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiDocNavigationComponent_tui_accordion_item_5_ng_template_4_ng_container_1_a_1_Template, 2, 2, "a", 17);
    core_js_["ɵɵtemplate"](2, TuiDocNavigationComponent_tui_accordion_item_5_ng_template_4_ng_container_1_ng_template_2_Template, 5, 5, "ng-template", null, 18, core_js_["ɵɵtemplateRefExtractor"]);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const item_r21 = ctx.$implicit;
    const _r24 = core_js_["ɵɵreference"](3);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", !item_r21.subPages)("ngIfElse", _r24);
  }
}
function TuiDocNavigationComponent_tui_accordion_item_5_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 15);
    core_js_["ɵɵtemplate"](1, TuiDocNavigationComponent_tui_accordion_item_5_ng_template_4_ng_container_1_Template, 4, 2, "ng-container", 16);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const index_r18 = core_js_["ɵɵnextContext"]().index;
    const ctx_r19 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", ctx_r19.items[index_r18]);
  }
}
function TuiDocNavigationComponent_tui_accordion_item_5_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "tui-accordion-item", 12);
    core_js_["ɵɵelementStart"](1, "span", 13);
    core_js_["ɵɵelementStart"](2, "strong");
    core_js_["ɵɵtext"](3);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵtemplate"](4, TuiDocNavigationComponent_tui_accordion_item_5_ng_template_4_Template, 2, 1, "ng-template", 14);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const label_r17 = ctx.$implicit;
    core_js_["ɵɵproperty"]("borders", null);
    core_js_["ɵɵadvance"](3);
    core_js_["ɵɵtextInterpolate"](label_r17);
  }
}
function TuiDocDocumentationComponent_h1_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "h1", 7);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate"](ctx_r0.heading);
  }
}
function TuiDocDocumentationComponent_td_8_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "td", 8);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", ctx_r1.texts[3], " ");
  }
}
function TuiDocDocumentationComponent_tr_9_tui_badge_4_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-badge", 19);
  }
}
function TuiDocDocumentationComponent_tr_9_span_5_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "span", 20);
    core_js_["ɵɵtext"](1, "deprecated");
    core_js_["ɵɵelementEnd"]();
  }
}
function TuiDocDocumentationComponent_tr_9_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0);
  }
}
function TuiDocDocumentationComponent_tr_9_tui_tooltip_10_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵtext"](0);
    core_js_["ɵɵelementStart"](1, "a", 23);
    core_js_["ɵɵelementStart"](2, "code");
    core_js_["ɵɵtext"](3, "ng-polymorpheus");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r11 = core_js_["ɵɵnextContext"](3);
    core_js_["ɵɵtextInterpolate1"](" ", ctx_r11.texts[4], " ");
  }
}
function TuiDocDocumentationComponent_tr_9_tui_tooltip_10_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "tui-tooltip", 21);
    core_js_["ɵɵtemplate"](1, TuiDocDocumentationComponent_tr_9_tui_tooltip_10_ng_template_1_Template, 4, 1, "ng-template", null, 22, core_js_["ɵɵtemplateRefExtractor"]);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const _r10 = core_js_["ɵɵreference"](2);
    const propertyConnector_r3 = core_js_["ɵɵnextContext"]().$implicit;
    core_js_["ɵɵproperty"]("describeId", propertyConnector_r3.attrName)("content", _r10);
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_tui_select_1_tui_data_list_wrapper_3_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-data-list-wrapper", 32);
  }
  if (rf & 2) {
    core_js_["ɵɵnextContext"](2);
    const _r15 = core_js_["ɵɵreference"](3);
    const propertyConnector_r3 = core_js_["ɵɵnextContext"](2).$implicit;
    core_js_["ɵɵproperty"]("items", propertyConnector_r3.documentationPropertyValues)("itemContent", _r15);
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_tui_select_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r23 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "tui-select", 29);
    core_js_["ɵɵlistener"]("ngModelChange", function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_tui_select_1_Template_tui_select_ngModelChange_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r23);
      const propertyConnector_r3 = core_js_["ɵɵnextContext"](3).$implicit;
      return propertyConnector_r3.onValueChange($event);
    });
    core_js_["ɵɵelementStart"](1, "code", 30);
    core_js_["ɵɵtext"](2, "null");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵtemplate"](3, TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_tui_select_1_tui_data_list_wrapper_3_Template, 1, 2, "tui-data-list-wrapper", 31);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    core_js_["ɵɵnextContext"]();
    const _r15 = core_js_["ɵɵreference"](3);
    const propertyConnector_r3 = core_js_["ɵɵnextContext"](2).$implicit;
    const ctx_r14 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("tuiTextfieldCleaner", ctx_r14.showCleaner(propertyConnector_r3.documentationPropertyType))("tuiTextfieldLabelOutside", true)("nativeId", propertyConnector_r3.attrName)("valueContent", _r15)("ngModel", propertyConnector_r3.documentationPropertyValue);
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "code");
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const data_r25 = ctx.$implicit;
    const ctx_r16 = core_js_["ɵɵnextContext"](4);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate"](ctx_r16.inspectAny(data_r25));
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_tui_toggle_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r32 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "tui-toggle", 38);
    core_js_["ɵɵlistener"]("ngModelChange", function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_tui_toggle_1_Template_tui_toggle_ngModelChange_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r32);
      const propertyConnector_r3 = core_js_["ɵɵnextContext"](4).$implicit;
      return propertyConnector_r3.onValueChange($event);
    });
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const propertyConnector_r3 = core_js_["ɵɵnextContext"](4).$implicit;
    core_js_["ɵɵproperty"]("nativeId", propertyConnector_r3.attrName)("showIcons", true)("ngModel", propertyConnector_r3.documentationPropertyValue);
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_tui_primitive_textfield_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r36 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "tui-primitive-textfield", 39);
    core_js_["ɵɵlistener"]("valueChange", function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_tui_primitive_textfield_2_Template_tui_primitive_textfield_valueChange_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r36);
      const propertyConnector_r3 = core_js_["ɵɵnextContext"](4).$implicit;
      return propertyConnector_r3.onValueChange($event);
    });
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const propertyConnector_r3 = core_js_["ɵɵnextContext"](4).$implicit;
    core_js_["ɵɵproperty"]("nativeId", propertyConnector_r3.attrName)("tuiTextfieldLabelOutside", true)("tuiTextfieldCleaner", true)("value", propertyConnector_r3.documentationPropertyValue || "");
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r40 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "div", 40);
    core_js_["ɵɵelementStart"](1, "tui-primitive-textfield", 41);
    core_js_["ɵɵlistener"]("valueChange", function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_div_3_Template_tui_primitive_textfield_valueChange_1_listener($event) {
      core_js_["ɵɵrestoreView"](_r40);
      const propertyConnector_r3 = core_js_["ɵɵnextContext"](4).$implicit;
      const ctx_r38 = core_js_["ɵɵnextContext"]();
      return ctx_r38.onColorChange(propertyConnector_r3, $event);
    });
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementStart"](2, "tui-input-count", 42);
    core_js_["ɵɵlistener"]("ngModelChange", function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_div_3_Template_tui_input_count_ngModelChange_2_listener($event) {
      core_js_["ɵɵrestoreView"](_r40);
      const propertyConnector_r3 = core_js_["ɵɵnextContext"](4).$implicit;
      const ctx_r41 = core_js_["ɵɵnextContext"]();
      return ctx_r41.onOpacityChange(propertyConnector_r3, $event);
    });
    core_js_["ɵɵtext"](3, " Opacity ");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const propertyConnector_r3 = core_js_["ɵɵnextContext"](4).$implicit;
    const ctx_r28 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("tuiTextfieldLabelOutside", true)("tuiInputOpacity", ctx_r28.getOpacity(propertyConnector_r3.documentationPropertyValue))("value", ctx_r28.getColor(propertyConnector_r3.documentationPropertyValue));
    core_js_["ɵɵattribute"]("id", propertyConnector_r3.attrName);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("max", 100)("ngModel", ctx_r28.getOpacity(propertyConnector_r3.documentationPropertyValue));
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_tui_input_count_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r46 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "tui-input-count", 43);
    core_js_["ɵɵlistener"]("ngModelChange", function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_tui_input_count_4_Template_tui_input_count_ngModelChange_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r46);
      const propertyConnector_r3 = core_js_["ɵɵnextContext"](4).$implicit;
      return propertyConnector_r3.onValueChange($event);
    });
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const propertyConnector_r3 = core_js_["ɵɵnextContext"](4).$implicit;
    core_js_["ɵɵproperty"]("nativeId", propertyConnector_r3.attrName)("tuiTextfieldLabelOutside", true)("ngModel", propertyConnector_r3.documentationPropertyValue);
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0, 33);
    core_js_["ɵɵtemplate"](1, TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_tui_toggle_1_Template, 1, 3, "tui-toggle", 34);
    core_js_["ɵɵtemplate"](2, TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_tui_primitive_textfield_2_Template, 1, 4, "tui-primitive-textfield", 35);
    core_js_["ɵɵtemplate"](3, TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_div_3_Template, 4, 6, "div", 36);
    core_js_["ɵɵtemplate"](4, TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_tui_input_count_4_Template, 1, 3, "tui-input-count", 37);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const propertyConnector_r3 = core_js_["ɵɵnextContext"](3).$implicit;
    core_js_["ɵɵproperty"]("ngSwitch", propertyConnector_r3.documentationPropertyType);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngSwitchCase", "boolean");
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngSwitchCase", "string");
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngSwitchCase", "color");
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngSwitchCase", "number");
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_tui_select_1_Template, 4, 5, "tui-select", 26);
    core_js_["ɵɵtemplate"](2, TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_2_Template, 2, 1, "ng-template", null, 27, core_js_["ɵɵtemplateRefExtractor"]);
    core_js_["ɵɵtemplate"](4, TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_Template, 5, 5, "ng-template", null, 28, core_js_["ɵɵtemplateRefExtractor"]);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const _r17 = core_js_["ɵɵreference"](5);
    const propertyConnector_r3 = core_js_["ɵɵnextContext"](2).$implicit;
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", propertyConnector_r3.hasItems)("ngIfElse", _r17);
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "td", 24);
    core_js_["ɵɵtemplate"](1, TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_Template, 6, 2, "ng-container", 25);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const propertyConnector_r3 = core_js_["ɵɵnextContext"]().$implicit;
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", propertyConnector_r3.shouldShowValues);
  }
}
function TuiDocDocumentationComponent_tr_9_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "tr", 9);
    core_js_["ɵɵelementStart"](1, "td", 10);
    core_js_["ɵɵelementStart"](2, "div", 11);
    core_js_["ɵɵtext"](3);
    core_js_["ɵɵtemplate"](4, TuiDocDocumentationComponent_tr_9_tui_badge_4_Template, 1, 0, "tui-badge", 12);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵtemplate"](5, TuiDocDocumentationComponent_tr_9_span_5_Template, 2, 0, "span", 13);
    core_js_["ɵɵtemplate"](6, TuiDocDocumentationComponent_tr_9_ng_container_6_Template, 1, 0, "ng-container", 14);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementStart"](7, "td", 15);
    core_js_["ɵɵelementStart"](8, "span", 16);
    core_js_["ɵɵtext"](9);
    core_js_["ɵɵtemplate"](10, TuiDocDocumentationComponent_tr_9_tui_tooltip_10_Template, 3, 2, "tui-tooltip", 17);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵtemplate"](11, TuiDocDocumentationComponent_tr_9_td_11_Template, 2, 1, "td", 18);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const propertyConnector_r3 = ctx.$implicit;
    const lastItem_r4 = ctx.last;
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵclassProp"]("deprecated", propertyConnector_r3.documentationPropertyDeprecated)("tui-table__tr_border_none", lastItem_r4);
    core_js_["ɵɵadvance"](3);
    core_js_["ɵɵtextInterpolate1"](" ", ctx_r2.stripOptional(propertyConnector_r3.attrName), " ");
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", ctx_r2.isOptional(propertyConnector_r3.attrName));
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", propertyConnector_r3.documentationPropertyDeprecated);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngTemplateOutlet", propertyConnector_r3.template);
    core_js_["ɵɵadvance"](3);
    core_js_["ɵɵtextInterpolate1"](" ", propertyConnector_r3.documentationPropertyType, " ");
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", ctx_r2.showContentTooltip(propertyConnector_r3.documentationPropertyType));
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", ctx_r2.showValues);
  }
}
function TuiDocExampleComponent_h3_0_button_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "button", 12);
    core_js_["ɵɵlistener"]("click", function TuiDocExampleComponent_h3_0_button_2_Template_button_click_0_listener() {
      core_js_["ɵɵrestoreView"](_r9);
      const ctx_r8 = core_js_["ɵɵnextContext"](2);
      return ctx_r8.copyExampleLink();
    });
    core_js_["ɵɵpipe"](1, "async");
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r7 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵproperty"]("title", core_js_["ɵɵpipeBind1"](1, 1, ctx_r7.copy$));
  }
}
function TuiDocExampleComponent_h3_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "h3", 10);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵtemplate"](2, TuiDocExampleComponent_h3_0_button_2_Template, 2, 3, "button", 11);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", ctx_r0.heading, " ");
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", ctx_r0.id);
  }
}
function TuiDocExampleComponent_h4_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "h4", 13);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate"](ctx_r1.description);
  }
}
function TuiDocExampleComponent_button_5_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "button", 14);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const tab_r10 = ctx.$implicit;
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate"](tab_r10);
  }
}
function TuiDocExampleComponent_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "button", 15);
    core_js_["ɵɵlistener"]("click", function TuiDocExampleComponent_button_6_Template_button_click_0_listener() {
      core_js_["ɵɵrestoreView"](_r12);
      const ctx_r11 = core_js_["ɵɵnextContext"]();
      return ctx_r11.codeEditor.open(ctx_r11.componentName, ctx_r11.id || "", ctx_r11.processedContent);
    });
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r3 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" Edit on ", ctx_r3.codeEditor.name, " ");
  }
}
function TuiDocExampleComponent_div_8_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 16);
    core_js_["ɵɵprojection"](1);
    core_js_["ɵɵelementEnd"]();
  }
}
function TuiDocExampleComponent_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-doc-copy", 17);
    core_js_["ɵɵelement"](1, "tui-doc-code", 18);
  }
  if (rf & 2) {
    const ctx_r6 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("cdkCopyToClipboard", ctx_r6.code);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("code", ctx_r6.code);
  }
}
function TuiDocMainComponent_tui_theme_night_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-theme-night");
  }
}
const _c6 = [[["tuiDocNavigation"]], [["tuiDocHeader"]], [["tuiOverDialogs"]], [["tuiOverNotifications"]], [["tuiOverPortals"]], [["tuiOverHints"]]];
const _c7 = ["tuiDocNavigation", "tuiDocHeader", "tuiOverDialogs", "tuiOverNotifications", "tuiOverPortals", "tuiOverHints"];
const _c8 = ["tuiDocHeader", ""];
function TuiDocHeaderComponent_tui_doc_navigation_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-doc-navigation", 3);
  }
}
function TuiDocPageComponent_tui_tag_3_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-tag", 9);
  }
}
function TuiDocPageComponent_tui_tag_4_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-tag", 10);
  }
  if (rf & 2) {
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("value", ctx_r1.package)("autoColor", true);
  }
}
const _c9 = function () {
  return {
    exact: true
  };
};
function TuiDocPageComponent_tui_tabs_with_more_5_ng_container_1_ng_container_1_a_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "a", 15);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r13 = core_js_["ɵɵnextContext"](2);
    const tab_r6 = ctx_r13.$implicit;
    const index_r8 = ctx_r13.index;
    const ctx_r12 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵproperty"]("routerLinkActiveOptions", core_js_["ɵɵpureFunction0"](2, _c9));
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", tab_r6.pageTab || ctx_r12.defaultTabs[index_r8], " ");
  }
}
function TuiDocPageComponent_tui_tabs_with_more_5_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiDocPageComponent_tui_tabs_with_more_5_ng_container_1_ng_container_1_a_1_Template, 2, 3, "a", 14);
    core_js_["ɵɵelementContainerEnd"]();
  }
}
function TuiDocPageComponent_tui_tabs_with_more_5_ng_container_1_ng_template_2_a_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "a", 17);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r15 = core_js_["ɵɵnextContext"](2);
    const tab_r6 = ctx_r15.$implicit;
    const index_r8 = ctx_r15.index;
    const ctx_r14 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵproperty"]("routerLink", ctx_r14.getRouterLink(tab_r6.pageTab || ctx_r14.defaultTabs[index_r8]));
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", tab_r6.pageTab || ctx_r14.defaultTabs[index_r8], " ");
  }
}
function TuiDocPageComponent_tui_tabs_with_more_5_ng_container_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵtemplate"](0, TuiDocPageComponent_tui_tabs_with_more_5_ng_container_1_ng_template_2_a_0_Template, 2, 2, "a", 16);
  }
}
function TuiDocPageComponent_tui_tabs_with_more_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiDocPageComponent_tui_tabs_with_more_5_ng_container_1_ng_container_1_Template, 2, 0, "ng-container", 12);
    core_js_["ɵɵtemplate"](2, TuiDocPageComponent_tui_tabs_with_more_5_ng_container_1_ng_template_2_Template, 1, 0, "ng-template", null, 13, core_js_["ɵɵtemplateRefExtractor"]);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const first_r7 = ctx.first;
    const _r10 = core_js_["ɵɵreference"](3);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", first_r7)("ngIfElse", _r10);
  }
}
function TuiDocPageComponent_tui_tabs_with_more_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "tui-tabs-with-more", 11);
    core_js_["ɵɵlistener"]("activeItemIndexChange", function TuiDocPageComponent_tui_tabs_with_more_5_Template_tui_tabs_with_more_activeItemIndexChange_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r17);
      const ctx_r16 = core_js_["ɵɵnextContext"]();
      return ctx_r16.activeItemIndex = $event;
    });
    core_js_["ɵɵtemplate"](1, TuiDocPageComponent_tui_tabs_with_more_5_ng_container_1_Template, 4, 2, "ng-container", 8);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("activeItemIndex", ctx_r2.activeItemIndex);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", ctx_r2.tabConnectors);
  }
}
function TuiDocPageComponent_tui_doc_see_also_9_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-doc-see-also", 18);
  }
  if (rf & 2) {
    const ctx_r3 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("seeAlso", ctx_r3.seeAlso);
  }
}
function TuiDocPageComponent_ng_container_10_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0);
  }
}
function TuiDocPageComponent_ng_container_10_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiDocPageComponent_ng_container_10_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 20);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const tab_r18 = core_js_["ɵɵnextContext"]().$implicit;
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngTemplateOutlet", tab_r18.template);
  }
}
function TuiDocPageComponent_ng_container_10_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiDocPageComponent_ng_container_10_ng_container_1_Template, 2, 1, "ng-container", 19);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const index_r19 = ctx.index;
    const ctx_r4 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", index_r19 === ctx_r4.activeItemIndex);
  }
}
function TuiDocSeeAlsoComponent_ng_container_2_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtext"](1, ", ");
    core_js_["ɵɵelementContainerEnd"]();
  }
}
function TuiDocSeeAlsoComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵelementStart"](1, "a", 2);
    core_js_["ɵɵtext"](2);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵtemplate"](3, TuiDocSeeAlsoComponent_ng_container_2_ng_container_3_Template, 2, 0, "ng-container", 3);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const last_r2 = ctx.last;
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("routerLink", ctx_r0.getRouterLink(item_r1));
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate"](item_r1);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", !last_r2);
  }
}
function TuiDocSourceCodeComponent_div_0_ng_template_1_a_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "a", 3);
  }
  if (rf & 2) {
    const link_r2 = core_js_["ɵɵnextContext"]().$implicit;
    const ctx_r3 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵproperty"]("title", ctx_r3.text)("href", link_r2, core_js_["ɵɵsanitizeUrl"]);
  }
}
function TuiDocSourceCodeComponent_div_0_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵtemplate"](0, TuiDocSourceCodeComponent_div_0_ng_template_1_a_0_Template, 1, 2, "a", 2);
  }
  if (rf & 2) {
    const link_r2 = ctx.$implicit;
    core_js_["ɵɵproperty"]("ngIf", link_r2);
  }
}
function TuiDocSourceCodeComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 1);
    core_js_["ɵɵtemplate"](1, TuiDocSourceCodeComponent_div_0_ng_template_1_Template, 1, 1, "ng-template");
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("content", ctx_r0.sourceCode)("context", ctx_r0.pathOptions);
  }
}
let TuiDocCodeComponent = /*#__PURE__*/(() => {
  let TuiDocCodeComponent = class TuiDocCodeComponent {
    constructor() {
      this.filename = '';
      this.code = '';
    }
    get hasFilename() {
      return !!this.filename;
    }
  };
  TuiDocCodeComponent.ɵfac = function TuiDocCodeComponent_Factory(t) {
    return new (t || TuiDocCodeComponent)();
  };
  TuiDocCodeComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDocCodeComponent,
    selectors: [["tui-doc-code"]],
    hostVars: 2,
    hostBindings: function TuiDocCodeComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("_has-filename", ctx.hasFilename);
      }
    },
    inputs: {
      filename: "filename",
      code: "code"
    },
    decls: 3,
    vars: 3,
    consts: [["class", "header", 4, "ngIf"], [1, "code"], [3, "lineNumbers", "highlight"], [1, "header"]],
    template: function TuiDocCodeComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵtemplate"](0, TuiDocCodeComponent_p_0_Template, 2, 1, "p", 0);
        core_js_["ɵɵelementStart"](1, "pre", 1);
        core_js_["ɵɵelement"](2, "code", 2);
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngIf", ctx.filename);
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵproperty"]("lineNumbers", true)("highlight", ctx.code);
      }
    },
    directives: [common_js_.NgIf, ngx_highlightjs/* Highlight */.y$],
    styles: ["[_nghost-%COMP%]{display:block}.header[_ngcontent-%COMP%]{font:var(--tui-font-text-s);font-weight:700}.code[_ngcontent-%COMP%]{margin:0}.hljs[_ngcontent-%COMP%]:not(:empty){font:var(--tui-font-text-m);padding:24px 32px;font-family:monospace;background-color:var(--tui-base-02);word-wrap:break-word;white-space:pre-wrap}@media all and (-webkit-min-device-pixel-ratio:0) and (min-resolution:0.001dpcm){.hljs[_ngcontent-%COMP%]:not(:empty)::-webkit-scrollbar, .hljs[_ngcontent-%COMP%]:not(:empty)::-webkit-scrollbar-thumb{width:16px;height:16px;border-radius:100px;background-clip:padding-box;border:6px solid transparent}.hljs[_ngcontent-%COMP%]:not(:empty)::-webkit-scrollbar{background-color:transparent}.hljs[_ngcontent-%COMP%]:not(:empty)::-webkit-scrollbar-thumb{background-color:var(--tui-clear-hover)}.hljs[_ngcontent-%COMP%]:not(:empty)::-webkit-scrollbar-thumb:hover{background-color:var(--tui-clear-active)}.hljs[_ngcontent-%COMP%]:not(:empty)::-webkit-scrollbar-thumb:active{background-color:var(--tui-text-03)}}._has-filename[_nghost-%COMP%]   .hljs[_ngcontent-%COMP%]:not(:empty){border-radius:12px}@media screen and (max-width:599px){.hljs[_ngcontent-%COMP%]:not(:empty){padding:16px}}"]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocCodeComponent.prototype, "filename", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocCodeComponent.prototype, "code", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._has-filename')], TuiDocCodeComponent.prototype, "hasFilename", null);
  return TuiDocCodeComponent;
})();
let TuiDocCodeModule = /*#__PURE__*/(() => {
  let TuiDocCodeModule = class TuiDocCodeModule {};
  TuiDocCodeModule.ɵfac = function TuiDocCodeModule_Factory(t) {
    return new (t || TuiDocCodeModule)();
  };
  TuiDocCodeModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocCodeModule
  });
  TuiDocCodeModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, ngx_highlightjs/* HighlightModule */._l]]
  });
  return TuiDocCodeModule;
})();
const COPIED_TIMEOUT = 1500;
// @dynamic
let TuiDocCopyComponent = /*#__PURE__*/(() => {
  let TuiDocCopyComponent = class TuiDocCopyComponent {
    constructor(texts$) {
      this.texts$ = texts$;
      this.copy$ = new Subject/* Subject */.xQ();
    }
    get copied$() {
      return this.copy$.pipe((0,switchMapTo/* switchMapTo */.c)((0,timer/* timer */.H)(COPIED_TIMEOUT).pipe((0,mapTo/* mapTo */.h)(false), (0,startWith/* startWith */.O)(true))));
    }
    onClick() {
      this.copy$.next();
    }
  };
  TuiDocCopyComponent.ɵfac = function TuiDocCopyComponent_Factory(t) {
    return new (t || TuiDocCopyComponent)(core_js_["ɵɵdirectiveInject"](TUI_COPY_TEXTS));
  };
  TuiDocCopyComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDocCopyComponent,
    selectors: [["tui-doc-copy"]],
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])],
    ngContentSelectors: taiga_ui_addon_doc_c0,
    decls: 2,
    vars: 3,
    consts: [["tuiButton", "", "type", "button", "class", "copy", "appearance", "", "size", "s", 3, "title", "click", 4, "ngIf"], ["tuiButton", "", "type", "button", "appearance", "", "size", "s", 1, "copy", 3, "title", "click"], [1, "content"], [1, "initial"]],
    template: function TuiDocCopyComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵtemplate"](0, TuiDocCopyComponent_button_0_Template, 6, 7, "button", 0);
        core_js_["ɵɵpipe"](1, "async");
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngIf", core_js_["ɵɵpipeBind1"](1, 1, ctx.texts$));
      }
    },
    directives: [common_js_.NgIf, taiga_ui_core_components_button/* TuiButtonComponent */.v],
    pipes: [common_js_.AsyncPipe],
    styles: ["[_nghost-%COMP%]{position:relative;display:inline-block;vertical-align:middle}.copy[_ngcontent-%COMP%]{transition-property:background;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;width:100%;color:var(--tui-text-01);background:var(--tui-base-01);overflow:hidden}.copy[_ngcontent-%COMP%]:hover{background:var(--tui-base-02)}.initial[_ngcontent-%COMP%]{white-space:nowrap}.initial[_ngcontent-%COMP%]:empty:before{content:attr(data-text)}.content[_ngcontent-%COMP%]{transition-property:transform;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;display:flex;flex-direction:column;transform:translateY(16px);text-align:center;line-height:32px}.content_moved[_ngcontent-%COMP%]{transform:translateY(-16px)}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDocCopyComponent.prototype, "copied$", null);
  TuiDocCopyComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TUI_COPY_TEXTS))], TuiDocCopyComponent);
  return TuiDocCopyComponent;
})();
let TuiDocCopyModule = /*#__PURE__*/(() => {
  let TuiDocCopyModule = class TuiDocCopyModule {};
  TuiDocCopyModule.ɵfac = function TuiDocCopyModule_Factory(t) {
    return new (t || TuiDocCopyModule)();
  };
  TuiDocCopyModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocCopyModule
  });
  TuiDocCopyModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, taiga_ui_core_components_button/* TuiButtonModule */.f]]
  });

  /**
   * TODO: think about reorganization in @taiga-ui/i18n way
   */
  /**
   * Works with a tuple
   * [@string tuiMode tooltip content, @string word 'background', @string 'form value']
   */
  return TuiDocCopyModule;
})();
const TUI_DOC_DEMO_TEXTS = new core_js_.InjectionToken('tui-doc-demo i18n texts', {
  factory: () => ['Read more more about modes: ', 'Background', 'Form value']
});
/**
 * Works with a tuple
 * [
 * @string word 'argument',
 * @string word 'type',
 * @string 'name and description',
 * @string word 'value'
 * @string message for tooltip about ng-polymorpheus
 * ]
 */
const TUI_DOC_DOCUMENTATION_TEXTS = new core_js_.InjectionToken('tui-doc-documentation i18n texts', {
  factory: () => ['Argument', 'Type', 'Name and description', 'Value', 'Learn about our dynamic templates from ']
});
/**
 * Works with a tuple
 * [
 * @string default tab name,
 * @string link to a sample copied message text,
 * @string link to a sample copied message label
 * ]
 */
const TUI_DOC_EXAMPLE_TEXTS = new core_js_.InjectionToken('tui-doc-example i18n texts', {
  factory: () => ['Preview', 'Link to a sample was successfully copied', 'Done']
});
const TUI_DOC_MENU_TEXT = new core_js_.InjectionToken('menu i18n text', {
  factory: () => 'Menu'
});
const TUI_DOC_SEARCH_TEXT = new core_js_.InjectionToken('search i18n text', {
  factory: () => 'Search'
});
const TUI_DOC_SEE_ALSO_TEXT = new core_js_.InjectionToken('tui-doc-see-also i18n text', {
  factory: () => 'See also'
});
const TUI_DOC_SOURCE_CODE_TEXT = new core_js_.InjectionToken('tui-doc-source-code i18n text', {
  factory: () => 'Source code'
});
var TuiDocDemoComponent_1;
const MIN_COMPONENT_WIDTH = 104;
// @dynamic
let TuiDocDemoComponent = TuiDocDemoComponent_1 = class TuiDocDemoComponent {
  constructor(isMobile, destroy$, renderer, platformId, locationRef, urlSerializer, texts) {
    this.isMobile = isMobile;
    this.destroy$ = destroy$;
    this.renderer = renderer;
    this.texts = texts;
    this.control = null;
    this.updateOnVariants = ['change', 'blur', 'submit'];
    this.updateOn = 'change';
    this.expanded = false;
    this.opaque = true;
    this.modeControl = new fesm2015_forms.FormControl();
    this.mode = null;
    this.change$ = new Subject/* Subject */.xQ();
    this.items = ['onLight', 'onDark'];
    this.initialX = 0;
    this.wrapperWidth = 0;
    this.isBrowser = (0,common_js_.isPlatformBrowser)(platformId);
    const parsedMode = locationRef.path().match(/tui-mode=(onDark|onLight)/);
    if (parsedMode !== null && parsedMode.length > 0) {
      this.modeControl.setValue(parsedMode[1]);
    }
    this.modeControl.valueChanges.pipe((0,startWith/* startWith */.O)(this.modeControl.value), (0,takeUntil/* takeUntil */.R)(this.destroy$)).subscribe(mode => {
      const urlTree = urlSerializer.parse(locationRef.path());
      urlTree.queryParams = Object.assign(Object.assign({}, urlTree.queryParams), {
        tuiMode: mode
      });
      locationRef.go(String(urlTree));
      this.mode = mode;
      this.change$.next();
    });
  }
  ngOnInit() {
    this.createForm();
  }
  ngAfterViewInit() {
    this.setResizerTextContent();
  }
  setResizerTextContent() {
    if (!this.content || !this.resizerText) {
      return;
    }
    const paddingLeft = this.isBrowser ? getComputedStyle(this.content.nativeElement).paddingLeft : '0';
    const {
      offsetWidth
    } = this.content.nativeElement;
    this.resizerText.nativeElement.textContent = String(offsetWidth - parseInt(paddingLeft || '0', 10) * 2);
  }
  onResize() {
    this.setResizerTextContent();
  }
  onDragStart(event) {
    event.preventDefault();
    this.initialX = event.clientX;
    this.wrapperWidth = this.wrapper ? this.wrapper.nativeElement.offsetWidth : 0;
  }
  onDragContinues(event) {
    const deltaX = this.initialX - event.clientX;
    this.resizeContent(deltaX);
    this.setResizerTextContent();
  }
  onDragEnd() {
    this.wrapperWidth = this.wrapper ? this.wrapper.nativeElement.offsetWidth : 0;
  }
  toggleDetails() {
    this.expanded = !this.expanded;
  }
  updateOnChange(updateOn) {
    this.updateOn = updateOn;
    this.createForm();
  }
  createForm() {
    const {
      control,
      updateOn
    } = this;
    if (!control) {
      return;
    }
    this.testForm = new fesm2015_forms.FormGroup({
      testValue: control
    }, {
      updateOn
    });
  }
  resizeContent(delta) {
    if (!this.wrapper) {
      return;
    }
    this.renderer.setStyle(this.wrapper.nativeElement, 'width', `${Math.max(this.wrapperWidth - delta, MIN_COMPONENT_WIDTH)}px`);
  }
};
TuiDocDemoComponent.ɵfac = function TuiDocDemoComponent_Factory(t) {
  return new (t || TuiDocDemoComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3), core_js_["ɵɵdirectiveInject"](core_js_.Renderer2), core_js_["ɵɵdirectiveInject"](core_js_.PLATFORM_ID), core_js_["ɵɵdirectiveInject"](common_js_.Location), core_js_["ɵɵdirectiveInject"](router_js_.UrlSerializer), core_js_["ɵɵdirectiveInject"](TUI_DOC_DEMO_TEXTS));
};
TuiDocDemoComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiDocDemoComponent,
  selectors: [["tui-doc-demo"]],
  contentQueries: function TuiDocDemoComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      core_js_["ɵɵcontentQuery"](dirIndex, core_js_.TemplateRef, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.template = _t.first);
    }
  },
  viewQuery: function TuiDocDemoComponent_Query(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵviewQuery"](taiga_ui_addon_doc_c1, 5);
      core_js_["ɵɵviewQuery"](taiga_ui_addon_doc_c2, 5);
      core_js_["ɵɵviewQuery"](taiga_ui_addon_doc_c3, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.content = _t.first);
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.wrapper = _t.first);
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.resizerText = _t.first);
    }
  },
  hostBindings: function TuiDocDemoComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵlistener"]("resize", function TuiDocDemoComponent_resize_HostBindingHandler() {
        return ctx.onResize();
      }, false, core_js_["ɵɵresolveWindow"]);
    }
  },
  inputs: {
    control: "control"
  },
  features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3, {
    provide: taiga_ui_core_directives_mode/* TuiModeDirective */.w,
    useExisting: (0,core_js_.forwardRef)(() => TuiDocDemoComponent_1)
  }])],
  ngContentSelectors: taiga_ui_addon_doc_c0,
  decls: 17,
  vars: 12,
  consts: [[1, "bg-toggle", 3, "tuiMode"], ["tooltip", ""], [4, "ngIf", "ngIfElse"], ["desktop", ""], ["size", "m", 1, "tui-space_left-3", 3, "ngModel", "ngModelChange"], [1, "wrapper"], ["wrapper", ""], ["id", "demoContent", 1, "content"], ["content", ""], ["class", "form", 3, "formGroup", 4, "ngIf"], ["tabindex", "-1", 1, "resizer", 3, "tuiDragStart", "tuiDragContinues", "tuiDragEnd"], [1, "resizer-text"], ["resizerText", ""], ["tuiLink", "", "tuiMode", "onDark", "routerLink", "/directives/mode"], ["tuiTextfieldSize", "s", 1, "mode", 3, "tuiTextfieldCleaner", "tuiHintContent", "formControl"], [3, "items", 4, "tuiDataList"], [3, "items"], ["describeId", "form", 3, "content"], ["tuiGroup", "", 1, "tui-space_left-3", 3, "collapsed"], ["size", "s", "nativeId", "form", 1, "tui-group__auto-width-item", 3, "item", "hideRadio", "formControl"], ["item", "onDark", "size", "s", "nativeId", "form", 1, "tui-group__auto-width-item", 3, "hideRadio", "formControl"], ["item", "onLight", "size", "s", "nativeId", "form", 1, "tui-group__auto-width-item", 3, "hideRadio", "formControl"], [1, "form", 3, "formGroup"], [1, "input-wrapper"], [4, "ngTemplateOutlet"], ["tuiButton", "", "type", "button", "size", "s", 1, "tui-space_top-3", 3, "iconRight", "click"], ["icon", ""], [1, "expand", 3, "expanded"], ["tuiExpandContent", ""], ["src", "tuiIconChevronDown", 1, "icon"], [1, "value"], ["tuiGroup", "", 1, "tui-space_top-3"], ["tuiTextfieldSize", "s", 1, "select", 3, "ngModel", "ngModelOptions", "ngModelChange"], ["tuiButton", "", "type", "reset", "size", "s", 1, "tui-group__auto-width-item"], ["tuiButton", "", "type", "submit", "size", "s", 1, "tui-group__auto-width-item"]],
  template: function TuiDocDemoComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"]();
      core_js_["ɵɵelementStart"](0, "div", 0);
      core_js_["ɵɵtemplate"](1, TuiDocDemoComponent_ng_template_1_Template, 4, 1, "ng-template", null, 1, core_js_["ɵɵtemplateRefExtractor"]);
      core_js_["ɵɵtemplate"](3, TuiDocDemoComponent_ng_container_3_Template, 4, 3, "ng-container", 2);
      core_js_["ɵɵtemplate"](4, TuiDocDemoComponent_ng_template_4_Template, 9, 9, "ng-template", null, 3, core_js_["ɵɵtemplateRefExtractor"]);
      core_js_["ɵɵelementStart"](6, "tui-checkbox-labeled", 4);
      core_js_["ɵɵlistener"]("ngModelChange", function TuiDocDemoComponent_Template_tui_checkbox_labeled_ngModelChange_6_listener($event) {
        return ctx.opaque = $event;
      });
      core_js_["ɵɵtext"](7);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementStart"](8, "div", 5, 6);
      core_js_["ɵɵelementStart"](10, "div", 7, 8);
      core_js_["ɵɵtemplate"](12, TuiDocDemoComponent_form_12_Template, 9, 5, "form", 9);
      core_js_["ɵɵprojection"](13);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementStart"](14, "button", 10);
      core_js_["ɵɵlistener"]("tuiDragStart", function TuiDocDemoComponent_Template_button_tuiDragStart_14_listener($event) {
        return ctx.onDragStart($event);
      })("tuiDragContinues", function TuiDocDemoComponent_Template_button_tuiDragContinues_14_listener($event) {
        return ctx.onDragContinues($event);
      })("tuiDragEnd", function TuiDocDemoComponent_Template_button_tuiDragEnd_14_listener() {
        return ctx.onDragEnd();
      });
      core_js_["ɵɵelement"](15, "span", 11, 12);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      const _r3 = core_js_["ɵɵreference"](5);
      core_js_["ɵɵproperty"]("tuiMode", null);
      core_js_["ɵɵadvance"](3);
      core_js_["ɵɵproperty"]("ngIf", ctx.isMobile)("ngIfElse", _r3);
      core_js_["ɵɵadvance"](3);
      core_js_["ɵɵproperty"]("ngModel", ctx.opaque);
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵtextInterpolate1"](" ", ctx.texts[1], " ");
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵclassProp"]("wrapper_dark", ctx.modeControl.value === "onDark")("wrapper_gray", ctx.modeControl.value === "onLight")("wrapper_transparent", !ctx.opaque);
      core_js_["ɵɵadvance"](4);
      core_js_["ɵɵproperty"]("ngIf", ctx.testForm);
    }
  },
  directives: [taiga_ui_core_directives_mode/* TuiModeDirective */.w, common_js_.NgIf, TuiCheckboxLabeledComponent, fesm2015_forms.NgControlStatus, fesm2015_forms.NgModel, TuiDragDirective, taiga_ui_core_components_link/* TuiLinkComponent */.V, router_js_.RouterLinkWithHref, TuiSelectComponent, TuiTextfieldSizeDirective, TuiTextfieldCleanerDirective, TuiHintControllerDirective, fesm2015_forms.FormControlDirective, TuiDataListDirective, TuiDataListWrapperComponent, TuiTooltipComponent, TuiGroupDirective, TuiRadioBlockComponent, fesm2015_forms["ɵNgNoValidate"], fesm2015_forms.NgControlStatusGroup, fesm2015_forms.FormGroupDirective, common_js_.NgTemplateOutlet, taiga_ui_core_components_button/* TuiButtonComponent */.v, TuiExpandComponent, TuiExpandContentDirective, taiga_ui_core_components_svg/* TuiSvgComponent */.P],
  pipes: [common_js_.JsonPipe],
  styles: ["[_nghost-%COMP%]{position:relative;display:block;min-width:100%;margin:24px 0}.bg-toggle[_ngcontent-%COMP%]{position:absolute;bottom:calc(100% + 12px);display:flex;align-items:center;justify-content:flex-end;pointer-events:none;width:100%}.bg-toggle[_ngcontent-%COMP%] > *[_ngcontent-%COMP%]{pointer-events:auto}.wrapper[_ngcontent-%COMP%]{box-shadow:0 8px 16px rgba(51,51,51,.2);display:flex;border:1px solid var(--tui-base-03);border-radius:var(--tui-radius-m);max-width:100%;min-height:96px;width:100%;background-color:var(--tui-base-01);overflow:hidden}.wrapper.wrapper_transparent[_ngcontent-%COMP%]{background-image:linear-gradient(45deg,var(--tui-base-02) 25%,transparent 25%),linear-gradient(-45deg,var(--tui-base-02) 25%,transparent 25%),linear-gradient(45deg,transparent 75%,var(--tui-base-02) 75%),linear-gradient(-45deg,transparent 75%,var(--tui-base-02) 75%);background-size:20px 20px;background-position:0 0,0 10px,10px -10px,-10px 0}.wrapper.wrapper_dark[_ngcontent-%COMP%]{background-color:#454e58;color:var(--tui-base-01)}.wrapper.wrapper_gray[_ngcontent-%COMP%]{background-color:#e5e7ea}.wrapper.wrapper_dark.wrapper_transparent[_ngcontent-%COMP%]{background-image:linear-gradient(45deg,var(--tui-focus) 25%,transparent 25%),linear-gradient(-45deg,var(--tui-focus) 25%,transparent 25%),linear-gradient(45deg,transparent 75%,var(--tui-focus) 75%),linear-gradient(-45deg,transparent 75%,var(--tui-focus) 75%)}.wrapper.wrapper_gray.wrapper_transparent[_ngcontent-%COMP%]{background-image:linear-gradient(45deg,var(--tui-base-05) 25%,transparent 25%),linear-gradient(-45deg,var(--tui-base-05) 25%,transparent 25%),linear-gradient(45deg,transparent 75%,var(--tui-base-05) 75%),linear-gradient(-45deg,transparent 75%,var(--tui-base-05) 75%)}.content[_ngcontent-%COMP%]{flex:1 1 0;min-width:0;padding:24px;box-sizing:border-box;overflow:hidden}@media screen and (max-width:599px){.wrapper[_ngcontent-%COMP%]{min-height:auto}.content[_ngcontent-%COMP%]{padding:16px}}.form[_ngcontent-%COMP%]{display:flex;flex-wrap:wrap;align-items:flex-start}.input-wrapper[_ngcontent-%COMP%]{width:100%;margin-bottom:8px}.expand[_ngcontent-%COMP%]{width:100%}.icon[_ngcontent-%COMP%]{transition-property:transform;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out}.icon_rotated[_ngcontent-%COMP%]{transform:rotate(180deg)}.value[_ngcontent-%COMP%]{flex:1;background:var(--tui-clear-inverse);padding:12px;border-radius:4px}.mode[_ngcontent-%COMP%]{width:200px}.select[_ngcontent-%COMP%]{max-width:240px}.resizer[_ngcontent-%COMP%]{-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:0;border:0;background:0 0;font-size:inherit;line-height:inherit;box-shadow:0 8px 16px rgba(51,51,51,.2);position:relative;width:56px;min-height:inherit;flex-shrink:0;border-left:1px solid var(--tui-base-03);cursor:col-resize;outline:0;background:var(--tui-base-01);color:var(--tui-text-01)}.resizer[_ngcontent-%COMP%]:after, .resizer[_ngcontent-%COMP%]:before{content:'';position:absolute;top:12px;left:50%;bottom:12px;width:1px;background:var(--tui-base-05)}.resizer[_ngcontent-%COMP%]:before{transform:translateX(2px)}.resizer[_ngcontent-%COMP%]:after{transform:translateX(-3px)}@media screen and (max-width:599px){.resizer[_ngcontent-%COMP%]{display:none}}.resizer-text[_ngcontent-%COMP%]{font:var(--tui-font-text-s);position:relative;z-index:1;padding:12px;background:var(--tui-base-01)}.wrapper_light[_ngcontent-%COMP%]   .resizer-text[_ngcontent-%COMP%]{background:#3e464e}@supports ((position:-webkit-sticky) or (position:sticky)){@media screen and (min-height:600px){[_nghost-%COMP%]{position:-webkit-sticky;position:sticky;top:74px;z-index:2}}}"],
  changeDetection: 0
});
TuiDocDemoComponent.ctorParameters = () => [{
  type: Boolean,
  decorators: [{
    type: core_js_.Inject,
    args: [taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL]
  }]
}, {
  type: taiga_ui_cdk_services/* TuiDestroyService */.a3,
  decorators: [{
    type: core_js_.Inject,
    args: [taiga_ui_cdk_services/* TuiDestroyService */.a3]
  }]
}, {
  type: core_js_.Renderer2,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.Renderer2]
  }]
}, {
  type: Object,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.PLATFORM_ID]
  }]
}, {
  type: common_js_.Location,
  decorators: [{
    type: core_js_.Inject,
    args: [common_js_.Location]
  }]
}, {
  type: router_js_.UrlSerializer,
  decorators: [{
    type: core_js_.Inject,
    args: [router_js_.UrlSerializer]
  }]
}, {
  type: Array,
  decorators: [{
    type: core_js_.Inject,
    args: [TUI_DOC_DEMO_TEXTS]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocDemoComponent.prototype, "control", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChild)(core_js_.TemplateRef)], TuiDocDemoComponent.prototype, "template", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('content')], TuiDocDemoComponent.prototype, "content", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('wrapper')], TuiDocDemoComponent.prototype, "wrapper", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('resizerText')], TuiDocDemoComponent.prototype, "resizerText", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('window:resize')], TuiDocDemoComponent.prototype, "onResize", null);
TuiDocDemoComponent = TuiDocDemoComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.Renderer2)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(core_js_.PLATFORM_ID)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(common_js_.Location)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(router_js_.UrlSerializer)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(TUI_DOC_DEMO_TEXTS))], TuiDocDemoComponent);
let TuiDocDemoModule = /*#__PURE__*/(() => {
  let TuiDocDemoModule = class TuiDocDemoModule {};
  TuiDocDemoModule.ɵfac = function TuiDocDemoModule_Factory(t) {
    return new (t || TuiDocDemoModule)();
  };
  TuiDocDemoModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocDemoModule
  });
  TuiDocDemoModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, fesm2015_forms.ReactiveFormsModule, fesm2015_forms.FormsModule, router_js_.RouterModule, taiga_ui_core_components_link/* TuiLinkModule */.j, TuiDragModule, taiga_ui_core_components_button/* TuiButtonModule */.f, TuiSelectModule, TuiExpandModule, TuiGroupModule, TuiTooltipModule, taiga_ui_core_directives_mode/* TuiModeModule */.z, TuiRadioBlockModule, TuiCheckboxLabeledModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiDataListWrapperModule, TuiDataListModule, TuiTextfieldControllerModule, TuiHintControllerModule]]
  });
  return TuiDocDemoModule;
})();
const MAP = {
  а: 'f',
  б: ',',
  в: 'd',
  г: 'u',
  д: 'l',
  е: 't',
  ё: '`',
  ж: ';',
  з: 'p',
  и: 'b',
  й: 'q',
  к: 'r',
  л: 'k',
  м: 'v',
  н: 'y',
  о: 'j',
  п: 'g',
  р: 'h',
  с: 'c',
  т: 'n',
  у: 'e',
  ф: 'a',
  х: '[',
  ц: 'w',
  ч: 'x',
  ш: 'i',
  щ: 'o',
  ъ: ']',
  ы: 's',
  ь: 'm',
  ю: '.',
  я: 'z'
};
/**
 * Translates text mistakenly typed in the Russian layout into English
 * @param string string with Russian layout characters
 * @return string with English layout characters
 */
function transliterateKeyboardLayout(string) {
  let newStr = '';
  for (let i = 0; i < string.length; i++) {
    newStr += string.charAt(i) in MAP ? MAP[string.charAt(i)] : string.charAt(i);
  }
  return newStr;
}
const TUI_DOC_PAGES = new core_js_.InjectionToken('Documentation pages', {
  factory: () => []
});
const TUI_DOC_TITLE = new core_js_.InjectionToken('Page title', {
  factory: () => ''
});
const NAVIGATION_TITLE = new core_js_.InjectionToken('Page title');
const NAVIGATION_LABELS = new core_js_.InjectionToken('Navigation sections labels for search');
const NAVIGATION_ITEMS = new core_js_.InjectionToken('Navigation pages');
const NAVIGATION_PROVIDERS = [taiga_ui_cdk_services/* TuiDestroyService */.a3, {
  provide: NAVIGATION_TITLE,
  deps: [router_js_.Router, router_js_.ActivatedRoute, TUI_DOC_TITLE, taiga_ui_cdk_services/* TuiDestroyService */.a3],
  useFactory: titleProviderFactory
}, {
  provide: NAVIGATION_LABELS,
  deps: [TUI_DOC_PAGES],
  useFactory: labelsProviderFactory
}, {
  provide: NAVIGATION_ITEMS,
  deps: [TUI_DOC_PAGES],
  useFactory: itemsProviderFactory
}];
function titleProviderFactory(router, activatedRoute, titlePrefix, destroy$) {
  return router.events.pipe((0,filter/* filter */.h)(event => event instanceof router_js_.NavigationEnd), (0,map/* map */.U)(() => activatedRoute.firstChild), (0,filter/* filter */.h)(taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN), (0,mergeMap/* mergeMap */.zg)(({
    data
  }) => data), (0,map/* map */.U)(({
    title
  }) => titlePrefix + title), (0,takeUntil/* takeUntil */.R)(destroy$));
}
function labelsProviderFactory(pages) {
  return pages.map(({
    section
  }) => section).filter((item, index, array) => array.indexOf(item) === index);
}
function itemsProviderFactory(pages) {
  const labels = labelsProviderFactory(pages);
  return labels.map(label => pages.filter(({
    section
  }) => section === label));
}
const SMALL_TABLET_SCREEN = 767;
const SCROLL_INTO_VIEW_DELAY = 200;
// @dynamic
let TuiDocNavigationComponent = /*#__PURE__*/(() => {
  let TuiDocNavigationComponent = class TuiDocNavigationComponent {
    constructor(titleService, locationRef, title$, documentRef, mode, labels, items, searchText) {
      this.documentRef = documentRef;
      this.mode = mode;
      this.labels = labels;
      this.items = items;
      this.searchText = searchText;
      this.search = '';
      this.open = false;
      this.menuOpen = false;
      this.openGroupsArr = [];
      this.mode$ = this.mode.change$.pipe((0,startWith/* startWith */.O)(null), (0,map/* map */.U)(() => this.mode.mode || 'onLight'));
      // Angular can't navigate no anchor links
      // https://stackoverflow.com/questions/36101756/angular2-routing-with-hashtag-to-page-anchor
      title$.subscribe(title => {
        titleService.setTitle(title);
        this.handleAnchorLink(locationRef.path(true));
      });
    }
    get openMenu() {
      return this.menuOpen;
    }
    get canOpen() {
      return this.search.length > 2;
    }
    get filteredItems() {
      return this.filterItems(this.flattenSubPages(this.items), this.search);
    }
    onGroupClick(index) {
      this.openGroupsArr[index] = !this.openGroupsArr[index];
    }
    toggleMenu() {
      if ((0,taiga_ui_core_utils_dom/* getScreenWidth */.zP)(this.documentRef) <= SMALL_TABLET_SCREEN) {
        this.menuOpen = !this.menuOpen;
      }
    }
    onSearchChange(search) {
      this.search = search;
      this.open = this.canOpen;
    }
    onClick() {
      this.open = false;
      this.menuOpen = false;
      this.search = '';
    }
    filterItems(items, search) {
      return items.map(section => (0,taiga_ui_cdk_utils_miscellaneous/* uniqBy */.mN)(section.filter(({
        title,
        keywords = ''
      }) => {
        title = title.toLowerCase();
        search = search.toLowerCase();
        keywords = keywords.toLowerCase();
        return title.includes(search) || keywords.includes(search) || title.includes(transliterateKeyboardLayout(search)) || keywords.includes(transliterateKeyboardLayout(search)) || search.replace(/-/gi, '').includes(title);
      }), 'title'));
    }
    flattenSubPages(items) {
      return items.reduce((array, item) => [...array, item.reduce((pages, page) => 'subPages' in page ? [...pages, ...page.subPages] : [...pages, page], [])], []);
    }
    handleAnchorLink(path) {
      const lastIndex = path.lastIndexOf('#');
      const hash = lastIndex === -1 ? '' : path.substr(lastIndex);
      if (!hash) {
        return;
      }
      setTimeout(() => {
        this.navigateToAnchorLink(hash);
        this.animateExample(hash);
      }, SCROLL_INTO_VIEW_DELAY);
    }
    navigateToAnchorLink(fragment) {
      const element = this.documentRef.querySelector(fragment);
      if (!element) {
        return;
      }
      element.scrollIntoView({
        block: 'start',
        inline: 'nearest',
        behavior: 'smooth'
      });
    }
    animateExample(fragment) {
      const element = this.documentRef.querySelector(fragment);
      if (element) {
        element.classList.add('tui-doc-animated-example');
      }
    }
  };
  TuiDocNavigationComponent.ɵfac = function TuiDocNavigationComponent_Factory(t) {
    return new (t || TuiDocNavigationComponent)(core_js_["ɵɵdirectiveInject"](platform_browser.Title), core_js_["ɵɵdirectiveInject"](common_js_.Location), core_js_["ɵɵdirectiveInject"](NAVIGATION_TITLE), core_js_["ɵɵdirectiveInject"](common_js_.DOCUMENT), core_js_["ɵɵdirectiveInject"](taiga_ui_core_directives_mode/* TuiModeDirective */.w), core_js_["ɵɵdirectiveInject"](NAVIGATION_LABELS), core_js_["ɵɵdirectiveInject"](NAVIGATION_ITEMS), core_js_["ɵɵdirectiveInject"](TUI_DOC_SEARCH_TEXT));
  };
  TuiDocNavigationComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDocNavigationComponent,
    selectors: [["tui-doc-navigation"]],
    hostVars: 2,
    hostBindings: function TuiDocNavigationComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("_open", ctx.openMenu);
      }
    },
    features: [core_js_["ɵɵProvidersFeature"](NAVIGATION_PROVIDERS)],
    ngContentSelectors: taiga_ui_addon_doc_c0,
    decls: 7,
    vars: 7,
    consts: [["class", "input", "tuiDropdownLimitWidth", "fixed", 3, "content", "canOpen", "open", "openChange", 4, "tuiLet"], [1, "navigation"], [1, "scrollbar"], [3, "tuiMode", "closeOthers", "rounded"], ["size", "s", 3, "borders", 4, "ngFor", "ngForOf"], ["tuiDropdownLimitWidth", "fixed", 1, "input", 3, "content", "canOpen", "open", "openChange"], ["iconAlign", "left", "tuiTextfieldSize", "m", "iconContent", "tuiIconSearch", 3, "pseudoFocused", "tuiTextfieldCleaner", "tuiTextfieldLabelOutside", "value", "valueChange"], ["dropdown", ""], [3, "label", 4, "ngFor", "ngForOf"], [3, "label"], ["tuiOption", "", 3, "routerLink", "click", 4, "ngFor", "ngForOf"], ["tuiOption", "", 3, "routerLink", "click"], ["size", "s", 3, "borders"], [1, "tui-space_left-2"], ["tuiAccordionItemContent", ""], [1, "section"], [4, "ngFor", "ngForOf"], ["tuiLink", "", "class", "sublink", "routerLinkActive", "sublink_active", 3, "routerLink", "click", 4, "ngIf", "ngIfElse"], ["subPages", ""], ["tuiLink", "", "routerLinkActive", "sublink_active", 1, "sublink", 3, "routerLink", "click"], ["routerLinkActive", "", 1, "subsection", 3, "routerLinkActiveOptions"], ["tuiLink", "", "type", "button", "class", "sublink sublink_subsection", 3, "click", 4, "ngIf"], [1, "tui-space_left-1", 3, "expanded"], [1, "section", "section_bordered"], ["tuiLink", "", "class", "sublink sublink_small", "routerLinkActive", "sublink_active", 3, "routerLink", "click", 4, "ngFor", "ngForOf"], ["tuiLink", "", "type", "button", 1, "sublink", "sublink_subsection", 3, "click"], ["src", "tuiIconChevronRight", 1, "chevron"], ["tuiLink", "", "routerLinkActive", "sublink_active", 1, "sublink", "sublink_small", 3, "routerLink", "click"]],
    template: function TuiDocNavigationComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵtemplate"](0, TuiDocNavigationComponent_tui_hosted_dropdown_0_Template, 5, 8, "tui-hosted-dropdown", 0);
        core_js_["ɵɵelementStart"](1, "nav", 1);
        core_js_["ɵɵelementStart"](2, "tui-scrollbar", 2);
        core_js_["ɵɵelementStart"](3, "tui-accordion", 3);
        core_js_["ɵɵpipe"](4, "async");
        core_js_["ɵɵtemplate"](5, TuiDocNavigationComponent_tui_accordion_item_5_Template, 5, 2, "tui-accordion-item", 4);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵprojection"](6);
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("tuiLet", ctx.filteredItems);
        core_js_["ɵɵadvance"](3);
        core_js_["ɵɵproperty"]("tuiMode", core_js_["ɵɵpipeBind1"](4, 5, ctx.mode$))("closeOthers", false)("rounded", false);
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵproperty"]("ngForOf", ctx.labels);
      }
    },
    directives: [taiga_ui_cdk_directives_let/* TuiLetDirective */.Ls, TuiScrollbarComponent, TuiAccordionComponent, taiga_ui_core_directives_mode/* TuiModeDirective */.w, common_js_.NgForOf, TuiHostedDropdownComponent, TuiDropdownControllerDirective, TuiPrimitiveTextfieldComponent, TuiTextfieldSizeDirective, TuiTextfieldCleanerDirective, TuiTextfieldLabelOutsideDirective, TuiDataListComponent, TuiOptGroupDirective, TuiOptionComponent, router_js_.RouterLinkWithHref, TuiAccordionItemComponent, TuiAccordionItemContentDirective, common_js_.NgIf, taiga_ui_core_components_link/* TuiLinkComponent */.V, router_js_.RouterLinkActive, TuiExpandComponent, taiga_ui_core_components_svg/* TuiSvgComponent */.P],
    pipes: [common_js_.AsyncPipe],
    styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;text-align:center;background:var(--tui-base-01);z-index:1}.input[_ngcontent-%COMP%]{display:block;margin:20px}.navigation[_ngcontent-%COMP%]{display:flex;max-height:100%;min-height:0;flex:1 1 0;text-align:left}.scrollbar[_ngcontent-%COMP%]{width:100%}.section[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:flex-start;margin:-16px 0 -8px}.section_bordered[_ngcontent-%COMP%]{margin:8px 0;border-left:1px solid var(--tui-base-03)}.subsection[_ngcontent-%COMP%]{margin-left:8px}.sublink[_ngcontent-%COMP%]{-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:0;border:0;background:0 0;font-size:inherit;font:var(--tui-font-text-m);margin-left:8px;line-height:44px}.sublink_small[_ngcontent-%COMP%]{margin-left:16px;line-height:24px}.sublink_small[_ngcontent-%COMP%]:not(:first-child){margin-top:16px}.sublink_subsection[_ngcontent-%COMP%]{margin-left:0;line-height:44px}.sublink_active[_ngcontent-%COMP%]{color:var(--tui-text-01)}.chevron[_ngcontent-%COMP%]{transition-property:transform;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;width:16px;height:16px;margin:-4px 4px 0 -3px}.chevron_active[_ngcontent-%COMP%]{transform:rotate(90deg)}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._open')], TuiDocNavigationComponent.prototype, "openMenu", null);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDocNavigationComponent.prototype, "filterItems", null);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDocNavigationComponent.prototype, "flattenSubPages", null);
  TuiDocNavigationComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(platform_browser.Title)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(common_js_.Location)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(NAVIGATION_TITLE)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(common_js_.DOCUMENT)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(taiga_ui_core_directives_mode/* TuiModeDirective */.w)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(NAVIGATION_LABELS)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(NAVIGATION_ITEMS)), (0,tslib_es6/* __param */.fM)(7, (0,core_js_.Inject)(TUI_DOC_SEARCH_TEXT))], TuiDocNavigationComponent);
  return TuiDocNavigationComponent;
})();
let TuiDocNavigationModule = /*#__PURE__*/(() => {
  let TuiDocNavigationModule = class TuiDocNavigationModule {};
  TuiDocNavigationModule.ɵfac = function TuiDocNavigationModule_Factory(t) {
    return new (t || TuiDocNavigationModule)();
  };
  TuiDocNavigationModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocNavigationModule
  });
  TuiDocNavigationModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, fesm2015_forms.FormsModule, router_js_.RouterModule, taiga_ui_core_components_button/* TuiButtonModule */.f, TuiPrimitiveTextfieldModule, TuiTextfieldControllerModule, TuiActiveZoneModule, taiga_ui_cdk_directives_let/* TuiLetModule */.WD, taiga_ui_core_directives_mode/* TuiModeModule */.z, taiga_ui_core_components_link/* TuiLinkModule */.j, TuiExpandModule, TuiHostedDropdownModule, TuiDropdownControllerModule, TuiAccordionModule, TuiScrollbarModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiDataListModule]]
  });
  return TuiDocNavigationModule;
})();
function rgbToHex(r, g, b) {
  return '#' + [r, g, b].map(x => {
    const hex = x.toString(16);
    return hex.length === 1 ? '0' + hex : hex;
  }).join('');
}
function hexToRgb(hex) {
  const matches = hex.replace('#', '').split('').map((char, _, array) => array.length === 3 ? char + char : char).join('').match(/.{2}/g);
  return matches ? matches.map(x => Number.parseInt(x, 16)) : [0, 0, 0];
}
function inspectArray(array, depth) {
  if (depth === 0) {
    return '[…]';
  }
  let result = '';
  let first = true;
  for (let index = 0; index < array.length; index++) {
    if (first) {
      first = false;
    } else {
      result += ', ';
    }
    result += index in array ? inspectAny(array[index], depth - 1) : 'empty';
  }
  return `[${result}]`;
}
function inspectObject(object, depth) {
  if (depth === 0) {
    return `{…}`;
  }
  let result = '';
  let first = true;
  for (const key in object) {
    if (!object.hasOwnProperty(key)) {
      continue;
    }
    if (first) {
      first = false;
    } else {
      result += ', ';
    }
    result += `${key}: ${inspectAny(object[key], depth - 1)}`;
  }
  return `{${result}}`;
}
// @bad TODO add more types
/**
 * Returns readable JS entity
 * @param data
 * @param depth
 * @return readable JS entity
 */
function inspectAny(data, depth) {
  if (data === null) {
    return 'null';
  }
  switch (typeof data) {
    case 'string':
      return `'${data}'`;
    case 'undefined':
    case 'number':
    case 'boolean':
    case 'function':
      return String(data);
  }
  if (data instanceof RegExp) {
    return data.toString();
  }
  if (Array.isArray(data)) {
    return inspectArray(data, depth);
  }
  return inspectObject(data, depth);
}
const SERIALIZED_SUFFIX = '$';
// @bad TODO: refactor output and value sync
let TuiDocDocumentationPropertyConnectorDirective = /*#__PURE__*/(() => {
  let TuiDocDocumentationPropertyConnectorDirective = class TuiDocDocumentationPropertyConnectorDirective {
    constructor(template, locationRef, activatedRoute, urlSerializer) {
      this.template = template;
      this.locationRef = locationRef;
      this.activatedRoute = activatedRoute;
      this.urlSerializer = urlSerializer;
      this.documentationPropertyName = '';
      this.documentationPropertyMode = null;
      this.documentationPropertyType = '';
      this.documentationPropertyValue = null;
      this.documentationPropertyDeprecated = false;
      this.documentationPropertyValues = null;
      this.documentationPropertyValueChange = new core_js_.EventEmitter();
      this.changed$ = new Subject/* Subject */.xQ();
    }
    ngOnInit() {
      this.parseParams(this.activatedRoute.snapshot.queryParams);
    }
    get attrName() {
      switch (this.documentationPropertyMode) {
        case 'input':
          return `[${this.documentationPropertyName}]`;
        case 'output':
          return `(${this.documentationPropertyName})`;
        case 'input-output':
          return `[(${this.documentationPropertyName})]`;
        default:
          return this.documentationPropertyName;
      }
    }
    get hasItems() {
      return !!this.documentationPropertyValues;
    }
    get shouldShowValues() {
      return this.documentationPropertyMode !== 'output';
    }
    ngOnChanges() {
      this.changed$.next();
    }
    onValueChange(value) {
      this.documentationPropertyValue = value;
      this.documentationPropertyValueChange.emit(value);
      this.setQueryParam(value);
    }
    parseParams(params) {
      if (!params[this.documentationPropertyName] && !params[this.documentationPropertyName + SERIALIZED_SUFFIX]) {
        return;
      }
      const isValueAvailableByKey = !!params[this.documentationPropertyName + SERIALIZED_SUFFIX];
      if (isValueAvailableByKey && this.documentationPropertyValues) {
        this.onValueChange(this.documentationPropertyValues[params[this.documentationPropertyName + SERIALIZED_SUFFIX]]);
        return;
      }
      this.onValueChange(!isNaN(Number(params[this.documentationPropertyName])) ? Number(params[this.documentationPropertyName]) : params[this.documentationPropertyName]);
    }
    setQueryParam(value) {
      const tree = this.urlSerializer.parse(this.locationRef.path());
      const isValueAvailableByKey = value instanceof Object;
      const computedValue = isValueAvailableByKey && this.documentationPropertyValues ? this.documentationPropertyValues.indexOf(value) : value;
      const suffix = isValueAvailableByKey ? SERIALIZED_SUFFIX : '';
      const propName = this.documentationPropertyName + suffix;
      tree.queryParams = Object.assign(Object.assign({}, tree.queryParams), {
        [propName]: computedValue
      });
      this.locationRef.go(String(tree));
    }
  };
  TuiDocDocumentationPropertyConnectorDirective.ɵfac = function TuiDocDocumentationPropertyConnectorDirective_Factory(t) {
    return new (t || TuiDocDocumentationPropertyConnectorDirective)(core_js_["ɵɵdirectiveInject"](core_js_.TemplateRef), core_js_["ɵɵdirectiveInject"](common_js_.Location), core_js_["ɵɵdirectiveInject"](router_js_.ActivatedRoute), core_js_["ɵɵdirectiveInject"](router_js_.UrlSerializer));
  };
  TuiDocDocumentationPropertyConnectorDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiDocDocumentationPropertyConnectorDirective,
    selectors: [["ng-template", "documentationPropertyName", ""]],
    inputs: {
      documentationPropertyName: "documentationPropertyName",
      documentationPropertyMode: "documentationPropertyMode",
      documentationPropertyType: "documentationPropertyType",
      documentationPropertyValue: "documentationPropertyValue",
      documentationPropertyDeprecated: "documentationPropertyDeprecated",
      documentationPropertyValues: "documentationPropertyValues"
    },
    outputs: {
      documentationPropertyValueChange: "documentationPropertyValueChange"
    },
    features: [core_js_["ɵɵNgOnChangesFeature"]]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocDocumentationPropertyConnectorDirective.prototype, "documentationPropertyName", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocDocumentationPropertyConnectorDirective.prototype, "documentationPropertyMode", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocDocumentationPropertyConnectorDirective.prototype, "documentationPropertyType", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocDocumentationPropertyConnectorDirective.prototype, "documentationPropertyValue", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocDocumentationPropertyConnectorDirective.prototype, "documentationPropertyDeprecated", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocDocumentationPropertyConnectorDirective.prototype, "documentationPropertyValues", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiDocDocumentationPropertyConnectorDirective.prototype, "documentationPropertyValueChange", void 0);
  TuiDocDocumentationPropertyConnectorDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.TemplateRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(common_js_.Location)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(router_js_.ActivatedRoute)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(router_js_.UrlSerializer))], TuiDocDocumentationPropertyConnectorDirective);

  // @bad TODO subscribe propertiesConnectors changes
  // @bad TODO refactor to make more flexible
  // @dynamic
  return TuiDocDocumentationPropertyConnectorDirective;
})();
let TuiDocDocumentationComponent = /*#__PURE__*/(() => {
  let TuiDocDocumentationComponent = class TuiDocDocumentationComponent {
    constructor(changeDetectorRef, texts) {
      this.changeDetectorRef = changeDetectorRef;
      this.texts = texts;
      this.heading = '';
      this.showValues = true;
      this.isAPI = false;
      this.propertiesConnectors = taiga_ui_cdk_constants/* EMPTY_QUERY */.Mm;
      this.activeItemIndex = 0;
    }
    ngAfterContentInit() {
      (0,taiga_ui_cdk_observables/* itemsQueryListObservable */.Fp)(this.propertiesConnectors).pipe((0,switchMap/* switchMap */.w)(items => (0,merge/* merge */.T)(...items.map(({
        changed$
      }) => changed$))), (0,taiga_ui_cdk_observables/* watch */.YP)(this.changeDetectorRef)).subscribe();
    }
    get type() {
      return this.isAPI ? this.texts[0] : this.texts[1];
    }
    getColor(color) {
      if (color.length === 4) {
        return color.split('').reduce((result, current) => [...result, current, current], []).join('').replace('#', '');
      }
      if (color.startsWith('#')) {
        return color;
      }
      if (color === 'transparent') {
        return '#000000';
      }
      const parsed = color.replace('rgb(', '').replace('rgba(', '').replace(')', '').replace(' ', '').split(',').map(v => Number.parseInt(v, 10));
      return rgbToHex(...parsed);
    }
    getOpacity(color) {
      if (color.startsWith('#') || color.startsWith('rgb(')) {
        return 100;
      }
      if (color === 'transparent') {
        return 0;
      }
      const lastComma = color.lastIndexOf(',');
      const parsed = color.substr(lastComma).replace(')', '').replace(' ', '').replace(',', '');
      return Math.round(Number.parseFloat(parsed) * 100);
    }
    onColorChange(connector, color) {
      const opacity = this.getOpacity(connector.documentationPropertyValue || '');
      if (opacity === 100) {
        connector.onValueChange(color);
        return;
      }
      const rgb = hexToRgb(color).join(', ');
      const result = `rgba(${rgb}, ${opacity / 100})`;
      connector.onValueChange(result);
    }
    onOpacityChange(connector, opacity) {
      const hex = this.getColor(connector.documentationPropertyValue || '');
      const rgb = hexToRgb(hex);
      const result = `rgba(${rgb}, ${opacity / 100})`;
      connector.onValueChange(result);
    }
    stripOptional(name) {
      return name.replace('?', '');
    }
    isOptional(name) {
      return name.includes('?');
    }
    showCleaner(type) {
      return type.includes('null');
    }
    showContentTooltip(type) {
      return type.includes('PolymorpheusContent');
    }
    inspectAny(data) {
      return inspectAny(data, 2);
    }
  };
  TuiDocDocumentationComponent.ɵfac = function TuiDocDocumentationComponent_Factory(t) {
    return new (t || TuiDocDocumentationComponent)(core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](TUI_DOC_DOCUMENTATION_TEXTS));
  };
  TuiDocDocumentationComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDocDocumentationComponent,
    selectors: [["tui-doc-documentation"]],
    contentQueries: function TuiDocDocumentationComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        core_js_["ɵɵcontentQuery"](dirIndex, TuiDocDocumentationPropertyConnectorDirective, 4);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.propertiesConnectors = _t);
      }
    },
    inputs: {
      heading: "heading",
      showValues: "showValues",
      isAPI: "isAPI"
    },
    ngContentSelectors: taiga_ui_addon_doc_c0,
    decls: 10,
    vars: 5,
    consts: [["class", "tui-text_h4", 4, "ngIf"], [1, "tui-table", "tui-table_layout_fixed", "tui-table_font-size_s"], [1, "tui-table__tr", "tui-table__tr_hover_disabled", "row", "row_header"], [1, "tui-table__th", "tui-table__th_first", "cell", "cell_prop"], [1, "tui-table__th"], ["class", "tui-table__th tui-table__th_last tui-table__th_text_right cell cell_value", 4, "ngIf"], ["class", "tui-table__tr tui-table__tr_hover_disabled row", 3, "deprecated", "tui-table__tr_border_none", 4, "ngFor", "ngForOf"], [1, "tui-text_h4"], [1, "tui-table__th", "tui-table__th_last", "tui-table__th_text_right", "cell", "cell_value"], [1, "tui-table__tr", "tui-table__tr_hover_disabled", "row"], [1, "tui-table__td", "tui-table__td_first", "tui-table__td_align_center", "cell"], [1, "property", "cell"], ["size", "s", "value", "Optional", 4, "ngIf"], ["class", "deprecated-label", 4, "ngIf"], [4, "ngTemplateOutlet"], [1, "tui-table__td", "tui-table__td_align_center", "cell"], [1, "type"], [3, "describeId", "content", 4, "ngIf"], ["class", "tui-table__td tui-table__td_align_center tui-table__td_last tui-table__td_text_right cell", 4, "ngIf"], ["size", "s", "value", "Optional"], [1, "deprecated-label"], [3, "describeId", "content"], ["content", ""], ["tuiLink", "", "tuiMode", "onDark", "target", "_blank", "href", "https://github.com/TinkoffCreditSystems/ng-polymorpheus"], [1, "tui-table__td", "tui-table__td_align_center", "tui-table__td_last", "tui-table__td_text_right", "cell"], [4, "ngIf"], ["tuiTextfieldSize", "m", "tuiDropdownLimitWidth", "min", 3, "tuiTextfieldCleaner", "tuiTextfieldLabelOutside", "nativeId", "valueContent", "ngModel", "ngModelChange", 4, "ngIf", "ngIfElse"], ["selectContent", ""], ["noItems", ""], ["tuiTextfieldSize", "m", "tuiDropdownLimitWidth", "min", 3, "tuiTextfieldCleaner", "tuiTextfieldLabelOutside", "nativeId", "valueContent", "ngModel", "ngModelChange"], [1, "exception"], [3, "items", "itemContent", 4, "tuiDataList"], [3, "items", "itemContent"], [3, "ngSwitch"], ["size", "l", 3, "nativeId", "showIcons", "ngModel", "ngModelChange", 4, "ngSwitchCase"], ["tuiTextfieldSize", "m", 3, "nativeId", "tuiTextfieldLabelOutside", "tuiTextfieldCleaner", "value", "valueChange", 4, "ngSwitchCase"], ["tuiGroup", "", 4, "ngSwitchCase"], ["tuiTextfieldSize", "m", 3, "nativeId", "tuiTextfieldLabelOutside", "ngModel", "ngModelChange", 4, "ngSwitchCase"], ["size", "l", 3, "nativeId", "showIcons", "ngModel", "ngModelChange"], ["tuiTextfieldSize", "m", 3, "nativeId", "tuiTextfieldLabelOutside", "tuiTextfieldCleaner", "value", "valueChange"], ["tuiGroup", ""], ["tuiTextfieldType", "color", "tuiTextfieldSize", "m", 3, "tuiTextfieldLabelOutside", "tuiInputOpacity", "value", "valueChange"], ["tuiTextfieldSize", "m", 3, "max", "ngModel", "ngModelChange"], ["tuiTextfieldSize", "m", 3, "nativeId", "tuiTextfieldLabelOutside", "ngModel", "ngModelChange"]],
    template: function TuiDocDocumentationComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵtemplate"](0, TuiDocDocumentationComponent_h1_0_Template, 2, 1, "h1", 0);
        core_js_["ɵɵprojection"](1);
        core_js_["ɵɵelementStart"](2, "table", 1);
        core_js_["ɵɵelementStart"](3, "tr", 2);
        core_js_["ɵɵelementStart"](4, "th", 3);
        core_js_["ɵɵtext"](5);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](6, "td", 4);
        core_js_["ɵɵtext"](7);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](8, TuiDocDocumentationComponent_td_8_Template, 2, 1, "td", 5);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](9, TuiDocDocumentationComponent_tr_9_Template, 12, 11, "tr", 6);
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngIf", ctx.heading);
        core_js_["ɵɵadvance"](5);
        core_js_["ɵɵtextInterpolate1"](" ", ctx.texts[2], " ");
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵtextInterpolate"](ctx.type);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.showValues && !ctx.isAPI);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngForOf", ctx.propertiesConnectors);
      }
    },
    directives: function () {
      return [common_js_.NgIf, common_js_.NgForOf, common_js_.NgTemplateOutlet, TuiBadgeComponent, TuiTooltipComponent, taiga_ui_core_components_link/* TuiLinkComponent */.V, taiga_ui_core_directives_mode/* TuiModeDirective */.w, TuiSelectComponent, TuiTextfieldSizeDirective, TuiDropdownControllerDirective, TuiTextfieldCleanerDirective, TuiTextfieldLabelOutsideDirective, fesm2015_forms.NgControlStatus, fesm2015_forms.NgModel, TuiDataListDirective, TuiDataListWrapperComponent, common_js_.NgSwitch, common_js_.NgSwitchCase, TuiToggleComponent, TuiPrimitiveTextfieldComponent, TuiGroupDirective, TuiTextfieldTypeDirective, TuiInputOpacityDirective, TuiInputCountComponent];
    },
    styles: ["[_nghost-%COMP%]{display:block;min-width:100%}.cell_prop[_ngcontent-%COMP%]{width:40%}.cell_value[_ngcontent-%COMP%]{max-width:320px}@media screen and (max-width:1023px){.cell_value[_ngcontent-%COMP%]{width:150px}}@media screen and (max-width:767px){.row[_ngcontent-%COMP%]{display:flex;flex-wrap:wrap}.row_header[_ngcontent-%COMP%]{display:none}.cell[_ngcontent-%COMP%]{width:100%;height:auto;padding:8px 0;text-align:left}}.property[_ngcontent-%COMP%]{font:var(--tui-font-text-m);margin-bottom:4px;font-family:monospace;color:#8f75d1}.type[_ngcontent-%COMP%]{font-family:monospace}.deprecated[_ngcontent-%COMP%]{background-color:var(--tui-error-bg)}.deprecated-label[_ngcontent-%COMP%]{margin-right:2px;color:var(--tui-error-fill)}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocDocumentationComponent.prototype, "heading", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocDocumentationComponent.prototype, "showValues", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocDocumentationComponent.prototype, "isAPI", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChildren)(TuiDocDocumentationPropertyConnectorDirective)], TuiDocDocumentationComponent.prototype, "propertiesConnectors", void 0);
  TuiDocDocumentationComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_DOC_DOCUMENTATION_TEXTS))], TuiDocDocumentationComponent);
  return TuiDocDocumentationComponent;
})();
let TuiInputOpacityDirective = /*#__PURE__*/(() => {
  let TuiInputOpacityDirective = class TuiInputOpacityDirective {
    constructor(renderer, tuiFocusableComponent) {
      this.renderer = renderer;
      this.tuiFocusableComponent = tuiFocusableComponent;
    }
    set tuiInputOpacity(opacity) {
      const {
        nativeFocusableElement
      } = this.tuiFocusableComponent;
      if (nativeFocusableElement) {
        this.renderer.setStyle(nativeFocusableElement, 'opacity', opacity / 100);
      }
    }
  };
  TuiInputOpacityDirective.ɵfac = function TuiInputOpacityDirective_Factory(t) {
    return new (t || TuiInputOpacityDirective)(core_js_["ɵɵdirectiveInject"](core_js_.Renderer2), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ));
  };
  TuiInputOpacityDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiInputOpacityDirective,
    selectors: [["", "tuiInputOpacity", ""]],
    inputs: {
      tuiInputOpacity: "tuiInputOpacity"
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiInputOpacityDirective.prototype, "tuiInputOpacity", null);
  TuiInputOpacityDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.Renderer2)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ))], TuiInputOpacityDirective);
  return TuiInputOpacityDirective;
})();
let TuiInputOpacityModule = /*#__PURE__*/(() => {
  let TuiInputOpacityModule = class TuiInputOpacityModule {};
  TuiInputOpacityModule.ɵfac = function TuiInputOpacityModule_Factory(t) {
    return new (t || TuiInputOpacityModule)();
  };
  TuiInputOpacityModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiInputOpacityModule
  });
  TuiInputOpacityModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiInputOpacityModule;
})();
let TuiDocDocumentationModule = /*#__PURE__*/(() => {
  let TuiDocDocumentationModule = class TuiDocDocumentationModule {};
  TuiDocDocumentationModule.ɵfac = function TuiDocDocumentationModule_Factory(t) {
    return new (t || TuiDocDocumentationModule)();
  };
  TuiDocDocumentationModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocDocumentationModule
  });
  TuiDocDocumentationModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, fesm2015_forms.FormsModule, router_js_.RouterModule, TuiBadgeModule, TuiSelectModule, TuiToggleModule, TuiTooltipModule, taiga_ui_core_components_link/* TuiLinkModule */.j, TuiInputCountModule, taiga_ui_core_directives_mode/* TuiModeModule */.z, TuiGroupModule, TuiInputOpacityModule, TuiPrimitiveTextfieldModule, TuiTextfieldControllerModule, TuiHintControllerModule, TuiDropdownControllerModule, TuiDataListModule, TuiDataListWrapperModule]]
  });
  return TuiDocDocumentationModule;
})();
const TUI_DOC_CODE_EDITOR = new core_js_.InjectionToken('Contains service for opening online IDE e.g. Stackblitz');
const TUI_DOC_EXAMPLE_CONTENT_PROCESSOR = new core_js_.InjectionToken('Processes content in example', {
  factory: () => taiga_ui_cdk_utils_miscellaneous/* identity */.yR
});

// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
let TuiDocExampleComponent = /*#__PURE__*/(() => {
  let TuiDocExampleComponent = class TuiDocExampleComponent {
    constructor(id, clipboard, notifications, location, copyTexts$, texts, codeEditor, processContent) {
      this.id = id;
      this.clipboard = clipboard;
      this.notifications = notifications;
      this.location = location;
      this.copyTexts$ = copyTexts$;
      this.texts = texts;
      this.codeEditor = codeEditor;
      this.processContent = processContent;
      this.heading = null;
      this.description = null;
      this.componentName = this.location.pathname.slice(1);
      this.activeItemIndex = 0;
      this.processedContent = {};
      this.defaultTab = this.texts[0];
      this.copy$ = this.copyTexts$.pipe((0,map/* map */.U)(([copy]) => copy));
    }
    set content(content) {
      this.processedContent = this.processContent(content);
    }
    get activeItem() {
      return this.tabs[this.activeItemIndex];
    }
    get tabs() {
      return this.getTabs(this.processedContent);
    }
    get code() {
      const code = this.processedContent[this.activeItem];
      return code ? code.trim() : '';
    }
    get isDefaultItem() {
      return this.activeItem === this.defaultTab;
    }
    copyExampleLink() {
      const hashPosition = this.location.href.indexOf('#');
      const currentUrl = hashPosition > -1 ? this.location.href.substr(0, hashPosition) : this.location.href;
      const url = `${currentUrl}#${this.id}`;
      this.clipboard.copy(url);
      this.notifications.show(this.texts[1], {
        label: this.texts[2],
        status: "success" /* Success */
      }).subscribe();
    }
    getTabs(content) {
      return [this.defaultTab, ...Object.keys(content)];
    }
  };
  TuiDocExampleComponent.ɵfac = function TuiDocExampleComponent_Factory(t) {
    return new (t || TuiDocExampleComponent)(core_js_["ɵɵinjectAttribute"]('id'), core_js_["ɵɵdirectiveInject"](Clipboard), core_js_["ɵɵdirectiveInject"](TuiNotificationsService), core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* LOCATION */.Ct), core_js_["ɵɵdirectiveInject"](TUI_COPY_TEXTS), core_js_["ɵɵdirectiveInject"](TUI_DOC_EXAMPLE_TEXTS), core_js_["ɵɵdirectiveInject"](TUI_DOC_CODE_EDITOR, 8), core_js_["ɵɵdirectiveInject"](TUI_DOC_EXAMPLE_CONTENT_PROCESSOR));
  };
  TuiDocExampleComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDocExampleComponent,
    selectors: [["tui-doc-example"]],
    inputs: {
      heading: "heading",
      description: "description",
      componentName: "componentName",
      content: "content"
    },
    ngContentSelectors: taiga_ui_addon_doc_c0,
    decls: 11,
    vars: 8,
    consts: [["class", "title", 4, "ngIf"], ["class", "description", 4, "ngIf"], [1, "example"], [1, "tabs"], [3, "activeItemIndex", "activeItemIndexChange"], ["tuiTab", "", 4, "ngFor", "ngForOf"], ["tuiButton", "", "appearance", "flat", "size", "s", 3, "click", 4, "ngIf"], [3, "ngSwitch"], ["class", "demo", "automation-id", "tui-doc-example", 4, "ngIf", "ngIfElse"], ["codeTab", ""], [1, "title"], ["tuiIconButton", "", "type", "button", "size", "xs", "class", "link-icon", "icon", "tuiIconLinkLarge", "appearance", "icon", 3, "title", "click", 4, "ngIf"], ["tuiIconButton", "", "type", "button", "size", "xs", "icon", "tuiIconLinkLarge", "appearance", "icon", 1, "link-icon", 3, "title", "click"], [1, "description"], ["tuiTab", ""], ["tuiButton", "", "appearance", "flat", "size", "s", 3, "click"], ["automation-id", "tui-doc-example", 1, "demo"], [1, "copy-code", 3, "cdkCopyToClipboard"], [3, "code"]],
    template: function TuiDocExampleComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵtemplate"](0, TuiDocExampleComponent_h3_0_Template, 3, 2, "h3", 0);
        core_js_["ɵɵtemplate"](1, TuiDocExampleComponent_h4_1_Template, 2, 1, "h4", 1);
        core_js_["ɵɵelementStart"](2, "div", 2);
        core_js_["ɵɵelementStart"](3, "div", 3);
        core_js_["ɵɵelementStart"](4, "tui-tabs", 4);
        core_js_["ɵɵlistener"]("activeItemIndexChange", function TuiDocExampleComponent_Template_tui_tabs_activeItemIndexChange_4_listener($event) {
          return ctx.activeItemIndex = $event;
        });
        core_js_["ɵɵtemplate"](5, TuiDocExampleComponent_button_5_Template, 2, 1, "button", 5);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](6, TuiDocExampleComponent_button_6_Template, 2, 1, "button", 6);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementContainerStart"](7, 7);
        core_js_["ɵɵtemplate"](8, TuiDocExampleComponent_div_8_Template, 2, 0, "div", 8);
        core_js_["ɵɵtemplate"](9, TuiDocExampleComponent_ng_template_9_Template, 2, 2, "ng-template", null, 9, core_js_["ɵɵtemplateRefExtractor"]);
        core_js_["ɵɵelementContainerEnd"]();
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        const _r5 = core_js_["ɵɵreference"](10);
        core_js_["ɵɵproperty"]("ngIf", ctx.heading);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.description);
        core_js_["ɵɵadvance"](3);
        core_js_["ɵɵproperty"]("activeItemIndex", ctx.activeItemIndex);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngForOf", ctx.tabs);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.codeEditor);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngSwitch", ctx.activeItem);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.isDefaultItem)("ngIfElse", _r5);
      }
    },
    directives: [common_js_.NgIf, TuiTabsComponent, common_js_.NgForOf, common_js_.NgSwitch, taiga_ui_core_components_button/* TuiButtonComponent */.v, TuiTabComponent, TuiDocCopyComponent, CdkCopyToClipboard, TuiDocCodeComponent],
    pipes: [common_js_.AsyncPipe],
    styles: ["[_nghost-%COMP%]{position:relative;display:block;padding-top:56px;clear:right}.title[_ngcontent-%COMP%]{font:var(--tui-font-heading-5);margin:0 0 8px}@media screen and (max-width:599px){[_nghost-%COMP%]{padding-top:32px}.title[_ngcontent-%COMP%]{font:var(--tui-font-heading-6)}}.description[_ngcontent-%COMP%]{font:var(--tui-font-text-m);font-weight:400;margin:0}.description[_ngcontent-%COMP%]:first-letter, .title[_ngcontent-%COMP%]:first-letter{text-transform:capitalize}.example[_ngcontent-%COMP%]{position:relative;margin-top:24px;border:1px solid var(--tui-base-03);border-radius:var(--tui-radius-m);box-shadow:0 2px 3px rgba(0,0,0,.1)}.tabs[_ngcontent-%COMP%]{padding:0 32px;box-shadow:inset 0 -1px var(--tui-base-03);display:flex;justify-content:space-between;align-items:center}@media screen and (max-width:599px){.example[_ngcontent-%COMP%]{margin-top:12px}.tabs[_ngcontent-%COMP%]{padding:0 16px}}.demo[_ngcontent-%COMP%]{padding:32px;overflow-x:auto}@media all and (-webkit-min-device-pixel-ratio:0) and (min-resolution:0.001dpcm){.demo[_ngcontent-%COMP%]::-webkit-scrollbar, .demo[_ngcontent-%COMP%]::-webkit-scrollbar-thumb{width:16px;height:16px;border-radius:100px;background-clip:padding-box;border:6px solid transparent}.demo[_ngcontent-%COMP%]::-webkit-scrollbar{background-color:transparent}.demo[_ngcontent-%COMP%]::-webkit-scrollbar-thumb{background-color:var(--tui-clear-hover)}.demo[_ngcontent-%COMP%]::-webkit-scrollbar-thumb:hover{background-color:var(--tui-clear-active)}.demo[_ngcontent-%COMP%]::-webkit-scrollbar-thumb:active{background-color:var(--tui-text-03)}}@media screen and (max-width:599px){.demo[_ngcontent-%COMP%]{padding:16px}}.copy-code[_ngcontent-%COMP%]{position:absolute;top:70px;right:16px}.link-icon[_ngcontent-%COMP%]{vertical-align:baseline}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocExampleComponent.prototype, "heading", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocExampleComponent.prototype, "description", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocExampleComponent.prototype, "content", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocExampleComponent.prototype, "componentName", void 0);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDocExampleComponent.prototype, "getTabs", null);
  TuiDocExampleComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Attribute)('id')), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(Clipboard)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(TuiNotificationsService)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(ng_web_apis_common/* LOCATION */.Ct)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(TUI_COPY_TEXTS)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(TUI_DOC_EXAMPLE_TEXTS)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(TUI_DOC_CODE_EDITOR)), (0,tslib_es6/* __param */.fM)(7, (0,core_js_.Inject)(TUI_DOC_EXAMPLE_CONTENT_PROCESSOR))], TuiDocExampleComponent);
  return TuiDocExampleComponent;
})();
let TuiDocExampleModule = /*#__PURE__*/(() => {
  let TuiDocExampleModule = class TuiDocExampleModule {};
  TuiDocExampleModule.ɵfac = function TuiDocExampleModule_Factory(t) {
    return new (t || TuiDocExampleModule)();
  };
  TuiDocExampleModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocExampleModule
  });
  TuiDocExampleModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, ClipboardModule, TuiTabsModule, taiga_ui_core_components_button/* TuiButtonModule */.f, TuiDocCopyModule, TuiDocCodeModule]]
  });
  return TuiDocExampleModule;
})();
var TuiDocMainComponent_1;
// @dynamic
let TuiDocMainComponent = TuiDocMainComponent_1 = class TuiDocMainComponent {
  constructor(storage, windowRef) {
    this.storage = storage;
    this.windowRef = windowRef;
    this.night = this.storage.getItem('night') === 'true' || this.storage.getItem('night') === null && this.windowRef.matchMedia('(prefers-color-scheme: dark)').matches;
    this.change$ = new Subject/* Subject */.xQ();
  }
  get mode() {
    return this.night ? 'onDark' : null;
  }
  onMode(night) {
    this.night = night;
    this.change$.next();
    this.storage.setItem('night', String(night));
  }
};
TuiDocMainComponent.ɵfac = function TuiDocMainComponent_Factory(t) {
  return new (t || TuiDocMainComponent)(core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* LOCAL_STORAGE */.H3), core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* WINDOW */.m9));
};
TuiDocMainComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiDocMainComponent,
  selectors: [["tui-doc-main"]],
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_core_directives_mode/* TuiModeDirective */.w,
    useExisting: (0,core_js_.forwardRef)(() => TuiDocMainComponent_1)
  }])],
  ngContentSelectors: _c7,
  decls: 20,
  vars: 2,
  consts: [[4, "ngIf"], [1, "tui-doc-page"], [1, "tui-doc-navigation"], [1, "tui-doc-content"], [1, "tui-doc-outlet"], ["tuiDocHeader", ""], [1, "tui-space_left-2", 3, "ngModel", "ngModelChange"], ["ngProjectAs", "tuiOverDialogs", 5, ["tuiOverDialogs"]], ["ngProjectAs", "tuiOverNotifications", 5, ["tuiOverNotifications"]], ["ngProjectAs", "tuiOverPortals", 5, ["tuiOverPortals"]], ["ngProjectAs", "tuiOverHints", 5, ["tuiOverHints"]]],
  template: function TuiDocMainComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"](_c6);
      core_js_["ɵɵtemplate"](0, TuiDocMainComponent_tui_theme_night_0_Template, 1, 0, "tui-theme-night", 0);
      core_js_["ɵɵelementStart"](1, "tui-root");
      core_js_["ɵɵelementStart"](2, "div", 1);
      core_js_["ɵɵelementStart"](3, "tui-doc-navigation", 2);
      core_js_["ɵɵprojection"](4);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementStart"](5, "div", 3);
      core_js_["ɵɵelement"](6, "router-outlet", 4);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementStart"](7, "header", 5);
      core_js_["ɵɵelementStart"](8, "label");
      core_js_["ɵɵtext"](9, " Night mode ");
      core_js_["ɵɵelementStart"](10, "tui-toggle", 6);
      core_js_["ɵɵlistener"]("ngModelChange", function TuiDocMainComponent_Template_tui_toggle_ngModelChange_10_listener($event) {
        return ctx.onMode($event);
      });
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵprojection"](11, 1);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementContainerStart"](12, 7);
      core_js_["ɵɵprojection"](13, 2);
      core_js_["ɵɵelementContainerEnd"]();
      core_js_["ɵɵelementContainerStart"](14, 8);
      core_js_["ɵɵprojection"](15, 3);
      core_js_["ɵɵelementContainerEnd"]();
      core_js_["ɵɵelementContainerStart"](16, 9);
      core_js_["ɵɵprojection"](17, 4);
      core_js_["ɵɵelementContainerEnd"]();
      core_js_["ɵɵelementContainerStart"](18, 10);
      core_js_["ɵɵprojection"](19, 5);
      core_js_["ɵɵelementContainerEnd"]();
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      core_js_["ɵɵproperty"]("ngIf", ctx.night);
      core_js_["ɵɵadvance"](10);
      core_js_["ɵɵproperty"]("ngModel", ctx.night);
    }
  },
  directives: function () {
    return [common_js_.NgIf, TuiRootComponent, TuiDocNavigationComponent, router_js_.RouterOutlet, TuiDocHeaderComponent, TuiToggleComponent, fesm2015_forms.NgControlStatus, fesm2015_forms.NgModel, TuiThemeNightComponent];
  },
  styles: ["@-webkit-keyframes tuiShaking{from,to{transform:translate3d(0,0,0)}10%,30%,50%,70%,90%{transform:translate3d(-5px,0,0)}20%,40%,60%,80%{transform:translate3d(5px,0,0)}}@keyframes tuiShaking{from,to{transform:translate3d(0,0,0)}10%,30%,50%,70%,90%{transform:translate3d(-5px,0,0)}20%,40%,60%,80%{transform:translate3d(5px,0,0)}}body{background:var(--tui-base-01)}code:not(.hljs):not(.exception){transition-property:background;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;background:var(--tui-base-02);color:var(--tui-text-02);vertical-align:middle;box-shadow:inset 0 -2px var(--tui-secondary);padding:6px 8px;font-size:14px;border-radius:8px}:focus code:not(.exception){background:var(--tui-base-01)}.tui-doc-page{position:relative;z-index:0;height:100%;padding-top:64px;box-sizing:border-box}tui-doc-navigation.tui-doc-navigation{position:fixed;top:64px;bottom:0;width:260px;border-right:1px solid var(--tui-base-03)}.tui-doc-content{height:100%;display:flex;flex-direction:column;margin-left:260px}@media screen and (max-width:767px){tui-doc-navigation.tui-doc-navigation{display:none}.tui-doc-content{margin-left:0}}.tui-doc-outlet+*{display:flex;flex-direction:column;min-height:0;flex-grow:1}.tui-doc-animated-example{-webkit-animation:1s .3s tuiShaking;animation:1s .3s tuiShaking}.hljs-tag{background:0 0}.hljs{display:block;overflow-x:auto;padding:.5em;color:var(--tui-text-primary);background-color:var(--tui-base-02)}.hljs-subst,.hljs-title{font-weight:400;color:var(--tui-text-01)}.hljs-comment,.hljs-quote{color:var(--tui-text-03);font-style:italic}.hljs-meta{color:#e38162}.hljs-keyword,.hljs-literal,.hljs-name,.hljs-section,.hljs-selector-class,.hljs-selector-id,.hljs-selector-tag,.hljs-type{font-weight:700;color:var(--tui-link)}.hljs-attribute,.hljs-link,.hljs-number,.hljs-regexp{font-weight:700;color:var(--tui-primary-active)}.hljs-link,.hljs-number,.hljs-regexp{font-weight:400}.hljs-string{color:var(--tui-positive);font-weight:700}.hljs-bullet,.hljs-formula,.hljs-symbol{color:var(--tui-text-primary);background:var(--tui-base-02);font-style:italic}.hljs-doctag{text-decoration:underline}.hljs-template-variable,.hljs-variable{color:var(--tui-warning-fill)}.hljs-addition{background:var(--tui-success-bg)}.hljs-deletion{background:var(--tui-error-bg)}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs .hljs-line-numbers{padding:0}.hljs-ln-numbers{vertical-align:top;opacity:.3;text-align:right;padding-right:1em!important}"],
  encapsulation: 2
});
TuiDocMainComponent.ctorParameters = () => [{
  type: Storage,
  decorators: [{
    type: core_js_.Inject,
    args: [ng_web_apis_common/* LOCAL_STORAGE */.H3]
  }]
}, {
  type: Window,
  decorators: [{
    type: core_js_.Inject,
    args: [ng_web_apis_common/* WINDOW */.m9]
  }]
}];
TuiDocMainComponent = TuiDocMainComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(ng_web_apis_common/* LOCAL_STORAGE */.H3)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(ng_web_apis_common/* WINDOW */.m9))], TuiDocMainComponent);
const TUI_DOC_LOGO = new core_js_.InjectionToken('Main logo', {
  factory: () => ''
});
let TuiDocHeaderComponent = /*#__PURE__*/(() => {
  let TuiDocHeaderComponent = class TuiDocHeaderComponent {
    constructor(logo, menu, router) {
      this.logo = logo;
      this.menu = menu;
      this.router = router;
      this.stream$ = new Subject/* Subject */.xQ();
      this.open$ = (0,merge/* merge */.T)(this.router.events.pipe((0,mapTo/* mapTo */.h)(false)), this.stream$).pipe((0,startWith/* startWith */.O)(false), (0,distinctUntilChanged/* distinctUntilChanged */.x)());
    }
    onClick() {
      this.stream$.next(true);
    }
    onActiveZone(active) {
      if (!active) {
        this.stream$.next(false);
      }
    }
  };
  TuiDocHeaderComponent.ɵfac = function TuiDocHeaderComponent_Factory(t) {
    return new (t || TuiDocHeaderComponent)(core_js_["ɵɵdirectiveInject"](TUI_DOC_LOGO), core_js_["ɵɵdirectiveInject"](TUI_DOC_MENU_TEXT), core_js_["ɵɵdirectiveInject"](router_js_.Router));
  };
  TuiDocHeaderComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDocHeaderComponent,
    selectors: [["header", "tuiDocHeader", ""]],
    attrs: _c8,
    ngContentSelectors: taiga_ui_addon_doc_c0,
    decls: 5,
    vars: 5,
    consts: [["tuiIconButton", "", "icon", "tuiIconMenuLarge", "appearance", "icon", 1, "menu", 3, "title", "click", "tuiActiveZoneChange"], ["class", "navigation", 4, "tuiSidebar"], ["polymorpheus-outlet", "", 1, "logo", "tui-text_h5", 3, "content"], [1, "navigation"]],
    template: function TuiDocHeaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵelementStart"](0, "button", 0);
        core_js_["ɵɵlistener"]("click", function TuiDocHeaderComponent_Template_button_click_0_listener() {
          return ctx.onClick();
        })("tuiActiveZoneChange", function TuiDocHeaderComponent_Template_button_tuiActiveZoneChange_0_listener($event) {
          return ctx.onActiveZone($event);
        });
        core_js_["ɵɵtemplate"](1, TuiDocHeaderComponent_tui_doc_navigation_1_Template, 1, 0, "tui-doc-navigation", 1);
        core_js_["ɵɵpipe"](2, "async");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelement"](3, "div", 2);
        core_js_["ɵɵprojection"](4);
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("title", ctx.menu);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("tuiSidebar", core_js_["ɵɵpipeBind1"](2, 3, ctx.open$));
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵproperty"]("content", ctx.logo);
      }
    },
    directives: [taiga_ui_core_components_button/* TuiButtonComponent */.v, TuiActiveZoneDirective, TuiSidebarDirective, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, TuiDocNavigationComponent],
    pipes: [common_js_.AsyncPipe],
    styles: ["[_nghost-%COMP%]{box-shadow:0 2px 16px rgba(0,0,0,.08);position:fixed;top:0;left:0;right:0;display:flex;height:63px;align-items:center;padding:0 20px;background:var(--tui-base-01);border-bottom:1px solid var(--tui-base-03);z-index:1}.logo[_ngcontent-%COMP%]{margin-right:auto}.menu[_ngcontent-%COMP%]{margin-left:-20px}@media screen and (min-width:768px){.menu[_ngcontent-%COMP%]{display:none}}.navigation[_ngcontent-%COMP%]{min-height:100%}"],
    changeDetection: 0
  });
  TuiDocHeaderComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TUI_DOC_LOGO)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_DOC_MENU_TEXT)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(router_js_.Router))], TuiDocHeaderComponent);
  return TuiDocHeaderComponent;
})();
let TuiDocHeaderModule = /*#__PURE__*/(() => {
  let TuiDocHeaderModule = class TuiDocHeaderModule {};
  TuiDocHeaderModule.ɵfac = function TuiDocHeaderModule_Factory(t) {
    return new (t || TuiDocHeaderModule)();
  };
  TuiDocHeaderModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocHeaderModule
  });
  TuiDocHeaderModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_button/* TuiButtonModule */.f, TuiSidebarModule, TuiActiveZoneModule, TuiDocNavigationModule]]
  });
  return TuiDocHeaderModule;
})();
let TuiDocMainModule = /*#__PURE__*/(() => {
  let TuiDocMainModule = class TuiDocMainModule {};
  TuiDocMainModule.ɵfac = function TuiDocMainModule_Factory(t) {
    return new (t || TuiDocMainModule)();
  };
  TuiDocMainModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocMainModule
  });
  TuiDocMainModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, router_js_.RouterModule, fesm2015_forms.FormsModule, TuiToggleModule, TuiThemeNightModule, TuiDocHeaderModule, TuiRootModule, TuiDialogModule, TuiNotificationsModule, TuiDocNavigationModule]]
  });
  return TuiDocMainModule;
})();
const TUI_DOC_DEFAULT_TABS = new core_js_.InjectionToken('Array of default tab names', {
  factory: () => []
});
let TuiDocPageTabConnectorDirective = /*#__PURE__*/(() => {
  let TuiDocPageTabConnectorDirective = class TuiDocPageTabConnectorDirective {
    constructor(template) {
      this.template = template;
    }
  };
  TuiDocPageTabConnectorDirective.ɵfac = function TuiDocPageTabConnectorDirective_Factory(t) {
    return new (t || TuiDocPageTabConnectorDirective)(core_js_["ɵɵdirectiveInject"](core_js_.TemplateRef));
  };
  TuiDocPageTabConnectorDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiDocPageTabConnectorDirective,
    selectors: [["", "pageTab", ""]],
    inputs: {
      pageTab: "pageTab"
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDocPageTabConnectorDirective.prototype, "pageTab", void 0);
  TuiDocPageTabConnectorDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.TemplateRef))], TuiDocPageTabConnectorDirective);
  return TuiDocPageTabConnectorDirective;
})();
const TUI_DOC_SEE_ALSO = new core_js_.InjectionToken('Array of arrays of related pages', {
  factory: () => []
});
const PAGE_SEE_ALSO = new core_js_.InjectionToken('Page see also');
const PAGE_PROVIDERS = [{
  provide: PAGE_SEE_ALSO,
  deps: [core_js_.ElementRef, TUI_DOC_SEE_ALSO],
  useFactory: seeAlsoProviderFactory
}];
function seeAlsoProviderFactory({
  nativeElement
}, seeAlsoGroups) {
  const groups = seeAlsoGroups.filter(group => group.indexOf(nativeElement.header) !== -1) || [];
  const seeAlsoSet = new Set(groups.join().split(',').filter(component => component && component !== nativeElement.header));
  return Array.from(seeAlsoSet);
}

// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
let TuiDocPageComponent = /*#__PURE__*/(() => {
  let TuiDocPageComponent = class TuiDocPageComponent {
    constructor(deprecated, defaultTabs, seeAlso) {
      this.deprecated = deprecated;
      this.defaultTabs = defaultTabs;
      this.seeAlso = seeAlso;
      this.header = '';
      this.package = '';
      this.type = '';
      this.path = '';
      this.activeItemIndex = NaN;
      this.tabConnectors = taiga_ui_cdk_constants/* EMPTY_QUERY */.Mm;
    }
    get showSeeAlso() {
      return !!this.seeAlso.length && this.activeItemIndex === 0;
    }
    getRouterLink(tab = '') {
      return `./${tab.replace(/ /g, '_')}`;
    }
  };
  TuiDocPageComponent.ɵfac = function TuiDocPageComponent_Factory(t) {
    return new (t || TuiDocPageComponent)(core_js_["ɵɵinjectAttribute"]('deprecated'), core_js_["ɵɵdirectiveInject"](TUI_DOC_DEFAULT_TABS), core_js_["ɵɵdirectiveInject"](PAGE_SEE_ALSO));
  };
  TuiDocPageComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDocPageComponent,
    selectors: [["tui-doc-page"]],
    contentQueries: function TuiDocPageComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        core_js_["ɵɵcontentQuery"](dirIndex, TuiDocPageTabConnectorDirective, 4);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.tabConnectors = _t);
      }
    },
    inputs: {
      header: "header",
      package: "package",
      type: "type",
      path: "path"
    },
    features: [core_js_["ɵɵProvidersFeature"](PAGE_PROVIDERS)],
    ngContentSelectors: taiga_ui_addon_doc_c0,
    decls: 11,
    vars: 10,
    consts: [[1, "header"], [1, "title"], ["class", "tag tag_deprecated", "value", "deprecated", "status", "custom", 4, "ngIf"], ["class", "tag tag_package", "status", "custom", 3, "value", "autoColor", 4, "ngIf"], ["class", "tabs", 3, "activeItemIndex", "activeItemIndexChange", 4, "ngIf"], [1, "source-code", 3, "header", "package", "type", "path"], [1, "content"], ["class", "see-also", 3, "seeAlso", 4, "ngIf"], [4, "ngFor", "ngForOf"], ["value", "deprecated", "status", "custom", 1, "tag", "tag_deprecated"], ["status", "custom", 1, "tag", "tag_package", 3, "value", "autoColor"], [1, "tabs", 3, "activeItemIndex", "activeItemIndexChange"], [4, "ngIf", "ngIfElse"], ["dynamicTab", ""], ["tuiTab", "", "routerLink", "./", "routerLinkActive", "", 3, "routerLinkActiveOptions", 4, "tuiTab"], ["tuiTab", "", "routerLink", "./", "routerLinkActive", "", 3, "routerLinkActiveOptions"], ["tuiTab", "", "routerLinkActive", "", 3, "routerLink", 4, "tuiTab"], ["tuiTab", "", "routerLinkActive", "", 3, "routerLink"], [1, "see-also", 3, "seeAlso"], [4, "ngIf"], [4, "ngTemplateOutlet"]],
    template: function TuiDocPageComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵelementStart"](0, "header", 0);
        core_js_["ɵɵelementStart"](1, "h1", 1);
        core_js_["ɵɵtext"](2);
        core_js_["ɵɵtemplate"](3, TuiDocPageComponent_tui_tag_3_Template, 1, 0, "tui-tag", 2);
        core_js_["ɵɵtemplate"](4, TuiDocPageComponent_tui_tag_4_Template, 1, 2, "tui-tag", 3);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](5, TuiDocPageComponent_tui_tabs_with_more_5_Template, 2, 2, "tui-tabs-with-more", 4);
        core_js_["ɵɵelement"](6, "tui-doc-source-code", 5);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](7, "div", 6);
        core_js_["ɵɵprojection"](8);
        core_js_["ɵɵtemplate"](9, TuiDocPageComponent_tui_doc_see_also_9_Template, 1, 1, "tui-doc-see-also", 7);
        core_js_["ɵɵtemplate"](10, TuiDocPageComponent_ng_container_10_Template, 2, 1, "ng-container", 8);
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵtextInterpolate1"](" ", ctx.header, " ");
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.deprecated !== null);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.package);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.tabConnectors.length);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("header", ctx.header)("package", ctx.package)("type", ctx.type)("path", ctx.path);
        core_js_["ɵɵadvance"](3);
        core_js_["ɵɵproperty"]("ngIf", ctx.showSeeAlso);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngForOf", ctx.tabConnectors);
      }
    },
    directives: function () {
      return [common_js_.NgIf, TuiDocSourceCodeComponent, common_js_.NgForOf, TuiTagComponent, TuiTabsWithMoreComponent, TuiTabDirective, TuiTabComponent, router_js_.RouterLinkWithHref, router_js_.RouterLinkActive, TuiDocSeeAlsoComponent, common_js_.NgTemplateOutlet];
    },
    styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;min-height:0;flex-basis:0;flex-grow:1}.header[_ngcontent-%COMP%]{font:var(--tui-font-heading-3);display:flex;flex-wrap:wrap;min-height:116px;color:var(--tui-text-01);box-shadow:inset 0 -1px 0 0 var(--tui-base-03);padding:60px 0 0;box-sizing:border-box;flex-shrink:0;margin:0 min(10vw,140px)}@media screen and (max-width:767px){.header[_ngcontent-%COMP%]{font:var(--tui-font-heading-4);min-height:72px;padding:20px 20px 0;margin:0}}.title[_ngcontent-%COMP%]{min-width:100%;font-size:inherit;margin:0}.tag[_ngcontent-%COMP%]{vertical-align:middle;text-transform:uppercase;margin-right:8px}.tag_deprecated[_ngcontent-%COMP%]{background-color:var(--tui-error-fill)}.tag.tag_package[_ngcontent-%COMP%]{color:#000}.tabs[_ngcontent-%COMP%]{flex:1;margin:18px 5px 0 0}@media screen and (max-width:767px){.tabs[_ngcontent-%COMP%]{margin-top:4px}}.content[_ngcontent-%COMP%]{padding:32px 0;margin:0 min(10vw,140px)}@media screen and (max-width:767px){.content[_ngcontent-%COMP%]{padding:32px 20px;margin:0}}.see-also[_ngcontent-%COMP%]{min-width:300px;width:30%;float:right;margin-left:24px}@media screen and (max-width:1023px){.see-also[_ngcontent-%COMP%]{float:none;width:100%;margin:0 0 24px}}.screenshots-skip-usage[_ngcontent-%COMP%]{margin-top:56px}@media screen and (max-width:599px){.screenshots-skip-usage[_ngcontent-%COMP%]{margin-top:32px}}.source-code[_ngcontent-%COMP%]{align-self:flex-end;line-height:44px}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocPageComponent.prototype, "header", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocPageComponent.prototype, "package", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocPageComponent.prototype, "type", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocPageComponent.prototype, "path", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChildren)(TuiDocPageTabConnectorDirective)], TuiDocPageComponent.prototype, "tabConnectors", void 0);
  TuiDocPageComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Attribute)('deprecated')), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_DOC_DEFAULT_TABS)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(PAGE_SEE_ALSO))], TuiDocPageComponent);

  // @dynamic
  return TuiDocPageComponent;
})();
let TuiDocSeeAlsoComponent = /*#__PURE__*/(() => {
  let TuiDocSeeAlsoComponent = class TuiDocSeeAlsoComponent {
    constructor(text, pages) {
      this.text = text;
      this.pages = pages;
      this.seeAlso = [];
    }
    getRouterLink(pageTitle) {
      for (let i = 0; i < this.pages.length; i++) {
        const page = this.pages.map(page => 'subPages' in page ? page.subPages : [page]).reduce((pages, subPages) => [...pages, ...subPages], []).find(page => page.title === pageTitle);
        if (page && page.route) {
          return page.route;
        }
      }
      return '';
    }
  };
  TuiDocSeeAlsoComponent.ɵfac = function TuiDocSeeAlsoComponent_Factory(t) {
    return new (t || TuiDocSeeAlsoComponent)(core_js_["ɵɵdirectiveInject"](TUI_DOC_SEE_ALSO_TEXT), core_js_["ɵɵdirectiveInject"](TUI_DOC_PAGES));
  };
  TuiDocSeeAlsoComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDocSeeAlsoComponent,
    selectors: [["tui-doc-see-also"]],
    inputs: {
      seeAlso: "seeAlso"
    },
    decls: 3,
    vars: 2,
    consts: [[1, "header"], [4, "ngFor", "ngForOf"], ["tuiLink", "", 3, "routerLink"], [4, "ngIf"]],
    template: function TuiDocSeeAlsoComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵelementStart"](0, "h5", 0);
        core_js_["ɵɵtext"](1);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](2, TuiDocSeeAlsoComponent_ng_container_2_Template, 4, 3, "ng-container", 1);
      }
      if (rf & 2) {
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵtextInterpolate"](ctx.text);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngForOf", ctx.seeAlso);
      }
    },
    directives: [common_js_.NgForOf, taiga_ui_core_components_link/* TuiLinkComponent */.V, router_js_.RouterLinkWithHref, common_js_.NgIf],
    styles: ["[_nghost-%COMP%]{display:block}.header[_ngcontent-%COMP%]{font-size:11px;line-height:16px;text-transform:uppercase;letter-spacing:.075em;color:var(--tui-text-02);margin:0 0 8px;white-space:nowrap}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocSeeAlsoComponent.prototype, "seeAlso", void 0);
  TuiDocSeeAlsoComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TUI_DOC_SEE_ALSO_TEXT)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_DOC_PAGES))], TuiDocSeeAlsoComponent);
  return TuiDocSeeAlsoComponent;
})();
let TuiDocSeeAlsoModule = /*#__PURE__*/(() => {
  let TuiDocSeeAlsoModule = class TuiDocSeeAlsoModule {};
  TuiDocSeeAlsoModule.ɵfac = function TuiDocSeeAlsoModule_Factory(t) {
    return new (t || TuiDocSeeAlsoModule)();
  };
  TuiDocSeeAlsoModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocSeeAlsoModule
  });
  TuiDocSeeAlsoModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, router_js_.RouterModule, taiga_ui_core_components_link/* TuiLinkModule */.j]]
  });
  return TuiDocSeeAlsoModule;
})();
const TUI_DOC_SOURCE_CODE = new core_js_.InjectionToken('Source code link', {
  factory: () => ''
});
let TuiDocSourceCodeComponent = /*#__PURE__*/(() => {
  let TuiDocSourceCodeComponent = class TuiDocSourceCodeComponent {
    constructor(sourceCode, text) {
      this.sourceCode = sourceCode;
      this.text = text;
      this.header = '';
      this.package = '';
      this.type = '';
      this.path = '';
    }
    get pathOptions() {
      return this.getPathOptions(this.header, this.package, this.type, this.path);
    }
    getPathOptions(header, packageName, type, path) {
      return {
        header,
        package: packageName,
        type,
        path
      };
    }
  };
  TuiDocSourceCodeComponent.ɵfac = function TuiDocSourceCodeComponent_Factory(t) {
    return new (t || TuiDocSourceCodeComponent)(core_js_["ɵɵdirectiveInject"](TUI_DOC_SOURCE_CODE), core_js_["ɵɵdirectiveInject"](TUI_DOC_SOURCE_CODE_TEXT));
  };
  TuiDocSourceCodeComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDocSourceCodeComponent,
    selectors: [["tui-doc-source-code"]],
    inputs: {
      header: "header",
      package: "package",
      type: "type",
      path: "path"
    },
    decls: 1,
    vars: 1,
    consts: [["polymorpheus-outlet", "", 3, "content", "context", 4, "ngIf"], ["polymorpheus-outlet", "", 3, "content", "context"], ["tuiIconButton", "", "type", "button", "icon", "tuiIconCodeLarge", "appearance", "icon", "target", "_blank", "size", "s", 3, "title", "href", 4, "ngIf"], ["tuiIconButton", "", "type", "button", "icon", "tuiIconCodeLarge", "appearance", "icon", "target", "_blank", "size", "s", 3, "title", "href"]],
    template: function TuiDocSourceCodeComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵtemplate"](0, TuiDocSourceCodeComponent_div_0_Template, 2, 2, "div", 0);
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngIf", !!ctx.sourceCode);
      }
    },
    directives: [common_js_.NgIf, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, taiga_ui_core_components_button/* TuiButtonComponent */.v],
    encapsulation: 2,
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocSourceCodeComponent.prototype, "header", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocSourceCodeComponent.prototype, "package", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocSourceCodeComponent.prototype, "type", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocSourceCodeComponent.prototype, "path", void 0);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDocSourceCodeComponent.prototype, "getPathOptions", null);
  TuiDocSourceCodeComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TUI_DOC_SOURCE_CODE)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_DOC_SOURCE_CODE_TEXT))], TuiDocSourceCodeComponent);
  return TuiDocSourceCodeComponent;
})();
let TuiDocSourceCodeModule = /*#__PURE__*/(() => {
  let TuiDocSourceCodeModule = class TuiDocSourceCodeModule {};
  TuiDocSourceCodeModule.ɵfac = function TuiDocSourceCodeModule_Factory(t) {
    return new (t || TuiDocSourceCodeModule)();
  };
  TuiDocSourceCodeModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocSourceCodeModule
  });
  TuiDocSourceCodeModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_button/* TuiButtonModule */.f]]
  });
  return TuiDocSourceCodeModule;
})();
let TuiDocPageModule = /*#__PURE__*/(() => {
  let TuiDocPageModule = class TuiDocPageModule {};
  TuiDocPageModule.ɵfac = function TuiDocPageModule_Factory(t) {
    return new (t || TuiDocPageModule)();
  };
  TuiDocPageModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocPageModule
  });
  TuiDocPageModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, router_js_.RouterModule, TuiDocSeeAlsoModule, TuiTabsModule, TuiTagModule, TuiDocSourceCodeModule]]
  });

  // TODO: remove in ivy compilation
  return TuiDocPageModule;
})();
const DEMO_TEXTS = ['Сделано с помощью директивы: ', 'Фон', 'Детали формы'];
const DOC_TEXTS = ['Аргумент', 'Тип', 'Имя и описание', 'Значение', 'Для работы с динамическими шаблонами используется'];
const EXAMPLE_TEXTS = ['Превью', 'Ссылка на пример скопирована', 'Готово'];
const TUI_DOC_RUSSIAN = [{
  provide: TUI_DOC_DEMO_TEXTS,
  useValue: DEMO_TEXTS
}, {
  provide: TUI_DOC_DOCUMENTATION_TEXTS,
  useValue: DOC_TEXTS
}, {
  provide: TUI_DOC_EXAMPLE_TEXTS,
  useValue: EXAMPLE_TEXTS
}, {
  provide: TUI_DOC_MENU_TEXT,
  useValue: 'Меню'
}, {
  provide: TUI_DOC_SEARCH_TEXT,
  useValue: 'Поиск'
}, {
  provide: TUI_DOC_SEE_ALSO_TEXT,
  useValue: 'Смотрите также'
}, {
  provide: TUI_DOC_SOURCE_CODE_TEXT,
  useValue: 'Исходный код'
}];

/**
 * Generates typical page routing structure
 */
function generateRoutes(type) {
  return [{
    path: '',
    component: type,
    children: [{
      path: ':tab',
      component: type
    }]
  }];
}
let TuiAddonDocModule = /*#__PURE__*/(() => {
  let TuiAddonDocModule = class TuiAddonDocModule {};
  TuiAddonDocModule.ɵfac = function TuiAddonDocModule_Factory(t) {
    return new (t || TuiAddonDocModule)();
  };
  TuiAddonDocModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiAddonDocModule
  });
  TuiAddonDocModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [TuiDocCodeModule, TuiDocDemoModule, TuiDocDocumentationModule, TuiDocPageModule, TuiDocExampleModule]
  });
  return TuiAddonDocModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocCodeModule, {
    declarations: function () {
      return [TuiDocCodeComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, ngx_highlightjs/* HighlightModule */._l];
    },
    exports: function () {
      return [TuiDocCodeComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocCopyModule, {
    declarations: function () {
      return [TuiDocCopyComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, taiga_ui_core_components_button/* TuiButtonModule */.f];
    },
    exports: function () {
      return [TuiDocCopyComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocDemoModule, {
    declarations: function () {
      return [TuiDocDemoComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, fesm2015_forms.ReactiveFormsModule, fesm2015_forms.FormsModule, router_js_.RouterModule, taiga_ui_core_components_link/* TuiLinkModule */.j, TuiDragModule, taiga_ui_core_components_button/* TuiButtonModule */.f, TuiSelectModule, TuiExpandModule, TuiGroupModule, TuiTooltipModule, taiga_ui_core_directives_mode/* TuiModeModule */.z, TuiRadioBlockModule, TuiCheckboxLabeledModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiDataListWrapperModule, TuiDataListModule, TuiTextfieldControllerModule, TuiHintControllerModule];
    },
    exports: function () {
      return [TuiDocDemoComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocNavigationModule, {
    declarations: function () {
      return [TuiDocNavigationComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, fesm2015_forms.FormsModule, router_js_.RouterModule, taiga_ui_core_components_button/* TuiButtonModule */.f, TuiPrimitiveTextfieldModule, TuiTextfieldControllerModule, TuiActiveZoneModule, taiga_ui_cdk_directives_let/* TuiLetModule */.WD, taiga_ui_core_directives_mode/* TuiModeModule */.z, taiga_ui_core_components_link/* TuiLinkModule */.j, TuiExpandModule, TuiHostedDropdownModule, TuiDropdownControllerModule, TuiAccordionModule, TuiScrollbarModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiDataListModule];
    },
    exports: function () {
      return [TuiDocNavigationComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiInputOpacityModule, {
    declarations: [TuiInputOpacityDirective],
    exports: [TuiInputOpacityDirective]
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocDocumentationModule, {
    declarations: function () {
      return [TuiDocDocumentationComponent, TuiDocDocumentationPropertyConnectorDirective];
    },
    imports: function () {
      return [common_js_.CommonModule, fesm2015_forms.FormsModule, router_js_.RouterModule, TuiBadgeModule, TuiSelectModule, TuiToggleModule, TuiTooltipModule, taiga_ui_core_components_link/* TuiLinkModule */.j, TuiInputCountModule, taiga_ui_core_directives_mode/* TuiModeModule */.z, TuiGroupModule, TuiInputOpacityModule, TuiPrimitiveTextfieldModule, TuiTextfieldControllerModule, TuiHintControllerModule, TuiDropdownControllerModule, TuiDataListModule, TuiDataListWrapperModule];
    },
    exports: function () {
      return [TuiDocDocumentationComponent, TuiDocDocumentationPropertyConnectorDirective];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocExampleModule, {
    declarations: function () {
      return [TuiDocExampleComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, ClipboardModule, TuiTabsModule, taiga_ui_core_components_button/* TuiButtonModule */.f, TuiDocCopyModule, TuiDocCodeModule];
    },
    exports: function () {
      return [TuiDocExampleComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocHeaderModule, {
    declarations: function () {
      return [TuiDocHeaderComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_button/* TuiButtonModule */.f, TuiSidebarModule, TuiActiveZoneModule, TuiDocNavigationModule];
    },
    exports: function () {
      return [TuiDocHeaderComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocMainModule, {
    declarations: function () {
      return [TuiDocMainComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, router_js_.RouterModule, fesm2015_forms.FormsModule, TuiToggleModule, TuiThemeNightModule, TuiDocHeaderModule, TuiRootModule, TuiDialogModule, TuiNotificationsModule, TuiDocNavigationModule];
    },
    exports: function () {
      return [TuiDocMainComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocSeeAlsoModule, {
    declarations: function () {
      return [TuiDocSeeAlsoComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, router_js_.RouterModule, taiga_ui_core_components_link/* TuiLinkModule */.j];
    },
    exports: function () {
      return [TuiDocSeeAlsoComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocSourceCodeModule, {
    declarations: function () {
      return [TuiDocSourceCodeComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_button/* TuiButtonModule */.f];
    },
    exports: function () {
      return [TuiDocSourceCodeComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocPageModule, {
    declarations: function () {
      return [TuiDocPageComponent, TuiDocPageTabConnectorDirective];
    },
    imports: function () {
      return [common_js_.CommonModule, router_js_.RouterModule, TuiDocSeeAlsoModule, TuiTabsModule, TuiTagModule, TuiDocSourceCodeModule];
    },
    exports: function () {
      return [TuiDocPageComponent, TuiDocPageTabConnectorDirective];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiAddonDocModule, {
    exports: [TuiDocCodeModule, TuiDocDemoModule, TuiDocDocumentationModule, TuiDocPageModule, TuiDocExampleModule]
  });
})();

/**
 * Public API Surface of @taiga-ui/addon-doc
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-addon-doc.js.map

/***/ }),

/***/ 6480:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F9: () => (/* binding */ AbstractTuiNullableControl),
/* harmony export */   GM: () => (/* binding */ AbstractTuiThemeSwitcher),
/* harmony export */   M$: () => (/* binding */ AbstractTuiControl),
/* harmony export */   Xn: () => (/* binding */ AbstractTuiInteractive),
/* harmony export */   d5: () => (/* binding */ AbstractTuiDialogService),
/* harmony export */   td: () => (/* binding */ TuiController)
/* harmony export */ });
/* unused harmony export AbstractTuiMultipleControl */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7582);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(3738);
/* harmony import */ var _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8939);
/* harmony import */ var _taiga_ui_cdk_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3770);
/* harmony import */ var _taiga_ui_cdk_decorators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4358);
/* harmony import */ var _taiga_ui_cdk_utils_miscellaneous__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8659);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9765);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(6682);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(8891);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(6215);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(6782);
/* harmony import */ var _taiga_ui_cdk_services__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(3503);













var AbstractTuiInteractive_1;
const TUI = 'tui_interactive_';
/**
 * The most basic class for interactive components
 */
let AbstractTuiInteractive = AbstractTuiInteractive_1 = class AbstractTuiInteractive {
  constructor() {
    this.hovered = false;
    this.pressed = false;
    this.focusVisible = false;
    this.pseudoHovered = null;
    this.pseudoPressed = null;
    this.pseudoFocused = null;
    /**
     * Determines if component is focusable with keyboard.
     */
    this.focusable = true;
    this.nativeId = '';
    /**
     * Emits 'true' on focus and 'false' on blur.
     */
    this.focusedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    this.pressedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    this.hoveredChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    this.focusVisibleChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    this.autoIdString = `${TUI}${AbstractTuiInteractive_1.autoId++}${Date.now()}`;
  }
  get computedDisabled() {
    return this.disabled;
  }
  get computedHovered() {
    return !this.computedDisabled && (0,_taiga_ui_cdk_utils_miscellaneous__WEBPACK_IMPORTED_MODULE_1__/* .fallbackValue */ .je)(this.pseudoHovered, this.hovered);
  }
  get computedPressed() {
    return !this.computedDisabled && (0,_taiga_ui_cdk_utils_miscellaneous__WEBPACK_IMPORTED_MODULE_1__/* .fallbackValue */ .je)(this.pseudoPressed, this.pressed);
  }
  get computedFocusable() {
    return !this.computedDisabled && (this.focusable || this.focused);
  }
  get computedFocused() {
    return !this.computedDisabled && (0,_taiga_ui_cdk_utils_miscellaneous__WEBPACK_IMPORTED_MODULE_1__/* .fallbackValue */ .je)(this.pseudoFocused, this.focused);
  }
  get computedFocusVisible() {
    return !this.computedDisabled && (0,_taiga_ui_cdk_utils_miscellaneous__WEBPACK_IMPORTED_MODULE_1__/* .fallbackValue */ .je)(this.pseudoFocused, this.focusVisible);
  }
  get id() {
    return !!this.nativeId ? this.nativeId : this.autoIdString;
  }
  updateHovered(hovered) {
    if (this.hovered === hovered) {
      return;
    }
    this.hovered = hovered;
    this.hoveredChange.emit(hovered);
  }
  updatePressed(pressed) {
    if (this.pressed === pressed) {
      return;
    }
    this.pressed = pressed;
    this.pressedChange.emit(pressed);
  }
  updateFocused(focused) {
    this.focusedChange.emit(focused);
  }
  updateFocusVisible(focusVisible) {
    if (this.focusVisible === focusVisible) {
      return;
    }
    this.focusVisible = focusVisible;
    this.focusVisibleChange.emit(focusVisible);
  }
};
AbstractTuiInteractive.ɵfac = function AbstractTuiInteractive_Factory(t) {
  return new (t || AbstractTuiInteractive)();
};
AbstractTuiInteractive.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
  type: AbstractTuiInteractive,
  hostVars: 10,
  hostBindings: function AbstractTuiInteractive_HostBindings(rf, ctx) {
    if (rf & 2) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("_disabled", ctx.computedDisabled)("_hovered", ctx.computedHovered)("_pressed", ctx.computedPressed)("_focused", ctx.computedFocused)("_focus-visible", ctx.computedFocusVisible);
    }
  },
  inputs: {
    pseudoHovered: "pseudoHovered",
    pseudoPressed: "pseudoPressed",
    pseudoFocused: "pseudoFocused",
    focusable: "focusable",
    nativeId: "nativeId"
  },
  outputs: {
    focusedChange: "focusedChange",
    pressedChange: "pressedChange",
    hoveredChange: "hoveredChange",
    focusVisibleChange: "focusVisibleChange"
  }
});
AbstractTuiInteractive.autoId = 0;
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk_decorators__WEBPACK_IMPORTED_MODULE_3__/* .tuiDefaultProp */ .TH)()], AbstractTuiInteractive.prototype, "pseudoHovered", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk_decorators__WEBPACK_IMPORTED_MODULE_3__/* .tuiDefaultProp */ .TH)()], AbstractTuiInteractive.prototype, "pseudoPressed", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk_decorators__WEBPACK_IMPORTED_MODULE_3__/* .tuiDefaultProp */ .TH)()], AbstractTuiInteractive.prototype, "pseudoFocused", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk_decorators__WEBPACK_IMPORTED_MODULE_3__/* .tuiDefaultProp */ .TH)()], AbstractTuiInteractive.prototype, "focusable", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk_decorators__WEBPACK_IMPORTED_MODULE_3__/* .tuiDefaultProp */ .TH)()], AbstractTuiInteractive.prototype, "nativeId", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Output)()], AbstractTuiInteractive.prototype, "focusedChange", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Output)()], AbstractTuiInteractive.prototype, "pressedChange", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Output)()], AbstractTuiInteractive.prototype, "hoveredChange", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Output)()], AbstractTuiInteractive.prototype, "focusVisibleChange", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._disabled')], AbstractTuiInteractive.prototype, "computedDisabled", null);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._hovered')], AbstractTuiInteractive.prototype, "computedHovered", null);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._pressed')], AbstractTuiInteractive.prototype, "computedPressed", null);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._focused')], AbstractTuiInteractive.prototype, "computedFocused", null);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._focus-visible')], AbstractTuiInteractive.prototype, "computedFocusVisible", null);

/**
 * Basic ControlValueAccessor class to build form components upon
 */
let AbstractTuiControl = /*#__PURE__*/(() => {
  let AbstractTuiControl = class AbstractTuiControl extends AbstractTuiInteractive {
    constructor(ngControl, changeDetectorRef) {
      super();
      this.ngControl = ngControl;
      this.changeDetectorRef = changeDetectorRef;
      this.onTouched = _taiga_ui_cdk_constants__WEBPACK_IMPORTED_MODULE_4__/* .EMPTY_FUNCTION */ .iD;
      this.onChange = _taiga_ui_cdk_constants__WEBPACK_IMPORTED_MODULE_4__/* .EMPTY_FUNCTION */ .iD;
      this.fallbackValue = this.getFallbackValue();
      this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_5__/* .Subject */ .xQ();
      this.readOnly = false;
      this.pseudoInvalid = null;
      if (this.ngControl === null) {
        _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_6__/* .tuiAssert */ .z.assert(false, `NgControl not injected in ${this.constructor.name}!\n`, 'Use [(ngModel)] or [formControl] or formControlName for correct work.');
      } else {
        this.ngControl.valueAccessor = this;
      }
    }
    get computedInvalid() {
      return !this.readOnly && !this.disabled && (this.pseudoInvalid !== null ? this.pseudoInvalid : this.touched && this.invalid);
    }
    get value() {
      return (0,_taiga_ui_cdk_utils_miscellaneous__WEBPACK_IMPORTED_MODULE_1__/* .fallbackValue */ .je)(this.previousInternalValue, this.fallbackValue);
    }
    get safeCurrentValue() {
      return (0,_taiga_ui_cdk_utils_miscellaneous__WEBPACK_IMPORTED_MODULE_1__/* .fallbackValue */ .je)(this.rawValue, this.fallbackValue);
    }
    get invalid() {
      return this.safeNgControlData(({
        invalid
      }) => invalid, false);
    }
    get valid() {
      return this.safeNgControlData(({
        valid
      }) => valid, false);
    }
    get touched() {
      return this.safeNgControlData(({
        touched
      }) => touched, false);
    }
    get disabled() {
      return this.safeNgControlData(({
        disabled
      }) => disabled, false);
    }
    get control() {
      return this.safeNgControlData(({
        control
      }) => control, null);
    }
    get computedName() {
      return this.controlName;
    }
    get controlName() {
      return this.ngControl && this.ngControl.name;
    }
    get rawValue() {
      const {
        ngControl
      } = this;
      if (ngControl === null) {
        return undefined;
      }
      return ngControl instanceof _angular_forms__WEBPACK_IMPORTED_MODULE_7__.NgModel && this.previousInternalValue === undefined ? ngControl.viewModel : ngControl.value;
    }
    ngOnInit() {
      if (!this.ngControl || !this.ngControl.valueChanges || !this.ngControl.statusChanges) {
        return;
      }
      (0,rxjs__WEBPACK_IMPORTED_MODULE_8__/* .merge */ .T)(this.ngControl.valueChanges, this.ngControl.statusChanges).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__/* .takeUntil */ .R)(this.destroy$)).subscribe(() => {
        this.refreshLocalValue(this.safeCurrentValue);
      });
    }
    ngOnDestroy() {
      this.destroy$.next();
      this.destroy$.complete();
    }
    checkControlUpdate() {
      this.changeDetectorRef.markForCheck();
    }
    registerOnChange(onChange) {
      this.onChange = onChange;
    }
    registerOnTouched(onTouched) {
      this.onTouched = onTouched;
    }
    setDisabledState() {
      this.checkControlUpdate();
    }
    writeValue(value) {
      this.refreshLocalValue(this.ngControl instanceof _angular_forms__WEBPACK_IMPORTED_MODULE_7__.NgModel && this.previousInternalValue === undefined ? this.ngControl.model : value);
    }
    updateFocused(focused) {
      if (!focused) {
        this.controlMarkAsTouched();
      }
      super.updateFocused(focused);
    }
    updateValue(value) {
      if (this.disabled || this.valueIdenticalComparator(this.value, value)) {
        return;
      }
      this.previousInternalValue = value;
      this.controlSetValue(value);
    }
    valueIdenticalComparator(oldValue, newValue) {
      return oldValue === newValue;
    }
    safeNgControlData(extractor, defaultFieldValue) {
      return (0,_taiga_ui_cdk_utils_miscellaneous__WEBPACK_IMPORTED_MODULE_1__/* .fallbackValue */ .je)(this.ngControl && extractor(this.ngControl), defaultFieldValue);
    }
    controlMarkAsTouched() {
      this.onTouched();
      this.checkControlUpdate();
    }
    controlSetValue(value) {
      this.onChange(value);
      this.checkControlUpdate();
    }
    refreshLocalValue(value) {
      this.previousInternalValue = value;
      this.checkControlUpdate();
    }
  };
  AbstractTuiControl.ɵfac = function AbstractTuiControl_Factory(t) {
    return new (t || AbstractTuiControl)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_forms__WEBPACK_IMPORTED_MODULE_7__.NgControl), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef));
  };
  AbstractTuiControl.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
    type: AbstractTuiControl,
    hostVars: 4,
    hostBindings: function AbstractTuiControl_HostBindings(rf, ctx) {
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("_readonly", ctx.readOnly)("_invalid", ctx.computedInvalid);
      }
    },
    inputs: {
      readOnly: "readOnly",
      pseudoInvalid: "pseudoInvalid"
    },
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]]
  });
  (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._readonly'), (0,_taiga_ui_cdk_decorators__WEBPACK_IMPORTED_MODULE_3__/* .tuiDefaultProp */ .TH)()], AbstractTuiControl.prototype, "readOnly", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk_decorators__WEBPACK_IMPORTED_MODULE_3__/* .tuiDefaultProp */ .TH)()], AbstractTuiControl.prototype, "pseudoInvalid", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._invalid')], AbstractTuiControl.prototype, "computedInvalid", null);
  return AbstractTuiControl;
})();
let TuiController = /*#__PURE__*/(() => {
  class TuiController {
    constructor() {
      this.change$ = new rxjs__WEBPACK_IMPORTED_MODULE_5__/* .Subject */ .xQ();
    }
    ngOnChanges() {
      this.change$.next();
    }
  }
  TuiController.ɵfac = function TuiController_Factory(t) {
    return new (t || TuiController)();
  };
  TuiController.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
    type: TuiController,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
  });
  return TuiController;
})();
let AbstractTuiDialogService = /*#__PURE__*/(() => {
  let AbstractTuiDialogService = class AbstractTuiDialogService extends rxjs__WEBPACK_IMPORTED_MODULE_10__/* .Observable */ .y {
    constructor(idService) {
      super(observer => this.dialogs$.subscribe(observer));
      this.idService = idService;
      this.dialogs$ = new rxjs__WEBPACK_IMPORTED_MODULE_11__/* .BehaviorSubject */ .X([]);
    }
    open(content, options = {}) {
      return new rxjs__WEBPACK_IMPORTED_MODULE_10__/* .Observable */ .y(observer => {
        const completeWith = result => {
          observer.next(result);
          observer.complete();
        };
        const dialog = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), options), {
          content,
          completeWith,
          $implicit: observer,
          component: this.component,
          id: this.idService.generate()
        });
        this.dialogs$.next([...this.dialogs$.value, dialog]);
        return () => {
          this.dialogs$.next(this.dialogs$.value.filter(item => item !== dialog));
        };
      });
    }
  };
  AbstractTuiDialogService.ɵfac = function AbstractTuiDialogService_Factory(t) {
    return new (t || AbstractTuiDialogService)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_taiga_ui_cdk_services__WEBPACK_IMPORTED_MODULE_12__/* .TuiIdService */ .ll));
  };
  AbstractTuiDialogService.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: AbstractTuiDialogService,
    factory: function (t) {
      return AbstractTuiDialogService.ɵfac(t);
    }
  });
  AbstractTuiDialogService = (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_cdk_services__WEBPACK_IMPORTED_MODULE_12__/* .TuiIdService */ .ll))], AbstractTuiDialogService);
  return AbstractTuiDialogService;
})();
let AbstractTuiMultipleControl = /*#__PURE__*/(/* unused pure expression or super */ null && ((() => {
  let AbstractTuiMultipleControl = class AbstractTuiMultipleControl extends AbstractTuiControl {
    clear() {
      this.updateValue([]);
    }
    getFallbackValue() {
      return [];
    }
  };
  AbstractTuiMultipleControl.ɵfac = /*@__PURE__*/function () {
    let ɵAbstractTuiMultipleControl_BaseFactory;
    return function AbstractTuiMultipleControl_Factory(t) {
      return (ɵAbstractTuiMultipleControl_BaseFactory || (ɵAbstractTuiMultipleControl_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AbstractTuiMultipleControl)))(t || AbstractTuiMultipleControl);
    };
  }();
  AbstractTuiMultipleControl.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({
    type: AbstractTuiMultipleControl,
    features: [ɵngcc0.ɵɵInheritDefinitionFeature]
  });
  return AbstractTuiMultipleControl;
})()));
let AbstractTuiNullableControl = /*#__PURE__*/(() => {
  let AbstractTuiNullableControl = class AbstractTuiNullableControl extends AbstractTuiControl {
    getFallbackValue() {
      return null;
    }
  };
  AbstractTuiNullableControl.ɵfac = /*@__PURE__*/function () {
    let ɵAbstractTuiNullableControl_BaseFactory;
    return function AbstractTuiNullableControl_Factory(t) {
      return (ɵAbstractTuiNullableControl_BaseFactory || (ɵAbstractTuiNullableControl_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](AbstractTuiNullableControl)))(t || AbstractTuiNullableControl);
    };
  }();
  AbstractTuiNullableControl.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
    type: AbstractTuiNullableControl,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]]
  });
  return AbstractTuiNullableControl;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * Use this abstract class to create your own toggleable themes.
 * A component extending this class must have CSS variables definitions
 * and have ViewEncapsulation set to NONE. A boolean input allows to
 * switch theme on or off.
 */
let AbstractTuiThemeSwitcher = /*#__PURE__*/(() => {
  class AbstractTuiThemeSwitcher {
    constructor(documentRef) {
      this.documentRef = documentRef;
      if (this.style !== null) {
        this.addTheme();
        return;
      }
      const styles = this.documentRef.head.querySelectorAll('style');
      this.constructor.style = styles[styles.length - 1];
    }
    get style() {
      return this.constructor.style;
    }
    ngOnDestroy() {
      this.removeTheme();
    }
    addTheme() {
      if (this.style && !this.documentRef.head.contains(this.style)) {
        for (let i = this.style.attributes.length - 1; i >= 0; i--) {
          this.style.removeAttribute(this.style.attributes[i].name);
        }
        this.documentRef.head.appendChild(this.style);
      }
    }
    removeTheme() {
      if (this.style && this.documentRef.head.contains(this.style)) {
        this.documentRef.head.removeChild(this.style);
      }
    }
  }
  AbstractTuiThemeSwitcher.ɵfac = function AbstractTuiThemeSwitcher_Factory(t) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinvalidFactory"]();
  };
  AbstractTuiThemeSwitcher.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
    type: AbstractTuiThemeSwitcher
  });
  AbstractTuiThemeSwitcher.style = null;

  /**
   * Generated bundle index. Do not edit.
   */
  return AbstractTuiThemeSwitcher;
})();


//# sourceMappingURL=taiga-ui-cdk-abstract.js.map

/***/ }),

/***/ 8939:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   z: () => (/* binding */ tuiAssert)
/* harmony export */ });
/* unused harmony export TuiValidationError */
/* harmony import */ var _taiga_ui_cdk_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3770);

const tuiAssert = {
  enabled: false,
  get assert() {
    return this.enabled ? Function.prototype.bind.call(console.assert, console) : _taiga_ui_cdk_constants__WEBPACK_IMPORTED_MODULE_0__/* .EMPTY_FUNCTION */ .iD;
  }
};
class TuiValidationError {
  constructor(message, context = {}) {
    this.message = message;
    this.context = context;
  }
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-classes.js.map

/***/ }),

/***/ 3770:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F: () => (/* binding */ CHAR_EN_DASH),
/* harmony export */   Iy: () => (/* binding */ ALWAYS_FALSE_HANDLER),
/* harmony export */   Kx: () => (/* binding */ TUI_PARENT_ANIMATION),
/* harmony export */   LZ: () => (/* binding */ EMPTY_ARRAY),
/* harmony export */   Lw: () => (/* binding */ svgNodeFilter),
/* harmony export */   Mm: () => (/* binding */ EMPTY_QUERY),
/* harmony export */   Yg: () => (/* binding */ POLLING_TIME),
/* harmony export */   bg: () => (/* binding */ TUI_DEFAULT_IDENTITY_MATCHER),
/* harmony export */   f$: () => (/* binding */ CHAR_NO_BREAK_SPACE),
/* harmony export */   iD: () => (/* binding */ EMPTY_FUNCTION),
/* harmony export */   yZ: () => (/* binding */ TUI_DEFAULT_STRINGIFY)
/* harmony export */ });
/* unused harmony exports ALWAYS_TRUE_HANDLER, CHAR_BULLET, CHAR_CURRENCY_SIGN, CHAR_ELLIPSIS, CHAR_ZERO_WIDTH_SPACE, EMPTY_VALIDATOR, TUI_DEFAULT_MATCHER, TUI_STRICT_MATCHER */
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6083);



/**
 * Handler that always returns `false`.
 */
const ALWAYS_FALSE_HANDLER = () => false;

/**
 * Handler that always returns `true`.
 */
const ALWAYS_TRUE_HANDLER = () => true;

/**
 * For type safety when using @ContentChildren and @ViewChildren
 *
 * NOTE: Be careful subscribing to 'changes'
 */
const EMPTY_QUERY = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.QueryList();
const EMPTY_ARRAY = [];
const EMPTY_FUNCTION = () => {};
const EMPTY_VALIDATOR = () => null;

/**
 * Default method to turn arbitrary object into string
 */
const TUI_DEFAULT_STRINGIFY = item => String(item);

/**
 * Default handler for matching stringified version of an item and a search query
 * @param item arbitrary element to match with a string
 * @param search search query
 * @param stringify handler to turn item into a string
 */
const TUI_DEFAULT_MATCHER = (item, search, stringify = TUI_DEFAULT_STRINGIFY) => stringify(item).toLowerCase().includes(search.toLowerCase());
/**
 * Default handler for strict matching stringified version of an item and a search query
 * @param item arbitrary element to match with a string
 * @param search search query
 * @param stringify handler to turn item into a string
 */
const TUI_STRICT_MATCHER = (item, search, stringify = TUI_DEFAULT_STRINGIFY) => stringify(item).toLowerCase() === search.toLowerCase();
/**
 * Default handler to match equality of two elements
 * ATTENTION: considers two empty arrays equal
 *
 * @param item1 first element
 * @param item2 second element
 */
const TUI_DEFAULT_IDENTITY_MATCHER = (item1, item2) => item1 === item2 || bothEmpty(item1, item2);
function bothEmpty(item1, item2) {
  return Array.isArray(item1) && Array.isArray(item2) && !item1.length && !item2.length;
}
const TUI_PARENT_ANIMATION = (0,_angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .trigger */ .X$)('tuiParentAnimation', [(0,_angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .transition */ .eR)(':enter', [(0,_angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .style */ .oB)({
  overflow: 'hidden'
}), (0,_angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .query */ .IO)('@*', [(0,_angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .animateChild */ .pV)()], {
  optional: true
})]), (0,_angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .transition */ .eR)(':leave', [(0,_angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .style */ .oB)({
  overflow: 'hidden'
}), (0,_angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .query */ .IO)('@*', [(0,_angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .animateChild */ .pV)()], {
  optional: true
})])]);
const POLLING_TIME = 1000 / 15;

// Filtering SVGElements for TreeWalker
// Filter must be a function in IE, other modern browsers are compliant to this format
const svgNodeFilter = node => 'ownerSVGElement' in node ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;

/**
 * {@link https://unicode-table.com/en/00A0/ Non-breaking space}.
 */
const CHAR_NO_BREAK_SPACE = '\u00A0';
/**
 * {@link https://unicode-table.com/en/2013/ EN dash}.
 */
const CHAR_EN_DASH = '\u2013';
/**
 * {@link https://unicode-table.com/en/2022/ Bullet}.
 */
const CHAR_BULLET = '\u2022';
/**
 * {@link https://unicode-table.com/en/2026/ Suspension points}.
 */
const CHAR_ELLIPSIS = '\u2026';
/**
 * {@link https://unicode-table.com/en/00A4/ Suspension points}.
 */
const CHAR_CURRENCY_SIGN = '\u00A4';
/**
 * {@link https://unicode-table.com/en/200b/ Suspension points}.
 */
const CHAR_ZERO_WIDTH_SPACE = '\u200b';

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-constants.js.map

/***/ }),

/***/ 4358:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NH: () => (/* binding */ tuiRequiredSetter),
/* harmony export */   TH: () => (/* binding */ tuiDefaultProp),
/* harmony export */   UM: () => (/* binding */ tuiPure)
/* harmony export */ });
/* harmony import */ var _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8939);


/**
 * Decorator for checking input values for undefined. You can also pass
 * optional assertion to check input against.
 *
 * See {@link createPropDecorator} for more details.
 *
 * CAUTION: This decorator overwrites other getters and setters.
 */
function tuiDefaultProp(assertion, ...args) {
  return (target, key) => {
    const {
      name
    } = target.constructor;
    const errorGetDefaultMessage = errorGetDefault(key, name);
    const errorSetDefaultMessage = errorSetDefault(key, name);
    Object.defineProperty(target, key, {
      get() {
        _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .z.assert(false, errorGetDefaultMessage);
        return undefined;
      },
      set(initialValue) {
        const isValid = initialValue !== undefined;
        const errorMessage = errorSetDefaultInitial(key, name);
        let currentValue = initialValue;
        _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .z.assert(isValid, errorMessage);
        if (isValid && assertion) {
          _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .z.assert(assertion.call(this, initialValue), `${String(key)} in ${name} received:`, initialValue, ...args);
        }
        Object.defineProperty(this, key, {
          get() {
            return currentValue;
          },
          set(value) {
            const isValid = value !== undefined;
            const backupValue = initialValue;
            _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .z.assert(isValid, errorSetDefaultMessage, String(backupValue));
            if (isValid && assertion) {
              _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .z.assert(assertion.call(this, value), `${String(key)} in ${name} received:`, value, ...args);
            }
            currentValue = isValid ? value : backupValue;
          }
        });
      }
    });
  };
}
function errorGetDefault(key, component) {
  return `Default value for ${String(key)} was not provided in ${component}, error in Taiga UI Angular Kit`;
}
function errorSetDefault(key, component) {
  return `Undefined was passed as ${String(key)} to ${component}, which is invalid input, using default value:`;
}
function errorSetDefaultInitial(key, component) {
  return `Undefined was passed as default value for ${String(key)} to ${component}, error in Taiga UI Angular Kit`;
}

/**
 * Implements lazy initialization for getter or memoization of a function call similar to pure {@link: Pipe}.
 * Replaces getter with its calculated value upon first call or keeps track of last call arguments and returned
 * value for function, skipping calculation when arguments are strictly the same.
 *
 * @throws error if used not on getter or function
 *
 * CAUTION: `this` is not available inside such functions/getters, they must be pure.
 */
function tuiPure(_target, propertyKey, {
  get,
  enumerable,
  value
}) {
  if (get) {
    return {
      enumerable,
      get() {
        const value = get.call(this);
        Object.defineProperty(this, propertyKey, {
          enumerable,
          value
        });
        return value;
      }
    };
  }
  if (typeof value !== 'function') {
    throw new Error('tuiPure can only be used with functions or getters');
  }
  const original = value;
  return {
    enumerable,
    get() {
      let previousArgs = [];
      let previousResult;
      const patched = (...args) => {
        if (previousArgs.length === args.length && args.every((arg, index) => arg === previousArgs[index])) {
          return previousResult;
        }
        previousArgs = args;
        previousResult = original.apply(this, args);
        return previousResult;
      };
      Object.defineProperty(this, propertyKey, {
        value: patched
      });
      return patched;
    }
  };
}

/**
 * Decorator for checking input setter values against a custom assertion which
 * takes value passed to input setter and component instance as arguments.
 * It specifically checks for undefined values and prevents calls to the
 * original setter in this case.
 */
function tuiRequiredSetter(assertion, ...args) {
  return (target, key, {
    configurable,
    enumerable,
    get,
    set
  }) => {
    const {
      name
    } = target.constructor;
    return {
      configurable,
      enumerable,
      get,
      set(value) {
        if (value !== undefined && assertion) {
          _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .z.assert(assertion.call(this, value), `${String(key)} in ${name} received:`, value, ...args);
        }
        if (!set || value === undefined) {
          _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .z.assert(value !== undefined, errorSet(key, name));
          return;
        }
        set.call(this, value);
      }
    };
  };
}
function errorSet(key, component) {
  return `Undefined was passed as ${String(key)} to ${component}, setter will not be called`;
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-decorators.js.map

/***/ }),

/***/ 2668:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ls: () => (/* binding */ TuiLetDirective),
/* harmony export */   WD: () => (/* binding */ TuiLetModule)
/* harmony export */ });
/* unused harmony export TuiLetContext */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7582);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);



/**
 * @internal
 */

class TuiLetContext {
  constructor(internalDirectiveInstance) {
    this.internalDirectiveInstance = internalDirectiveInstance;
  }
  get $implicit() {
    return this.internalDirectiveInstance.tuiLet;
  }
  get tuiLet() {
    return this.internalDirectiveInstance.tuiLet;
  }
}

/**
 * Works like *ngIf but does not have a condition — use it to declare
 * the result of pipes calculation (i.e. async pipe)
 */
let TuiLetDirective = /*#__PURE__*/(() => {
  let TuiLetDirective = class TuiLetDirective {
    constructor(viewContainer, templateRef) {
      viewContainer.createEmbeddedView(templateRef, new TuiLetContext(this));
    }
    /**
     * Asserts the correct type of the context for the template that `TuiLet` will render.
     *
     * The presence of this method is a signal to the Ivy template type-check compiler that the
     * `TuiLet` structural directive renders its template with a specific context type.
     */
    static ngTemplateContextGuard(_dir, _ctx) {
      return true;
    }
  };
  TuiLetDirective.ɵfac = function TuiLetDirective_Factory(t) {
    return new (t || TuiLetDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef));
  };
  TuiLetDirective.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
    type: TuiLetDirective,
    selectors: [["", "tuiLet", ""]],
    inputs: {
      tuiLet: "tuiLet"
    }
  });
  (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)()], TuiLetDirective.prototype, "tuiLet", void 0);
  TuiLetDirective = (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef)), (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__param */ .fM)(1, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef))], TuiLetDirective);
  return TuiLetDirective;
})();
let TuiLetModule = /*#__PURE__*/(() => {
  let TuiLetModule = class TuiLetModule {};
  TuiLetModule.ɵfac = function TuiLetModule_Factory(t) {
    return new (t || TuiLetModule)();
  };
  TuiLetModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
    type: TuiLetModule
  });
  TuiLetModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({});
  return TuiLetModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](TuiLetModule, {
    declarations: [TuiLetDirective],
    exports: [TuiLetDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-let.js.map

/***/ }),

/***/ 908:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AA: () => (/* binding */ dragAndDropFrom),
  So: () => (/* binding */ focusVisibleObservable),
  Fp: () => (/* binding */ itemsQueryListObservable),
  _d: () => (/* binding */ pressedObservable),
  PF: () => (/* binding */ preventDefault),
  UW: () => (/* binding */ stopPropagation),
  Gx: () => (/* binding */ tuiReplayedValueChangesFrom),
  Yr: () => (/* binding */ tuiZoneOptimized),
  fL: () => (/* binding */ tuiZonefree),
  eh: () => (/* binding */ typedFromEvent),
  YP: () => (/* binding */ watch)
});

// UNUSED EXPORTS: TuiDragState, mouseDragFinishFrom, mustBePresent, tuiIsAlive, tuiZonefull

// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-miscellaneous.js
var taiga_ui_cdk_utils_miscellaneous = __webpack_require__(8659);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/fromEvent.js
var fromEvent = __webpack_require__(2759);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/merge.js
var merge = __webpack_require__(6682);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/concat.js + 1 modules
var concat = __webpack_require__(8071);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/pipe.js
var pipe = __webpack_require__(4022);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/timer.js
var timer = __webpack_require__(6797);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Observable.js + 2 modules
var Observable = __webpack_require__(8891);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/take.js
var take = __webpack_require__(5257);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js
var operators_map = __webpack_require__(8002);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/of.js
var of = __webpack_require__(5917);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/endWith.js


function endWith(...array) {
  return source => (0,concat/* concat */.z)(source, (0,of.of)(...array));
}
//# sourceMappingURL=endWith.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/takeWhile.js
var takeWhile = __webpack_require__(409);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/repeat.js
var repeat = __webpack_require__(9196);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/switchMapTo.js
var switchMapTo = __webpack_require__(9499);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/mapTo.js
var mapTo = __webpack_require__(6736);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/startWith.js
var startWith = __webpack_require__(9761);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js
var distinctUntilChanged = __webpack_require__(7519);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/shareReplay.js
var shareReplay = __webpack_require__(7349);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/filter.js
var filter = __webpack_require__(5435);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscriber.js
var Subscriber = __webpack_require__(7393);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/ignoreElements.js

function ignoreElements() {
  return function ignoreElementsOperatorFunction(source) {
    return source.lift(new IgnoreElementsOperator());
  };
}
class IgnoreElementsOperator {
  call(subscriber, source) {
    return source.subscribe(new IgnoreElementsSubscriber(subscriber));
  }
}
class IgnoreElementsSubscriber extends Subscriber/* Subscriber */.L {
  _next(unused) {}
}
//# sourceMappingURL=ignoreElements.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/withLatestFrom.js
var withLatestFrom = __webpack_require__(7057);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/tap.js
var tap = __webpack_require__(8307);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-focus.js
var taiga_ui_cdk_utils_focus = __webpack_require__(7179);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-observables.js




function typedFromEvent(target, event, options = {}) {
  return (0,fromEvent/* fromEvent */.R)(target, event, options);
}

/**
 * Letting go of the mouse after it was pressed
 * @param target
 */
function mouseDragFinishFrom(target) {
  return (0,merge/* merge */.T)(typedFromEvent(target, 'mouseup'), typedFromEvent(target, 'dragend'));
}
class TuiDragState {
  constructor(stage, event) {
    this.stage = stage;
    this.event = event;
  }
}
function dragAndDropFrom(element) {
  const {
    ownerDocument
  } = element;
  if (!ownerDocument) {
    throw new Error('element does not have ownerDocument');
  }
  return (0,concat/* concat */.z)(typedFromEvent(element, 'mousedown').pipe((0,take/* take */.q)(1), (0,operators_map/* map */.U)(event => new TuiDragState(0 /* Start */, event))), (0,merge/* merge */.T)(typedFromEvent(ownerDocument, 'mousemove').pipe((0,operators_map/* map */.U)(event => new TuiDragState(1 /* Continues */, event))), mouseDragFinishFrom(ownerDocument).pipe((0,take/* take */.q)(1), (0,operators_map/* map */.U)(event => new TuiDragState(2 /* End */, event)), endWith(null))).pipe((0,takeWhile/* takeWhile */.o)(taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN))).pipe((0,repeat/* repeat */.r)());
}

/**
 * Operator to set lifespan after which current value is considered obsolete
 */
function tuiIsAlive(lifespan = 0) {
  return (0,pipe/* pipe */.z)((0,switchMapTo/* switchMapTo */.c)((0,timer/* timer */.H)(lifespan).pipe((0,mapTo/* mapTo */.h)(false), (0,startWith/* startWith */.O)(true))), (0,distinctUntilChanged/* distinctUntilChanged */.x)());
}
let documentMouseUpIsAlive$;
let documentMouseDownIsAlive$;
function focusVisibleObservable(element) {
  const elementBlur$ = typedFromEvent(element, 'blur');
  const {
    ownerDocument
  } = element;
  if (!ownerDocument) {
    throw new Error('element does not have ownerDocument');
  }
  if (!documentMouseDownIsAlive$ || !documentMouseUpIsAlive$) {
    documentMouseUpIsAlive$ = typedFromEvent(ownerDocument, 'mouseup', {
      capture: true
    }).pipe(tuiIsAlive(), (0,startWith/* startWith */.O)(false), (0,shareReplay/* shareReplay */.d)(1));
    documentMouseDownIsAlive$ = typedFromEvent(ownerDocument, 'mousedown', {
      capture: true
    }).pipe(tuiIsAlive(), (0,startWith/* startWith */.O)(false), (0,shareReplay/* shareReplay */.d)(1));
  }
  return (0,merge/* merge */.T)(
  // focus events excluding ones that came right after mouse action
  (0,concat/* concat */.z)(typedFromEvent(element, 'focus').pipe((0,take/* take */.q)(1)),
  // filtering out blur events when element remains focused so that we ignore browser tab focus loss
  elementBlur$.pipe((0,filter/* filter */.h)(() => !(0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(element)), (0,take/* take */.q)(1), ignoreElements())).pipe((0,repeat/* repeat */.r)(), (0,withLatestFrom/* withLatestFrom */.M)(documentMouseDownIsAlive$, documentMouseUpIsAlive$, (_event, elementActual, documentActual) => elementActual || documentActual), (0,filter/* filter */.h)(isUserFocus => !isUserFocus))).pipe((0,switchMapTo/* switchMapTo */.c)(elementBlur$.pipe((0,mapTo/* mapTo */.h)(false), (0,take/* take */.q)(1), (0,startWith/* startWith */.O)(true))), (0,distinctUntilChanged/* distinctUntilChanged */.x)());
}

/**
 * Converts changes observable of a QueryList to an Observable of arrays
 */
function itemsQueryListObservable(queryList) {
  return queryList.changes.pipe((0,operators_map/* map */.U)(() => (0,taiga_ui_cdk_utils_miscellaneous/* getOriginalArrayFromQueryList */.ct)(queryList)), (0,startWith/* startWith */.O)((0,taiga_ui_cdk_utils_miscellaneous/* getOriginalArrayFromQueryList */.ct)(queryList)));
}
function mustBePresent() {
  return map(value => {
    if (!isPresent(value)) {
      throw new Error('Value must present');
    }
    return value;
  });
}
function pressedObservable(element) {
  const {
    ownerDocument
  } = element;
  if (!ownerDocument) {
    throw new Error('element does not have ownerDocument');
  }
  return typedFromEvent(element, 'mousedown').pipe((0,filter/* filter */.h)(({
    isTrusted
  }) => isTrusted), (0,switchMapTo/* switchMapTo */.c)(mouseDragFinishFrom(ownerDocument).pipe((0,mapTo/* mapTo */.h)(false), (0,take/* take */.q)(1), (0,startWith/* startWith */.O)(true))));
}
function preventDefault() {
  return (0,tap/* tap */.b)(e => {
    e.preventDefault();
  });
}

/**
 * Turns AbstractControl/Abstract-control-directive valueChanges into ReplaySubject(1)
 */
function tuiReplayedValueChangesFrom(control) {
  return new Observable/* Observable */.y(subscriber => {
    if (!control.valueChanges) {
      throw new Error('Control does not have valueChanges');
    }
    control.valueChanges.pipe((0,startWith/* startWith */.O)(control.value)).subscribe(subscriber);
  });
}
function stopPropagation() {
  return (0,tap/* tap */.b)(e => {
    e.stopPropagation();
  });
}
function watch(changeDetectorRef) {
  return (0,tap/* tap */.b)(() => {
    changeDetectorRef.markForCheck();
  });
}
class TuiZonefreeOperator {
  constructor(ngZone) {
    this.ngZone = ngZone;
  }
  call(observer, source) {
    return this.ngZone.runOutsideAngular(() => source.subscribe(observer));
  }
}
function tuiZonefull(ngZone) {
  return source => new Observable/* Observable */.y(subscriber => source.subscribe({
    next: value => ngZone.run(() => subscriber.next(value)),
    error: error => ngZone.run(() => subscriber.error(error)),
    complete: () => ngZone.run(() => subscriber.complete())
  }));
}
function tuiZonefree(ngZone) {
  return source => source.lift(new TuiZonefreeOperator(ngZone));
}
function tuiZoneOptimized(ngZone) {
  return (0,pipe/* pipe */.z)(tuiZonefree(ngZone), tuiZonefull(ngZone));
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-observables.js.map

/***/ }),

/***/ 3503:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  a3: () => (/* binding */ TuiDestroyService),
  gH: () => (/* binding */ TuiDirectiveStylesService),
  ku: () => (/* binding */ TuiFocusVisibleService),
  gs: () => (/* binding */ TuiHoveredService),
  ll: () => (/* binding */ TuiIdService),
  AQ: () => (/* binding */ TuiObscuredService),
  b0: () => (/* binding */ TuiParentsScrollService),
  tl: () => (/* binding */ TuiResizeService),
  Fr: () => (/* binding */ TuiStaticRequestService)
});

// UNUSED EXPORTS: TuiScrollService

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.mjs
var tslib_es6 = __webpack_require__(7582);
// EXTERNAL MODULE: consume shared module (default) @angular/core@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/core/fesm2015/core.js)
var core_js_ = __webpack_require__(8312);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subject.js
var Subject = __webpack_require__(9765);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Observable.js + 2 modules
var Observable = __webpack_require__(8891);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/merge.js
var merge = __webpack_require__(6682);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/defer.js
var observable_defer = __webpack_require__(1439);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/fromEvent.js
var fromEvent = __webpack_require__(2759);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/interval.js
var interval = __webpack_require__(945);
// EXTERNAL MODULE: consume shared module (default) @angular/common@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/common/fesm2015/common.js)
var common_js_ = __webpack_require__(3008);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-tokens.js
var taiga_ui_cdk_tokens = __webpack_require__(8096);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-observables.js + 2 modules
var taiga_ui_cdk_observables = __webpack_require__(908);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/takeUntil.js
var operators_takeUntil = __webpack_require__(6782);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/switchMap.js
var operators_switchMap = __webpack_require__(3190);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/filter.js
var filter = __webpack_require__(5435);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/take.js
var take = __webpack_require__(5257);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/mapTo.js
var mapTo = __webpack_require__(6736);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/startWith.js
var startWith = __webpack_require__(9761);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js
var distinctUntilChanged = __webpack_require__(7519);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/delay.js + 1 modules
var delay = __webpack_require__(1289);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js
var operators_map = __webpack_require__(8002);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/catchError.js
var catchError = __webpack_require__(5304);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/debounceTime.js
var debounceTime = __webpack_require__(4395);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/shareReplay.js
var shareReplay = __webpack_require__(7349);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-dom.js
var taiga_ui_cdk_utils_dom = __webpack_require__(5242);
// EXTERNAL MODULE: ./node_modules/@ng-web-apis/common/fesm2015/ng-web-apis-common.js
var ng_web_apis_common = __webpack_require__(2579);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-constants.js
var taiga_ui_cdk_constants = __webpack_require__(3770);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/share.js + 1 modules
var share = __webpack_require__(8819);
;// CONCATENATED MODULE: ./node_modules/@ng-web-apis/resize-observer/fesm2015/ng-web-apis-resize-observer.js





/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */


const RESIZE_OPTION_BOX_DEFAULT = 'content-box';
/** @type {?} */
const RESIZE_OPTION_BOX = new core_js_.InjectionToken('Box model to observe changes', {
  providedIn: 'root',
  factory: () => RESIZE_OPTION_BOX_DEFAULT
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const RESIZE_OBSERVER_SUPPORT = new core_js_.InjectionToken('Resize Observer API support', {
  providedIn: 'root',
  factory: () => !!(0,core_js_.inject)(ng_web_apis_common/* WINDOW */.m9).ResizeObserver
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @dynamic
let ResizeObserverService = /*#__PURE__*/(() => {
  class ResizeObserverService extends Observable/* Observable */.y {
    /**
     * @param {?} __0
     * @param {?} ngZone
     * @param {?} support
     * @param {?} box
     */
    constructor({
      nativeElement
    }, ngZone, support, box) {
      /** @type {?} */
      let observer;
      super(subscriber => {
        if (!support) {
          subscriber.error('ResizeObserver is not supported in your browser');
          return;
        }
        observer = new ResizeObserver(entries => {
          ngZone.run(() => {
            subscriber.next(entries);
          });
        });
        observer.observe(nativeElement, {
          box
        });
        return () => {
          observer.disconnect();
        };
      });
      return this.pipe((0,share/* share */.B)());
    }
  }
  ResizeObserverService.ɵfac = function ResizeObserverService_Factory(t) {
    return new (t || ResizeObserverService)(core_js_["ɵɵinject"](core_js_.ElementRef), core_js_["ɵɵinject"](core_js_.NgZone), core_js_["ɵɵinject"](RESIZE_OBSERVER_SUPPORT), core_js_["ɵɵinject"](RESIZE_OPTION_BOX));
  };
  ResizeObserverService.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: ResizeObserverService,
    factory: ResizeObserverService.ɵfac
  });
  /** @nocollapse */
  return ResizeObserverService;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// TODO switch to Attribute once https://github.com/angular/angular/issues/36479 is fixed
/**
 * @param {?} __0
 * @return {?}
 */
function boxExtractor({
  nativeElement
}) {
  /** @type {?} */
  const attribute = /** @type {?} */nativeElement.getAttribute('waResizeBox');
  return boxFactory(attribute);
}
/**
 * @param {?} box
 * @return {?}
 */
function boxFactory(box) {
  return box || RESIZE_OPTION_BOX_DEFAULT;
}
// @dynamic
let ResizeObserverDirective = /*#__PURE__*/(() => {
  class ResizeObserverDirective {
    /**
     * @param {?} entries$
     * @param {?} _box
     */
    constructor(entries$, _box) {
      this.waResizeObserver = entries$;
    }
  }
  ResizeObserverDirective.ɵfac = function ResizeObserverDirective_Factory(t) {
    return new (t || ResizeObserverDirective)(core_js_["ɵɵdirectiveInject"](ResizeObserverService), core_js_["ɵɵinjectAttribute"]('waResizeBox'));
  };
  ResizeObserverDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: ResizeObserverDirective,
    selectors: [["", "waResizeObserver", ""]],
    outputs: {
      waResizeObserver: "waResizeObserver"
    },
    features: [core_js_["ɵɵProvidersFeature"]([ResizeObserverService, {
      provide: RESIZE_OPTION_BOX,
      deps: [core_js_.ElementRef],
      useFactory: boxExtractor
    }])]
  });
  /** @nocollapse */
  return ResizeObserverDirective;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
let ResizeObserverModule = /*#__PURE__*/(() => {
  class ResizeObserverModule {}
  ResizeObserverModule.ɵfac = function ResizeObserverModule_Factory(t) {
    return new (t || ResizeObserverModule)();
  };
  ResizeObserverModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: ResizeObserverModule
  });
  ResizeObserverModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return ResizeObserverModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](ResizeObserverModule, {
    declarations: [ResizeObserverDirective],
    exports: [ResizeObserverDirective]
  });
})();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */



//# sourceMappingURL=ng-web-apis-resize-observer.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-services.js















/**
 * Observable abstraction over ngOnDestroy to use with takeUntil
 */


let TuiDestroyService = /*#__PURE__*/(() => {
  let TuiDestroyService = class TuiDestroyService extends Subject/* Subject */.xQ {
    ngOnDestroy() {
      this.next();
      this.complete();
    }
  };
  TuiDestroyService.ɵfac = /*@__PURE__*/function () {
    let ɵTuiDestroyService_BaseFactory;
    return function TuiDestroyService_Factory(t) {
      return (ɵTuiDestroyService_BaseFactory || (ɵTuiDestroyService_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiDestroyService)))(t || TuiDestroyService);
    };
  }();
  TuiDestroyService.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: TuiDestroyService,
    factory: function (t) {
      return TuiDestroyService.ɵfac(t);
    }
  });

  /**
   * Service to use styles with directives
   * @dynamic
   */
  return TuiDestroyService;
})();
let TuiDirectiveStylesService = /*#__PURE__*/(() => {
  let TuiDirectiveStylesService = class TuiDirectiveStylesService {
    constructor(documentRef, renderer) {
      this.documentRef = documentRef;
      this.renderer = renderer;
    }
    addStyle(styles, attribute) {
      if (this.documentRef.head.querySelector(`style[${attribute}]`)) {
        return;
      }
      const style = this.renderer.createElement('style');
      this.renderer.setProperty(style, 'textContent', styles);
      this.renderer.setAttribute(style, attribute, '');
      this.documentRef.head.appendChild(style);
    }
  };
  TuiDirectiveStylesService.ɵfac = function TuiDirectiveStylesService_Factory(t) {
    return new (t || TuiDirectiveStylesService)(core_js_["ɵɵinject"](common_js_.DOCUMENT), core_js_["ɵɵinject"](taiga_ui_cdk_tokens/* TUI_DEFAULT_RENDERER */.HO));
  };
  TuiDirectiveStylesService.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function TuiDirectiveStylesService_Factory() {
      return new TuiDirectiveStylesService((0,core_js_["ɵɵinject"])(common_js_.DOCUMENT), (0,core_js_["ɵɵinject"])(taiga_ui_cdk_tokens/* TUI_DEFAULT_RENDERER */.HO));
    },
    token: TuiDirectiveStylesService,
    providedIn: "root"
  });
  TuiDirectiveStylesService = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(common_js_.DOCUMENT)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_DEFAULT_RENDERER */.HO))], TuiDirectiveStylesService);

  /**
   * Service to imitate :focus-visible
   * (https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible)
   * in browsers that do not support it
   * @dynamic
   */
  return TuiDirectiveStylesService;
})();
let TuiFocusVisibleService = /*#__PURE__*/(() => {
  let TuiFocusVisibleService = class TuiFocusVisibleService extends Observable/* Observable */.y {
    constructor({
      nativeElement
    }, changeDetectorRef, destroy$) {
      super(subscriber => this.focusVisible$.subscribe(subscriber));
      this.focusVisible$ = (0,taiga_ui_cdk_observables/* focusVisibleObservable */.So)(nativeElement).pipe((0,taiga_ui_cdk_observables/* watch */.YP)(changeDetectorRef), (0,operators_takeUntil/* takeUntil */.R)(destroy$));
    }
  };
  TuiFocusVisibleService.ɵfac = function TuiFocusVisibleService_Factory(t) {
    return new (t || TuiFocusVisibleService)(core_js_["ɵɵinject"](core_js_.ElementRef), core_js_["ɵɵinject"](core_js_.ChangeDetectorRef), core_js_["ɵɵinject"](TuiDestroyService));
  };
  TuiFocusVisibleService.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: TuiFocusVisibleService,
    factory: function (t) {
      return TuiFocusVisibleService.ɵfac(t);
    }
  });
  TuiFocusVisibleService = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(TuiDestroyService))], TuiFocusVisibleService);

  // @dynamic
  return TuiFocusVisibleService;
})();
let TuiHoveredService = /*#__PURE__*/(() => {
  let TuiHoveredService = class TuiHoveredService {
    constructor(documentRef, ngZone) {
      this.ngZone = ngZone;
      this.documentEvents$ = (0,merge/* merge */.T)((0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(documentRef, 'mousemove'), (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(documentRef, 'touchend'));
    }
    createHovered$(target, options = {
      passive: true
    }) {
      return (0,merge/* merge */.T)((0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(target, 'mouseenter', options), (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(target, 'touchstart', options)).pipe((0,operators_switchMap/* switchMap */.w)(() => (0,merge/* merge */.T)((0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(target, 'mouseleave', options), this.documentEvents$.pipe((0,filter/* filter */.h)(event => !target.contains((0,taiga_ui_cdk_utils_dom/* getActualTarget */.Bq)(event))), (0,taiga_ui_cdk_observables/* tuiZoneOptimized */.Yr)(this.ngZone), (0,take/* take */.q)(1))).pipe((0,mapTo/* mapTo */.h)(false), (0,startWith/* startWith */.O)(true))), (0,distinctUntilChanged/* distinctUntilChanged */.x)());
    }
  };
  TuiHoveredService.ɵfac = function TuiHoveredService_Factory(t) {
    return new (t || TuiHoveredService)(core_js_["ɵɵinject"](common_js_.DOCUMENT), core_js_["ɵɵinject"](core_js_.NgZone));
  };
  TuiHoveredService.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function TuiHoveredService_Factory() {
      return new TuiHoveredService((0,core_js_["ɵɵinject"])(common_js_.DOCUMENT), (0,core_js_["ɵɵinject"])(core_js_.NgZone));
    },
    token: TuiHoveredService,
    providedIn: "root"
  });
  TuiHoveredService = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(common_js_.DOCUMENT)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.NgZone))], TuiHoveredService);
  return TuiHoveredService;
})();
var TuiIdService_1;
const TUI = 'tui_';
/**
 * Generates unique ids
 */
let TuiIdService = TuiIdService_1 = class TuiIdService {
  generate() {
    return `${TUI}${TuiIdService_1.autoId++}${Date.now()}`;
  }
};
TuiIdService.ɵfac = function TuiIdService_Factory(t) {
  return new (t || TuiIdService)();
};
TuiIdService.autoId = 0;
TuiIdService.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
  factory: function TuiIdService_Factory() {
    return new TuiIdService();
  },
  token: TuiIdService,
  providedIn: "root"
});

/**
 * Service that subscribes to scroll events of all parent elements
 */
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
let TuiParentsScrollService = /*#__PURE__*/(() => {
  let TuiParentsScrollService = class TuiParentsScrollService extends Observable/* Observable */.y {
    constructor({
      nativeElement
    }, windowRef) {
      super(subscriber => this.callback$.subscribe(subscriber));
      this.callback$ = (0,observable_defer/* defer */.P)(() => {
        const eventTargets = [windowRef, nativeElement];
        while (nativeElement.parentElement) {
          nativeElement = nativeElement.parentElement;
          eventTargets.push(nativeElement);
        }
        return (0,merge/* merge */.T)(...eventTargets.map(element => (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(element, 'scroll')));
      });
    }
  };
  TuiParentsScrollService.ɵfac = function TuiParentsScrollService_Factory(t) {
    return new (t || TuiParentsScrollService)(core_js_["ɵɵinject"](core_js_.ElementRef), core_js_["ɵɵinject"](ng_web_apis_common/* WINDOW */.m9));
  };
  TuiParentsScrollService.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: TuiParentsScrollService,
    factory: function (t) {
      return TuiParentsScrollService.ɵfac(t);
    }
  });
  TuiParentsScrollService = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(ng_web_apis_common/* WINDOW */.m9))], TuiParentsScrollService);

  // @bad TODO: Consider Intersection Observer with fallback to current implementation
  /**
   * Service that monitors element visibility by subscribing to scrolls
   * and polling with set interval, returns either null or an array
   * of elements that overlap given element edges
   */
  // Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
  // @dynamic
  return TuiParentsScrollService;
})();
let TuiObscuredService = /*#__PURE__*/(() => {
  let TuiObscuredService = class TuiObscuredService extends Observable/* Observable */.y {
    constructor(parentsScroll$, {
      nativeElement
    }, ngZone, windowRef, destroy$) {
      super(subscriber => this.obscured$.subscribe(subscriber));
      this.obscured$ = (0,merge/* merge */.T)(
      // delay is added so it will not interfere with other listeners
      (0,merge/* merge */.T)(parentsScroll$, (0,fromEvent/* fromEvent */.R)(windowRef, 'resize')).pipe((0,delay/* delay */.g)(0)), (0,interval/* interval */.F)(taiga_ui_cdk_constants/* POLLING_TIME */.Yg)).pipe((0,operators_map/* map */.U)(() => (0,taiga_ui_cdk_utils_dom/* getElementObscurers */.hh)(nativeElement)), (0,startWith/* startWith */.O)(null), (0,distinctUntilChanged/* distinctUntilChanged */.x)(), (0,taiga_ui_cdk_observables/* tuiZoneOptimized */.Yr)(ngZone), (0,operators_takeUntil/* takeUntil */.R)(destroy$));
    }
  };
  TuiObscuredService.ɵfac = function TuiObscuredService_Factory(t) {
    return new (t || TuiObscuredService)(core_js_["ɵɵinject"](TuiParentsScrollService, 2), core_js_["ɵɵinject"](core_js_.ElementRef), core_js_["ɵɵinject"](core_js_.NgZone), core_js_["ɵɵinject"](ng_web_apis_common/* WINDOW */.m9), core_js_["ɵɵinject"](TuiDestroyService));
  };
  TuiObscuredService.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: TuiObscuredService,
    factory: function (t) {
      return TuiObscuredService.ɵfac(t);
    }
  });
  TuiObscuredService = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TuiParentsScrollService)), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.NgZone)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(ng_web_apis_common/* WINDOW */.m9)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(TuiDestroyService))], TuiObscuredService);

  // @dynamic
  return TuiObscuredService;
})();
let TuiResizeService = /*#__PURE__*/(() => {
  let TuiResizeService = class TuiResizeService extends ResizeObserverService {
    constructor(elementRef, ngZone, destroy$, support, box) {
      super(elementRef, ngZone, support, box);
      return this.pipe((0,catchError/* catchError */.K)(() => (0,interval/* interval */.F)(taiga_ui_cdk_constants/* POLLING_TIME */.Yg).pipe((0,operators_map/* map */.U)(() => `${elementRef.nativeElement.clientWidth} ${elementRef.nativeElement.clientHeight}`), (0,distinctUntilChanged/* distinctUntilChanged */.x)(), (0,mapTo/* mapTo */.h)(taiga_ui_cdk_constants/* EMPTY_ARRAY */.LZ))), (0,operators_takeUntil/* takeUntil */.R)(destroy$), (0,debounceTime/* debounceTime */.b)(0), (0,taiga_ui_cdk_observables/* tuiZonefree */.fL)(ngZone));
    }
  };
  TuiResizeService.ɵfac = function TuiResizeService_Factory(t) {
    return new (t || TuiResizeService)(core_js_["ɵɵinject"](core_js_.ElementRef), core_js_["ɵɵinject"](core_js_.NgZone), core_js_["ɵɵinject"](TuiDestroyService), core_js_["ɵɵinject"](RESIZE_OBSERVER_SUPPORT), core_js_["ɵɵinject"](RESIZE_OPTION_BOX));
  };
  TuiResizeService.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: TuiResizeService,
    factory: function (t) {
      return TuiResizeService.ɵfac(t);
    }
  });
  TuiResizeService = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.NgZone)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(TuiDestroyService)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(RESIZE_OBSERVER_SUPPORT)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(RESIZE_OPTION_BOX))], TuiResizeService);
  return TuiResizeService;
})();
const SCROLL_TIME = 300;
// @dynamic
let TuiScrollService = /*#__PURE__*/(/* unused pure expression or super */ null && ((() => {
  let TuiScrollService = class TuiScrollService {
    constructor(performanceRef, animationFrame$) {
      this.performanceRef = performanceRef;
      this.animationFrame$ = animationFrame$;
    }
    scroll$(element, scrollTop, scrollLeft = element.scrollLeft, duration = SCROLL_TIME) {
      tuiAssert.assert(duration >= 0, 'Duration cannot be negative');
      tuiAssert.assert(scrollTop >= 0, 'scrollTop cannot be negative');
      tuiAssert.assert(scrollLeft >= 0, 'scrollLeft cannot be negative');
      const initialTop = element.scrollTop;
      const initialLeft = element.scrollLeft;
      const deltaTop = scrollTop - initialTop;
      const deltaLeft = scrollLeft - initialLeft;
      const observable = !duration ? of([scrollTop, scrollLeft]) : defer(() => of(this.performanceRef.now())).pipe(switchMap(start => this.animationFrame$.pipe(map(now => now - start))), takeUntil(timer(duration)), map(elapsed => easeInOutQuad(clamp(elapsed / duration, 0, 1))), map(percent => [initialTop + deltaTop * percent, initialLeft + deltaLeft * percent]));
      return observable.pipe(tap(([scrollTop, scrollLeft]) => {
        element.scrollTop = scrollTop;
        element.scrollLeft = scrollLeft;
      }));
    }
  };
  TuiScrollService.ɵfac = function TuiScrollService_Factory(t) {
    return new (t || TuiScrollService)(ɵngcc0.ɵɵinject(PERFORMANCE), ɵngcc0.ɵɵinject(ANIMATION_FRAME));
  };
  TuiScrollService.ɵprov = ɵɵdefineInjectable({
    factory: function TuiScrollService_Factory() {
      return new TuiScrollService(ɵɵinject(PERFORMANCE), ɵɵinject(ANIMATION_FRAME));
    },
    token: TuiScrollService,
    providedIn: "root"
  });
  TuiScrollService = __decorate([__param(0, Inject(PERFORMANCE)), __param(1, Inject(ANIMATION_FRAME))], TuiScrollService);
  return TuiScrollService;
})()));
let TuiStaticRequestService = /*#__PURE__*/(() => {
  let TuiStaticRequestService = class TuiStaticRequestService {
    constructor() {
      this.cache = new Map();
    }
    request(url) {
      const cache = this.cache.get(url);
      if (cache) {
        return cache;
      }
      const observable = new Observable/* Observable */.y(observer => {
        const xhr = new XMLHttpRequest();
        xhr.onreadystatechange = () => {
          if (xhr.readyState === 4) {
            const response = xhr.responseType ? xhr.response : xhr.responseText;
            if (xhr.status === 200) {
              observer.next(response);
              observer.complete();
            } else {
              observer.error(response);
            }
          }
        };
        xhr.open('GET', url);
        xhr.send();
        return () => {
          xhr.abort();
        };
      });
      const piped = observable.pipe((0,shareReplay/* shareReplay */.d)(1));
      this.cache.set(url, piped);
      return piped;
    }
  };
  TuiStaticRequestService.ɵfac = function TuiStaticRequestService_Factory(t) {
    return new (t || TuiStaticRequestService)();
  };
  TuiStaticRequestService.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function TuiStaticRequestService_Factory() {
      return new TuiStaticRequestService();
    },
    token: TuiStaticRequestService,
    providedIn: "root"
  });
  return TuiStaticRequestService;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-services.js.map

/***/ }),

/***/ 8096:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FA: () => (/* binding */ TUI_IS_IOS),
/* harmony export */   HO: () => (/* binding */ TUI_DEFAULT_RENDERER),
/* harmony export */   KZ: () => (/* binding */ TUI_FOCUSABLE_ITEM_ACCESSOR),
/* harmony export */   XG: () => (/* binding */ TUI_IS_ANDROID),
/* harmony export */   fL: () => (/* binding */ TUI_IS_MOBILE),
/* harmony export */   hm: () => (/* binding */ TUI_SANITIZER),
/* harmony export */   qY: () => (/* binding */ TUI_DIALOGS),
/* harmony export */   wk: () => (/* binding */ TUI_ACTIVE_ELEMENT)
/* harmony export */ });
/* unused harmony export TUI_REMOVED_ELEMENT */
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ng_web_apis_common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(2579);
/* harmony import */ var _taiga_ui_cdk_observables__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(908);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6215);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6797);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(6682);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3190);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6736);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9761);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(8819);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(6782);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(2361);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(7057);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(5435);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(8002);
/* harmony import */ var _angular_animations_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9221);






const TUI_REMOVED_ELEMENT = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('Element currently being removed by AnimationEngine', {
  factory: () => {
    var _a;
    const stub = {
      onRemovalComplete: () => {}
    };
    const skip$ = new rxjs__WEBPACK_IMPORTED_MODULE_1__/* .BehaviorSubject */ .X(null);
    const engine = _angular_animations_browser__WEBPACK_IMPORTED_MODULE_2__/* ["ɵAnimationEngine"] */ .Th ? (_a = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_angular_animations_browser__WEBPACK_IMPORTED_MODULE_2__/* ["ɵAnimationEngine"] */ .Th, _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectFlags.Optional)) !== null && _a !== void 0 ? _a : stub : stub;
    const {
      onRemovalComplete = stub.onRemovalComplete
    } = engine;
    engine.onRemovalComplete = (element, context) => {
      skip$.next(element);
      onRemovalComplete(element, context);
    };
    return skip$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__/* .switchMap */ .w)(element => (0,rxjs__WEBPACK_IMPORTED_MODULE_4__/* .timer */ .H)(0).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__/* .mapTo */ .h)(null), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__/* .startWith */ .O)(element))), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__/* .share */ .B)());
  }
});
const TUI_ACTIVE_ELEMENT = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('Active element on the document for ActiveZone', {
  factory: () => {
    const skip$ = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(TUI_REMOVED_ELEMENT);
    const windowRef = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_8__/* .WINDOW */ .m9);
    const focusout$ = (0,_taiga_ui_cdk_observables__WEBPACK_IMPORTED_MODULE_9__/* .typedFromEvent */ .eh)(windowRef, 'focusout');
    const focusin$ = (0,_taiga_ui_cdk_observables__WEBPACK_IMPORTED_MODULE_9__/* .typedFromEvent */ .eh)(windowRef, 'focusin');
    const blur$ = (0,_taiga_ui_cdk_observables__WEBPACK_IMPORTED_MODULE_9__/* .typedFromEvent */ .eh)(windowRef, 'blur');
    const mousedown$ = (0,_taiga_ui_cdk_observables__WEBPACK_IMPORTED_MODULE_9__/* .typedFromEvent */ .eh)(windowRef, 'mousedown');
    const mouseup$ = (0,_taiga_ui_cdk_observables__WEBPACK_IMPORTED_MODULE_9__/* .typedFromEvent */ .eh)(windowRef, 'mouseup');
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_10__/* .merge */ .T)(focusout$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_11__/* .takeUntil */ .R)(mousedown$), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_12__/* .repeatWhen */ .a)(() => mouseup$), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_13__/* .withLatestFrom */ .M)(skip$), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_14__/* .filter */ .h)(([{
      target
    }, element]) => target !== element), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_15__/* .map */ .U)(([{
      relatedTarget
    }]) => relatedTarget)), blur$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_15__/* .map */ .U)(() => windowRef.document.activeElement), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_14__/* .filter */ .h)(element => !!element && element.matches('iframe'))), (0,rxjs__WEBPACK_IMPORTED_MODULE_10__/* .merge */ .T)(mousedown$, focusin$).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_15__/* .map */ .U)(({
      target
    }) => target))).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__/* .share */ .B)());
  }
});

// https://github.com/angular/angular/issues/17824#issuecomment-353239017
const TUI_DEFAULT_RENDERER = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('A Renderer2 for global services', {
  // @ts-ignore
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.RendererFactory2).createRenderer(null, null)
});
const TUI_DIALOGS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('A stream of dialogs');
const TUI_FOCUSABLE_ITEM_ACCESSOR = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('A component that can be focused');
const IOS_REG_EXP = /ipad|iphone|ipod/;
const TUI_IS_IOS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('iOS browser detection', {
  providedIn: 'root',
  factory: () => IOS_REG_EXP.test((0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_8__/* .USER_AGENT */ .yZ).toLowerCase())
});

// https://stackoverflow.com/a/11381730/2706426 http://detectmobilebrowsers.com/
const firstRegex = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/;
const secondRegex = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/;
const TUI_IS_MOBILE = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('Mobile browser detection', {
  providedIn: 'root',
  factory: () => firstRegex.test((0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_8__/* .USER_AGENT */ .yZ).toLowerCase()) || secondRegex.test((0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_8__/* .USER_AGENT */ .yZ).substr(0, 4).toLowerCase())
});
const TUI_IS_ANDROID = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('Mobile browser that is not iOS (technically includes Windows Phone, Blackberry etc.)', {
  providedIn: 'root',
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(TUI_IS_MOBILE) && !(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(TUI_IS_IOS)
});

/* @deprecated export token from @taiga-ui/core package **/
const TUI_SANITIZER = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('A custom Sanitizer to sanitize source before inlining');

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-tokens.js.map

/***/ }),

/***/ 1213:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G6: () => (/* binding */ isSafari),
/* harmony export */   Q0: () => (/* binding */ isEdgeOlderThan),
/* harmony export */   vU: () => (/* binding */ isFirefox),
/* harmony export */   w1: () => (/* binding */ isIE)
/* harmony export */ });
/* unused harmony export isEdge */
function isEdge(userAgent) {
  return userAgent.toLowerCase().includes('edge');
}
function isEdgeOlderThan(version, userAgent) {
  const EDGE = 'edge/';
  const currentVersion = parseInt(userAgent.slice(userAgent.toLowerCase().indexOf(EDGE) + EDGE.length), 10);
  return currentVersion < version;
}
function isFirefox(userAgent) {
  return userAgent.toLowerCase().includes('firefox');
}
function isIE(userAgent) {
  return userAgent.toLowerCase().includes('trident');
}
function isSafari(element) {
  const documentRef = element.ownerDocument;
  const windowRef = documentRef && documentRef.defaultView;
  return !!windowRef && 'safari' in windowRef;
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-utils-browser.js.map

/***/ }),

/***/ 5242:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bq: () => (/* binding */ getActualTarget),
/* harmony export */   Q4: () => (/* binding */ getClosestElement),
/* harmony export */   Xr: () => (/* binding */ isCurrentTarget),
/* harmony export */   eE: () => (/* binding */ canScroll),
/* harmony export */   hO: () => (/* binding */ tuiCustomEvent),
/* harmony export */   hh: () => (/* binding */ getElementObscurers),
/* harmony export */   pW: () => (/* binding */ getElementOffset),
/* harmony export */   rP: () => (/* binding */ getScrollParent),
/* harmony export */   sy: () => (/* binding */ getDocumentOrShadowRoot),
/* harmony export */   vV: () => (/* binding */ containsOrAfter)
/* harmony export */ });
/* unused harmony exports getClipboardDataText, isNodeIn */
/* harmony import */ var _taiga_ui_cdk_utils_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5648);
/* harmony import */ var _taiga_ui_cdk_utils_miscellaneous__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8659);
/* harmony import */ var _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8939);



function canScroll(element, rootElement, vertical, scrollEnd) {
  return vertical ? canScrollVertical(element, rootElement, scrollEnd) : canScrollHorizontal(element, rootElement, scrollEnd);
}
function canScrollVertical(element, rootElement, scrollEnd) {
  let currentElement = element;
  while (currentElement !== rootElement.parentElement) {
    if (Math.floor(currentElement.scrollTop) > 0 && !scrollEnd || Math.ceil(currentElement.scrollTop + currentElement.clientHeight) < currentElement.scrollHeight && scrollEnd) {
      return true;
    }
    if (currentElement.parentElement) {
      currentElement = currentElement.parentElement;
    } else {
      return false;
    }
  }
  return false;
}
function canScrollHorizontal(element, rootElement, scrollEnd) {
  let currentElement = element;
  while (currentElement !== rootElement.parentElement) {
    if (Math.floor(currentElement.scrollLeft) > 0 && !scrollEnd || Math.ceil(currentElement.scrollLeft + currentElement.clientWidth) < currentElement.scrollWidth && scrollEnd) {
      return true;
    }
    if (currentElement.parentElement) {
      currentElement = currentElement.parentElement;
    } else {
      return false;
    }
  }
  return false;
}
function containsOrAfter(current, node) {
  return current.contains(node) || !!(
  // tslint:disable:no-bitwise
  node.compareDocumentPosition(current) & Node.DOCUMENT_POSITION_PRECEDING);
}
function tuiCustomEvent(name, {
  bubbles = false,
  cancelable = false,
  detail = null
} = {}, documentRef) {
  if (typeof CustomEvent === 'function') {
    return new CustomEvent(name, {
      bubbles,
      cancelable,
      detail
    });
  }
  const customEvent = documentRef.createEvent('CustomEvent');
  customEvent.initCustomEvent(name, bubbles, cancelable, detail);
  return customEvent;
}

/**
 * Gets actual target from open Shadow DOM if event happened within it
 */
function getActualTarget(event) {
  if ('composedPath' in event) {
    return event.composedPath()[0];
  }
  return event.target;
}

/**
 * Gets text from data of clipboardEvent, it also works in IE and Edge browsers
 */
function getClipboardDataText(event, format = 'text/plain') {
  return 'clipboardData' in event && event.clipboardData !== null ? event.clipboardData.getData(format) : event.target.ownerDocument.defaultView.clipboardData.getData('text');
}

/**
 * Gets closest element by selector i.e. {@link Element.closest}
 */
function getClosestElement(element, selector) {
  const closest = Element.prototype.closest;
  if (closest) {
    return closest.call(element, selector);
  }
  const matchesSelector = Element.prototype.matches || Element.prototype.msMatchesSelector;
  do {
    if (matchesSelector.call(element, selector)) {
      return element;
    }
    element = element.parentElement;
  } while (element !== null);
  return null;
}
function getDocumentOrShadowRoot(node) {
  return 'getRootNode' in node && node.ownerDocument && node.ownerDocument.body.contains(node) ? node.getRootNode() : node.ownerDocument;
}

/**
 * Returns array of Elements covering edges of given element or null if at least one edge middle point is visible
 *
 * CAUTION: Empty array means element if offscreen i.e. covered by no elements, rather than not covered
 */
function getElementObscurers(element) {
  const {
    ownerDocument
  } = element;
  if (!ownerDocument || !ownerDocument.defaultView) {
    return null;
  }
  const {
    innerWidth,
    innerHeight
  } = ownerDocument.defaultView;
  const documentRef = getDocumentOrShadowRoot(element);
  const rect = element.getBoundingClientRect();
  const left = (0,_taiga_ui_cdk_utils_math__WEBPACK_IMPORTED_MODULE_0__/* .clamp */ .uZ)(Math.round(rect.left) + 2, 0, innerWidth);
  const top = (0,_taiga_ui_cdk_utils_math__WEBPACK_IMPORTED_MODULE_0__/* .clamp */ .uZ)(Math.round(rect.top) + 2, 0, innerHeight);
  const right = (0,_taiga_ui_cdk_utils_math__WEBPACK_IMPORTED_MODULE_0__/* .clamp */ .uZ)(Math.round(rect.right) - 2, 0, innerWidth);
  const bottom = (0,_taiga_ui_cdk_utils_math__WEBPACK_IMPORTED_MODULE_0__/* .clamp */ .uZ)(Math.round(rect.bottom) - 2, 0, innerHeight);
  const horizontalMiddle = (0,_taiga_ui_cdk_utils_math__WEBPACK_IMPORTED_MODULE_0__/* .clamp */ .uZ)(Math.round(rect.left + rect.width / 2), 0, innerWidth);
  const verticalMiddle = (0,_taiga_ui_cdk_utils_math__WEBPACK_IMPORTED_MODULE_0__/* .clamp */ .uZ)(Math.round(rect.top + rect.height / 2), 0, innerHeight);
  const elements = [documentRef.elementFromPoint(horizontalMiddle, top), documentRef.elementFromPoint(horizontalMiddle, bottom), documentRef.elementFromPoint(left, verticalMiddle), documentRef.elementFromPoint(right, verticalMiddle)];
  const nonNull = elements.filter(_taiga_ui_cdk_utils_miscellaneous__WEBPACK_IMPORTED_MODULE_1__/* .isPresent */ .EN);
  if (!nonNull.length) {
    return nonNull;
  }
  const filtered = nonNull.filter(el => !element.contains(el));
  return filtered.length === 4 ? filtered : null;
}

/**
 * Calculates offset for an element relative to it's parent several levels above
 *
 * @param host parent element
 * @param element
 * @return object with offsetTop and offsetLeft number properties
 */
function getElementOffset(host, element) {
  _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_2__/* .tuiAssert */ .z.assert(host.contains(element), 'Host must contain element');
  let {
    offsetTop,
    offsetLeft,
    offsetParent
  } = element;
  while (offsetParent && offsetParent instanceof HTMLElement && offsetParent !== host) {
    offsetTop += offsetParent.offsetTop;
    offsetLeft += offsetParent.offsetLeft;
    offsetParent = offsetParent.offsetParent;
  }
  return {
    offsetTop,
    offsetLeft
  };
}

/**
 * Finds nearest parent with scroll in it
 *
 * @param element initial element
 * @param vertical flag for orientation of scroll
 */
function getScrollParent(element, vertical = true) {
  if (element === null) {
    return null;
  }
  if (vertical && element.scrollHeight > element.clientHeight) {
    return element;
  }
  if (!vertical && element.scrollWidth > element.clientWidth) {
    return element;
  }
  return getScrollParent(element.parentElement, vertical);
}
function isCurrentTarget({
  target,
  currentTarget
}) {
  return target === currentTarget;
}

/**
 * Checks if node is inside a specific selector
 *
 * @param node
 * @param selector
 * @return true if node is inside a particular selector
 */
function isNodeIn(node, selector) {
  return node.nodeType === Node.TEXT_NODE ? !!node.parentElement && !!getClosestElement(node.parentElement, selector) : node.nodeType === Node.ELEMENT_NODE && !!getClosestElement(node, selector);
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-utils-dom.js.map

/***/ }),

/***/ 7179:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Gi: () => (/* binding */ setNativeMouseFocused),
/* harmony export */   KF: () => (/* binding */ isNativeFocusedIn),
/* harmony export */   NY: () => (/* binding */ setNativeFocused),
/* harmony export */   O9: () => (/* binding */ getClosestKeyboardFocusable),
/* harmony export */   PO: () => (/* binding */ blurNativeFocused),
/* harmony export */   Wb: () => (/* binding */ isNativeKeyboardFocusable),
/* harmony export */   dO: () => (/* binding */ getNativeFocused),
/* harmony export */   kA: () => (/* binding */ getClosestFocusable),
/* harmony export */   pr: () => (/* binding */ moveFocus),
/* harmony export */   zV: () => (/* binding */ isNativeFocused)
/* harmony export */ });
/* unused harmony export isNativeMouseFocusable */
/* harmony import */ var _taiga_ui_cdk_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3770);


/**
 * Returns current active element, including shadow dom
 *
 * @return element or null
 */
function getNativeFocused(documentRef) {
  if (!documentRef.activeElement || !documentRef.activeElement.shadowRoot) {
    return documentRef.activeElement;
  }
  let element = documentRef.activeElement.shadowRoot.activeElement;
  while (element && element.shadowRoot) {
    element = element.shadowRoot.activeElement;
  }
  return element;
}

/**
 * Focuses or blurs and element
 *
 * @param element native element
 * @param focused boolean focused state
 * @param preventScroll optional flag to prevent native scroll to the element
 */
function setNativeFocused(element, focused = true, preventScroll = false) {
  if (focused) {
    element.focus({
      preventScroll
    });
  } else {
    element.blur();
  }
}

/**
 * Finds and blurs current active element, including shadow DOM
 */
function blurNativeFocused(documentRef) {
  const activeElement = getNativeFocused(documentRef);
  if (activeElement instanceof HTMLElement) {
    setNativeFocused(activeElement, false);
  }
}

/**
 * Checks for signs that element can be focused with keyboard. tabIndex above 0 is ignored to
 * only target natural focus order. Not checking the possibility of an element to
 * be focused, for example element can have display: none applied to it or any other
 * circumstances could prevent actual focus.
 */
function isNativeKeyboardFocusable(element) {
  if (element.hasAttribute('disabled') || element.getAttribute('tabIndex') === '-1') {
    return false;
  }
  if (element instanceof HTMLElement && element.isContentEditable || element.getAttribute('tabIndex') === '0') {
    return true;
  }
  switch (element.tagName) {
    case 'BUTTON':
    case 'SELECT':
    case 'TEXTAREA':
      return true;
    case 'VIDEO':
    case 'AUDIO':
      return element.hasAttribute('controls');
    case 'INPUT':
      return element.getAttribute('type') !== 'hidden';
    case 'A':
    case 'LINK':
      return element.hasAttribute('href');
    default:
      return false;
  }
}
function isNativeMouseFocusable(element) {
  return !element.hasAttribute('disabled') && (element.getAttribute('tabIndex') === '-1' || isNativeKeyboardFocusable(element));
}

/**
 * Finds closest element that can be focused with a keyboard or mouse in theory
 *
 * @param initial current HTML element
 * @param prev should it look backwards instead (find item that will be focused with Shift + Tab)
 * @param root top Node limiting the search area
 * @param keyboard determine if only keyboard focus is of interest
 *
 */
function getClosestFocusable(initial, prev = false, root, keyboard = true) {
  if (!root.ownerDocument) {
    return null;
  }
  const check = keyboard ? isNativeKeyboardFocusable : isNativeMouseFocusable;
  // Deprecated but ony this overload works in IE
  // Filter must be a function in IE, other modern browsers are compliant to this format
  const treeWalker = root.ownerDocument.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, _taiga_ui_cdk_constants__WEBPACK_IMPORTED_MODULE_0__/* .svgNodeFilter */ .Lw, false);
  treeWalker.currentNode = initial;
  while (prev ? treeWalker.previousNode() : treeWalker.nextNode()) {
    if (treeWalker.currentNode instanceof HTMLElement) {
      initial = treeWalker.currentNode;
    }
    if (check(initial)) {
      return initial;
    }
  }
  return null;
}
/** @deprecated use getClosestFocusable */
const getClosestKeyboardFocusable = getClosestFocusable;

/**
 * Checks if element is focused.
 *
 * Could return true even after blur since element remains focused if you switch away from a browser tab.
 *
 * @param node or null (as a common return value of DOM nodes walking)
 * @return true if focused
 */
function isNativeFocused(node) {
  return !!node && !!node.ownerDocument && getNativeFocused(node.ownerDocument) === node;
}

/**
 * Checks if focused element is within given element.
 *
 * @param node
 * @return true if focused node is contained within element
 */
function isNativeFocusedIn(node) {
  // !node.contains - check for IE11
  if (!node.ownerDocument || !node.contains) {
    return false;
  }
  const nativeFocused = getNativeFocused(node.ownerDocument);
  return nativeFocused !== null && node.contains(nativeFocused);
}

/**
 * Utility method for moving focus in a list of elements
 *
 * @param currentIndex currently focused index
 * @param elements array of focusable elements
 * @param step a step to move focus by, typically -1 or 1
 */
function moveFocus(currentIndex, elements, step) {
  currentIndex += step;
  while (currentIndex >= 0 && currentIndex < elements.length) {
    setNativeFocused(elements[currentIndex]);
    if (isNativeFocused(elements[currentIndex])) {
      return;
    }
    currentIndex += step;
  }
}

/**
 * Focuses or blurs element with mouse action imitation (to spoof {@link TuiFocusVisibleService})
 *
 * @param element
 * @param focused desired focused state
 * @param preventScroll optionally prevent native browser scroll after focus
 */
function setNativeMouseFocused(element, focused = true, preventScroll = false) {
  if (!element.ownerDocument) {
    return;
  }
  if (typeof Event === 'function') {
    element.dispatchEvent(new Event('mousedown', {
      bubbles: true,
      cancelable: true
    }));
  } else {
    const event = element.ownerDocument.createEvent('Event');
    event.initEvent('mousedown', true, true);
    element.dispatchEvent(event);
  }
  setNativeFocused(element, focused, preventScroll);
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-utils-focus.js.map

/***/ }),

/***/ 5648:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z2: () => (/* binding */ inRange),
/* harmony export */   uZ: () => (/* binding */ clamp)
/* harmony export */ });
/* unused harmony exports ceil, floor, normalizeToIntNumber, quantize, round, sum, toRadians */
/* harmony import */ var _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8939);


/**
 * Clamps a value between two inclusive limits
 *
 * @param value
 * @param min lower limit
 * @param max upper limit
 */
function clamp(value, min, max) {
  _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .z.assert(!isNaN(value));
  _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .z.assert(!isNaN(min));
  _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .z.assert(!isNaN(max));
  _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .z.assert(max >= min);
  return Math.min(max, Math.max(min, value));
}

/**
 * Checks if the value is in range
 *
 * @param value
 * @param fromInclude lower inclusive limit
 * @param toExclude upper exclusive limit
 */
function inRange(value, fromInclude, toExclude) {
  _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .z.assert(!isNaN(value));
  _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .z.assert(!isNaN(fromInclude));
  _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .z.assert(!isNaN(toExclude));
  _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .z.assert(fromInclude < toExclude);
  return value >= fromInclude && value < toExclude;
}

/**
 * Normalizes any number to an integer within inclusive range
 *
 * @param value
 * @param min lower inclusive integer
 * @param max upper inclusive integer
 * @return an integer between min and max inclusive
 */
function normalizeToIntNumber(value, min, max) {
  tuiAssert.assert(Number.isInteger(min));
  tuiAssert.assert(Number.isInteger(max));
  tuiAssert.assert(min <= max);
  if (isNaN(value) || value <= min) {
    return min;
  }
  if (value >= max) {
    return max;
  }
  return Math.round(value);
}

/**
 * Rounds a number to the closest value in a fixed discrete series
 *
 * @param value
 * @param quantum series step
 */
function quantize(value, quantum) {
  tuiAssert.assert(Number.isFinite(value));
  tuiAssert.assert(Number.isFinite(quantum));
  tuiAssert.assert(quantum > 0);
  const remainder = value % quantum;
  return remainder < quantum / 2 ? value - remainder : value + quantum - remainder;
}
const MAX_PRECISION = 292;
function round(value, precision = 0) {
  return calculate(value, precision, Math.round);
}
function ceil(value, precision = 0) {
  return calculate(value, precision, Math.ceil);
}
function floor(value, precision = 0) {
  return calculate(value, precision, Math.floor);
}
/**
 * Rounding number to the set precision
 *
 * @param value
 * @param precision number of digits in a float part
 * @param func rounding function (round, floor, ceil)
 */
function calculate(value, precision, func) {
  if (value === Infinity) {
    return value;
  }
  tuiAssert.assert(!isNaN(value), 'Value must be number');
  tuiAssert.assert(Number.isInteger(precision), 'Precision must be integer');
  precision = Math.min(precision, MAX_PRECISION);
  const pair = `${value}e`.split('e');
  const tempValue = func(Number(`${pair[0]}e${Number(pair[1]) + precision}`));
  const processedPair = `${tempValue}e`.split('e');
  return Number(`${processedPair[0]}e${Number(processedPair[1]) - precision}`);
}

/**
 * Calculates sum of any number of passed arguments
 */
function sum(...args) {
  return args.reduce((a, b) => a + b, 0);
}

/**
 * Converts angle in degrees to radians
 */
function toRadians(deg) {
  return deg * Math.PI / 180;
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-utils-math.js.map

/***/ }),

/***/ 8659:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EN: () => (/* binding */ isPresent),
/* harmony export */   ct: () => (/* binding */ getOriginalArrayFromQueryList),
/* harmony export */   hj: () => (/* binding */ isNumber),
/* harmony export */   je: () => (/* binding */ fallbackValue),
/* harmony export */   mN: () => (/* binding */ uniqBy),
/* harmony export */   rT: () => (/* binding */ isElementEditable),
/* harmony export */   yR: () => (/* binding */ identity)
/* harmony export */ });
/* unused harmony exports easeInOutQuad, flatLength, markControlAsTouchedAndValidate, nullableSame */


function easeInOutQuad(t) {
  tuiAssert.assert(0 <= t && t <= 1, 'Input must be between 0 and 1 inclusive.');
  return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
}
function isPresent(value) {
  return value !== null && value !== undefined;
}

/**
 * If the value is null or undefined, returns default value
 * @param value
 * @param fallback alternative fallback
 */
function fallbackValue(value, fallback) {
  return isPresent(value) ? value : fallback;
}

/**
 * Flattens two dimensional array and calculates resulting length
 *
 * @param array twi dimensional array
 */
function flatLength(array) {
  return array.reduce((count, section) => count + section.length, 0);
}

/**
 * Extracts original array from {@link QueryList} rather than
 * creating a copy like {@link QueryList.toArray} does.
 * @param queryList
 * @returns original array from {@link QueryList}.
 */
function getOriginalArrayFromQueryList(queryList) {
  let array = [];
  queryList.find((_item, _index, originalArray) => {
    array = originalArray;
    return true;
  });
  return array;
}
function identity(item) {
  return item;
}
function isElementEditable(element) {
  return element instanceof HTMLInputElement && !element.readOnly || element instanceof HTMLTextAreaElement && !element.readOnly || element.isContentEditable;
}
function isNumber(value) {
  return typeof value === 'number';
}
function markControlAsTouchedAndValidate(control) {
  if (control instanceof FormArray) {
    control.controls.forEach(nestedControl => {
      markControlAsTouchedAndValidate(nestedControl);
    });
    return;
  }
  if (control instanceof FormGroup) {
    Object.values(control.controls).forEach(nestedControl => {
      markControlAsTouchedAndValidate(nestedControl);
    });
    return;
  }
  control.markAsTouched();
  control.updateValueAndValidity();
}

/**
 * Checks identity for nullable elements.
 *
 * @param a element a
 * @param b element b
 * @param handler called if both elements are not null
 * @return true if either both are null or they pass identity handler
 */
function nullableSame(a, b, handler) {
  if (a === null) {
    return b === null;
  }
  if (b === null) {
    return false;
  }
  return handler(a, b);
}
function uniqBy(array, key) {
  return Array.from(array.reduce((map, item) => map.has(item[key]) ? map : map.set(item[key], item), new Map()).values());
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-utils-miscellaneous.js.map

/***/ }),

/***/ 2628:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   f: () => (/* binding */ TuiButtonModule),
/* harmony export */   v: () => (/* binding */ TuiButtonComponent)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(7582);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6480);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(908);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7179);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3503);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(8096);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(4358);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(8891);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6782);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3008);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _taiga_ui_core_components_loader__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(719);
/* harmony import */ var _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(4789);
/* harmony import */ var _taiga_ui_core_components_wrapper__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1144);
/* harmony import */ var _tinkoff_ng_polymorpheus__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(9570);


















const _c0 = ["tuiButton", ""];
function TuiButtonComponent_span_2_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "tui-svg", 6);
  }
  if (rf & 2) {
    const icon_r4 = ctx.$implicit;
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("src", icon_r4);
  }
}
function TuiButtonComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "span", 5);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, TuiButtonComponent_span_2_ng_template_1_Template, 1, 1, "ng-template");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("content", ctx_r0.icon);
  }
}
function TuiButtonComponent_span_4_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "tui-svg", 6);
  }
  if (rf & 2) {
    const icon_r6 = ctx.$implicit;
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("src", icon_r6);
  }
}
function TuiButtonComponent_span_4_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "span", 7);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, TuiButtonComponent_span_4_ng_template_1_Template, 1, 1, "ng-template");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("content", ctx_r1.iconRight);
  }
}
function TuiButtonComponent_tui_loader_5_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "tui-loader", 8);
  }
  if (rf & 2) {
    const ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("size", ctx_r2.loaderSize)("inheritColor", true);
  }
}
const _c1 = ["*"];
var TuiButtonComponent_1;
let TuiButtonComponent = TuiButtonComponent_1 = class TuiButtonComponent extends _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_2__/* .AbstractTuiInteractive */ .Xn {
  constructor(elementRef, focusVisible$, hoveredService, destroy$, changeDetectorRef) {
    super();
    this.elementRef = elementRef;
    this.appearance = "primary" /* Primary */;
    this.disabled = false;
    this.icon = '';
    this.iconRight = '';
    this.shape = null;
    this.showLoader = false;
    this.size = 'l';
    hoveredService.createHovered$(elementRef.nativeElement).pipe((0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_3__/* .watch */ .YP)(changeDetectorRef), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__/* .takeUntil */ .R)(destroy$)).subscribe(hovered => {
      this.updateHovered(hovered);
    });
    (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_3__/* .pressedObservable */ ._d)(elementRef.nativeElement).pipe((0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_3__/* .watch */ .YP)(changeDetectorRef), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__/* .takeUntil */ .R)(destroy$)).subscribe(pressed => {
      this.updatePressed(pressed);
    });
    focusVisible$.subscribe(focusVisible => {
      this.updateFocusVisible(focusVisible);
    });
  }
  get nativeFocusableElement() {
    return this.nativeDisabled ? null : this.elementRef.nativeElement;
  }
  get focused() {
    return (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_5__/* .isNativeFocused */ .zV)(this.elementRef.nativeElement);
  }
  get loaderSize() {
    return this.size === 'l' || this.size === 'xl' ? 'm' : 's';
  }
  get nativeDisabled() {
    return this.computedDisabled || this.showLoader ? '' : null;
  }
  get tabIndex() {
    return this.focusable ? 0 : -1;
  }
  onFocused(focused) {
    this.updateFocused(focused);
  }
};
TuiButtonComponent.ɵfac = function TuiButtonComponent_Factory(t) {
  return new (t || TuiButtonComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__/* .TuiFocusVisibleService */ .ku), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__/* .TuiHoveredService */ .gs), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__/* .TuiDestroyService */ .a3), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef));
};
TuiButtonComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
  type: TuiButtonComponent,
  selectors: [["button", "tuiButton", ""], ["button", "tuiIconButton", ""], ["a", "tuiButton", ""], ["a", "tuiIconButton", ""]],
  hostVars: 7,
  hostBindings: function TuiButtonComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("focusin", function TuiButtonComponent_focusin_HostBindingHandler() {
        return ctx.onFocused(true);
      })("focusout", function TuiButtonComponent_focusout_HostBindingHandler() {
        return ctx.onFocused(false);
      });
    }
    if (rf & 2) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵhostProperty"]("tabIndex", ctx.tabIndex);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("data-appearance", ctx.appearance)("data-tui-host-shape", ctx.shape)("data-tui-host-size", ctx.size)("disabled", ctx.nativeDisabled);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("_loading", ctx.showLoader);
    }
  },
  inputs: {
    appearance: "appearance",
    disabled: "disabled",
    icon: "icon",
    iconRight: "iconRight",
    shape: "shape",
    showLoader: "showLoader",
    size: "size"
  },
  features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
    provide: _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__/* .TUI_FOCUSABLE_ITEM_ACCESSOR */ .KZ,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => TuiButtonComponent_1)
  }, _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__/* .TuiDestroyService */ .a3, _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__/* .TuiFocusVisibleService */ .ku]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]],
  attrs: _c0,
  ngContentSelectors: _c1,
  decls: 6,
  vars: 8,
  consts: [[1, "wrapper", 3, "appearance", "hovered", "pressed", "disabled", "focused"], [1, "content"], ["class", "left", "polymorpheus-outlet", "", 3, "content", 4, "ngIf"], ["class", "right", "polymorpheus-outlet", "", 3, "content", 4, "ngIf"], ["class", "loader", 3, "size", "inheritColor", 4, "ngIf"], ["polymorpheus-outlet", "", 1, "left", 3, "content"], [1, "icon", 3, "src"], ["polymorpheus-outlet", "", 1, "right", 3, "content"], [1, "loader", 3, "size", "inheritColor"]],
  template: function TuiButtonComponent_Template(rf, ctx) {
    if (rf & 1) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "tui-wrapper", 0);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "span", 1);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, TuiButtonComponent_span_2_Template, 2, 1, "span", 2);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](3);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](4, TuiButtonComponent_span_4_Template, 2, 1, "span", 3);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](5, TuiButtonComponent_tui_loader_5_Template, 1, 2, "tui-loader", 4);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("appearance", ctx.appearance)("hovered", ctx.computedHovered)("pressed", ctx.computedPressed)("disabled", ctx.computedDisabled)("focused", ctx.computedFocusVisible);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.icon);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.iconRight);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.showLoader);
    }
  },
  directives: [_taiga_ui_core_components_wrapper__WEBPACK_IMPORTED_MODULE_8__/* .TuiWrapperComponent */ .Q, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, _tinkoff_ng_polymorpheus__WEBPACK_IMPORTED_MODULE_9__/* .PolymorpheusOutletComponent */ .r1, _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_10__/* .TuiSvgComponent */ .P, _taiga_ui_core_components_loader__WEBPACK_IMPORTED_MODULE_11__/* .TuiLoaderComponent */ .kM],
  styles: ["[_nghost-%COMP%]{-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:0;border:0;background:0 0;font-size:inherit;line-height:inherit;font:var(--tui-font-text-s);color:var(--tui-text-01);position:relative;display:inline-block;flex-shrink:0;vertical-align:top;border-radius:var(--tui-radius-m);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;text-decoration:none;font-weight:700;outline:0}[disabled][_nghost-%COMP%]{pointer-events:none}[tuiIconButton][_nghost-%COMP%]   .left[_ngcontent-%COMP%], [tuiIconButton][_nghost-%COMP%]   .right[_ngcontent-%COMP%]{margin:0}[data-tui-host-shape=rounded][_nghost-%COMP%]{border-radius:100px}[data-tui-host-size=xs][_nghost-%COMP%]{height:var(--tui-height-xs);font-weight:400}[data-tui-host-size=xs][data-tui-host-shape=square][_nghost-%COMP%], [data-tui-host-size=xs][tuiIconButton][_nghost-%COMP%]{height:var(--tui-height-xs);width:var(--tui-height-xs)}[data-tui-host-size='s'][_nghost-%COMP%]{height:var(--tui-height-s);font-weight:400}[data-tui-host-size='s'][data-tui-host-shape=square][_nghost-%COMP%], [data-tui-host-size='s'][tuiIconButton][_nghost-%COMP%]{height:var(--tui-height-s);width:var(--tui-height-s)}[data-tui-host-size='m'][_nghost-%COMP%]{height:var(--tui-height-m);font-size:15px}[data-tui-host-size='m'][data-tui-host-shape=square][_nghost-%COMP%], [data-tui-host-size='m'][tuiIconButton][_nghost-%COMP%]{height:var(--tui-height-m);width:var(--tui-height-m)}[data-tui-host-size='l'][_nghost-%COMP%]{height:var(--tui-height-l);font-size:15px}[data-tui-host-size='l'][data-tui-host-shape=square][_nghost-%COMP%], [data-tui-host-size='l'][tuiIconButton][_nghost-%COMP%]{height:var(--tui-height-l);width:var(--tui-height-l)}[data-tui-host-size=xl][_nghost-%COMP%]{height:60px;font-size:15px}[data-tui-host-size=xl][data-tui-host-shape=square][_nghost-%COMP%], [data-tui-host-size=xl][tuiIconButton][_nghost-%COMP%]{height:60px;width:60px}.loader[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%;cursor:default}.left[_ngcontent-%COMP%]{margin:0 8px 0 -4px}.right[_ngcontent-%COMP%]{margin:0 -4px 0 8px}.icon[_ngcontent-%COMP%]{display:block}[data-tui-host-size='s'][_nghost-%COMP%]   .icon[_ngcontent-%COMP%], [data-tui-host-size=xs][_nghost-%COMP%]   .icon[_ngcontent-%COMP%]{width:16px;height:16px}[tuiIconButton][_nghost-%COMP%]   .icon[_ngcontent-%COMP%], [tuiIconButton][_nghost-%COMP%]   .left[_ngcontent-%COMP%], [tuiIconButton][_nghost-%COMP%]   .right[_ngcontent-%COMP%]{display:flex;width:100%;height:100%;align-items:center;justify-content:center}.wrapper[_ngcontent-%COMP%]{position:relative;z-index:0;box-sizing:border-box;cursor:pointer}[data-tui-host-size=xs][_nghost-%COMP%]   .wrapper[_ngcontent-%COMP%]{padding:0 8px}[data-tui-host-size='s'][_nghost-%COMP%]   .wrapper[_ngcontent-%COMP%]{padding:0 12px}[data-tui-host-size='m'][_nghost-%COMP%]   .wrapper[_ngcontent-%COMP%]{padding:0 24px}[data-tui-host-size='l'][_nghost-%COMP%]   .wrapper[_ngcontent-%COMP%]{padding:0 36px}[data-tui-host-size=xl][_nghost-%COMP%]   .wrapper[_ngcontent-%COMP%]{padding:0 40px}[data-tui-host-shape=square][_nghost-%COMP%]   .wrapper[_ngcontent-%COMP%], [tuiIconButton][_nghost-%COMP%]   .wrapper[_ngcontent-%COMP%]{padding:0}.content[_ngcontent-%COMP%]{display:flex;height:100%;align-items:center;justify-content:center;text-align:center}._loading[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{opacity:0}"],
  changeDetection: 0
});
TuiButtonComponent.ctorParameters = () => [{
  type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef]
  }]
}, {
  type: _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__/* .TuiFocusVisibleService */ .ku,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__/* .TuiFocusVisibleService */ .ku]
  }]
}, {
  type: _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__/* .TuiHoveredService */ .gs,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__/* .TuiHoveredService */ .gs]
  }]
}, {
  type: rxjs__WEBPACK_IMPORTED_MODULE_12__/* .Observable */ .y,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__/* .TuiDestroyService */ .a3]
  }]
}, {
  type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef]
  }]
}];
(0,tslib__WEBPACK_IMPORTED_MODULE_13__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('attr.data-appearance'), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_14__/* .tuiDefaultProp */ .TH)()], TuiButtonComponent.prototype, "appearance", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_13__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_14__/* .tuiDefaultProp */ .TH)()], TuiButtonComponent.prototype, "disabled", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_13__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_14__/* .tuiDefaultProp */ .TH)()], TuiButtonComponent.prototype, "icon", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_13__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_14__/* .tuiDefaultProp */ .TH)()], TuiButtonComponent.prototype, "iconRight", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_13__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('attr.data-tui-host-shape'), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_14__/* .tuiDefaultProp */ .TH)()], TuiButtonComponent.prototype, "shape", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_13__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._loading'), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_14__/* .tuiDefaultProp */ .TH)()], TuiButtonComponent.prototype, "showLoader", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_13__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('attr.data-tui-host-size'), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_14__/* .tuiDefaultProp */ .TH)()], TuiButtonComponent.prototype, "size", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_13__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('attr.disabled')], TuiButtonComponent.prototype, "nativeDisabled", null);
(0,tslib__WEBPACK_IMPORTED_MODULE_13__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('tabIndex')], TuiButtonComponent.prototype, "tabIndex", null);
(0,tslib__WEBPACK_IMPORTED_MODULE_13__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener)('focusin', ['true']), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener)('focusout', ['false'])], TuiButtonComponent.prototype, "onFocused", null);
TuiButtonComponent = TuiButtonComponent_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_13__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_13__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef)), (0,tslib__WEBPACK_IMPORTED_MODULE_13__/* .__param */ .fM)(1, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__/* .TuiFocusVisibleService */ .ku)), (0,tslib__WEBPACK_IMPORTED_MODULE_13__/* .__param */ .fM)(2, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__/* .TuiHoveredService */ .gs)), (0,tslib__WEBPACK_IMPORTED_MODULE_13__/* .__param */ .fM)(3, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__/* .TuiDestroyService */ .a3)), (0,tslib__WEBPACK_IMPORTED_MODULE_13__/* .__param */ .fM)(4, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef))], TuiButtonComponent);
let TuiButtonModule = /*#__PURE__*/(() => {
  let TuiButtonModule = class TuiButtonModule {};
  TuiButtonModule.ɵfac = function TuiButtonModule_Factory(t) {
    return new (t || TuiButtonModule)();
  };
  TuiButtonModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
    type: TuiButtonModule
  });
  TuiButtonModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
    imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule, _tinkoff_ng_polymorpheus__WEBPACK_IMPORTED_MODULE_9__/* .PolymorpheusModule */ .wq, _taiga_ui_core_components_wrapper__WEBPACK_IMPORTED_MODULE_8__/* .TuiWrapperModule */ .W, _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_10__/* .TuiSvgModule */ .E, _taiga_ui_core_components_loader__WEBPACK_IMPORTED_MODULE_11__/* .TuiLoaderModule */ .dS]]
  });
  return TuiButtonModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](TuiButtonModule, {
    declarations: function () {
      return [TuiButtonComponent];
    },
    imports: function () {
      return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule, _tinkoff_ng_polymorpheus__WEBPACK_IMPORTED_MODULE_9__/* .PolymorpheusModule */ .wq, _taiga_ui_core_components_wrapper__WEBPACK_IMPORTED_MODULE_8__/* .TuiWrapperModule */ .W, _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_10__/* .TuiSvgModule */ .E, _taiga_ui_core_components_loader__WEBPACK_IMPORTED_MODULE_11__/* .TuiLoaderModule */ .dS];
    },
    exports: function () {
      return [TuiButtonComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-button.js.map

/***/ }),

/***/ 2847:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   V: () => (/* binding */ TuiLinkComponent),
/* harmony export */   j: () => (/* binding */ TuiLinkModule)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(7582);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2541);
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_router__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7179);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3503);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8096);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(4358);
/* harmony import */ var _taiga_ui_core_providers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(2130);
/* harmony import */ var _taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1587);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(8891);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3008);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(4789);















const _c0 = ["tuiLink", ""];
function TuiLinkComponent_tui_svg_0_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "tui-svg", 3);
  }
  if (rf & 2) {
    const ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("src", ctx_r0.icon);
  }
}
function TuiLinkComponent_tui_svg_3_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "tui-svg", 4);
  }
  if (rf & 2) {
    const ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("src", ctx_r1.icon);
  }
}
const _c1 = ["*"];
var TuiLinkComponent_1;
// @bad TODO: Think about extending Interactive
let TuiLinkComponent = TuiLinkComponent_1 = class TuiLinkComponent {
  constructor(elementRef, mode$, routerLinkActive, focusVisible$) {
    this.elementRef = elementRef;
    this.mode$ = mode$;
    this.routerLinkActive = routerLinkActive;
    this.pseudo = false;
    this.icon = null;
    this.iconAlign = 'right';
    this.iconRotated = false;
    this.mode = null;
    this.focusVisible = false;
    focusVisible$.subscribe(visible => {
      this.focusVisible = visible;
    });
  }
  get nativeFocusableElement() {
    return this.elementRef.nativeElement;
  }
  get focused() {
    return (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_3__/* .isNativeFocused */ .zV)(this.nativeFocusableElement);
  }
  get active() {
    return !!this.routerLinkActive && this.routerLinkActive.isActive;
  }
  get hasIcon() {
    return this.icon !== null;
  }
  get iconAlignLeft() {
    return this.hasIcon && this.iconAlign === 'left';
  }
  get iconAlignRight() {
    return this.hasIcon && this.iconAlign === 'right';
  }
};
TuiLinkComponent.ɵfac = function TuiLinkComponent_Factory(t) {
  return new (t || TuiLinkComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_4__/* .TUI_MODE */ .Au), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_router__WEBPACK_IMPORTED_MODULE_1__.RouterLinkActive, 8), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_5__/* .TuiFocusVisibleService */ .ku));
};
TuiLinkComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
  type: TuiLinkComponent,
  selectors: [["a", "tuiLink", ""], ["button", "tuiLink", ""]],
  hostVars: 9,
  hostBindings: function TuiLinkComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("$.data-mode.attr", function TuiLinkComponent___data_mode_attr_HostBindingHandler() {
        return ctx.mode$;
      });
    }
    if (rf & 2) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("data-mode", ctx.mode);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("_pseudo", ctx.pseudo)("_icon-rotated", ctx.iconRotated)("_focus-visible", ctx.focusVisible)("_active", ctx.active);
    }
  },
  inputs: {
    pseudo: "pseudo",
    icon: "icon",
    iconAlign: "iconAlign",
    iconRotated: "iconRotated",
    mode: "mode"
  },
  exportAs: ["tuiLink"],
  features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
    provide: _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__/* .TUI_FOCUSABLE_ITEM_ACCESSOR */ .KZ,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => TuiLinkComponent_1)
  }, _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_5__/* .TuiFocusVisibleService */ .ku, _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_5__/* .TuiDestroyService */ .a3, _taiga_ui_core_providers__WEBPACK_IMPORTED_MODULE_7__/* .MODE_PROVIDER */ .CV])],
  attrs: _c0,
  ngContentSelectors: _c1,
  decls: 4,
  vars: 2,
  consts: [["class", "icon icon_left", 3, "src", 4, "ngIf"], [1, "content"], ["class", "icon icon_right", 3, "src", 4, "ngIf"], [1, "icon", "icon_left", 3, "src"], [1, "icon", "icon_right", 3, "src"]],
  template: function TuiLinkComponent_Template(rf, ctx) {
    if (rf & 1) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, TuiLinkComponent_tui_svg_0_Template, 1, 1, "tui-svg", 0);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "span", 1);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](2);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, TuiLinkComponent_tui_svg_3_Template, 1, 1, "tui-svg", 2);
    }
    if (rf & 2) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.iconAlignLeft);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](3);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.iconAlignRight);
    }
  },
  directives: [_angular_common__WEBPACK_IMPORTED_MODULE_2__.NgIf, _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_8__/* .TuiSvgComponent */ .P],
  styles: ["[_nghost-%COMP%]{-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:0;border:0;background:0 0;font-size:inherit;line-height:inherit;transition-property:color;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;color:var(--tui-link);text-decoration:none;text-align:left;text-transform:inherit;font-weight:inherit;cursor:pointer;outline:0}[_nghost-%COMP%]:hover{color:var(--tui-link-hover)}[_nghost-%COMP%]:disabled{opacity:var(--tui-disabled-opacity);cursor:default}[data-mode=onLight][_nghost-%COMP%]{color:var(--tui-text-03)}[data-mode=onLight]._active[_nghost-%COMP%], [data-mode=onLight][_nghost-%COMP%]:hover{color:var(--tui-text-01)}[data-mode=onLight]._pseudo[_nghost-%COMP%]{color:var(--tui-text-01)}[data-mode=onLight]._pseudo._active[_nghost-%COMP%], [data-mode=onLight]._pseudo[_nghost-%COMP%]:hover{color:var(--tui-text-03)}[data-mode=onLight][data-mode=negative][_nghost-%COMP%]{color:var(--tui-negative-night)}[data-mode=onLight][data-mode=negative]._active[_nghost-%COMP%], [data-mode=onLight][data-mode=negative][_nghost-%COMP%]:active, [data-mode=onLight][data-mode=negative][_nghost-%COMP%]:hover{color:var(--tui-negative-night-hover)}[data-mode=onDark][_nghost-%COMP%]{color:var(--tui-text-03-night)}[data-mode=onDark]._active[_nghost-%COMP%], [data-mode=onDark][_nghost-%COMP%]:active, [data-mode=onDark][_nghost-%COMP%]:hover{color:var(--tui-text-01-night)}[data-mode=onDark]._pseudo[_nghost-%COMP%]{color:var(--tui-text-01-night)}[data-mode=onDark]._pseudo._active[_nghost-%COMP%], [data-mode=onDark]._pseudo[_nghost-%COMP%]:active, [data-mode=onDark]._pseudo[_nghost-%COMP%]:hover{color:var(--tui-text-03-night)}[data-mode=onDark][data-mode=positive][_nghost-%COMP%]{color:var(--tui-positive-night)}[data-mode=onDark][data-mode=positive]._active[_nghost-%COMP%], [data-mode=onDark][data-mode=positive][_nghost-%COMP%]:active, [data-mode=onDark][data-mode=positive][_nghost-%COMP%]:hover{color:var(--tui-positive-night-hover)}[data-mode=negative][_nghost-%COMP%]{color:var(--tui-negative)}[data-mode=negative][_nghost-%COMP%]:hover{color:var(--tui-negative-hover)}[data-mode=positive][_nghost-%COMP%]{color:var(--tui-positive)}[data-mode=positive][_nghost-%COMP%]:hover{color:var(--tui-positive-hover)}.content[_ngcontent-%COMP%]{display:inline-block}._focus-visible[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{background:var(--tui-selection)}[data-mode=onLight]._focus-visible[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{background:var(--tui-text-01);color:var(--tui-base-01)}[data-mode=onDark]._focus-visible[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{background:var(--tui-base-01);color:var(--tui-text-01)}[data-mode=positive]._focus-visible[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{background:var(--tui-success-bg)}[data-mode=negative]._focus-visible[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{background:var(--tui-error-bg)}._pseudo[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{padding-bottom:.15em;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}.icon[_ngcontent-%COMP%]{transition-property:transform;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;margin-top:-2px;opacity:.8}.icon_left[_ngcontent-%COMP%]{margin-right:4px}.icon_right[_ngcontent-%COMP%]{margin-left:4px}._hovered[_nghost-%COMP%]   .icon[_ngcontent-%COMP%]{opacity:1}._icon-rotated[_nghost-%COMP%]   .icon[_ngcontent-%COMP%]{transform:rotate(180deg)}"],
  changeDetection: 0
});
TuiLinkComponent.ctorParameters = () => [{
  type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef]
  }]
}, {
  type: rxjs__WEBPACK_IMPORTED_MODULE_9__/* .Observable */ .y,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_4__/* .TUI_MODE */ .Au]
  }]
}, {
  type: _angular_router__WEBPACK_IMPORTED_MODULE_1__.RouterLinkActive,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [_angular_router__WEBPACK_IMPORTED_MODULE_1__.RouterLinkActive]
  }]
}, {
  type: _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_5__/* .TuiFocusVisibleService */ .ku,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_5__/* .TuiFocusVisibleService */ .ku]
  }]
}];
(0,tslib__WEBPACK_IMPORTED_MODULE_10__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._pseudo'), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_11__/* .tuiDefaultProp */ .TH)()], TuiLinkComponent.prototype, "pseudo", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_10__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_11__/* .tuiDefaultProp */ .TH)()], TuiLinkComponent.prototype, "icon", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_10__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_11__/* .tuiDefaultProp */ .TH)()], TuiLinkComponent.prototype, "iconAlign", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_10__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._icon-rotated'), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_11__/* .tuiDefaultProp */ .TH)()], TuiLinkComponent.prototype, "iconRotated", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_10__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('attr.data-mode'), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_11__/* .tuiDefaultProp */ .TH)()], TuiLinkComponent.prototype, "mode", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_10__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._focus-visible')], TuiLinkComponent.prototype, "focusVisible", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_10__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._active')], TuiLinkComponent.prototype, "active", null);
TuiLinkComponent = TuiLinkComponent_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_10__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_10__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef)), (0,tslib__WEBPACK_IMPORTED_MODULE_10__/* .__param */ .fM)(1, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_4__/* .TUI_MODE */ .Au)), (0,tslib__WEBPACK_IMPORTED_MODULE_10__/* .__param */ .fM)(2, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional)()), (0,tslib__WEBPACK_IMPORTED_MODULE_10__/* .__param */ .fM)(2, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_angular_router__WEBPACK_IMPORTED_MODULE_1__.RouterLinkActive)), (0,tslib__WEBPACK_IMPORTED_MODULE_10__/* .__param */ .fM)(3, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_5__/* .TuiFocusVisibleService */ .ku))], TuiLinkComponent);
let TuiLinkModule = /*#__PURE__*/(() => {
  let TuiLinkModule = class TuiLinkModule {};
  TuiLinkModule.ɵfac = function TuiLinkModule_Factory(t) {
    return new (t || TuiLinkModule)();
  };
  TuiLinkModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
    type: TuiLinkModule
  });
  TuiLinkModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
    imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_2__.CommonModule, _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_8__/* .TuiSvgModule */ .E]]
  });
  return TuiLinkModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](TuiLinkModule, {
    declarations: function () {
      return [TuiLinkComponent];
    },
    imports: function () {
      return [_angular_common__WEBPACK_IMPORTED_MODULE_2__.CommonModule, _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_8__/* .TuiSvgModule */ .E];
    },
    exports: function () {
      return [TuiLinkComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-link.js.map

/***/ }),

/***/ 719:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dS: () => (/* binding */ TuiLoaderModule),
/* harmony export */   kM: () => (/* binding */ TuiLoaderComponent)
/* harmony export */ });
/* unused harmony export TuiLoaderDirective */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(7582);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3008);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _ng_web_apis_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2579);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1213);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7179);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8096);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(4358);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(908);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(3503);
/* harmony import */ var _taiga_ui_core_utils_miscellaneous__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6640);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(9328);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(6782);
/* harmony import */ var _tinkoff_ng_polymorpheus__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(9570);










// @dynamic




function TuiLoaderComponent_div_2_div_3_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnamespaceSVG"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnamespaceHTML"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](0, "div", 6);
  }
  if (rf & 2) {
    const ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵclassProp"]("text_horizontal", ctx_r1.isHorizontal);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("content", ctx_r1.textContent);
  }
}
function TuiLoaderComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementStart"](0, "div", 2);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnamespaceSVG"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementStart"](1, "svg", 3);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](2, "circle", 4);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](3, TuiLoaderComponent_div_2_div_3_Template, 1, 3, "div", 5);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵclassProp"]("loader_horizontal", ctx_r0.isHorizontal)("loader_inherit-color", ctx_r0.inheritColor);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("data-tui-element-size", ctx_r0.size);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](3);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngIf", ctx_r0.hasText);
  }
}
const _c0 = ["*"];
let TuiLoaderComponent = /*#__PURE__*/(() => {
  let TuiLoaderComponent = class TuiLoaderComponent {
    constructor(documentRef, elementRef, userAgent, isIos) {
      this.documentRef = documentRef;
      this.elementRef = elementRef;
      this.userAgent = userAgent;
      this.isIos = isIos;
      this.size = 'm';
      this.inheritColor = false;
      this.overlay = false;
      this.textContent = null;
      this.loading = true;
      this.animatedWithJs = (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_2__/* .isEdgeOlderThan */ .Q0)(17, this.userAgent) || (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_2__/* .isIE */ .w1)(this.userAgent);
      this.isApple = (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_2__/* .isSafari */ .G6)(this.elementRef.nativeElement) || this.isIos;
    }
    set showLoader(value) {
      // @bad TODO: https://github.com/angular/angular/issues/32083 think of a better way
      if (value && this.focused) {
        (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_3__/* .blurNativeFocused */ .PO)(this.documentRef);
      }
      this.loading = value;
    }
    get hasOverlay() {
      return this.overlay && this.loading;
    }
    get hasText() {
      return !!this.textContent;
    }
    get isHorizontal() {
      return !(0,_taiga_ui_core_utils_miscellaneous__WEBPACK_IMPORTED_MODULE_4__/* .sizeBigger */ .Bb)(this.size);
    }
    get focused() {
      return (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_3__/* .isNativeFocusedIn */ .KF)(this.elementRef.nativeElement);
    }
  };
  TuiLoaderComponent.ɵfac = function TuiLoaderComponent_Factory(t) {
    return new (t || TuiLoaderComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_5__/* .USER_AGENT */ .yZ), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__/* .TUI_IS_IOS */ .FA));
  };
  TuiLoaderComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineComponent"]({
    type: TuiLoaderComponent,
    selectors: [["tui-loader"]],
    hostVars: 4,
    hostBindings: function TuiLoaderComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵclassProp"]("_loading", ctx.loading)("_animated-with-js", ctx.animatedWithJs);
      }
    },
    inputs: {
      size: "size",
      inheritColor: "inheritColor",
      overlay: "overlay",
      textContent: "textContent",
      showLoader: "showLoader"
    },
    ngContentSelectors: _c0,
    decls: 3,
    vars: 6,
    consts: [[1, "content", 3, "disabled"], ["class", "loader", 3, "loader_horizontal", "loader_inherit-color", 4, "ngIf"], [1, "loader"], ["automation-id", "tui-loader__loader", "focusable", "false", "viewBox", "0 0 100 100", "xmlns", "http://www.w3.org/2000/svg", 1, "icon"], ["cx", "50", "cy", "50", "r", "50", "stroke-dasharray", "314", 1, "circle"], ["polymorpheus-outlet", "", "automation-id", "tui-loader__text", "class", "text", 3, "text_horizontal", "content", 4, "ngIf"], ["polymorpheus-outlet", "", "automation-id", "tui-loader__text", 1, "text", 3, "content"]],
    template: function TuiLoaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementStart"](0, "fieldset", 0);
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵprojection"](1);
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](2, TuiLoaderComponent_div_2_Template, 4, 6, "div", 1);
      }
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵclassProp"]("content_has-overlay", ctx.hasOverlay)("content_loading", ctx.loading);
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("disabled", ctx.loading && !ctx.isApple);
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](2);
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngIf", ctx.loading);
      }
    },
    directives: function () {
      return [_angular_common__WEBPACK_IMPORTED_MODULE_0__.NgIf, TuiLoaderDirective, _tinkoff_ng_polymorpheus__WEBPACK_IMPORTED_MODULE_7__/* .PolymorpheusOutletComponent */ .r1];
    },
    styles: ["@-webkit-keyframes tuiLoaderDashOffset{0%,100%{stroke-dashoffset:-66}50%{stroke-dashoffset:-314}}@keyframes tuiLoaderDashOffset{0%,100%{stroke-dashoffset:-66}50%{stroke-dashoffset:-314}}@-webkit-keyframes tuiLoaderRotate{0%{transform:rotate(0)}50%{transform:rotate(1turn)}100%{transform:rotate(3turn)}}@keyframes tuiLoaderRotate{0%{transform:rotate(0)}50%{transform:rotate(1turn)}100%{transform:rotate(3turn)}}[_nghost-%COMP%]{position:relative;display:flex}._loading[_nghost-%COMP%]{overflow:hidden}.content[_ngcontent-%COMP%]{z-index:0;min-width:100%;height:100%;padding:0;margin:0;border:none}.content_has-overlay[_ngcontent-%COMP%]{opacity:.3}.content_loading[_ngcontent-%COMP%]{pointer-events:none}.loader[_ngcontent-%COMP%]{position:relative;left:-100%;display:flex;flex-direction:column;align-items:center;justify-content:center;min-width:100%;flex-shrink:0;-ms-grid-row-align:center;align-self:center;color:var(--tui-text-01);stroke:var(--tui-primary);-webkit-animation:tuiFadeIn var(--tui-duration);animation:tuiFadeIn var(--tui-duration)}.loader.loader_horizontal[_ngcontent-%COMP%]{flex-direction:row}.loader.loader_inherit-color[_ngcontent-%COMP%]{color:inherit;stroke:currentColor}.loader[data-tui-element-size=xs][_ngcontent-%COMP%]{font-size:12px;stroke-width:38}.loader[data-tui-element-size='s'][_ngcontent-%COMP%]{font-size:16px;stroke-width:25}.loader[data-tui-element-size='m'][_ngcontent-%COMP%]{font-size:24px;stroke-width:17}.loader[data-tui-element-size='l'][_ngcontent-%COMP%]{font-size:40px;stroke-width:15}.loader[data-tui-element-size=xl][_ngcontent-%COMP%]{font-size:56px;stroke-width:14}.loader[data-tui-element-size=xxl][_ngcontent-%COMP%]{font-size:80px;stroke-width:10}.text[_ngcontent-%COMP%]{font:var(--tui-font-text-s);color:var(--tui-text-01);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;margin-top:16px;color:inherit;max-width:100%;text-align:center;stroke-width:0}.text_horizontal[_ngcontent-%COMP%]{margin:0 0 0 16px}.icon[_ngcontent-%COMP%]{display:block;min-width:1em;max-width:1em;min-height:1em;max-height:1em;margin:4px -.5em;border-radius:100%;overflow:hidden;transform:scale(1,-1)}[_nghost-%COMP%]:not(._animated-with-js)   .icon[_ngcontent-%COMP%]{-webkit-animation:3s linear infinite tuiLoaderRotate;animation:3s linear infinite tuiLoaderRotate}.circle[_ngcontent-%COMP%]{fill:none;stroke:inherit;stroke-width:inherit;-webkit-animation:3s linear infinite tuiLoaderDashOffset;animation:3s linear infinite tuiLoaderDashOffset}"],
    changeDetection: 0
  });
  (0,tslib__WEBPACK_IMPORTED_MODULE_8__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_9__/* .tuiDefaultProp */ .TH)()], TuiLoaderComponent.prototype, "size", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_8__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_9__/* .tuiDefaultProp */ .TH)()], TuiLoaderComponent.prototype, "inheritColor", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_8__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_9__/* .tuiDefaultProp */ .TH)()], TuiLoaderComponent.prototype, "overlay", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_8__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_9__/* .tuiDefaultProp */ .TH)()], TuiLoaderComponent.prototype, "textContent", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_8__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_9__/* .tuiRequiredSetter */ .NH)()], TuiLoaderComponent.prototype, "showLoader", null);
  (0,tslib__WEBPACK_IMPORTED_MODULE_8__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.HostBinding)('class._loading')], TuiLoaderComponent.prototype, "loading", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_8__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.HostBinding)('class._animated-with-js')], TuiLoaderComponent.prototype, "animatedWithJs", void 0);
  TuiLoaderComponent = (0,tslib__WEBPACK_IMPORTED_MODULE_8__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_8__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT)), (0,tslib__WEBPACK_IMPORTED_MODULE_8__/* .__param */ .fM)(1, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef)), (0,tslib__WEBPACK_IMPORTED_MODULE_8__/* .__param */ .fM)(2, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_5__/* .USER_AGENT */ .yZ)), (0,tslib__WEBPACK_IMPORTED_MODULE_8__/* .__param */ .fM)(3, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__/* .TUI_IS_IOS */ .FA))], TuiLoaderComponent);
  return TuiLoaderComponent;
})();
const PERIMETER = 314;
const COEFFICIENT = 1.5;
let TuiLoaderDirective = /*#__PURE__*/(() => {
  let TuiLoaderDirective = class TuiLoaderDirective {
    constructor(animationFrame$, ngZone, destroy$, elementRef, userAgent) {
      this.elementRef = elementRef;
      this.strokeDasharray = PERIMETER;
      this.strokeDashoffset = 0;
      if (!(0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_2__/* .isEdgeOlderThan */ .Q0)(17, userAgent) && !(0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_2__/* .isIE */ .w1)(userAgent)) {
        return;
      }
      animationFrame$.pipe((0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_10__/* .tuiZonefree */ .fL)(ngZone), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_11__/* .pairwise */ .G)(), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_12__/* .takeUntil */ .R)(destroy$)).subscribe(([cur, prev]) => {
        this.animate(prev - cur);
      });
    }
    animate(delta) {
      if (this.strokeDasharray < 0) {
        this.strokeDasharray = PERIMETER * 2;
        this.strokeDashoffset = 0;
      }
      const strokeDasharray = Math.abs(this.strokeDasharray - PERIMETER);
      const fps = 1000 / delta;
      const offsetStep = 1 + Math.floor(this.strokeDasharray / PERIMETER);
      const {
        style
      } = this.elementRef.nativeElement;
      style.strokeDashoffset = this.strokeDashoffset.toString();
      style.strokeDasharray = PERIMETER - strokeDasharray + ' ' + strokeDasharray;
      this.strokeDasharray -= PERIMETER / COEFFICIENT / fps;
      this.strokeDashoffset += offsetStep * PERIMETER / COEFFICIENT / fps;
      // this.elementRef.nativeElement.parentElement!.style.animation = 'none';
    }
  };

  TuiLoaderDirective.ɵfac = function TuiLoaderDirective_Factory(t) {
    return new (t || TuiLoaderDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_5__/* .ANIMATION_FRAME */ .L1), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_13__/* .TuiDestroyService */ .a3), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_5__/* .USER_AGENT */ .yZ));
  };
  TuiLoaderDirective.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
    type: TuiLoaderDirective,
    selectors: [["circle"]],
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_13__/* .TuiDestroyService */ .a3])]
  });
  TuiLoaderDirective = (0,tslib__WEBPACK_IMPORTED_MODULE_8__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_8__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_5__/* .ANIMATION_FRAME */ .L1)), (0,tslib__WEBPACK_IMPORTED_MODULE_8__/* .__param */ .fM)(1, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone)), (0,tslib__WEBPACK_IMPORTED_MODULE_8__/* .__param */ .fM)(2, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_13__/* .TuiDestroyService */ .a3)), (0,tslib__WEBPACK_IMPORTED_MODULE_8__/* .__param */ .fM)(3, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef)), (0,tslib__WEBPACK_IMPORTED_MODULE_8__/* .__param */ .fM)(4, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_5__/* .USER_AGENT */ .yZ))], TuiLoaderDirective);
  return TuiLoaderDirective;
})();
let TuiLoaderModule = /*#__PURE__*/(() => {
  let TuiLoaderModule = class TuiLoaderModule {};
  TuiLoaderModule.ɵfac = function TuiLoaderModule_Factory(t) {
    return new (t || TuiLoaderModule)();
  };
  TuiLoaderModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
    type: TuiLoaderModule
  });
  TuiLoaderModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
    imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_0__.CommonModule, _tinkoff_ng_polymorpheus__WEBPACK_IMPORTED_MODULE_7__/* .PolymorpheusModule */ .wq]]
  });
  return TuiLoaderModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵsetNgModuleScope"](TuiLoaderModule, {
    declarations: function () {
      return [TuiLoaderComponent, TuiLoaderDirective];
    },
    imports: function () {
      return [_angular_common__WEBPACK_IMPORTED_MODULE_0__.CommonModule, _tinkoff_ng_polymorpheus__WEBPACK_IMPORTED_MODULE_7__/* .PolymorpheusModule */ .wq];
    },
    exports: function () {
      return [TuiLoaderComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-loader.js.map

/***/ }),

/***/ 885:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Hi: () => (/* binding */ TuiNotificationModule),
/* harmony export */   Ls: () => (/* binding */ TuiNotificationComponent)
/* harmony export */ });
/* unused harmony export STATUS_ICON */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7582);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4358);
/* harmony import */ var _taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1587);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3008);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _taiga_ui_core_components_button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2628);
/* harmony import */ var _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4789);













function TuiNotificationComponent_tui_svg_0_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "tui-svg", 3);
  }
  if (rf & 2) {
    const ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("src", ctx_r0.icon);
  }
}
function TuiNotificationComponent_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "button", 4);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function TuiNotificationComponent_button_3_Template_button_click_0_listener() {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r3);
      const ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
      return ctx_r2.close.emit();
    });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpipe"](1, "async");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("title", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpipeBind1"](1, 1, ctx_r1.closeWord$));
  }
}
const _c0 = ["*"];
const STATUS_ICON = {
  info: 'tuiIconInfo',
  success: 'tuiIconCheckCircle',
  error: 'tuiIconCancel',
  warning: 'tuiIconAttention'
};
// @bad TODO: Think about moving to kit
let TuiNotificationComponent = /*#__PURE__*/(() => {
  let TuiNotificationComponent = class TuiNotificationComponent {
    constructor(closeWord$) {
      this.closeWord$ = closeWord$;
      this.hasIcon = true;
      this.status = "info" /* Info */;
      this.close = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    }
    get icon() {
      return STATUS_ICON[this.status];
    }
    get hasClose() {
      return !!this.close.observers.length;
    }
  };
  TuiNotificationComponent.ɵfac = function TuiNotificationComponent_Factory(t) {
    return new (t || TuiNotificationComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_2__/* .TUI_CLOSE_WORD */ .U0));
  };
  TuiNotificationComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: TuiNotificationComponent,
    selectors: [["tui-notification"]],
    hostVars: 5,
    hostBindings: function TuiNotificationComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("data-tui-host-status", ctx.status);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("_has-icon", ctx.hasIcon)("_has-close-button", ctx.hasClose);
      }
    },
    inputs: {
      hasIcon: "hasIcon",
      status: "status"
    },
    outputs: {
      close: "close"
    },
    ngContentSelectors: _c0,
    decls: 4,
    vars: 2,
    consts: [["automation-id", "tui-notification__icon", "class", "icon", 3, "src", 4, "ngIf"], [1, "content"], ["tuiIconButton", "", "type", "button", "automation-id", "tui-notification__close", "size", "xs", "class", "close", "icon", "tuiIconCloseLarge", "appearance", "icon", 3, "title", "click", 4, "ngIf"], ["automation-id", "tui-notification__icon", 1, "icon", 3, "src"], ["tuiIconButton", "", "type", "button", "automation-id", "tui-notification__close", "size", "xs", "icon", "tuiIconCloseLarge", "appearance", "icon", 1, "close", 3, "title", "click"]],
    template: function TuiNotificationComponent_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, TuiNotificationComponent_tui_svg_0_Template, 1, 1, "tui-svg", 0);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "div", 1);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](2);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, TuiNotificationComponent_button_3_Template, 2, 3, "button", 2);
      }
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.hasIcon);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](3);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.hasClose);
      }
    },
    directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_3__/* .TuiSvgComponent */ .P, _taiga_ui_core_components_button__WEBPACK_IMPORTED_MODULE_4__/* .TuiButtonComponent */ .v],
    pipes: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.AsyncPipe],
    styles: ["[_nghost-%COMP%]{font:var(--tui-font-text-s);color:var(--tui-text-01);position:relative;display:block;padding:13px 16px 11px;border-radius:var(--tui-radius-m);background:#fff;background:var(--tui-base-01);overflow:hidden}[_nghost-%COMP%]:after{position:absolute;top:0;left:0;width:100%;height:100%;content:'';pointer-events:none}._has-close-button[_nghost-%COMP%]{padding-right:32px}._has-icon[_nghost-%COMP%]{padding-left:44px}[data-tui-host-status=info][_nghost-%COMP%]{color:var(--tui-info-fill)}[data-tui-host-status=info][_nghost-%COMP%]:after{background:var(--tui-info-bg)}[data-tui-host-status=success][_nghost-%COMP%]{color:var(--tui-success-fill)}[data-tui-host-status=success][_nghost-%COMP%]:after{background:var(--tui-success-bg)}[data-tui-host-status=error][_nghost-%COMP%]{color:var(--tui-error-fill)}[data-tui-host-status=error][_nghost-%COMP%]:after{background:var(--tui-error-bg)}[data-tui-host-status=warning][_nghost-%COMP%]{color:var(--tui-warning-fill)}[data-tui-host-status=warning][_nghost-%COMP%]:after{background:var(--tui-warning-bg)}.content[_ngcontent-%COMP%]{word-wrap:break-word;color:var(--tui-text-01)}.icon[_ngcontent-%COMP%]{position:absolute;top:0;left:16px;display:flex;width:16px;height:100%;max-height:48px;align-items:center}.close[_ngcontent-%COMP%]{position:absolute;top:10px;right:8px}"],
    changeDetection: 0
  });
  (0,tslib__WEBPACK_IMPORTED_MODULE_5__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._has-icon'), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__/* .tuiDefaultProp */ .TH)()], TuiNotificationComponent.prototype, "hasIcon", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_5__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('attr.data-tui-host-status'), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__/* .tuiDefaultProp */ .TH)()], TuiNotificationComponent.prototype, "status", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_5__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Output)()], TuiNotificationComponent.prototype, "close", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_5__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._has-close-button')], TuiNotificationComponent.prototype, "hasClose", null);
  TuiNotificationComponent = (0,tslib__WEBPACK_IMPORTED_MODULE_5__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_5__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_2__/* .TUI_CLOSE_WORD */ .U0))], TuiNotificationComponent);
  return TuiNotificationComponent;
})();
let TuiNotificationModule = /*#__PURE__*/(() => {
  let TuiNotificationModule = class TuiNotificationModule {};
  TuiNotificationModule.ɵfac = function TuiNotificationModule_Factory(t) {
    return new (t || TuiNotificationModule)();
  };
  TuiNotificationModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
    type: TuiNotificationModule
  });
  TuiNotificationModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
    imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule, _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_3__/* .TuiSvgModule */ .E, _taiga_ui_core_components_button__WEBPACK_IMPORTED_MODULE_4__/* .TuiButtonModule */ .f]]
  });
  return TuiNotificationModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](TuiNotificationModule, {
    declarations: function () {
      return [TuiNotificationComponent];
    },
    imports: function () {
      return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule, _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_3__/* .TuiSvgModule */ .E, _taiga_ui_core_components_button__WEBPACK_IMPORTED_MODULE_4__/* .TuiButtonModule */ .f];
    },
    exports: function () {
      return [TuiNotificationComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-notification.js.map

/***/ }),

/***/ 4789:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ TuiSvgModule),
/* harmony export */   P: () => (/* binding */ TuiSvgComponent)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(7582);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3008);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(1211);
/* harmony import */ var _ng_web_apis_common__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(2579);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1213);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(5242);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(8939);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(3503);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(4358);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(2668);
/* harmony import */ var _taiga_ui_core_constants__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(8269);
/* harmony import */ var _taiga_ui_core_services__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(7941);
/* harmony import */ var _taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(1587);
/* harmony import */ var _taiga_ui_core_utils_miscellaneous__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(6640);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2298);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5917);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3190);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9761);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(5304);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(8002);

















function TuiSvgComponent_ng_container_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](0, "div", 3);
  }
  if (rf & 2) {
    const innerHTML_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]().tuiLet;
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("innerHTML", innerHTML_r1, _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵsanitizeHtml"]);
  }
}
function TuiSvgComponent_ng_container_0_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵgetCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnamespaceSVG"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementStart"](0, "svg", 4);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵlistener"]("error", function TuiSvgComponent_ng_container_0_ng_template_2_Template__svg_svg_error_0_listener() {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵrestoreView"](_r7);
      const ctx_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"](2);
      return ctx_r6.onError();
    });
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](1, "use");
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("href", ctx_r4.use, null, "xlink");
  }
}
function TuiSvgComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](1, TuiSvgComponent_ng_container_0_div_1_Template, 1, 1, "div", 1);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](2, TuiSvgComponent_ng_container_0_ng_template_2_Template, 2, 1, "ng-template", null, 2, _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplateRefExtractor"]);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const _r3 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵreference"](3);
    const ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngIf", ctx_r0.isInnerHTML)("ngIfElse", _r3);
  }
}
const UNDEFINED_NAMED_ICON = 'Attempted to use undefined named icon';
const MISSING_EXTERNAL_ICON = 'External icon is missing on the given URL';
const FAILED_EXTERNAL_ICON = 'Failed to load external SVG';
// TODO: Consider moving to CDK along with SvgService and SvgDefsHostComponent
// @dynamic
let TuiSvgComponent = /*#__PURE__*/(() => {
  let TuiSvgComponent = class TuiSvgComponent {
    constructor(documentRef, windowRef, iconsPath, tuiSanitizer, svgService, staticRequestService, sanitizer, elementRef, userAgent) {
      this.documentRef = documentRef;
      this.windowRef = windowRef;
      this.iconsPath = iconsPath;
      this.tuiSanitizer = tuiSanitizer;
      this.svgService = svgService;
      this.staticRequestService = staticRequestService;
      this.sanitizer = sanitizer;
      this.elementRef = elementRef;
      this.userAgent = userAgent;
      this.icon = '';
      this.src$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__/* .ReplaySubject */ .t(1);
      this.isIE = (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_3__/* .isIE */ .w1)(this.userAgent);
      this.innerHTML$ = this.src$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__/* .switchMap */ .w)(() => this.isExternal ? this.getExternalIcon(this.icon) : (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.of)(this.getSafeHtml(this.icon))), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__/* .startWith */ .O)(''));
    }
    set src(src) {
      this.icon = src;
      this.src$.next();
    }
    get use() {
      return this.icon.includes('.svg#') ? this.icon : this.resolveName(this.icon, this.iconsPath);
    }
    get isInnerHTML() {
      return this.isSrc || this.isExternal || this.isName && this.isShadowDOM;
    }
    get isShadowDOM() {
      return (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__/* .getDocumentOrShadowRoot */ .sy)(this.elementRef.nativeElement) !== this.documentRef;
    }
    get isUse() {
      return this.use.includes('.svg#');
    }
    get isExternal() {
      return this.isUrl || this.isIE && this.isUse || this.isCrossDomain;
    }
    get isUrl() {
      return this.icon.endsWith('.svg');
    }
    get isSrc() {
      return (0,_taiga_ui_core_utils_miscellaneous__WEBPACK_IMPORTED_MODULE_8__/* .isPresumedHTMLString */ .zL)(this.icon);
    }
    get isName() {
      return !this.isUrl && !this.isUse && !this.isSrc;
    }
    get isCrossDomain() {
      const {
        use,
        isUse,
        windowRef
      } = this;
      return isUse && use.startsWith('http') && !!windowRef.origin && !use.startsWith(windowRef.origin);
    }
    onError(message = MISSING_EXTERNAL_ICON) {
      const {
        icon
      } = this;
      const event = (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__/* .tuiCustomEvent */ .hO)(_taiga_ui_core_constants__WEBPACK_IMPORTED_MODULE_9__/* .TUI_ICON_ERROR */ .qT, {
        bubbles: true,
        detail: {
          message,
          icon
        }
      }, this.documentRef);
      _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_10__/* .tuiAssert */ .z.assert(false, message, icon);
      this.elementRef.nativeElement.dispatchEvent(event);
    }
    resolveName(name, iconsPath) {
      return iconsPath(name);
    }
    getSafeHtml(src) {
      return this.isSrc ? this.sanitize(src) : this.process(src);
    }
    process(src) {
      const icon = this.svgService.getOriginal(src);
      if (this.isName && !icon && !!src) {
        this.onError(UNDEFINED_NAMED_ICON);
      }
      // Empty line for innerHTML when icon is shown through USE tag
      return !this.isShadowDOM || !this.isName ? '' : this.sanitize(icon || '');
    }
    sanitize(src) {
      return this.tuiSanitizer ? this.sanitizer.bypassSecurityTrustHtml(this.tuiSanitizer.sanitize(_angular_core__WEBPACK_IMPORTED_MODULE_1__.SecurityContext.HTML, src) || '') : src;
    }
    // @bad TODO: Create a simple XMLHttpRequest to Observable service
    getExternalIcon(src) {
      const url = src.includes('.svg') ? src : this.use;
      return this.staticRequestService.request(url).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_11__/* .catchError */ .K)(() => {
        this.onError(FAILED_EXTERNAL_ICON);
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.of)('');
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_12__/* .map */ .U)(response => this.sanitize(response.replace('<svg', '<svg focusable="false"'))));
    }
  };
  TuiSvgComponent.ɵfac = function TuiSvgComponent_Factory(t) {
    return new (t || TuiSvgComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_13__/* .WINDOW */ .m9), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_ICONS_PATH */ .ki), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_SANITIZER */ .hm, 8), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_taiga_ui_core_services__WEBPACK_IMPORTED_MODULE_15__/* .TuiSvgService */ .K5), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_16__/* .TuiStaticRequestService */ .Fr), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_platform_browser__WEBPACK_IMPORTED_MODULE_17__.DomSanitizer), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_13__/* .USER_AGENT */ .yZ));
  };
  TuiSvgComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineComponent"]({
    type: TuiSvgComponent,
    selectors: [["tui-svg"]],
    inputs: {
      src: "src"
    },
    decls: 2,
    vars: 3,
    consts: [[4, "tuiLet"], ["class", "src", 3, "innerHTML", 4, "ngIf", "ngIfElse"], ["useTemplate", ""], [1, "src", 3, "innerHTML"], ["version", "1.1", "xmlns", "http://www.w3.org/2000/svg", 0, "xmlns", "xlink", "http://www.w3.org/1999/xlink", "focusable", "false", "width", "100%", "height", "100%", 3, "error"]],
    template: function TuiSvgComponent_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](0, TuiSvgComponent_ng_container_0_Template, 4, 2, "ng-container", 0);
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵpipe"](1, "async");
      }
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("tuiLet", _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵpipeBind1"](1, 1, ctx.innerHTML$));
      }
    },
    directives: [_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_18__/* .TuiLetDirective */ .Ls, _angular_common__WEBPACK_IMPORTED_MODULE_0__.NgIf],
    pipes: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.AsyncPipe],
    styles: ["[_nghost-%COMP%]{display:inline-block;vertical-align:middle;flex-shrink:0;line-height:0;height:24px;width:24px;fill:currentColor}.src[_ngcontent-%COMP%]{display:flex;height:100%;align-items:center;justify-content:center}"],
    changeDetection: 0
  });
  (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_20__/* .tuiRequiredSetter */ .NH)()], TuiSvgComponent.prototype, "src", null);
  (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__decorate */ .gn)([_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_20__/* .tuiPure */ .UM], TuiSvgComponent.prototype, "resolveName", null);
  TuiSvgComponent = (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT)), (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(1, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_13__/* .WINDOW */ .m9)), (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(2, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_ICONS_PATH */ .ki)), (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(3, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional)()), (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(3, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_SANITIZER */ .hm)), (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(4, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_taiga_ui_core_services__WEBPACK_IMPORTED_MODULE_15__/* .TuiSvgService */ .K5)), (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(5, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_16__/* .TuiStaticRequestService */ .Fr)), (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(6, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_angular_platform_browser__WEBPACK_IMPORTED_MODULE_17__.DomSanitizer)), (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(7, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef)), (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(8, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_13__/* .USER_AGENT */ .yZ))], TuiSvgComponent);
  return TuiSvgComponent;
})();
let TuiSvgModule = /*#__PURE__*/(() => {
  let TuiSvgModule = class TuiSvgModule {};
  TuiSvgModule.ɵfac = function TuiSvgModule_Factory(t) {
    return new (t || TuiSvgModule)();
  };
  TuiSvgModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
    type: TuiSvgModule
  });
  TuiSvgModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
    imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_0__.CommonModule, _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_18__/* .TuiLetModule */ .WD]]
  });
  return TuiSvgModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵsetNgModuleScope"](TuiSvgModule, {
    declarations: function () {
      return [TuiSvgComponent];
    },
    imports: function () {
      return [_angular_common__WEBPACK_IMPORTED_MODULE_0__.CommonModule, _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_18__/* .TuiLetModule */ .WD];
    },
    exports: function () {
      return [TuiSvgComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-svg.js.map

/***/ }),

/***/ 1144:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Q: () => (/* binding */ TuiWrapperComponent),
/* harmony export */   W: () => (/* binding */ TuiWrapperModule)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7582);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8096);
/* harmony import */ var _taiga_ui_core_providers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2130);
/* harmony import */ var _taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1587);








const _c0 = ["*"];
let TuiWrapperComponent = /*#__PURE__*/(() => {
  let TuiWrapperComponent = class TuiWrapperComponent {
    constructor(isMobile, mode$) {
      this.isMobile = isMobile;
      this.mode$ = mode$;
      this.disabled = false;
      this.readOnly = false;
      this.hovered = false;
      this.pressed = false;
      this.focused = false;
      this.invalid = false;
      this.appearance = '';
    }
    get computedInvalid() {
      return !this.disabled && !this.readOnly && this.invalid;
    }
    get computedFocused() {
      return this.focused && !this.disabled;
    }
    get interactiveState() {
      if (this.disabled) {
        return "disabled" /* Disabled */;
      }

      if (this.readOnly) {
        return "readonly" /* Readonly */;
      }

      if (this.pressed && !this.isMobile) {
        return "pressed" /* Pressed */;
      }

      if (this.hovered && !this.isMobile) {
        return "hovered" /* Hovered */;
      }

      return null;
    }
  };
  TuiWrapperComponent.ɵfac = function TuiWrapperComponent_Factory(t) {
    return new (t || TuiWrapperComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_1__/* .TUI_IS_MOBILE */ .fL), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_2__/* .TUI_MODE */ .Au));
  };
  TuiWrapperComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: TuiWrapperComponent,
    selectors: [["tui-wrapper"]],
    hostVars: 6,
    hostBindings: function TuiWrapperComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("$.data-mode.attr", function TuiWrapperComponent___data_mode_attr_HostBindingHandler() {
          return ctx.mode$;
        });
      }
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("data-appearance", ctx.appearance)("data-state", ctx.interactiveState);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("_invalid", ctx.computedInvalid)("_focused", ctx.computedFocused);
      }
    },
    inputs: {
      disabled: "disabled",
      readOnly: "readOnly",
      hovered: "hovered",
      pressed: "pressed",
      focused: "focused",
      invalid: "invalid",
      appearance: "appearance"
    },
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([_taiga_ui_core_providers__WEBPACK_IMPORTED_MODULE_3__/* .MODE_PROVIDER */ .CV])],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function TuiWrapperComponent_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    styles: ["[_nghost-%COMP%]{transition-property:color,background;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;position:relative;display:block;height:100%;width:100%;text-align:left;border-radius:inherit}[_nghost-%COMP%]:after{transition-property:box-shadow;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;content:'';position:absolute;top:0;left:0;right:0;bottom:0;border-radius:inherit;border:1px solid currentColor;pointer-events:none;color:transparent}._focused[_nghost-%COMP%]:after{border-width:2px;color:var(--tui-focus)}[data-state=disabled][_nghost-%COMP%]{pointer-events:none}"],
    changeDetection: 0
  });
  (0,tslib__WEBPACK_IMPORTED_MODULE_4__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)()], TuiWrapperComponent.prototype, "disabled", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_4__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)()], TuiWrapperComponent.prototype, "readOnly", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_4__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)()], TuiWrapperComponent.prototype, "hovered", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_4__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)()], TuiWrapperComponent.prototype, "pressed", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_4__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)()], TuiWrapperComponent.prototype, "focused", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_4__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)()], TuiWrapperComponent.prototype, "invalid", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_4__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('attr.data-appearance')], TuiWrapperComponent.prototype, "appearance", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_4__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._invalid')], TuiWrapperComponent.prototype, "computedInvalid", null);
  (0,tslib__WEBPACK_IMPORTED_MODULE_4__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._focused')], TuiWrapperComponent.prototype, "computedFocused", null);
  (0,tslib__WEBPACK_IMPORTED_MODULE_4__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('attr.data-state')], TuiWrapperComponent.prototype, "interactiveState", null);
  TuiWrapperComponent = (0,tslib__WEBPACK_IMPORTED_MODULE_4__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_4__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_1__/* .TUI_IS_MOBILE */ .fL)), (0,tslib__WEBPACK_IMPORTED_MODULE_4__/* .__param */ .fM)(1, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_2__/* .TUI_MODE */ .Au))], TuiWrapperComponent);
  return TuiWrapperComponent;
})();
let TuiWrapperModule = /*#__PURE__*/(() => {
  let TuiWrapperModule = class TuiWrapperModule {};
  TuiWrapperModule.ɵfac = function TuiWrapperModule_Factory(t) {
    return new (t || TuiWrapperModule)();
  };
  TuiWrapperModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
    type: TuiWrapperModule
  });
  TuiWrapperModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({});
  return TuiWrapperModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](TuiWrapperModule, {
    declarations: [TuiWrapperComponent],
    exports: [TuiWrapperComponent]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-wrapper.js.map

/***/ }),

/***/ 8269:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Nq: () => (/* binding */ tuiEditingKeys),
/* harmony export */   P8: () => (/* binding */ TUI_EXPAND_LOADED),
/* harmony export */   R3: () => (/* binding */ TUI_NON_DIGITS_REGEXP),
/* harmony export */   fe: () => (/* binding */ TUI_SCROLL_INTO_VIEW),
/* harmony export */   hW: () => (/* binding */ TUI_DIGIT_REGEXP),
/* harmony export */   jK: () => (/* binding */ DEFAULT_MARGIN),
/* harmony export */   oA: () => (/* binding */ DEFAULT_ICONS_PATH),
/* harmony export */   qT: () => (/* binding */ TUI_ICON_ERROR),
/* harmony export */   q_: () => (/* binding */ DEFAULT_MIN_HEIGHT),
/* harmony export */   v1: () => (/* binding */ MASK_CARET_TRAP),
/* harmony export */   yA: () => (/* binding */ DEFAULT_MAX_WIDTH),
/* harmony export */   ze: () => (/* binding */ DEFAULT_MAX_HEIGHT)
/* harmony export */ });
/* unused harmony exports MEDIA, TUI_DEFAULT_MARKER_HANDLER, TUI_LAST_PUNCTUATION_MARK_REGEXP, TUI_LATIN_AND_NUMBERS_REGEXP, TUI_LATIN_REGEXP, TUI_NON_DIGIT_REGEXP, VERSION */

const DEFAULT_MARGIN = 4;
const DEFAULT_MIN_HEIGHT = 80;
const DEFAULT_MAX_HEIGHT = 400;
const DEFAULT_MAX_WIDTH = 600;
const DEFAULT_ICONS_PATH = name => name.includes('.svg#') ? name : `#${name}`;
const TUI_DEFAULT_MARKER_HANDLER = () => EMPTY_ARRAY;
const tuiEditingKeys = ['Spacebar', 'Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'Left', 'Right', 'End', 'Home'];

/**
 * An event indicating that async data for expand has finished loading.
 * Dispatch to finish loading states for {@link TuiExpandComponent}.
 */
const TUI_EXPAND_LOADED = 'tui-expand-loaded';
/**
 * An event for scrolling an element into view within {@link TuiScrollbarComponent}.
 */
const TUI_SCROLL_INTO_VIEW = 'tui-scroll-into-view';
/**
 * An event indicating and error during icon loading in {@link TuiSvgComponent}.
 */
const TUI_ICON_ERROR = 'tui-icon-error';
const MASK_CARET_TRAP = '[]';

/**
 * Media constants are exact the same as css media breakpoints
 */
const MEDIA = {
  mobile: 320,
  tablet: 600,
  desktopSmall: 1024,
  desktopLarge: 1360
};
const TUI_DIGIT_REGEXP = /\d/;
const TUI_NON_DIGIT_REGEXP = /\D/;
const TUI_NON_DIGITS_REGEXP = /\D+/g;
const TUI_LAST_PUNCTUATION_MARK_REGEXP = /[.,\\/#!$%\\^&\\*;:{}=\\-_\`~()]$/;
const TUI_LATIN_REGEXP = /[A-z]/;
const TUI_LATIN_AND_NUMBERS_REGEXP = /[A-z|0-9]/;
const VERSION = '2.10.1';

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-constants.js.map

/***/ }),

/***/ 5452:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   w: () => (/* binding */ TuiModeDirective),
/* harmony export */   z: () => (/* binding */ TuiModeModule)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7582);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6480);




let TuiModeDirective = /*#__PURE__*/(() => {
  let TuiModeDirective = class TuiModeDirective extends _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_1__/* .TuiController */ .td {
    constructor() {
      super(...arguments);
      this.mode = null;
    }
  };
  TuiModeDirective.ɵfac = /*@__PURE__*/function () {
    let ɵTuiModeDirective_BaseFactory;
    return function TuiModeDirective_Factory(t) {
      return (ɵTuiModeDirective_BaseFactory || (ɵTuiModeDirective_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](TuiModeDirective)))(t || TuiModeDirective);
    };
  }();
  TuiModeDirective.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
    type: TuiModeDirective,
    selectors: [["", "tuiMode", ""]],
    inputs: {
      mode: ["tuiMode", "mode"]
    },
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]]
  });
  (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)('tuiMode')], TuiModeDirective.prototype, "mode", void 0);
  return TuiModeDirective;
})();
let TuiModeModule = /*#__PURE__*/(() => {
  let TuiModeModule = class TuiModeModule {};
  TuiModeModule.ɵfac = function TuiModeModule_Factory(t) {
    return new (t || TuiModeModule)();
  };
  TuiModeModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
    type: TuiModeModule
  });
  TuiModeModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({});
  return TuiModeModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](TuiModeModule, {
    declarations: [TuiModeDirective],
    exports: [TuiModeDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-directives-mode.js.map

/***/ }),

/***/ 2130:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CV: () => (/* binding */ MODE_PROVIDER),
/* harmony export */   my: () => (/* binding */ watchedControllerFactory)
/* harmony export */ });
/* unused harmony export modeFactory */
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(908);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6782);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9761);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8002);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _taiga_ui_core_directives_mode__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(5452);
/* harmony import */ var _taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1587);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9193);






function watchedControllerFactory(controller, changeDetectorRef, destroy$) {
  controller.change$.pipe((0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_1__/* .watch */ .YP)(changeDetectorRef), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__/* .takeUntil */ .R)(destroy$)).subscribe();
  return controller;
}
function modeFactory(mode, {
  nativeElement
}) {
  const mode$ = mode ? mode.change$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__/* .startWith */ .O)(null), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__/* .map */ .U)(() => mode.mode)) : rxjs__WEBPACK_IMPORTED_MODULE_5__/* .EMPTY */ .E;
  return nativeElement['$.data-mode.attr'] = mode$;
}
const MODE_PROVIDER = {
  provide: _taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_6__/* .TUI_MODE */ .Au,
  deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional(), _taiga_ui_core_directives_mode__WEBPACK_IMPORTED_MODULE_7__/* .TuiModeDirective */ .w], _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef],
  useFactory: modeFactory
};

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-providers.js.map

/***/ }),

/***/ 7941:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BN: () => (/* binding */ TuiHintService),
/* harmony export */   K5: () => (/* binding */ TuiSvgService),
/* harmony export */   Ok: () => (/* binding */ TuiRouterLinkActiveService)
/* harmony export */ });
/* unused harmony export TuiNightThemeService */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(7582);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6215);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8891);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(9193);
/* harmony import */ var _ng_web_apis_common__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(2579);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8002);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7519);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6782);
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2541);
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_router__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(908);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(3503);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(8939);
/* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(1211);
/* harmony import */ var _taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(1587);
/* harmony import */ var _taiga_ui_core_utils_dom__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(7766);











/**
 * Service for displaying hints/tooltips
 */





let TuiHintService = /*#__PURE__*/(() => {
  let TuiHintService = class TuiHintService extends rxjs__WEBPACK_IMPORTED_MODULE_2__/* .BehaviorSubject */ .X {
    constructor() {
      super([]);
      /**
       * TODO: v2.0
       * We need the following logic for desribedBy
       * move it into another service that can register hints and
       * manage it using TuiHintService inside
       */
      this.directives = [];
    }
    add(directive) {
      this.next(this.value.concat(directive));
    }
    remove(directive) {
      if (this.value.includes(directive)) {
        this.next(this.value.filter(hint => hint !== directive));
      }
    }
    register(directive) {
      this.directives = [...this.directives, directive];
    }
    unregister(directive) {
      this.remove(directive);
      this.directives = this.directives.filter(dir => dir !== directive);
    }
    showHintForId(id) {
      const directive = this.findDirectiveWithHintId(id);
      if (directive) {
        this.add(directive);
      }
    }
    hideHintForId(id) {
      const directive = this.findDirectiveWithHintId(id);
      if (directive) {
        this.remove(directive);
      }
    }
    findDirectiveWithHintId(id) {
      return this.directives.find(directive => directive.tuiHintId === id);
    }
  };
  TuiHintService.ɵfac = function TuiHintService_Factory(t) {
    return new (t || TuiHintService)();
  };
  TuiHintService.ɵprov = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
    factory: function TuiHintService_Factory() {
      return new TuiHintService();
    },
    token: TuiHintService,
    providedIn: "root"
  });

  // @dynamic
  return TuiHintService;
})();
let TuiNightThemeService = /*#__PURE__*/(/* unused pure expression or super */ null && ((() => {
  let TuiNightThemeService = class TuiNightThemeService extends Observable {
    constructor(windowRef) {
      const media = windowRef.matchMedia('(prefers-color-scheme: dark)');
      const media$ = fromEvent(media, 'change').pipe(startWith(null), map(() => media.matches), share());
      super(subscriber => media$.subscribe(subscriber));
    }
  };
  TuiNightThemeService.ɵfac = function TuiNightThemeService_Factory(t) {
    return new (t || TuiNightThemeService)(ɵngcc0.ɵɵinject(WINDOW));
  };
  TuiNightThemeService.ɵprov = ɵɵdefineInjectable({
    factory: function TuiNightThemeService_Factory() {
      return new TuiNightThemeService(ɵɵinject(WINDOW));
    },
    token: TuiNightThemeService,
    providedIn: "root"
  });
  TuiNightThemeService = __decorate([__param(0, Inject(WINDOW))], TuiNightThemeService);
  return TuiNightThemeService;
})()));
let TuiRouterLinkActiveService = /*#__PURE__*/(() => {
  let TuiRouterLinkActiveService = class TuiRouterLinkActiveService extends rxjs__WEBPACK_IMPORTED_MODULE_3__/* .Observable */ .y {
    constructor(routerLinkActive, ngZone, animationFrame$, destroy$) {
      const stream$ = routerLinkActive ? animationFrame$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__/* .map */ .U)(() => routerLinkActive.isActive), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__/* .distinctUntilChanged */ .x)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__/* .tuiZoneOptimized */ .Yr)(ngZone), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__/* .takeUntil */ .R)(destroy$)) : rxjs__WEBPACK_IMPORTED_MODULE_8__/* .EMPTY */ .E;
      super(subscriber => stream$.subscribe(subscriber));
    }
  };
  TuiRouterLinkActiveService.ɵfac = function TuiRouterLinkActiveService_Factory(t) {
    return new (t || TuiRouterLinkActiveService)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_router__WEBPACK_IMPORTED_MODULE_1__.RouterLinkActive, 8), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_9__/* .ANIMATION_FRAME */ .L1), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_10__/* .TuiDestroyService */ .a3));
  };
  TuiRouterLinkActiveService.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: TuiRouterLinkActiveService,
    factory: function (t) {
      return TuiRouterLinkActiveService.ɵfac(t);
    }
  });
  TuiRouterLinkActiveService = (0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional)()), (0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_angular_router__WEBPACK_IMPORTED_MODULE_1__.RouterLinkActive)), (0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__param */ .fM)(1, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone)), (0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__param */ .fM)(2, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_9__/* .ANIMATION_FRAME */ .L1)), (0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__param */ .fM)(3, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_10__/* .TuiDestroyService */ .a3))], TuiRouterLinkActiveService);

  /**
   * Service for reusing SVGs without inlining each instance
   */
  // @dynamic
  return TuiRouterLinkActiveService;
})();
let TuiSvgService = /*#__PURE__*/(() => {
  let TuiSvgService = class TuiSvgService {
    constructor(tuiSanitizer, sanitizer, icons) {
      this.tuiSanitizer = tuiSanitizer;
      this.sanitizer = sanitizer;
      this.items$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__/* .BehaviorSubject */ .X(new Map());
      this.originals = {};
      this.define(icons);
    }
    define(icons) {
      const {
        value
      } = this.items$;
      Object.keys(icons).forEach(key => {
        this.defineIcon(key, icons[key], value);
      });
      this.items$.next(value);
    }
    getOriginal(name) {
      return this.originals[name] || null;
    }
    defineIcon(name, src, map) {
      if (map.has(name)) {
        return;
      }
      const parsed = this.parseSrc(name, src);
      if (!parsed) {
        _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_12__/* .tuiAssert */ .z.assert(false, 'Unable to parse given SVG src');
        return;
      }
      map.set(name, parsed);
      this.originals = Object.assign(Object.assign({}, this.originals), {
        [name]: src
      });
    }
    parseSrc(name, src) {
      return this.sanitize((0,_taiga_ui_core_utils_dom__WEBPACK_IMPORTED_MODULE_13__/* .processIcon */ .c3)(src, name));
    }
    sanitize(src) {
      return this.sanitizer.bypassSecurityTrustHtml((this.tuiSanitizer ? this.tuiSanitizer.sanitize(_angular_core__WEBPACK_IMPORTED_MODULE_0__.SecurityContext.HTML, src) : this.sanitizer.sanitize(_angular_core__WEBPACK_IMPORTED_MODULE_0__.SecurityContext.HTML, src)) || '');
    }
  };
  TuiSvgService.ɵfac = function TuiSvgService_Factory(t) {
    return new (t || TuiSvgService)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_SANITIZER */ .hm, 8), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_platform_browser__WEBPACK_IMPORTED_MODULE_15__.DomSanitizer), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_ICONS */ .It));
  };
  TuiSvgService.ɵprov = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
    factory: function TuiSvgService_Factory() {
      return new TuiSvgService((0,_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_SANITIZER */ .hm, 8), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_platform_browser__WEBPACK_IMPORTED_MODULE_15__.DomSanitizer), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_ICONS */ .It));
    },
    token: TuiSvgService,
    providedIn: "root"
  });
  TuiSvgService = (0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional)()), (0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_SANITIZER */ .hm)), (0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__param */ .fM)(1, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_angular_platform_browser__WEBPACK_IMPORTED_MODULE_15__.DomSanitizer)), (0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__param */ .fM)(2, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_ICONS */ .It))], TuiSvgService);
  return TuiSvgService;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-services.js.map

/***/ }),

/***/ 1587:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $_: () => (/* binding */ TUI_SCROLL_REF),
/* harmony export */   Au: () => (/* binding */ TUI_MODE),
/* harmony export */   Cc: () => (/* binding */ TUI_DATA_LIST_ACCESSOR),
/* harmony export */   IQ: () => (/* binding */ TUI_OPTION_CONTENT),
/* harmony export */   It: () => (/* binding */ TUI_ICONS),
/* harmony export */   Jd: () => (/* binding */ TUI_DROPDOWN_DIRECTIVE),
/* harmony export */   N1: () => (/* binding */ TUI_DATA_LIST_HOST),
/* harmony export */   PH: () => (/* binding */ TUI_NOTHING_FOUND_MESSAGE),
/* harmony export */   Pw: () => (/* binding */ TUI_ANIMATION_OPTIONS),
/* harmony export */   U0: () => (/* binding */ TUI_CLOSE_WORD),
/* harmony export */   dx: () => (/* binding */ TUI_ANIMATIONS_DURATION),
/* harmony export */   hm: () => (/* binding */ TUI_SANITIZER),
/* harmony export */   jt: () => (/* binding */ TUI_TEXTFIELD_APPEARANCE),
/* harmony export */   ki: () => (/* binding */ TUI_ICONS_PATH),
/* harmony export */   sE: () => (/* binding */ TUI_VALUE_ACCESSOR),
/* harmony export */   uW: () => (/* binding */ TUI_ASSERT_ENABLED),
/* harmony export */   zP: () => (/* binding */ TUI_ELEMENT_REF)
/* harmony export */ });
/* unused harmony exports TUI_DEFAULT_ERROR_MESSAGE, TUI_DOCUMENT_OR_SHADOW_ROOT, TUI_MONTHS, TUI_SHORT_WEEK_DAYS, TUI_SPIN_TEXTS */
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _taiga_ui_i18n__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(121);
/* harmony import */ var _taiga_ui_core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6640);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8096);




const TUI_ANIMATIONS_DURATION = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('Duration of all Taiga UI animations in ms', {
  factory: () => 300
});
const TUI_ANIMATION_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('Options for Taiga UI animations', {
  factory: () => ({
    params: {
      duration: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(TUI_ANIMATIONS_DURATION)
    }
  })
});
const TUI_ASSERT_ENABLED = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('Flag to enable assertions across Taiga UI', {
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.isDevMode)()
});
const TUI_DATA_LIST_ACCESSOR = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('Accessor for options');
const TUI_DATA_LIST_HOST = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('DataList controller');
const TUI_DOCUMENT_OR_SHADOW_ROOT = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('Document or ShadowRoot');
const TUI_DROPDOWN_DIRECTIVE = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('Directive controlling TuiDropdownBoxComponent');
const TUI_ELEMENT_REF = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('ElementRef when you cannot use @Input for single time injection');
const TUI_MONTHS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('Localized months names', {
  factory: (0,_taiga_ui_i18n__WEBPACK_IMPORTED_MODULE_1__/* .extractI18n */ .H)('months')
});
const TUI_CLOSE_WORD = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(`i18n 'close' word`, {
  factory: (0,_taiga_ui_i18n__WEBPACK_IMPORTED_MODULE_1__/* .extractI18n */ .H)('close')
});
const TUI_NOTHING_FOUND_MESSAGE = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(`i18n 'Nothing found' message`, {
  factory: (0,_taiga_ui_i18n__WEBPACK_IMPORTED_MODULE_1__/* .extractI18n */ .H)('nothingFoundMessage')
});
const TUI_DEFAULT_ERROR_MESSAGE = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(`i18n of error message`, {
  factory: (0,_taiga_ui_i18n__WEBPACK_IMPORTED_MODULE_1__/* .extractI18n */ .H)('defaultErrorMessage')
});
const TUI_SPIN_TEXTS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('spin i18n texts', {
  factory: (0,_taiga_ui_i18n__WEBPACK_IMPORTED_MODULE_1__/* .extractI18n */ .H)('spinTexts')
});
const TUI_SHORT_WEEK_DAYS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('calendars i18n texts', {
  factory: (0,_taiga_ui_i18n__WEBPACK_IMPORTED_MODULE_1__/* .extractI18n */ .H)('shortWeekDays')
});
const TUI_ICONS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('A key/value dictionary of icon names and src to be defined with TuiSvgService', {
  factory: () => ({})
});
const TUI_ICONS_PATH = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('A handler to retrieve USE id for icon by name', {
  factory: () => (0,_taiga_ui_core_utils__WEBPACK_IMPORTED_MODULE_2__/* .iconsPathFactory */ .Dj)('assets/taiga-ui/icons/')
});
const TUI_MODE = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('Mode stream for private providers');
const TUI_OPTION_CONTENT = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('Content for tuiOption component');
const TUI_SANITIZER = _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_3__/* .TUI_SANITIZER */ .hm;
const TUI_SCROLL_REF = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('Scrollable container');
const TUI_TEXTFIELD_APPEARANCE = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('Appearance for inputs', {
  factory: () => "textfield" /* Textfield */
});

const TUI_VALUE_ACCESSOR = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('Buffer token to pass NG_VALUE_ACCESSOR to a different Injector');

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-tokens.js.map

/***/ }),

/***/ 7766:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c3: () => (/* binding */ processIcon),
/* harmony export */   rn: () => (/* binding */ checkFixedPosition),
/* harmony export */   zP: () => (/* binding */ getScreenWidth)
/* harmony export */ });
/* unused harmony exports areCssVarsSupported, getSafeAreaSize */


/**
 * TODO: remove "any" in new TS version; https://github.com/ng-web-apis/common/pull/6
 */
function areCssVarsSupported(cssRef, userAgent) {
  return cssRef.supports('(--a: 0)') && !isEdgeOlderThan(17, userAgent);
}
function checkFixedPosition(element) {
  if (!element || typeof getComputedStyle === 'undefined') {
    return false;
  }
  const style = getComputedStyle(element);
  return style.getPropertyValue('position') === 'fixed' || checkFixedPosition(element.parentElement);
}

/**
 * Calculates size of safe area on mobile devices (status bars)
 *
 * ATTENTION: Only use in browser environment
 */
function getSafeAreaSize() {
  if (!CSS.supports('padding-top: env(safe-area-inset-top)')) {
    return 0;
  }
  const div = document.createElement('div');
  div.style.paddingTop = 'env(safe-area-inset-top)';
  document.body.appendChild(div);
  const safeAreaSize = parseInt(window.getComputedStyle(div).paddingTop, 10) || 0;
  document.body.removeChild(div);
  return safeAreaSize;
}
function getScreenWidth(documentRef) {
  return Math.max(documentRef.documentElement.clientWidth, documentRef.defaultView ? documentRef.defaultView.innerWidth : 0);
}
const WIDTH_SEARCH = 'width="';
const HEIGHT_SEARCH = 'height="';
const START = '<svg';
function processIcon(source, name) {
  if (source.includes(`id="${name}"`)) {
    return source;
  }
  const src = source.substring(source.indexOf(START));
  const attributes = src.substring(0, src.indexOf('>'));
  if (!attributes || !attributes.includes(WIDTH_SEARCH) || !attributes.includes(HEIGHT_SEARCH)) {
    return src.replace(START, `<svg xmlns="http://www.w3.org/2000/svg"><g id="${name}" xmlns="http://www.w3.org/2000/svg"><svg`) + '</g></svg>';
  }
  const indexOfWidth = attributes.indexOf(WIDTH_SEARCH);
  const indexOfHeight = attributes.indexOf(HEIGHT_SEARCH);
  const widthOffset = indexOfWidth + WIDTH_SEARCH.length;
  const heightOffset = indexOfHeight + HEIGHT_SEARCH.length;
  const widthString = attributes.substring(widthOffset, attributes.indexOf('"', widthOffset));
  const heightString = attributes.substring(heightOffset, attributes.indexOf('"', heightOffset));
  if (!heightString || !widthString || widthString.includes('%') || heightString.includes('%')) {
    return src.replace(START, `<svg id="${name}"`);
  }
  const width = parseInt(widthString, 10);
  const height = parseInt(heightString, 10);
  const transform = `translate(-${width / 2},-${height / 2})`;
  return `<g id="${name}" xmlns="http://www.w3.org/2000/svg" transform="${transform}"><svg x="50%" y="50%">${src}</svg></g>`;
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-utils-dom.js.map

/***/ }),

/***/ 6640:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bb: () => (/* binding */ sizeBigger),
/* harmony export */   Dj: () => (/* binding */ iconsPathFactory),
/* harmony export */   Rb: () => (/* binding */ isEditingKey),
/* harmony export */   tQ: () => (/* binding */ getPadding),
/* harmony export */   zL: () => (/* binding */ isPresumedHTMLString)
/* harmony export */ });
/* harmony import */ var _taiga_ui_core_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8269);

const PADDING_SMALL = 12;
const PADDING_LARGE = 16;
const ITEM_SIZE = 24;
const CONTENT_SIZE = 40;
function getPadding(sizeBig, hasIcon, hasCleaner = false, hasTooltip = false, hasContent = false) {
  let padding = sizeBig ? PADDING_LARGE : PADDING_SMALL;
  if (hasIcon) {
    padding += ITEM_SIZE;
  }
  if (hasCleaner) {
    padding += ITEM_SIZE;
  }
  if (hasTooltip) {
    padding += ITEM_SIZE;
  }
  if (hasContent) {
    padding += CONTENT_SIZE;
  }
  return padding;
}
function iconsPathFactory(staticPath) {
  const base = staticPath[staticPath.length - 1] === '/' ? staticPath : staticPath + '/';
  return name => {
    if (name.startsWith('tuiIcon')) {
      return `${base}${name}.svg#${name}`;
    }
    return (0,_taiga_ui_core_constants__WEBPACK_IMPORTED_MODULE_0__/* .DEFAULT_ICONS_PATH */ .oA)(name);
  };
}

/**
 * Check if pressed key is interactive in terms of input field
 */
function isEditingKey(key) {
  return key.length === 1 || _taiga_ui_core_constants__WEBPACK_IMPORTED_MODULE_0__/* .tuiEditingKeys */ .Nq.indexOf(key) !== -1;
}
function isPresumedHTMLString(candidate) {
  const trimmed = candidate.trim();
  return trimmed.startsWith('<') && trimmed.endsWith('>');
}
const SIZES = ['xs', 's', 'm', 'l', 'xl', 'xxl'];
/**
 * Compares size constants to determine if first size is bigger than the second
 *
 * @param size size that we need to compare
 * @param biggerThanSize size to compare with, 's' by default
 */
function sizeBigger(size, biggerThanSize = 's') {
  return SIZES.indexOf(size) > SIZES.indexOf(biggerThanSize);
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-utils-miscellaneous.js.map

/***/ }),

/***/ 121:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  H: () => (/* binding */ extractI18n)
});

// UNUSED EXPORTS: TUI_LANGUAGE

// EXTERNAL MODULE: consume shared module (default) @angular/core@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/core/fesm2015/core.js)
var core_js_ = __webpack_require__(8312);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js
var map = __webpack_require__(8002);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/i18n/fesm2015/taiga-ui-i18n-languages-english.js
const TUI_ENGLISH_LANGUAGE_CORE = {
  months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
  close: 'Close',
  nothingFoundMessage: 'Nothing found',
  defaultErrorMessage: 'Value is invalid',
  spinTexts: ['Previous', 'Next'],
  shortWeekDays: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
};
const TUI_ENGLISH_LANGUAGE_KIT = {
  cancel: 'Cancel',
  done: 'Done',
  more: 'More',
  otherDate: 'Other date...',
  mobileCalendarTexts: ['Choose day', 'Choose range'],
  range: ['from', 'to'],
  countTexts: ['Plus', 'Minus'],
  time: {
    'HH:MM': 'HH:MM',
    'HH:MM:SS': 'HH:MM:SS',
    'HH:MM:SS.MSS': 'HH:MM:SS.MSS'
  },
  digitalInformationUnits: ['B', 'KB', 'MB'],
  passwordTexts: ['Show password', 'Hide password'],
  copyTexts: ['Copy', 'Copied'],
  shortCalendarMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  pagination: ['Previous page', 'Next page'],
  fileTexts: {
    loadingError: 'Loading error',
    preview: 'Preview',
    remove: 'Remove'
  },
  inputFileTexts: {
    defaultLabelSingle: 'or drag\u00A0it\u00A0here',
    defaultLabelMultiple: 'or drag\u00A0them\u00A0here',
    defaultLinkSingle: 'Choose a file',
    defaultLinkMultiple: 'Choose files',
    maxSizeRejectionReason: 'File exceeds size ',
    formatRejectionReason: 'Wrong file format',
    drop: 'Drop file here',
    dropMultiple: 'Drop files here'
  }
};
const TUI_ENGLISH_LANGUAGE_ADDON_COMMERCE = {
  cardNumber: ['Number', 'Card number'],
  cardExpiry: ['Expiry', 'Card expiry']
};
const TUI_ENGLISH_LANGUAGE_ADDON_EDITOR = {
  colorSelectorModeNames: ['Solid color', 'Gradient'],
  toolbarTools: {
    undo: 'Undo',
    redo: 'Redo',
    font: 'Font',
    fontStyle: 'Font style',
    fontSize: 'Font size',
    bold: 'Bold',
    italic: 'Italic',
    underline: 'Underline',
    strikeThrough: 'Strike through',
    justify: 'Justify',
    justifyLeft: 'Justify left',
    justifyCenter: 'Justify center',
    justifyRight: 'Justify right',
    justifyFull: 'Justify full',
    list: 'List',
    indent: 'Indent',
    outdent: 'Outdent',
    unorderedList: 'Unordered list',
    orderedList: 'Ordered list',
    quote: 'Quote',
    foreColor: 'Color',
    backColor: 'Background color',
    hiliteColor: 'Highlight color',
    clear: 'Clear',
    link: 'Link',
    attach: 'Attach file',
    tex: 'Insert TeX',
    code: 'Code',
    image: 'Insert image',
    insertHorizontalRule: 'Insert horizontal rule',
    superscript: 'Superscript',
    subscript: 'Subscript'
  }
};
const TUI_ENGLISH_LANGUAGE_ADDON_TABLE = {
  showHideText: 'Show/Hide',
  paginationTexts: {
    pages: 'Pages',
    linesPerPage: 'Lines per page',
    of: 'of'
  }
};
const TUI_ENGLISH_LANGUAGE = Object.assign(Object.assign(Object.assign(Object.assign({}, TUI_ENGLISH_LANGUAGE_CORE), TUI_ENGLISH_LANGUAGE_KIT), TUI_ENGLISH_LANGUAGE_ADDON_TABLE), TUI_ENGLISH_LANGUAGE_ADDON_COMMERCE);

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-i18n-languages-english.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/of.js
var of = __webpack_require__(5917);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/i18n/fesm2015/taiga-ui-i18n-tools.js




const TUI_LANGUAGE = new core_js_.InjectionToken(`Language for Taiga UI libraries i18n`, {
  factory: () => (0,of.of)(TUI_ENGLISH_LANGUAGE)
});
function extractI18n(key) {
  return () => (0,core_js_.inject)(TUI_LANGUAGE).pipe((0,map/* map */.U)(lang => lang[key]));
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-i18n-tools.js.map

/***/ }),

/***/ 9570:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Al: () => (/* binding */ PolymorpheusComponent),
/* harmony export */   GL: () => (/* binding */ PolymorpheusTemplate),
/* harmony export */   r1: () => (/* binding */ PolymorpheusOutletComponent),
/* harmony export */   wq: () => (/* binding */ PolymorpheusModule),
/* harmony export */   yf: () => (/* binding */ POLYMORPHEUS_CONTEXT)
/* harmony export */ });
/* unused harmony exports ɵa, ɵb */
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3008);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_1__);



/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Use this token to access context within your components when
 * instantiating them through {\@link PolymorpheusOutletComponent}
 * @type {?}
 */


const _c0 = ["polymorpheus-outlet", ""];
function PolymorpheusOutletComponent_ng_container_0_ng_template_2_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainer"](0, 6);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpipe"](1, "injector");
  }
  if (rf & 2) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);
    const _r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](1);
    const ctx_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngComponentOutlet", ctx_r5.content.component)("ngComponentOutletInjector", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpipeBind2"](1, 2, ctx_r5.content, _r2.context));
  }
}
function PolymorpheusOutletComponent_ng_container_0_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, PolymorpheusOutletComponent_ng_container_0_ng_template_2_ng_container_0_Template, 2, 5, "ng-container", 5);
  }
  if (rf & 2) {
    const ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r4.guard(ctx_r4.content));
  }
}
function PolymorpheusOutletComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0, 2, 3);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, PolymorpheusOutletComponent_ng_container_0_ng_template_2_Template, 1, 1, "ng-template", null, 4, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const _r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](3);
    const ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", ctx_r0.getTemplate(ctx_r0.content, _r3))("ngTemplateOutletContext", ctx_r0.context);
  }
}
function PolymorpheusOutletComponent_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const ctx_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx_r6.primitive);
  }
}
const _c1 = function (a0) {
  return {
    $implicit: a0
  };
};
function PolymorpheusOutletComponent_ng_container_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainer"](0, 9);
  }
  if (rf & 2) {
    const ctx_r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", ctx_r8.template)("ngTemplateOutletContext", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction1"](2, _c1, ctx_r8.primitive));
  }
}
function PolymorpheusOutletComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, PolymorpheusOutletComponent_ng_container_1_ng_container_1_Template, 2, 1, "ng-container", 7);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, PolymorpheusOutletComponent_ng_container_1_ng_template_2_Template, 1, 4, "ng-template", null, 8, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const _r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](3);
    const ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !ctx_r1.template)("ngIfElse", _r7);
  }
}
const POLYMORPHEUS_CONTEXT = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('Context from polymorpheus-outlet');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Wrapper class for a component that will be used as content for {\@link PolymorpheusOutletComponent}
 *
 * @param component — an Angular component to be dynamically created
 * @param injector — optional {\@link Injector} for lazy loaded module case
 * @template T, C
 */
class PolymorpheusComponent {
  /**
   * @param {?} component
   * @param {?=} injector
   */
  constructor(component, injector = null) {
    this.component = component;
    this.injector = injector;
  }
  /**
   * @param {?} injector
   * @param {?} context
   * @return {?}
   */
  createInjector(injector, context) {
    return _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector.create({
      parent: this.injector || injector,
      providers: [{
        provide: POLYMORPHEUS_CONTEXT,
        useValue: context
      }]
    });
  }
}
if (false) {}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * ng-template wrapper directive also stores {\@link ChangeDetectorRef} to properly handle change detection.
 * @template C
 */
let PolymorpheusTemplate = /*#__PURE__*/(() => {
  class PolymorpheusTemplate {
    /**
     * @param {?} template
     * @param {?} changeDetectorRef
     */
    constructor(template, changeDetectorRef) {
      this.template = template;
      this.changeDetectorRef = changeDetectorRef;
      this.polymorpheus = '';
    }
    /**
     * @return {?}
     */
    check() {
      this.changeDetectorRef.markForCheck();
    }
    /**
     * @template T
     * @param {?} _dir
     * @param {?} _ctx
     * @return {?}
     */
    static ngTemplateContextGuard(_dir, _ctx) {
      return true;
    }
  }
  PolymorpheusTemplate.ɵfac = function PolymorpheusTemplate_Factory(t) {
    return new (t || PolymorpheusTemplate)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef, 2), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef));
  };
  PolymorpheusTemplate.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
    type: PolymorpheusTemplate,
    selectors: [["ng-template", "polymorpheus", ""]],
    inputs: {
      polymorpheus: "polymorpheus"
    },
    exportAs: ["polymorpheus"]
  });
  /** @nocollapse */
  return PolymorpheusTemplate;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
if (false) {}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Outlet instantiating {\@link PolymorpheusContent} with given context
 * @template C
 */
let PolymorpheusOutletComponent = /*#__PURE__*/(() => {
  class PolymorpheusOutletComponent {
    constructor() {
      this.template = null;
      this.content = null;
    }
    /**
     * @return {?}
     */
    get primitive() {
      if (!this.content || this.isAdvanced(this.content)) {
        return '';
      }
      return typeof this.content === 'function' ? this.content(this.context) : this.content;
    }
    /**
     * @param {?} content
     * @return {?}
     */
    isAdvanced(content) {
      return isTemplate(content) || isComponent(content);
    }
    /**
     * @param {?} content
     * @param {?} componentTmp
     * @return {?}
     */
    getTemplate(content, componentTmp) {
      if (isComponent(content)) {
        return componentTmp;
      }
      return isDirective(content) ? content.template : content;
    }
    /**
     * @param {?} content
     * @return {?}
     */
    guard(content) {
      return isComponent(content);
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    ngOnChanges({
      content,
      context
    }) {
      // TODO: Keep an eye on private field, name can change
      /** @type {?} */
      const componentRef = /** @type {?} */!content && context && this.outlet && this.outlet['_componentRef'];
      if (componentRef) {
        componentRef.injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef).markForCheck();
      }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
      if (isDirective(this.content)) {
        this.content.check();
      }
    }
  }
  PolymorpheusOutletComponent.ɵfac = function PolymorpheusOutletComponent_Factory(t) {
    return new (t || PolymorpheusOutletComponent)();
  };
  PolymorpheusOutletComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: PolymorpheusOutletComponent,
    selectors: [["", "polymorpheus-outlet", ""]],
    contentQueries: function PolymorpheusOutletComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef, 5);
      }
      if (rf & 2) {
        let _t;
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.template = _t.first);
      }
    },
    viewQuery: function PolymorpheusOutletComponent_Query(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgComponentOutlet, 5);
      }
      if (rf & 2) {
        let _t;
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.outlet = _t.first);
      }
    },
    inputs: {
      content: "content",
      context: "context"
    },
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
    attrs: _c0,
    decls: 2,
    vars: 2,
    consts: [["context", "", 3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], [4, "ngIf"], ["context", "", 3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["mutableContext", "context"], ["component", ""], [3, "ngComponentOutlet", "ngComponentOutletInjector", 4, "ngIf"], [3, "ngComponentOutlet", "ngComponentOutletInjector"], [4, "ngIf", "ngIfElse"], ["child", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function PolymorpheusOutletComponent_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, PolymorpheusOutletComponent_ng_container_0_Template, 4, 2, "ng-container", 0);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, PolymorpheusOutletComponent_ng_container_1_Template, 4, 2, "ng-container", 1);
      }
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.isAdvanced(ctx.content));
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.primitive);
      }
    },
    directives: function () {
      return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, ContextDirective, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgTemplateOutlet, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgComponentOutlet];
    },
    pipes: function () {
      return [InjectorPipe];
    },
    encapsulation: 2,
    changeDetection: 0
  });
  return PolymorpheusOutletComponent;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
if (false) {}
/**
 * @template C
 * @param {?} content
 * @return {?}
 */
function isDirective(content) {
  return content instanceof PolymorpheusTemplate;
}
/**
 * @template C
 * @param {?} content
 * @return {?}
 */
function isComponent(content) {
  return content instanceof PolymorpheusComponent;
}
/**
 * @template C
 * @param {?} content
 * @return {?}
 */
function isTemplate(content) {
  return isDirective(content) || content instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Helper directive, extracting first {\@link EmbeddedViewRef} context if it's present
 * @template C
 */
let ContextDirective = /*#__PURE__*/(() => {
  class ContextDirective {
    /**
     * @param {?} viewContainerRef
     */
    constructor(viewContainerRef) {
      this.viewContainerRef = viewContainerRef;
    }
    /**
     * @return {?}
     */
    get context() {
      /** @type {?} */
      const viewRef = /** @type {?} */this.viewContainerRef.get(0);
      return viewRef && viewRef.context;
    }
  }
  ContextDirective.ɵfac = function ContextDirective_Factory(t) {
    return new (t || ContextDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef));
  };
  ContextDirective.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
    type: ContextDirective,
    selectors: [["", "context", ""]],
    exportAs: ["context"]
  });
  /** @nocollapse */
  return ContextDirective;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
if (false) {}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Internal use {\@link Pipe} to create {\@link Injector}
 * only when either content or context change
 * @template C
 */
let InjectorPipe = /*#__PURE__*/(() => {
  class InjectorPipe {
    /**
     * @param {?} injector
     */
    constructor(injector) {
      this.injector = injector;
    }
    /**
     * @param {?} content
     * @param {?} context
     * @return {?}
     */
    transform(content, context) {
      return content.createInjector(this.injector, context);
    }
  }
  InjectorPipe.ɵfac = function InjectorPipe_Factory(t) {
    return new (t || InjectorPipe)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector, 16));
  };
  InjectorPipe.ɵpipe = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefinePipe"]({
    name: "injector",
    type: InjectorPipe,
    pure: true
  });
  /** @nocollapse */
  return InjectorPipe;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
if (false) {}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
let PolymorpheusModule = /*#__PURE__*/(() => {
  class PolymorpheusModule {}
  PolymorpheusModule.ɵfac = function PolymorpheusModule_Factory(t) {
    return new (t || PolymorpheusModule)();
  };
  PolymorpheusModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
    type: PolymorpheusModule
  });
  PolymorpheusModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
    imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule]]
  });
  return PolymorpheusModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](PolymorpheusModule, {
    declarations: function () {
      return [PolymorpheusOutletComponent, PolymorpheusTemplate, ContextDirective, InjectorPipe];
    },
    imports: function () {
      return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule];
    },
    exports: function () {
      return [PolymorpheusOutletComponent, PolymorpheusTemplate];
    }
  });
})();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */



//# sourceMappingURL=tinkoff-ng-polymorpheus.js.map

/***/ }),

/***/ 1120:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
var core_1 = __webpack_require__(8312);
var forms_1 = __webpack_require__(3738);
var platform_browser_1 = __webpack_require__(1211);
var textMaskCore_1 = __webpack_require__(2775);
var ɵngcc0 = __webpack_require__(8312);
var TextMaskConfig = /** @class */function () {
  function TextMaskConfig() {}
  return TextMaskConfig;
}();
__webpack_unused_export__ = TextMaskConfig;
exports.wR = {
  provide: forms_1.NG_VALUE_ACCESSOR,
  useExisting: core_1.forwardRef(function () {
    return MaskedInputDirective;
  }),
  multi: true
};
/**
 * We must check whether the agent is Android because composition events
 * behave differently between iOS and Android.
 */
function _isAndroid() {
  var userAgent = platform_browser_1.ɵgetDOM() ? platform_browser_1.ɵgetDOM().getUserAgent() : '';
  return /android (\d+)/.test(userAgent.toLowerCase());
}
var MaskedInputDirective = /** @class */function () {
  function MaskedInputDirective(_renderer, _elementRef, _compositionMode) {
    this._renderer = _renderer;
    this._elementRef = _elementRef;
    this._compositionMode = _compositionMode;
    this.textMaskConfig = {
      mask: [],
      guide: true,
      placeholderChar: '_',
      pipe: undefined,
      keepCharPositions: false
    };
    this.onChange = function (_) {};
    this.onTouched = function () {};
    /** Whether the user is creating a composition string (IME events). */
    this._composing = false;
    if (this._compositionMode == null) {
      this._compositionMode = !_isAndroid();
    }
  }
  MaskedInputDirective.prototype.ngOnChanges = function (changes) {
    this._setupMask(true);
    if (this.textMaskInputElement !== undefined) {
      this.textMaskInputElement.update(this.inputElement.value);
    }
  };
  MaskedInputDirective.prototype.writeValue = function (value) {
    this._setupMask();
    // set the initial value for cases where the mask is disabled
    var normalizedValue = value == null ? '' : value;
    this._renderer.setProperty(this.inputElement, 'value', normalizedValue);
    if (this.textMaskInputElement !== undefined) {
      this.textMaskInputElement.update(value);
    }
  };
  MaskedInputDirective.prototype.registerOnChange = function (fn) {
    this.onChange = fn;
  };
  MaskedInputDirective.prototype.registerOnTouched = function (fn) {
    this.onTouched = fn;
  };
  MaskedInputDirective.prototype.setDisabledState = function (isDisabled) {
    this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
  };
  MaskedInputDirective.prototype._handleInput = function (value) {
    if (!this._compositionMode || this._compositionMode && !this._composing) {
      this._setupMask();
      if (this.textMaskInputElement !== undefined) {
        this.textMaskInputElement.update(value);
        // get the updated value
        value = this.inputElement.value;
        this.onChange(value);
      }
    }
  };
  MaskedInputDirective.prototype._setupMask = function (create) {
    if (create === void 0) {
      create = false;
    }
    if (!this.inputElement) {
      if (this._elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {
        // `textMask` directive is used directly on an input element
        this.inputElement = this._elementRef.nativeElement;
      } else {
        // `textMask` directive is used on an abstracted input element, `md-input-container`, etc
        this.inputElement = this._elementRef.nativeElement.getElementsByTagName('INPUT')[0];
      }
    }
    if (this.inputElement && create) {
      this.textMaskInputElement = textMaskCore_1.createTextMaskInputElement(Object.assign({
        inputElement: this.inputElement
      }, this.textMaskConfig));
    }
  };
  MaskedInputDirective.prototype._compositionStart = function () {
    this._composing = true;
  };
  MaskedInputDirective.prototype._compositionEnd = function (value) {
    this._composing = false;
    this._compositionMode && this._handleInput(value);
  };
  /** @nocollapse */
  MaskedInputDirective.ctorParameters = function () {
    return [{
      type: core_1.Renderer2
    }, {
      type: core_1.ElementRef
    }, {
      type: undefined,
      decorators: [{
        type: core_1.Optional
      }, {
        type: core_1.Inject,
        args: [forms_1.COMPOSITION_BUFFER_MODE]
      }]
    }];
  };
  MaskedInputDirective.propDecorators = {
    'textMaskConfig': [{
      type: core_1.Input,
      args: ['textMask']
    }]
  };
  MaskedInputDirective.ɵfac = function MaskedInputDirective_Factory(t) {
    return new (t || MaskedInputDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(forms_1.COMPOSITION_BUFFER_MODE, 8));
  };
  MaskedInputDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({
    type: MaskedInputDirective,
    selectors: [["", "textMask", ""]],
    hostBindings: function MaskedInputDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵngcc0.ɵɵlistener("input", function MaskedInputDirective_input_HostBindingHandler($event) {
          return ctx._handleInput($event.target.value);
        })("blur", function MaskedInputDirective_blur_HostBindingHandler() {
          return ctx.onTouched();
        })("compositionstart", function MaskedInputDirective_compositionstart_HostBindingHandler() {
          return ctx._compositionStart();
        })("compositionend", function MaskedInputDirective_compositionend_HostBindingHandler($event) {
          return ctx._compositionEnd($event.target.value);
        });
      }
    },
    inputs: {
      textMaskConfig: ["textMask", "textMaskConfig"]
    },
    exportAs: ["textMask"],
    features: [ɵngcc0.ɵɵProvidersFeature([exports.wR]), ɵngcc0.ɵɵNgOnChangesFeature]
  });
  (function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
  })();
  return MaskedInputDirective;
}();
exports.hd = MaskedInputDirective;
var TextMaskModule = /** @class */function () {
  function TextMaskModule() {}
  /** @nocollapse */
  TextMaskModule.ctorParameters = function () {
    return [];
  };
  TextMaskModule.ɵfac = function TextMaskModule_Factory(t) {
    return new (t || TextMaskModule)();
  };
  TextMaskModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({
    type: TextMaskModule
  });
  TextMaskModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});
  (function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
  })();
  (function () {
    (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TextMaskModule, {
      declarations: [MaskedInputDirective],
      exports: [MaskedInputDirective]
    });
  })();
  return TextMaskModule;
}();
exports.QA = TextMaskModule;
var textMaskCore_2 = __webpack_require__(2775);
__webpack_unused_export__ = textMaskCore_2.conformToMask;

//# sourceMappingURL=angular2TextMask.js.map

/***/ }),

/***/ 7841:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  rN: () => (/* binding */ HIGHLIGHT_OPTIONS),
  y$: () => (/* binding */ Highlight),
  _l: () => (/* binding */ HighlightModule)
});

// UNUSED EXPORTS: HighlightJS, HighlightLoader, ɵ0

// EXTERNAL MODULE: consume shared module (default) @angular/core@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/core/fesm2015/core.js)
var core_js_ = __webpack_require__(8312);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/BehaviorSubject.js
var BehaviorSubject = __webpack_require__(6215);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/empty.js
var empty = __webpack_require__(9193);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/throwError.js
var throwError = __webpack_require__(205);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/fromArray.js
var fromArray = __webpack_require__(6693);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isArray.js
var isArray = __webpack_require__(9796);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscriber.js
var Subscriber = __webpack_require__(7393);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/symbol/iterator.js
var iterator = __webpack_require__(377);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/innerSubscribe.js
var innerSubscribe = __webpack_require__(5345);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/observable/zip.js





function zip(...observables) {
  const resultSelector = observables[observables.length - 1];
  if (typeof resultSelector === 'function') {
    observables.pop();
  }
  return (0,fromArray/* fromArray */.n)(observables, undefined).lift(new ZipOperator(resultSelector));
}
class ZipOperator {
  constructor(resultSelector) {
    this.resultSelector = resultSelector;
  }
  call(subscriber, source) {
    return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
  }
}
class ZipSubscriber extends Subscriber/* Subscriber */.L {
  constructor(destination, resultSelector, values = Object.create(null)) {
    super(destination);
    this.resultSelector = resultSelector;
    this.iterators = [];
    this.active = 0;
    this.resultSelector = typeof resultSelector === 'function' ? resultSelector : undefined;
  }
  _next(value) {
    const iterators = this.iterators;
    if ((0,isArray/* isArray */.k)(value)) {
      iterators.push(new StaticArrayIterator(value));
    } else if (typeof value[iterator/* iterator */.hZ] === 'function') {
      iterators.push(new StaticIterator(value[iterator/* iterator */.hZ]()));
    } else {
      iterators.push(new ZipBufferIterator(this.destination, this, value));
    }
  }
  _complete() {
    const iterators = this.iterators;
    const len = iterators.length;
    this.unsubscribe();
    if (len === 0) {
      this.destination.complete();
      return;
    }
    this.active = len;
    for (let i = 0; i < len; i++) {
      let iterator = iterators[i];
      if (iterator.stillUnsubscribed) {
        const destination = this.destination;
        destination.add(iterator.subscribe());
      } else {
        this.active--;
      }
    }
  }
  notifyInactive() {
    this.active--;
    if (this.active === 0) {
      this.destination.complete();
    }
  }
  checkIterators() {
    const iterators = this.iterators;
    const len = iterators.length;
    const destination = this.destination;
    for (let i = 0; i < len; i++) {
      let iterator = iterators[i];
      if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
        return;
      }
    }
    let shouldComplete = false;
    const args = [];
    for (let i = 0; i < len; i++) {
      let iterator = iterators[i];
      let result = iterator.next();
      if (iterator.hasCompleted()) {
        shouldComplete = true;
      }
      if (result.done) {
        destination.complete();
        return;
      }
      args.push(result.value);
    }
    if (this.resultSelector) {
      this._tryresultSelector(args);
    } else {
      destination.next(args);
    }
    if (shouldComplete) {
      destination.complete();
    }
  }
  _tryresultSelector(args) {
    let result;
    try {
      result = this.resultSelector.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  }
}
class StaticIterator {
  constructor(iterator) {
    this.iterator = iterator;
    this.nextResult = iterator.next();
  }
  hasValue() {
    return true;
  }
  next() {
    const result = this.nextResult;
    this.nextResult = this.iterator.next();
    return result;
  }
  hasCompleted() {
    const nextResult = this.nextResult;
    return Boolean(nextResult && nextResult.done);
  }
}
class StaticArrayIterator {
  constructor(array) {
    this.array = array;
    this.index = 0;
    this.length = 0;
    this.length = array.length;
  }
  [iterator/* iterator */.hZ]() {
    return this;
  }
  next(value) {
    const i = this.index++;
    const array = this.array;
    return i < this.length ? {
      value: array[i],
      done: false
    } : {
      value: null,
      done: true
    };
  }
  hasValue() {
    return this.array.length > this.index;
  }
  hasCompleted() {
    return this.array.length === this.index;
  }
}
class ZipBufferIterator extends innerSubscribe/* SimpleOuterSubscriber */.Ds {
  constructor(destination, parent, observable) {
    super(destination);
    this.parent = parent;
    this.observable = observable;
    this.stillUnsubscribed = true;
    this.buffer = [];
    this.isComplete = false;
  }
  [iterator/* iterator */.hZ]() {
    return this;
  }
  next() {
    const buffer = this.buffer;
    if (buffer.length === 0 && this.isComplete) {
      return {
        value: null,
        done: true
      };
    } else {
      return {
        value: buffer.shift(),
        done: false
      };
    }
  }
  hasValue() {
    return this.buffer.length > 0;
  }
  hasCompleted() {
    return this.buffer.length === 0 && this.isComplete;
  }
  notifyComplete() {
    if (this.buffer.length > 0) {
      this.isComplete = true;
      this.parent.notifyInactive();
    } else {
      this.destination.complete();
    }
  }
  notifyNext(innerValue) {
    this.buffer.push(innerValue);
    this.parent.checkIterators();
  }
  subscribe() {
    return (0,innerSubscribe/* innerSubscribe */.ft)(this.observable, new innerSubscribe/* SimpleInnerSubscriber */.IY(this));
  }
}
//# sourceMappingURL=zip.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/from.js + 6 modules
var from = __webpack_require__(4402);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/animationFrame.js + 2 modules
var animationFrame = __webpack_require__(1927);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/filter.js
var filter = __webpack_require__(5435);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js
var map = __webpack_require__(8002);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/take.js
var take = __webpack_require__(5257);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/switchMap.js
var switchMap = __webpack_require__(3190);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/tap.js
var tap = __webpack_require__(8307);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/catchError.js
var catchError = __webpack_require__(5304);
// EXTERNAL MODULE: consume shared module (default) @angular/common@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/common/fesm2015/common.js)
var common_js_ = __webpack_require__(3008);
// EXTERNAL MODULE: ./node_modules/@angular/platform-browser/fesm2015/platform-browser.js
var platform_browser = __webpack_require__(1211);
;// CONCATENATED MODULE: ./node_modules/ngx-highlightjs/fesm2015/ngx-highlightjs.js







const HIGHLIGHT_OPTIONS = new core_js_.InjectionToken('HIGHLIGHT_OPTIONS');

// @dynamic
let HighlightLoader = /*#__PURE__*/(() => {
  class HighlightLoader {
    constructor(doc, platformId, _options) {
      this._options = _options;
      // Stream that emits when hljs library is loaded and ready to use
      this._ready = new BehaviorSubject/* BehaviorSubject */.X(null);
      this.ready = this._ready.asObservable().pipe((0,filter/* filter */.h)(hljs => !!hljs), (0,map/* map */.U)(hljs => hljs), (0,take/* take */.q)(1));
      // Check if hljs is already available
      if ((0,common_js_.isPlatformBrowser)(platformId) && doc.defaultView.hljs) {
        this._ready.next(doc.defaultView.hljs);
      } else {
        // Load hljs library
        this._loadLibrary().pipe((0,switchMap/* switchMap */.w)(hljs => {
          if (this._options && this._options.lineNumbersLoader) {
            // Make hljs available on window object (required for the line numbers library)
            doc.defaultView.hljs = hljs;
            // Load line numbers library
            return this.loadLineNumbers().pipe((0,tap/* tap */.b)(() => this._ready.next(hljs)));
          } else {
            this._ready.next(hljs);
            return empty/* EMPTY */.E;
          }
        }), (0,catchError/* catchError */.K)(e => {
          console.error('[HLJS] ', e);
          return empty/* EMPTY */.E;
        })).subscribe();
      }
    }
    /**
     * Lazy-Load highlight.js library
     */
    _loadLibrary() {
      if (this._options) {
        if (this._options.fullLibraryLoader && this._options.coreLibraryLoader) {
          return (0,throwError/* throwError */._)('The full library and the core library were imported, only one of them should be imported!');
        }
        if (this._options.fullLibraryLoader && this._options.languages) {
          return (0,throwError/* throwError */._)('The highlighting languages were imported they are not needed!');
        }
        if (this._options.coreLibraryLoader && !this._options.languages) {
          return (0,throwError/* throwError */._)('The highlighting languages were not imported!');
        }
        if (!this._options.coreLibraryLoader && this._options.languages) {
          return (0,throwError/* throwError */._)('The core library was not imported!');
        }
        if (this._options.fullLibraryLoader) {
          return this.loadFullLibrary();
        }
        if (this._options.coreLibraryLoader && this._options.languages && Object.keys(this._options.languages).length) {
          return this.loadCoreLibrary().pipe((0,switchMap/* switchMap */.w)(hljs => this._loadLanguages(hljs)));
        }
      }
      return (0,throwError/* throwError */._)('Highlight.js library was not imported!');
    }
    /**
     * Lazy-load highlight.js languages
     */
    _loadLanguages(hljs) {
      const languages = Object.entries(this._options.languages).map(([langName, langLoader]) => importModule(langLoader()).pipe((0,tap/* tap */.b)(langFunc => hljs.registerLanguage(langName, langFunc))));
      return zip(...languages).pipe((0,map/* map */.U)(() => hljs));
    }
    /**
     * Import highlight.js core library
     */
    loadCoreLibrary() {
      return importModule(this._options.coreLibraryLoader());
    }
    /**
     * Import highlight.js library with all languages
     */
    loadFullLibrary() {
      return importModule(this._options.fullLibraryLoader());
    }
    /**
     * Import line numbers library
     */
    loadLineNumbers() {
      return importModule(this._options.lineNumbersLoader());
    }
  }
  HighlightLoader.ɵfac = function HighlightLoader_Factory(t) {
    return new (t || HighlightLoader)(core_js_["ɵɵinject"](common_js_.DOCUMENT), core_js_["ɵɵinject"](core_js_.PLATFORM_ID), core_js_["ɵɵinject"](HIGHLIGHT_OPTIONS, 8));
  };
  HighlightLoader.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function HighlightLoader_Factory() {
      return new HighlightLoader((0,core_js_["ɵɵinject"])(common_js_.DOCUMENT), (0,core_js_["ɵɵinject"])(core_js_.PLATFORM_ID), (0,core_js_["ɵɵinject"])(HIGHLIGHT_OPTIONS, 8));
    },
    token: HighlightLoader,
    providedIn: "root"
  });
  return HighlightLoader;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * Map loader response to module object
 */
const importModule = moduleLoader => {
  return (0,from/* from */.D)(moduleLoader).pipe((0,filter/* filter */.h)(module => !!module && !!module.default), (0,map/* map */.U)(module => module.default));
};
const ɵ0 = (/* unused pure expression or super */ null && (importModule));
let HighlightJS = /*#__PURE__*/(() => {
  class HighlightJS {
    constructor(_loader, options) {
      this._loader = _loader;
      this._hljs = null;
      // Load highlight.js library on init
      _loader.ready.pipe().subscribe(hljs => {
        this._hljs = hljs;
        if (options && options.config) {
          // Set global config if present
          hljs.configure(options.config);
          if (hljs.listLanguages().length < 1) {
            console.error('[HighlightJS]: No languages were registered!');
          }
        }
      });
    }
    // A reference for hljs library
    get hljs() {
      return this._hljs;
    }
    /**
     * Core highlighting function.
     * @param name Accepts a language name, or an alias
     * @param value A string with the code to highlight.
     * @param ignore_illegals When present and evaluates to a true value, forces highlighting to finish
     * even in case of detecting illegal syntax for the language instead of throwing an exception.
     * @param continuation An optional mode stack representing unfinished parsing.
     * When present, the function will restart parsing from this state instead of initializing a new one
     */
    highlight(name, value, ignore_illegals, continuation) {
      return this._loader.ready.pipe((0,map/* map */.U)(hljs => hljs.highlight(name, value, ignore_illegals, continuation)));
    }
    /**
     * Highlighting with language detection.
     * @param value Accepts a string with the code to highlight
     * @param languageSubset An optional array of language names and aliases restricting detection to only those languages.
     * The subset can also be set with configure, but the local parameter overrides the option if set.
     */
    highlightAuto(value, languageSubset) {
      return this._loader.ready.pipe((0,map/* map */.U)(hljs => hljs.highlightAuto(value, languageSubset)));
    }
    /**
     * Post-processing of the highlighted markup.
     * Currently consists of replacing indentation TAB characters and using <br> tags instead of new-line characters.
     * Options are set globally with configure.
     * @param value Accepts a string with the highlighted markup
     */
    fixMarkup(value) {
      return this._loader.ready.pipe((0,map/* map */.U)(hljs => hljs.fixMarkup(value)));
    }
    /**
     * Applies highlighting to a DOM node containing code.
     * The function uses language detection by default but you can specify the language in the class attribute of the DOM node.
     * See the class reference for all available language names and aliases.
     * @param block The element to apply highlight on.
     */
    highlightBlock(block) {
      return this._loader.ready.pipe((0,map/* map */.U)(hljs => hljs.highlightBlock(block)));
    }
    /**
     * Configures global options:
     * @param config HighlightJs configuration argument
     */
    configure(config) {
      return this._loader.ready.pipe((0,map/* map */.U)(hljs => hljs.configure(config)));
    }
    /**
     * Applies highlighting to all <pre><code>..</code></pre> blocks on a page.
     */
    initHighlighting() {
      return this._loader.ready.pipe((0,map/* map */.U)(hljs => hljs.initHighlighting()));
    }
    /**
     * Adds new language to the library under the specified name. Used mostly internally.
     * @param name A string with the name of the language being registered
     * @param language A function that returns an object which represents the language definition.
     * The function is passed the hljs object to be able to use common regular expressions defined within it.
     */
    registerLanguage(name, language) {
      return this._loader.ready.pipe((0,tap/* tap */.b)(hljs => hljs.registerLanguage(name, language)));
    }
    /**
     * @return The languages names list.
     */
    listLanguages() {
      return this._loader.ready.pipe((0,map/* map */.U)(hljs => hljs.listLanguages()));
    }
    /**
     * Looks up a language by name or alias.
     * @param name Language name
     * @return The language object if found, undefined otherwise.
     */
    getLanguage(name) {
      return this._loader.ready.pipe((0,map/* map */.U)(hljs => hljs.getLanguage(name)));
    }
    /**
     * Display line numbers
     * @param el Code element
     */
    lineNumbersBlock(el) {
      return this._loader.ready.pipe((0,filter/* filter */.h)(hljs => !!hljs.lineNumbersBlock), (0,tap/* tap */.b)(hljs => hljs.lineNumbersBlock(el)));
    }
  }
  HighlightJS.ɵfac = function HighlightJS_Factory(t) {
    return new (t || HighlightJS)(core_js_["ɵɵinject"](HighlightLoader), core_js_["ɵɵinject"](HIGHLIGHT_OPTIONS, 8));
  };
  HighlightJS.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function HighlightJS_Factory() {
      return new HighlightJS((0,core_js_["ɵɵinject"])(HighlightLoader), (0,core_js_["ɵɵinject"])(HIGHLIGHT_OPTIONS, 8));
    },
    token: HighlightJS,
    providedIn: "root"
  });
  return HighlightJS;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
let Highlight = /*#__PURE__*/(() => {
  class Highlight {
    constructor(el, _hljs, _sanitizer, _options) {
      this._hljs = _hljs;
      this._sanitizer = _sanitizer;
      this._options = _options;
      // Stream that emits when code string is highlighted
      this.highlighted = new core_js_.EventEmitter();
      this._nativeElement = el.nativeElement;
    }
    ngOnChanges(changes) {
      if (this.code && changes.code && typeof changes.code.currentValue !== 'undefined' && changes.code.currentValue !== changes.code.previousValue) {
        this.highlightElement(this.code, this.languages);
      }
    }
    /**
     * Highlighting with language detection and fix markup.
     * @param code Accepts a string with the code to highlight
     * @param languages An optional array of language names and aliases restricting detection to only those languages.
     * The subset can also be set with configure, but the local parameter overrides the option if set.
     */
    highlightElement(code, languages) {
      // Set code text before highlighting
      this.setTextContent(code);
      this._hljs.highlightAuto(code, languages).subscribe(res => {
        // Set highlighted code
        this.setInnerHTML(res.value);
        // Check if user want to show line numbers
        if (this.lineNumbers && this._options && this._options.lineNumbersLoader) {
          this.addLineNumbers();
        }
        // Forward highlight response to the highlighted output
        this.highlighted.emit(res);
      });
    }
    addLineNumbers() {
      // Clean up line numbers observer
      this.destroyLineNumbersObserver();
      animationFrame/* animationFrameScheduler */.Z.schedule(() => {
        // Add line numbers
        this._hljs.lineNumbersBlock(this._nativeElement).subscribe();
        // If lines count is 1, the line numbers library will not add numbers
        // Observe changes to add 'hljs-line-numbers' class only when line numbers is added to the code element
        this._lineNumbersObs = new MutationObserver(() => {
          if (this._nativeElement.firstElementChild && this._nativeElement.firstElementChild.tagName.toUpperCase() === 'TABLE') {
            this._nativeElement.classList.add('hljs-line-numbers');
          }
          this.destroyLineNumbersObserver();
        });
        this._lineNumbersObs.observe(this._nativeElement, {
          childList: true
        });
      });
    }
    destroyLineNumbersObserver() {
      if (this._lineNumbersObs) {
        this._lineNumbersObs.disconnect();
        this._lineNumbersObs = null;
      }
    }
    setTextContent(content) {
      animationFrame/* animationFrameScheduler */.Z.schedule(() => this._nativeElement.textContent = content);
    }
    setInnerHTML(content) {
      animationFrame/* animationFrameScheduler */.Z.schedule(() => this._nativeElement.innerHTML = this._sanitizer.sanitize(core_js_.SecurityContext.HTML, content) || '');
    }
  }
  Highlight.ɵfac = function Highlight_Factory(t) {
    return new (t || Highlight)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](HighlightJS), core_js_["ɵɵdirectiveInject"](platform_browser.DomSanitizer), core_js_["ɵɵdirectiveInject"](HIGHLIGHT_OPTIONS, 8));
  };
  Highlight.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: Highlight,
    selectors: [["", "highlight", ""]],
    hostVars: 2,
    hostBindings: function Highlight_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("hljs", true);
      }
    },
    inputs: {
      code: ["highlight", "code"],
      languages: "languages",
      lineNumbers: "lineNumbers"
    },
    outputs: {
      highlighted: "highlighted"
    },
    features: [core_js_["ɵɵNgOnChangesFeature"]]
  });
  return Highlight;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
let HighlightModule = /*#__PURE__*/(() => {
  class HighlightModule {}
  HighlightModule.ɵfac = function HighlightModule_Factory(t) {
    return new (t || HighlightModule)();
  };
  HighlightModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: HighlightModule
  });
  HighlightModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return HighlightModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](HighlightModule, {
    declarations: [Highlight],
    exports: [Highlight]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=ngx-highlightjs.js.map

/***/ }),

/***/ 3098:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ Notification)
/* harmony export */ });
/* unused harmony export NotificationKind */
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9193);
/* harmony import */ var _observable_of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5917);
/* harmony import */ var _observable_throwError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(205);



var NotificationKind = /*#__PURE__*/(/* unused pure expression or super */ null && ((() => {
  (function (NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
  })(NotificationKind || (NotificationKind = {}));
  return NotificationKind;
})()));
class Notification {
  constructor(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === 'N';
  }
  observe(observer) {
    switch (this.kind) {
      case 'N':
        return observer.next && observer.next(this.value);
      case 'E':
        return observer.error && observer.error(this.error);
      case 'C':
        return observer.complete && observer.complete();
    }
  }
  do(next, error, complete) {
    const kind = this.kind;
    switch (kind) {
      case 'N':
        return next && next(this.value);
      case 'E':
        return error && error(this.error);
      case 'C':
        return complete && complete();
    }
  }
  accept(nextOrObserver, error, complete) {
    if (nextOrObserver && typeof nextOrObserver.next === 'function') {
      return this.observe(nextOrObserver);
    } else {
      return this.do(nextOrObserver, error, complete);
    }
  }
  toObservable() {
    const kind = this.kind;
    switch (kind) {
      case 'N':
        return (0,_observable_of__WEBPACK_IMPORTED_MODULE_0__.of)(this.value);
      case 'E':
        return (0,_observable_throwError__WEBPACK_IMPORTED_MODULE_1__/* .throwError */ ._)(this.error);
      case 'C':
        return (0,_observable_empty__WEBPACK_IMPORTED_MODULE_2__/* .empty */ .c)();
    }
    throw new Error('unexpected notification kind value');
  }
  static createNext(value) {
    if (typeof value !== 'undefined') {
      return new Notification('N', value);
    }
    return Notification.undefinedValueNotification;
  }
  static createError(err) {
    return new Notification('E', undefined, err);
  }
  static createComplete() {
    return Notification.completeNotification;
  }
}
Notification.completeNotification = new Notification('C');
Notification.undefinedValueNotification = new Notification('N', undefined);
//# sourceMappingURL=Notification.js.map

/***/ }),

/***/ 2298:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  t: () => (/* binding */ ReplaySubject)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subject.js
var Subject = __webpack_require__(9765);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js + 1 modules
var AsyncAction = __webpack_require__(6465);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/QueueAction.js

class QueueAction extends AsyncAction/* AsyncAction */.o {
  constructor(scheduler, work) {
    super(scheduler, work);
    this.scheduler = scheduler;
    this.work = work;
  }
  schedule(state, delay = 0) {
    if (delay > 0) {
      return super.schedule(state, delay);
    }
    this.delay = delay;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  }
  execute(state, delay) {
    return delay > 0 || this.closed ? super.execute(state, delay) : this._execute(state, delay);
  }
  requestAsyncId(scheduler, id, delay = 0) {
    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
      return super.requestAsyncId(scheduler, id, delay);
    }
    return scheduler.flush(this);
  }
}
//# sourceMappingURL=QueueAction.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js + 1 modules
var AsyncScheduler = __webpack_require__(6102);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/QueueScheduler.js

class QueueScheduler extends AsyncScheduler/* AsyncScheduler */.v {}
//# sourceMappingURL=QueueScheduler.js.map
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/queue.js


const queueScheduler = new QueueScheduler(QueueAction);
const queue = queueScheduler;
//# sourceMappingURL=queue.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscription.js + 1 modules
var Subscription = __webpack_require__(5319);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscriber.js
var Subscriber = __webpack_require__(7393);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Notification.js
var Notification = __webpack_require__(3098);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/observeOn.js


function observeOn(scheduler, delay = 0) {
  return function observeOnOperatorFunction(source) {
    return source.lift(new ObserveOnOperator(scheduler, delay));
  };
}
class ObserveOnOperator {
  constructor(scheduler, delay = 0) {
    this.scheduler = scheduler;
    this.delay = delay;
  }
  call(subscriber, source) {
    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
  }
}
class ObserveOnSubscriber extends Subscriber/* Subscriber */.L {
  constructor(destination, scheduler, delay = 0) {
    super(destination);
    this.scheduler = scheduler;
    this.delay = delay;
  }
  static dispatch(arg) {
    const {
      notification,
      destination
    } = arg;
    notification.observe(destination);
    this.unsubscribe();
  }
  scheduleMessage(notification) {
    const destination = this.destination;
    destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
  }
  _next(value) {
    this.scheduleMessage(Notification/* Notification */.P.createNext(value));
  }
  _error(err) {
    this.scheduleMessage(Notification/* Notification */.P.createError(err));
    this.unsubscribe();
  }
  _complete() {
    this.scheduleMessage(Notification/* Notification */.P.createComplete());
    this.unsubscribe();
  }
}
class ObserveOnMessage {
  constructor(notification, destination) {
    this.notification = notification;
    this.destination = destination;
  }
}
//# sourceMappingURL=observeOn.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = __webpack_require__(7971);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/SubjectSubscription.js
var SubjectSubscription = __webpack_require__(8858);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/ReplaySubject.js






class ReplaySubject extends Subject/* Subject */.xQ {
  constructor(bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY, scheduler) {
    super();
    this.scheduler = scheduler;
    this._events = [];
    this._infiniteTimeWindow = false;
    this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
    this._windowTime = windowTime < 1 ? 1 : windowTime;
    if (windowTime === Number.POSITIVE_INFINITY) {
      this._infiniteTimeWindow = true;
      this.next = this.nextInfiniteTimeWindow;
    } else {
      this.next = this.nextTimeWindow;
    }
  }
  nextInfiniteTimeWindow(value) {
    if (!this.isStopped) {
      const _events = this._events;
      _events.push(value);
      if (_events.length > this._bufferSize) {
        _events.shift();
      }
    }
    super.next(value);
  }
  nextTimeWindow(value) {
    if (!this.isStopped) {
      this._events.push(new ReplayEvent(this._getNow(), value));
      this._trimBufferThenGetEvents();
    }
    super.next(value);
  }
  _subscribe(subscriber) {
    const _infiniteTimeWindow = this._infiniteTimeWindow;
    const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
    const scheduler = this.scheduler;
    const len = _events.length;
    let subscription;
    if (this.closed) {
      throw new ObjectUnsubscribedError/* ObjectUnsubscribedError */.N();
    } else if (this.isStopped || this.hasError) {
      subscription = Subscription/* Subscription */.w.EMPTY;
    } else {
      this.observers.push(subscriber);
      subscription = new SubjectSubscription/* SubjectSubscription */.W(this, subscriber);
    }
    if (scheduler) {
      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
    }
    if (_infiniteTimeWindow) {
      for (let i = 0; i < len && !subscriber.closed; i++) {
        subscriber.next(_events[i]);
      }
    } else {
      for (let i = 0; i < len && !subscriber.closed; i++) {
        subscriber.next(_events[i].value);
      }
    }
    if (this.hasError) {
      subscriber.error(this.thrownError);
    } else if (this.isStopped) {
      subscriber.complete();
    }
    return subscription;
  }
  _getNow() {
    return (this.scheduler || queue).now();
  }
  _trimBufferThenGetEvents() {
    const now = this._getNow();
    const _bufferSize = this._bufferSize;
    const _windowTime = this._windowTime;
    const _events = this._events;
    const eventsCount = _events.length;
    let spliceCount = 0;
    while (spliceCount < eventsCount) {
      if (now - _events[spliceCount].time < _windowTime) {
        break;
      }
      spliceCount++;
    }
    if (eventsCount > _bufferSize) {
      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
    }
    if (spliceCount > 0) {
      _events.splice(0, spliceCount);
    }
    return _events;
  }
}
class ReplayEvent {
  constructor(time, value) {
    this.time = time;
    this.value = value;
  }
}
//# sourceMappingURL=ReplaySubject.js.map

/***/ }),

/***/ 2759:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ fromEvent)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8891);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9796);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9105);
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8002);




const toString = (() => Object.prototype.toString)();
function fromEvent(target, eventName, options, resultSelector) {
  if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__/* .isFunction */ .m)(options)) {
    resultSelector = options;
    options = undefined;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe((0,_operators_map__WEBPACK_IMPORTED_MODULE_1__/* .map */ .U)(args => (0,_util_isArray__WEBPACK_IMPORTED_MODULE_2__/* .isArray */ .k)(args) ? resultSelector(...args) : resultSelector(args)));
  }
  return new _Observable__WEBPACK_IMPORTED_MODULE_3__/* .Observable */ .y(subscriber => {
    function handler(e) {
      if (arguments.length > 1) {
        subscriber.next(Array.prototype.slice.call(arguments));
      } else {
        subscriber.next(e);
      }
    }
    setupSubscription(target, eventName, handler, subscriber, options);
  });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
  let unsubscribe;
  if (isEventTarget(sourceObj)) {
    const source = sourceObj;
    sourceObj.addEventListener(eventName, handler, options);
    unsubscribe = () => source.removeEventListener(eventName, handler, options);
  } else if (isJQueryStyleEventEmitter(sourceObj)) {
    const source = sourceObj;
    sourceObj.on(eventName, handler);
    unsubscribe = () => source.off(eventName, handler);
  } else if (isNodeStyleEventEmitter(sourceObj)) {
    const source = sourceObj;
    sourceObj.addListener(eventName, handler);
    unsubscribe = () => source.removeListener(eventName, handler);
  } else if (sourceObj && sourceObj.length) {
    for (let i = 0, len = sourceObj.length; i < len; i++) {
      setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
    }
  } else {
    throw new TypeError('Invalid event target');
  }
  subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isEventTarget(sourceObj) {
  return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
//# sourceMappingURL=fromEvent.js.map

/***/ }),

/***/ 945:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F: () => (/* binding */ interval)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8891);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3637);
/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6561);



function interval(period = 0, scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__/* .async */ .P) {
  if (!(0,_util_isNumeric__WEBPACK_IMPORTED_MODULE_1__/* .isNumeric */ .k)(period) || period < 0) {
    period = 0;
  }
  if (!scheduler || typeof scheduler.schedule !== 'function') {
    scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__/* .async */ .P;
  }
  return new _Observable__WEBPACK_IMPORTED_MODULE_2__/* .Observable */ .y(subscriber => {
    subscriber.add(scheduler.schedule(dispatch, period, {
      subscriber,
      counter: 0,
      period
    }));
    return subscriber;
  });
}
function dispatch(state) {
  const {
    subscriber,
    counter,
    period
  } = state;
  subscriber.next(counter);
  this.schedule({
    subscriber,
    counter: counter + 1,
    period
  }, period);
}
//# sourceMappingURL=interval.js.map

/***/ }),

/***/ 205:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _: () => (/* binding */ throwError)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8891);

function throwError(error, scheduler) {
  if (!scheduler) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__/* .Observable */ .y(subscriber => subscriber.error(error));
  } else {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__/* .Observable */ .y(subscriber => scheduler.schedule(dispatch, 0, {
      error,
      subscriber
    }));
  }
}
function dispatch({
  error,
  subscriber
}) {
  subscriber.error(error);
}
//# sourceMappingURL=throwError.js.map

/***/ }),

/***/ 6797:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   H: () => (/* binding */ timer)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8891);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3637);
/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6561);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4869);




function timer(dueTime = 0, periodOrScheduler, scheduler) {
  let period = -1;
  if ((0,_util_isNumeric__WEBPACK_IMPORTED_MODULE_0__/* .isNumeric */ .k)(periodOrScheduler)) {
    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
  } else if ((0,_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__/* .isScheduler */ .K)(periodOrScheduler)) {
    scheduler = periodOrScheduler;
  }
  if (!(0,_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__/* .isScheduler */ .K)(scheduler)) {
    scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_2__/* .async */ .P;
  }
  return new _Observable__WEBPACK_IMPORTED_MODULE_3__/* .Observable */ .y(subscriber => {
    const due = (0,_util_isNumeric__WEBPACK_IMPORTED_MODULE_0__/* .isNumeric */ .k)(dueTime) ? dueTime : +dueTime - scheduler.now();
    return scheduler.schedule(dispatch, due, {
      index: 0,
      period,
      subscriber
    });
  });
}
function dispatch(state) {
  const {
    index,
    period,
    subscriber
  } = state;
  subscriber.next(index);
  if (subscriber.closed) {
    return;
  } else if (period === -1) {
    return subscriber.complete();
  }
  state.index = index + 1;
  this.schedule(state, period);
}
//# sourceMappingURL=timer.js.map

/***/ }),

/***/ 4395:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   b: () => (/* binding */ debounceTime)
/* harmony export */ });
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7393);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3637);


function debounceTime(dueTime, scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__/* .async */ .P) {
  return source => source.lift(new DebounceTimeOperator(dueTime, scheduler));
}
class DebounceTimeOperator {
  constructor(dueTime, scheduler) {
    this.dueTime = dueTime;
    this.scheduler = scheduler;
  }
  call(subscriber, source) {
    return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
  }
}
class DebounceTimeSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_1__/* .Subscriber */ .L {
  constructor(destination, dueTime, scheduler) {
    super(destination);
    this.dueTime = dueTime;
    this.scheduler = scheduler;
    this.debouncedSubscription = null;
    this.lastValue = null;
    this.hasValue = false;
  }
  _next(value) {
    this.clearDebounce();
    this.lastValue = value;
    this.hasValue = true;
    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
  }
  _complete() {
    this.debouncedNext();
    this.destination.complete();
  }
  debouncedNext() {
    this.clearDebounce();
    if (this.hasValue) {
      const {
        lastValue
      } = this;
      this.lastValue = null;
      this.hasValue = false;
      this.destination.next(lastValue);
    }
  }
  clearDebounce() {
    const debouncedSubscription = this.debouncedSubscription;
    if (debouncedSubscription !== null) {
      this.remove(debouncedSubscription);
      debouncedSubscription.unsubscribe();
      this.debouncedSubscription = null;
    }
  }
}
function dispatchNext(subscriber) {
  subscriber.debouncedNext();
}
//# sourceMappingURL=debounceTime.js.map

/***/ }),

/***/ 1289:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  g: () => (/* binding */ delay)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/async.js
var scheduler_async = __webpack_require__(3637);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/util/isDate.js
function isDate(value) {
  return value instanceof Date && !isNaN(+value);
}
//# sourceMappingURL=isDate.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscriber.js
var Subscriber = __webpack_require__(7393);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Notification.js
var Notification = __webpack_require__(3098);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/delay.js




function delay(delay, scheduler = scheduler_async/* async */.P) {
  const absoluteDelay = isDate(delay);
  const delayFor = absoluteDelay ? +delay - scheduler.now() : Math.abs(delay);
  return source => source.lift(new DelayOperator(delayFor, scheduler));
}
class DelayOperator {
  constructor(delay, scheduler) {
    this.delay = delay;
    this.scheduler = scheduler;
  }
  call(subscriber, source) {
    return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
  }
}
class DelaySubscriber extends Subscriber/* Subscriber */.L {
  constructor(destination, delay, scheduler) {
    super(destination);
    this.delay = delay;
    this.scheduler = scheduler;
    this.queue = [];
    this.active = false;
    this.errored = false;
  }
  static dispatch(state) {
    const source = state.source;
    const queue = source.queue;
    const scheduler = state.scheduler;
    const destination = state.destination;
    while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {
      queue.shift().notification.observe(destination);
    }
    if (queue.length > 0) {
      const delay = Math.max(0, queue[0].time - scheduler.now());
      this.schedule(state, delay);
    } else {
      this.unsubscribe();
      source.active = false;
    }
  }
  _schedule(scheduler) {
    this.active = true;
    const destination = this.destination;
    destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
      source: this,
      destination: this.destination,
      scheduler: scheduler
    }));
  }
  scheduleNotification(notification) {
    if (this.errored === true) {
      return;
    }
    const scheduler = this.scheduler;
    const message = new DelayMessage(scheduler.now() + this.delay, notification);
    this.queue.push(message);
    if (this.active === false) {
      this._schedule(scheduler);
    }
  }
  _next(value) {
    this.scheduleNotification(Notification/* Notification */.P.createNext(value));
  }
  _error(err) {
    this.errored = true;
    this.queue = [];
    this.destination.error(err);
    this.unsubscribe();
  }
  _complete() {
    this.scheduleNotification(Notification/* Notification */.P.createComplete());
    this.unsubscribe();
  }
}
class DelayMessage {
  constructor(time, notification) {
    this.time = time;
    this.notification = notification;
  }
}
//# sourceMappingURL=delay.js.map

/***/ }),

/***/ 7519:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   x: () => (/* binding */ distinctUntilChanged)
/* harmony export */ });
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7393);

function distinctUntilChanged(compare, keySelector) {
  return source => source.lift(new DistinctUntilChangedOperator(compare, keySelector));
}
class DistinctUntilChangedOperator {
  constructor(compare, keySelector) {
    this.compare = compare;
    this.keySelector = keySelector;
  }
  call(subscriber, source) {
    return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
  }
}
class DistinctUntilChangedSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__/* .Subscriber */ .L {
  constructor(destination, compare, keySelector) {
    super(destination);
    this.keySelector = keySelector;
    this.hasKey = false;
    if (typeof compare === 'function') {
      this.compare = compare;
    }
  }
  compare(x, y) {
    return x === y;
  }
  _next(value) {
    let key;
    try {
      const {
        keySelector
      } = this;
      key = keySelector ? keySelector(value) : value;
    } catch (err) {
      return this.destination.error(err);
    }
    let result = false;
    if (this.hasKey) {
      try {
        const {
          compare
        } = this;
        result = compare(this.key, key);
      } catch (err) {
        return this.destination.error(err);
      }
    } else {
      this.hasKey = true;
    }
    if (!result) {
      this.key = key;
      this.destination.next(value);
    }
  }
}
//# sourceMappingURL=distinctUntilChanged.js.map

/***/ }),

/***/ 6736:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   h: () => (/* binding */ mapTo)
/* harmony export */ });
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7393);

function mapTo(value) {
  return source => source.lift(new MapToOperator(value));
}
class MapToOperator {
  constructor(value) {
    this.value = value;
  }
  call(subscriber, source) {
    return source.subscribe(new MapToSubscriber(subscriber, this.value));
  }
}
class MapToSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__/* .Subscriber */ .L {
  constructor(destination, value) {
    super(destination);
    this.value = value;
  }
  _next(x) {
    this.destination.next(this.value);
  }
}
//# sourceMappingURL=mapTo.js.map

/***/ }),

/***/ 9328:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ pairwise)
/* harmony export */ });
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7393);

function pairwise() {
  return source => source.lift(new PairwiseOperator());
}
class PairwiseOperator {
  call(subscriber, source) {
    return source.subscribe(new PairwiseSubscriber(subscriber));
  }
}
class PairwiseSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__/* .Subscriber */ .L {
  constructor(destination) {
    super(destination);
    this.hasPrev = false;
  }
  _next(value) {
    let pair;
    if (this.hasPrev) {
      pair = [this.prev, value];
    } else {
      this.hasPrev = true;
    }
    this.prev = value;
    if (pair) {
      this.destination.next(pair);
    }
  }
}
//# sourceMappingURL=pairwise.js.map

/***/ }),

/***/ 9196:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   r: () => (/* binding */ repeat)
/* harmony export */ });
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7393);
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9193);


function repeat(count = -1) {
  return source => {
    if (count === 0) {
      return (0,_observable_empty__WEBPACK_IMPORTED_MODULE_0__/* .empty */ .c)();
    } else if (count < 0) {
      return source.lift(new RepeatOperator(-1, source));
    } else {
      return source.lift(new RepeatOperator(count - 1, source));
    }
  };
}
class RepeatOperator {
  constructor(count, source) {
    this.count = count;
    this.source = source;
  }
  call(subscriber, source) {
    return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
  }
}
class RepeatSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_1__/* .Subscriber */ .L {
  constructor(destination, count, source) {
    super(destination);
    this.count = count;
    this.source = source;
  }
  complete() {
    if (!this.isStopped) {
      const {
        source,
        count
      } = this;
      if (count === 0) {
        return super.complete();
      } else if (count > -1) {
        this.count = count - 1;
      }
      source.subscribe(this._unsubscribeAndRecycle());
    }
  }
}
//# sourceMappingURL=repeat.js.map

/***/ }),

/***/ 2361:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ repeatWhen)
/* harmony export */ });
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9765);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5345);


function repeatWhen(notifier) {
  return source => source.lift(new RepeatWhenOperator(notifier));
}
class RepeatWhenOperator {
  constructor(notifier) {
    this.notifier = notifier;
  }
  call(subscriber, source) {
    return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
  }
}
class RepeatWhenSubscriber extends _innerSubscribe__WEBPACK_IMPORTED_MODULE_0__/* .SimpleOuterSubscriber */ .Ds {
  constructor(destination, notifier, source) {
    super(destination);
    this.notifier = notifier;
    this.source = source;
    this.sourceIsBeingSubscribedTo = true;
  }
  notifyNext() {
    this.sourceIsBeingSubscribedTo = true;
    this.source.subscribe(this);
  }
  notifyComplete() {
    if (this.sourceIsBeingSubscribedTo === false) {
      return super.complete();
    }
  }
  complete() {
    this.sourceIsBeingSubscribedTo = false;
    if (!this.isStopped) {
      if (!this.retries) {
        this.subscribeToRetries();
      }
      if (!this.retriesSubscription || this.retriesSubscription.closed) {
        return super.complete();
      }
      this._unsubscribeAndRecycle();
      this.notifications.next(undefined);
    }
  }
  _unsubscribe() {
    const {
      notifications,
      retriesSubscription
    } = this;
    if (notifications) {
      notifications.unsubscribe();
      this.notifications = undefined;
    }
    if (retriesSubscription) {
      retriesSubscription.unsubscribe();
      this.retriesSubscription = undefined;
    }
    this.retries = undefined;
  }
  _unsubscribeAndRecycle() {
    const {
      _unsubscribe
    } = this;
    this._unsubscribe = null;
    super._unsubscribeAndRecycle();
    this._unsubscribe = _unsubscribe;
    return this;
  }
  subscribeToRetries() {
    this.notifications = new _Subject__WEBPACK_IMPORTED_MODULE_1__/* .Subject */ .xQ();
    let retries;
    try {
      const {
        notifier
      } = this;
      retries = notifier(this.notifications);
    } catch (e) {
      return super.complete();
    }
    this.retries = retries;
    this.retriesSubscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_0__/* .innerSubscribe */ .ft)(retries, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_0__/* .SimpleInnerSubscriber */ .IY(this));
  }
}
//# sourceMappingURL=repeatWhen.js.map

/***/ }),

/***/ 7349:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   d: () => (/* binding */ shareReplay)
/* harmony export */ });
/* harmony import */ var _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2298);

function shareReplay(configOrBufferSize, windowTime, scheduler) {
  let config;
  if (configOrBufferSize && typeof configOrBufferSize === 'object') {
    config = configOrBufferSize;
  } else {
    config = {
      bufferSize: configOrBufferSize,
      windowTime,
      refCount: false,
      scheduler
    };
  }
  return source => source.lift(shareReplayOperator(config));
}
function shareReplayOperator({
  bufferSize = Number.POSITIVE_INFINITY,
  windowTime = Number.POSITIVE_INFINITY,
  refCount: useRefCount,
  scheduler
}) {
  let subject;
  let refCount = 0;
  let subscription;
  let hasError = false;
  let isComplete = false;
  return function shareReplayOperation(source) {
    refCount++;
    let innerSub;
    if (!subject || hasError) {
      hasError = false;
      subject = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__/* .ReplaySubject */ .t(bufferSize, windowTime, scheduler);
      innerSub = subject.subscribe(this);
      subscription = source.subscribe({
        next(value) {
          subject.next(value);
        },
        error(err) {
          hasError = true;
          subject.error(err);
        },
        complete() {
          isComplete = true;
          subscription = undefined;
          subject.complete();
        }
      });
      if (isComplete) {
        subscription = undefined;
      }
    } else {
      innerSub = subject.subscribe(this);
    }
    this.add(() => {
      refCount--;
      innerSub.unsubscribe();
      innerSub = undefined;
      if (subscription && !isComplete && useRefCount && refCount === 0) {
        subscription.unsubscribe();
        subscription = undefined;
        subject = undefined;
      }
    });
  };
}
//# sourceMappingURL=shareReplay.js.map

/***/ }),

/***/ 9499:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ switchMapTo)
/* harmony export */ });
/* harmony import */ var _switchMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3190);

function switchMapTo(innerObservable, resultSelector) {
  return resultSelector ? (0,_switchMap__WEBPACK_IMPORTED_MODULE_0__/* .switchMap */ .w)(() => innerObservable, resultSelector) : (0,_switchMap__WEBPACK_IMPORTED_MODULE_0__/* .switchMap */ .w)(() => innerObservable);
}
//# sourceMappingURL=switchMapTo.js.map

/***/ }),

/***/ 6782:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ takeUntil)
/* harmony export */ });
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5345);

function takeUntil(notifier) {
  return source => source.lift(new TakeUntilOperator(notifier));
}
class TakeUntilOperator {
  constructor(notifier) {
    this.notifier = notifier;
  }
  call(subscriber, source) {
    const takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
    const notifierSubscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_0__/* .innerSubscribe */ .ft)(this.notifier, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_0__/* .SimpleInnerSubscriber */ .IY(takeUntilSubscriber));
    if (notifierSubscription && !takeUntilSubscriber.seenValue) {
      takeUntilSubscriber.add(notifierSubscription);
      return source.subscribe(takeUntilSubscriber);
    }
    return takeUntilSubscriber;
  }
}
class TakeUntilSubscriber extends _innerSubscribe__WEBPACK_IMPORTED_MODULE_0__/* .SimpleOuterSubscriber */ .Ds {
  constructor(destination) {
    super(destination);
    this.seenValue = false;
  }
  notifyNext() {
    this.seenValue = true;
    this.complete();
  }
  notifyComplete() {}
}
//# sourceMappingURL=takeUntil.js.map

/***/ }),

/***/ 409:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   o: () => (/* binding */ takeWhile)
/* harmony export */ });
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7393);

function takeWhile(predicate, inclusive = false) {
  return source => source.lift(new TakeWhileOperator(predicate, inclusive));
}
class TakeWhileOperator {
  constructor(predicate, inclusive) {
    this.predicate = predicate;
    this.inclusive = inclusive;
  }
  call(subscriber, source) {
    return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
  }
}
class TakeWhileSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__/* .Subscriber */ .L {
  constructor(destination, predicate, inclusive) {
    super(destination);
    this.predicate = predicate;
    this.inclusive = inclusive;
    this.index = 0;
  }
  _next(value) {
    const destination = this.destination;
    let result;
    try {
      result = this.predicate(value, this.index++);
    } catch (err) {
      destination.error(err);
      return;
    }
    this.nextOrComplete(value, result);
  }
  nextOrComplete(value, predicateResult) {
    const destination = this.destination;
    if (Boolean(predicateResult)) {
      destination.next(value);
    } else {
      if (this.inclusive) {
        destination.next(value);
      }
      destination.complete();
    }
  }
}
//# sourceMappingURL=takeWhile.js.map

/***/ }),

/***/ 7057:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   M: () => (/* binding */ withLatestFrom)
/* harmony export */ });
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5197);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(509);


function withLatestFrom(...args) {
  return source => {
    let project;
    if (typeof args[args.length - 1] === 'function') {
      project = args.pop();
    }
    const observables = args;
    return source.lift(new WithLatestFromOperator(observables, project));
  };
}
class WithLatestFromOperator {
  constructor(observables, project) {
    this.observables = observables;
    this.project = project;
  }
  call(subscriber, source) {
    return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
  }
}
class WithLatestFromSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__/* .OuterSubscriber */ .L {
  constructor(destination, observables, project) {
    super(destination);
    this.observables = observables;
    this.project = project;
    this.toRespond = [];
    const len = observables.length;
    this.values = new Array(len);
    for (let i = 0; i < len; i++) {
      this.toRespond.push(i);
    }
    for (let i = 0; i < len; i++) {
      let observable = observables[i];
      this.add((0,_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__/* .subscribeToResult */ .D)(this, observable, undefined, i));
    }
  }
  notifyNext(_outerValue, innerValue, outerIndex) {
    this.values[outerIndex] = innerValue;
    const toRespond = this.toRespond;
    if (toRespond.length > 0) {
      const found = toRespond.indexOf(outerIndex);
      if (found !== -1) {
        toRespond.splice(found, 1);
      }
    }
  }
  notifyComplete() {}
  _next(value) {
    if (this.toRespond.length === 0) {
      const args = [value, ...this.values];
      if (this.project) {
        this._tryProject(args);
      } else {
        this.destination.next(args);
      }
    }
  }
  _tryProject(args) {
    let result;
    try {
      result = this.project.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  }
}
//# sourceMappingURL=withLatestFrom.js.map

/***/ }),

/***/ 6465:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  o: () => (/* binding */ AsyncAction)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscription.js + 1 modules
var Subscription = __webpack_require__(5319);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/Action.js

class Action extends Subscription/* Subscription */.w {
  constructor(scheduler, work) {
    super();
  }
  schedule(state, delay = 0) {
    return this;
  }
}
//# sourceMappingURL=Action.js.map
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js

class AsyncAction extends Action {
  constructor(scheduler, work) {
    super(scheduler, work);
    this.scheduler = scheduler;
    this.work = work;
    this.pending = false;
  }
  schedule(state, delay = 0) {
    if (this.closed) {
      return this;
    }
    this.state = state;
    const id = this.id;
    const scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay);
    }
    this.pending = true;
    this.delay = delay;
    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
    return this;
  }
  requestAsyncId(scheduler, id, delay = 0) {
    return setInterval(scheduler.flush.bind(scheduler, this), delay);
  }
  recycleAsyncId(scheduler, id, delay = 0) {
    if (delay !== null && this.delay === delay && this.pending === false) {
      return id;
    }
    clearInterval(id);
    return undefined;
  }
  execute(state, delay) {
    if (this.closed) {
      return new Error('executing a cancelled action');
    }
    this.pending = false;
    const error = this._execute(state, delay);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  }
  _execute(state, delay) {
    let errored = false;
    let errorValue = undefined;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = !!e && e || new Error(e);
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  }
  _unsubscribe() {
    const id = this.id;
    const scheduler = this.scheduler;
    const actions = scheduler.actions;
    const index = actions.indexOf(this);
    this.work = null;
    this.state = null;
    this.pending = false;
    this.scheduler = null;
    if (index !== -1) {
      actions.splice(index, 1);
    }
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, null);
    }
    this.delay = null;
  }
}
//# sourceMappingURL=AsyncAction.js.map

/***/ }),

/***/ 6102:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  v: () => (/* binding */ AsyncScheduler)
});

;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/Scheduler.js
let Scheduler = /*#__PURE__*/(() => {
  class Scheduler {
    constructor(SchedulerAction, now = Scheduler.now) {
      this.SchedulerAction = SchedulerAction;
      this.now = now;
    }
    schedule(work, delay = 0, state) {
      return new this.SchedulerAction(this, work).schedule(state, delay);
    }
  }
  Scheduler.now = () => Date.now();
  //# sourceMappingURL=Scheduler.js.map
  return Scheduler;
})();
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js

class AsyncScheduler extends Scheduler {
  constructor(SchedulerAction, now = Scheduler.now) {
    super(SchedulerAction, () => {
      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
        return AsyncScheduler.delegate.now();
      } else {
        return now();
      }
    });
    this.actions = [];
    this.active = false;
    this.scheduled = undefined;
  }
  schedule(work, delay = 0, state) {
    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
      return AsyncScheduler.delegate.schedule(work, delay, state);
    } else {
      return super.schedule(work, delay, state);
    }
  }
  flush(action) {
    const {
      actions
    } = this;
    if (this.active) {
      actions.push(action);
      return;
    }
    let error;
    this.active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this.active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  }
}
//# sourceMappingURL=AsyncScheduler.js.map

/***/ }),

/***/ 1927:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: () => (/* binding */ animationFrameScheduler)
});

// UNUSED EXPORTS: animationFrame

// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js + 1 modules
var AsyncAction = __webpack_require__(6465);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameAction.js

class AnimationFrameAction extends AsyncAction/* AsyncAction */.o {
  constructor(scheduler, work) {
    super(scheduler, work);
    this.scheduler = scheduler;
    this.work = work;
  }
  requestAsyncId(scheduler, id, delay = 0) {
    if (delay !== null && delay > 0) {
      return super.requestAsyncId(scheduler, id, delay);
    }
    scheduler.actions.push(this);
    return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(() => scheduler.flush(null)));
  }
  recycleAsyncId(scheduler, id, delay = 0) {
    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
      return super.recycleAsyncId(scheduler, id, delay);
    }
    if (scheduler.actions.length === 0) {
      cancelAnimationFrame(id);
      scheduler.scheduled = undefined;
    }
    return undefined;
  }
}
//# sourceMappingURL=AnimationFrameAction.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js + 1 modules
var AsyncScheduler = __webpack_require__(6102);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameScheduler.js

class AnimationFrameScheduler extends AsyncScheduler/* AsyncScheduler */.v {
  flush(action) {
    this.active = true;
    this.scheduled = undefined;
    const {
      actions
    } = this;
    let error;
    let index = -1;
    let count = actions.length;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (++index < count && (action = actions.shift()));
    this.active = false;
    if (error) {
      while (++index < count && (action = actions.shift())) {
        action.unsubscribe();
      }
      throw error;
    }
  }
}
//# sourceMappingURL=AnimationFrameScheduler.js.map
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/animationFrame.js


const animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);
const animationFrame = (/* unused pure expression or super */ null && (animationFrameScheduler));
//# sourceMappingURL=animationFrame.js.map

/***/ }),

/***/ 3637:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ async)
/* harmony export */ });
/* unused harmony export asyncScheduler */
/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6465);
/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6102);


const asyncScheduler = new _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__/* .AsyncScheduler */ .v(_AsyncAction__WEBPACK_IMPORTED_MODULE_1__/* .AsyncAction */ .o);
const async = asyncScheduler;
//# sourceMappingURL=async.js.map

/***/ }),

/***/ 6561:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   k: () => (/* binding */ isNumeric)
/* harmony export */ });
/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9796);

function isNumeric(val) {
  return !(0,_isArray__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .k)(val) && val - parseFloat(val) + 1 >= 0;
}
//# sourceMappingURL=isNumeric.js.map

/***/ }),

/***/ 2775:
/***/ (function(module) {

!function (e, r) {
   true ? module.exports = r() : 0;
}(this, function () {
  return function (e) {
    function r(n) {
      if (t[n]) return t[n].exports;
      var o = t[n] = {
        exports: {},
        id: n,
        loaded: !1
      };
      return e[n].call(o.exports, o, o.exports, r), o.loaded = !0, o.exports;
    }
    var t = {};
    return r.m = e, r.c = t, r.p = "", r(0);
  }([function (e, r, t) {
    "use strict";

    function n(e) {
      return e && e.__esModule ? e : {
        default: e
      };
    }
    Object.defineProperty(r, "__esModule", {
      value: !0
    });
    var o = t(3);
    Object.defineProperty(r, "conformToMask", {
      enumerable: !0,
      get: function () {
        return n(o).default;
      }
    });
    var i = t(2);
    Object.defineProperty(r, "adjustCaretPosition", {
      enumerable: !0,
      get: function () {
        return n(i).default;
      }
    });
    var a = t(5);
    Object.defineProperty(r, "createTextMaskInputElement", {
      enumerable: !0,
      get: function () {
        return n(a).default;
      }
    });
  }, function (e, r) {
    "use strict";

    Object.defineProperty(r, "__esModule", {
      value: !0
    }), r.placeholderChar = "_", r.strFunction = "function";
  }, function (e, r) {
    "use strict";

    function t(e) {
      var r = e.previousConformedValue,
        t = void 0 === r ? o : r,
        i = e.previousPlaceholder,
        a = void 0 === i ? o : i,
        u = e.currentCaretPosition,
        l = void 0 === u ? 0 : u,
        s = e.conformedValue,
        f = e.rawValue,
        d = e.placeholderChar,
        c = e.placeholder,
        p = e.indexesOfPipedChars,
        v = void 0 === p ? n : p,
        h = e.caretTrapIndexes,
        m = void 0 === h ? n : h;
      if (0 === l || !f.length) return 0;
      var y = f.length,
        g = t.length,
        b = c.length,
        C = s.length,
        P = y - g,
        k = P > 0,
        x = 0 === g,
        O = P > 1 && !k && !x;
      if (O) return l;
      var T = k && (t === s || s === c),
        w = 0,
        M = void 0,
        S = void 0;
      if (T) w = l - P;else {
        var j = s.toLowerCase(),
          _ = f.toLowerCase(),
          V = _.substr(0, l).split(o),
          A = V.filter(function (e) {
            return j.indexOf(e) !== -1;
          });
        S = A[A.length - 1];
        var N = a.substr(0, A.length).split(o).filter(function (e) {
            return e !== d;
          }).length,
          E = c.substr(0, A.length).split(o).filter(function (e) {
            return e !== d;
          }).length,
          F = E !== N,
          R = void 0 !== a[A.length - 1] && void 0 !== c[A.length - 2] && a[A.length - 1] !== d && a[A.length - 1] !== c[A.length - 1] && a[A.length - 1] === c[A.length - 2];
        !k && (F || R) && N > 0 && c.indexOf(S) > -1 && void 0 !== f[l] && (M = !0, S = f[l]);
        for (var I = v.map(function (e) {
            return j[e];
          }), J = I.filter(function (e) {
            return e === S;
          }).length, W = A.filter(function (e) {
            return e === S;
          }).length, q = c.substr(0, c.indexOf(d)).split(o).filter(function (e, r) {
            return e === S && f[r] !== e;
          }).length, L = q + W + J + (M ? 1 : 0), z = 0, B = 0; B < C; B++) {
          var D = j[B];
          if (w = B + 1, D === S && z++, z >= L) break;
        }
      }
      if (k) {
        for (var G = w, H = w; H <= b; H++) if (c[H] === d && (G = H), c[H] === d || m.indexOf(H) !== -1 || H === b) return G;
      } else if (M) {
        for (var K = w - 1; K >= 0; K--) if (s[K] === S || m.indexOf(K) !== -1 || 0 === K) return K;
      } else for (var Q = w; Q >= 0; Q--) if (c[Q - 1] === d || m.indexOf(Q) !== -1 || 0 === Q) return Q;
    }
    Object.defineProperty(r, "__esModule", {
      value: !0
    }), r.default = t;
    var n = [],
      o = "";
  }, function (e, r, t) {
    "use strict";

    function n() {
      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
        r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : u,
        t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      if (!(0, i.isArray)(r)) {
        if (("undefined" == typeof r ? "undefined" : o(r)) !== a.strFunction) throw new Error("Text-mask:conformToMask; The mask property must be an array.");
        r = r(e, t), r = (0, i.processCaretTraps)(r).maskWithoutCaretTraps;
      }
      var n = t.guide,
        s = void 0 === n || n,
        f = t.previousConformedValue,
        d = void 0 === f ? l : f,
        c = t.placeholderChar,
        p = void 0 === c ? a.placeholderChar : c,
        v = t.placeholder,
        h = void 0 === v ? (0, i.convertMaskToPlaceholder)(r, p) : v,
        m = t.currentCaretPosition,
        y = t.keepCharPositions,
        g = s === !1 && void 0 !== d,
        b = e.length,
        C = d.length,
        P = h.length,
        k = r.length,
        x = b - C,
        O = x > 0,
        T = m + (O ? -x : 0),
        w = T + Math.abs(x);
      if (y === !0 && !O) {
        for (var M = l, S = T; S < w; S++) h[S] === p && (M += p);
        e = e.slice(0, T) + M + e.slice(T, b);
      }
      for (var j = e.split(l).map(function (e, r) {
          return {
            char: e,
            isNew: r >= T && r < w
          };
        }), _ = b - 1; _ >= 0; _--) {
        var V = j[_].char;
        if (V !== p) {
          var A = _ >= T && C === k;
          V === h[A ? _ - x : _] && j.splice(_, 1);
        }
      }
      var N = l,
        E = !1;
      e: for (var F = 0; F < P; F++) {
        var R = h[F];
        if (R === p) {
          if (j.length > 0) for (; j.length > 0;) {
            var I = j.shift(),
              J = I.char,
              W = I.isNew;
            if (J === p && g !== !0) {
              N += p;
              continue e;
            }
            if (r[F].test(J)) {
              if (y === !0 && W !== !1 && d !== l && s !== !1 && O) {
                for (var q = j.length, L = null, z = 0; z < q; z++) {
                  var B = j[z];
                  if (B.char !== p && B.isNew === !1) break;
                  if (B.char === p) {
                    L = z;
                    break;
                  }
                }
                null !== L ? (N += J, j.splice(L, 1)) : F--;
              } else N += J;
              continue e;
            }
            E = !0;
          }
          g === !1 && (N += h.substr(F, P));
          break;
        }
        N += R;
      }
      if (g && O === !1) {
        for (var D = null, G = 0; G < N.length; G++) h[G] === p && (D = G);
        N = null !== D ? N.substr(0, D + 1) : l;
      }
      return {
        conformedValue: N,
        meta: {
          someCharsRejected: E
        }
      };
    }
    Object.defineProperty(r, "__esModule", {
      value: !0
    });
    var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
      return typeof e;
    } : function (e) {
      return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    };
    r.default = n;
    var i = t(4),
      a = t(1),
      u = [],
      l = "";
  }, function (e, r, t) {
    "use strict";

    function n() {
      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : f,
        r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : s.placeholderChar;
      if (!o(e)) throw new Error("Text-mask:convertMaskToPlaceholder; The mask property must be an array.");
      if (e.indexOf(r) !== -1) throw new Error("Placeholder character must not be used as part of the mask. Please specify a character that is not present in your mask as your placeholder character.\n\n" + ("The placeholder character that was received is: " + JSON.stringify(r) + "\n\n") + ("The mask that was received is: " + JSON.stringify(e)));
      return e.map(function (e) {
        return e instanceof RegExp ? r : e;
      }).join("");
    }
    function o(e) {
      return Array.isArray && Array.isArray(e) || e instanceof Array;
    }
    function i(e) {
      return "string" == typeof e || e instanceof String;
    }
    function a(e) {
      return "number" == typeof e && void 0 === e.length && !isNaN(e);
    }
    function u(e) {
      return "undefined" == typeof e || null === e;
    }
    function l(e) {
      for (var r = [], t = void 0; t = e.indexOf(d), t !== -1;) r.push(t), e.splice(t, 1);
      return {
        maskWithoutCaretTraps: e,
        indexes: r
      };
    }
    Object.defineProperty(r, "__esModule", {
      value: !0
    }), r.convertMaskToPlaceholder = n, r.isArray = o, r.isString = i, r.isNumber = a, r.isNil = u, r.processCaretTraps = l;
    var s = t(1),
      f = [],
      d = "[]";
  }, function (e, r, t) {
    "use strict";

    function n(e) {
      return e && e.__esModule ? e : {
        default: e
      };
    }
    function o(e) {
      var r = {
        previousConformedValue: void 0,
        previousPlaceholder: void 0
      };
      return {
        state: r,
        update: function (t) {
          var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e,
            o = n.inputElement,
            s = n.mask,
            d = n.guide,
            m = n.pipe,
            g = n.placeholderChar,
            b = void 0 === g ? v.placeholderChar : g,
            C = n.keepCharPositions,
            P = void 0 !== C && C,
            k = n.showMask,
            x = void 0 !== k && k;
          if ("undefined" == typeof t && (t = o.value), t !== r.previousConformedValue) {
            ("undefined" == typeof s ? "undefined" : l(s)) === y && void 0 !== s.pipe && void 0 !== s.mask && (m = s.pipe, s = s.mask);
            var O = void 0,
              T = void 0;
            if (s instanceof Array && (O = (0, p.convertMaskToPlaceholder)(s, b)), s !== !1) {
              var w = a(t),
                M = o.selectionEnd,
                S = r.previousConformedValue,
                j = r.previousPlaceholder,
                _ = void 0;
              if (("undefined" == typeof s ? "undefined" : l(s)) === v.strFunction) {
                if (T = s(w, {
                  currentCaretPosition: M,
                  previousConformedValue: S,
                  placeholderChar: b
                }), T === !1) return;
                var V = (0, p.processCaretTraps)(T),
                  A = V.maskWithoutCaretTraps,
                  N = V.indexes;
                T = A, _ = N, O = (0, p.convertMaskToPlaceholder)(T, b);
              } else T = s;
              var E = {
                  previousConformedValue: S,
                  guide: d,
                  placeholderChar: b,
                  pipe: m,
                  placeholder: O,
                  currentCaretPosition: M,
                  keepCharPositions: P
                },
                F = (0, c.default)(w, T, E),
                R = F.conformedValue,
                I = ("undefined" == typeof m ? "undefined" : l(m)) === v.strFunction,
                J = {};
              I && (J = m(R, u({
                rawValue: w
              }, E)), J === !1 ? J = {
                value: S,
                rejected: !0
              } : (0, p.isString)(J) && (J = {
                value: J
              }));
              var W = I ? J.value : R,
                q = (0, f.default)({
                  previousConformedValue: S,
                  previousPlaceholder: j,
                  conformedValue: W,
                  placeholder: O,
                  rawValue: w,
                  currentCaretPosition: M,
                  placeholderChar: b,
                  indexesOfPipedChars: J.indexesOfPipedChars,
                  caretTrapIndexes: _
                }),
                L = W === O && 0 === q,
                z = x ? O : h,
                B = L ? z : W;
              r.previousConformedValue = B, r.previousPlaceholder = O, o.value !== B && (o.value = B, i(o, q));
            }
          }
        }
      };
    }
    function i(e, r) {
      document.activeElement === e && (g ? b(function () {
        return e.setSelectionRange(r, r, m);
      }, 0) : e.setSelectionRange(r, r, m));
    }
    function a(e) {
      if ((0, p.isString)(e)) return e;
      if ((0, p.isNumber)(e)) return String(e);
      if (void 0 === e || null === e) return h;
      throw new Error("The 'value' provided to Text Mask needs to be a string or a number. The value received was:\n\n " + JSON.stringify(e));
    }
    Object.defineProperty(r, "__esModule", {
      value: !0
    });
    var u = Object.assign || function (e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = arguments[r];
          for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
        }
        return e;
      },
      l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e;
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
      };
    r.default = o;
    var s = t(2),
      f = n(s),
      d = t(3),
      c = n(d),
      p = t(4),
      v = t(1),
      h = "",
      m = "none",
      y = "object",
      g = "undefined" != typeof navigator && /Android/i.test(navigator.userAgent),
      b = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : setTimeout;
  }]);
});

/***/ }),

/***/ 7582:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fM: () => (/* binding */ __param),
/* harmony export */   gn: () => (/* binding */ __decorate)
/* harmony export */ });
/* unused harmony exports __extends, __assign, __rest, __esDecorate, __runInitializers, __propKey, __setFunctionName, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __spreadArray, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet, __classPrivateFieldIn, __addDisposableResource, __disposeResources */
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose;
    if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  function next() {
    while (env.stack.length) {
      var rec = env.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
      }
      catch (e) {
          fail(e);
      }
    }
    if (env.hasError) throw env.error;
  }
  return next();
}

/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ({
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
});


/***/ })

}]);