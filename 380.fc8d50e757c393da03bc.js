(self["webpackChunkdemo"] = self["webpackChunkdemo"] || []).push([[380],{

/***/ 6099:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ HostChildWarningModule)
/* harmony export */ });
/* harmony import */ var _taiga_ui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(885);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);


let HostChildWarningModule = /*#__PURE__*/(() => {
  class HostChildWarningModule {}
  HostChildWarningModule.ɵfac = function HostChildWarningModule_Factory(t) {
    return new (t || HostChildWarningModule)();
  };
  HostChildWarningModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
    type: HostChildWarningModule
  });
  HostChildWarningModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
    imports: [[_taiga_ui_core__WEBPACK_IMPORTED_MODULE_1__/* .TuiNotificationModule */ .Hi]]
  });
  return HostChildWarningModule;
})();

/***/ }),

/***/ 4380:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/@angular/platform-browser/fesm2015/platform-browser.js
var platform_browser = __webpack_require__(1211);
// EXTERNAL MODULE: consume shared module (default) @angular/core@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/core/fesm2015/core.js)
var core_js_ = __webpack_require__(8312);
// EXTERNAL MODULE: ./node_modules/@angular/animations/fesm2015/animations.js
var animations = __webpack_require__(6083);
// EXTERNAL MODULE: ./node_modules/@angular/animations/fesm2015/browser.js
var browser = __webpack_require__(9221);
// EXTERNAL MODULE: consume shared module (default) @angular/common@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/common/fesm2015/common.js)
var common_js_ = __webpack_require__(3008);
;// CONCATENATED MODULE: ./node_modules/@angular/platform-browser/fesm2015/animations.js
/**
 * @license Angular v12.2.17
 * (c) 2010-2021 Google LLC. https://angular.io/
 * License: MIT
 */







/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


let BrowserAnimationBuilder = /*#__PURE__*/(() => {
  class BrowserAnimationBuilder extends animations/* AnimationBuilder */._j {
    constructor(rootRenderer, doc) {
      super();
      this._nextAnimationId = 0;
      const typeData = {
        id: '0',
        encapsulation: core_js_.ViewEncapsulation.None,
        styles: [],
        data: {
          animation: []
        }
      };
      this._renderer = rootRenderer.createRenderer(doc.body, typeData);
    }
    build(animation) {
      const id = this._nextAnimationId.toString();
      this._nextAnimationId++;
      const entry = Array.isArray(animation) ? (0,animations/* sequence */.vP)(animation) : animation;
      issueAnimationCommand(this._renderer, null, id, 'register', [entry]);
      return new BrowserAnimationFactory(id, this._renderer);
    }
  }
  BrowserAnimationBuilder.ɵfac = function BrowserAnimationBuilder_Factory(t) {
    return new (t || BrowserAnimationBuilder)(core_js_["ɵɵinject"](core_js_.RendererFactory2), core_js_["ɵɵinject"](common_js_.DOCUMENT));
  };
  BrowserAnimationBuilder.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: BrowserAnimationBuilder,
    factory: BrowserAnimationBuilder.ɵfac
  });
  return BrowserAnimationBuilder;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
class BrowserAnimationFactory extends animations/* AnimationFactory */.LC {
  constructor(_id, _renderer) {
    super();
    this._id = _id;
    this._renderer = _renderer;
  }
  create(element, options) {
    return new RendererAnimationPlayer(this._id, element, options || {}, this._renderer);
  }
}
class RendererAnimationPlayer {
  constructor(id, element, options, _renderer) {
    this.id = id;
    this.element = element;
    this._renderer = _renderer;
    this.parentPlayer = null;
    this._started = false;
    this.totalTime = 0;
    this._command('create', options);
  }
  _listen(eventName, callback) {
    return this._renderer.listen(this.element, `@@${this.id}:${eventName}`, callback);
  }
  _command(command, ...args) {
    return issueAnimationCommand(this._renderer, this.element, this.id, command, args);
  }
  onDone(fn) {
    this._listen('done', fn);
  }
  onStart(fn) {
    this._listen('start', fn);
  }
  onDestroy(fn) {
    this._listen('destroy', fn);
  }
  init() {
    this._command('init');
  }
  hasStarted() {
    return this._started;
  }
  play() {
    this._command('play');
    this._started = true;
  }
  pause() {
    this._command('pause');
  }
  restart() {
    this._command('restart');
  }
  finish() {
    this._command('finish');
  }
  destroy() {
    this._command('destroy');
  }
  reset() {
    this._command('reset');
    this._started = false;
  }
  setPosition(p) {
    this._command('setPosition', p);
  }
  getPosition() {
    var _a, _b;
    return (_b = (_a = this._renderer.engine.players[+this.id]) === null || _a === void 0 ? void 0 : _a.getPosition()) !== null && _b !== void 0 ? _b : 0;
  }
}
function issueAnimationCommand(renderer, element, id, command, args) {
  return renderer.setProperty(element, `@@${id}:${command}`, args);
}
const ANIMATION_PREFIX = '@';
const DISABLE_ANIMATIONS_FLAG = '@.disabled';
let AnimationRendererFactory = /*#__PURE__*/(() => {
  class AnimationRendererFactory {
    constructor(delegate, engine, _zone) {
      this.delegate = delegate;
      this.engine = engine;
      this._zone = _zone;
      this._currentId = 0;
      this._microtaskId = 1;
      this._animationCallbacksBuffer = [];
      this._rendererCache = new Map();
      this._cdRecurDepth = 0;
      this.promise = Promise.resolve(0);
      engine.onRemovalComplete = (element, delegate) => {
        // Note: if an component element has a leave animation, and the component
        // a host leave animation, the view engine will call `removeChild` for the parent
        // component renderer as well as for the child component renderer.
        // Therefore, we need to check if we already removed the element.
        if (delegate && delegate.parentNode(element)) {
          delegate.removeChild(element.parentNode, element);
        }
      };
    }
    createRenderer(hostElement, type) {
      const EMPTY_NAMESPACE_ID = '';
      // cache the delegates to find out which cached delegate can
      // be used by which cached renderer
      const delegate = this.delegate.createRenderer(hostElement, type);
      if (!hostElement || !type || !type.data || !type.data['animation']) {
        let renderer = this._rendererCache.get(delegate);
        if (!renderer) {
          renderer = new BaseAnimationRenderer(EMPTY_NAMESPACE_ID, delegate, this.engine);
          // only cache this result when the base renderer is used
          this._rendererCache.set(delegate, renderer);
        }
        return renderer;
      }
      const componentId = type.id;
      const namespaceId = type.id + '-' + this._currentId;
      this._currentId++;
      this.engine.register(namespaceId, hostElement);
      const registerTrigger = trigger => {
        if (Array.isArray(trigger)) {
          trigger.forEach(registerTrigger);
        } else {
          this.engine.registerTrigger(componentId, namespaceId, hostElement, trigger.name, trigger);
        }
      };
      const animationTriggers = type.data['animation'];
      animationTriggers.forEach(registerTrigger);
      return new AnimationRenderer(this, namespaceId, delegate, this.engine);
    }
    begin() {
      this._cdRecurDepth++;
      if (this.delegate.begin) {
        this.delegate.begin();
      }
    }
    _scheduleCountTask() {
      // always use promise to schedule microtask instead of use Zone
      this.promise.then(() => {
        this._microtaskId++;
      });
    }
    /** @internal */
    scheduleListenerCallback(count, fn, data) {
      if (count >= 0 && count < this._microtaskId) {
        this._zone.run(() => fn(data));
        return;
      }
      if (this._animationCallbacksBuffer.length == 0) {
        Promise.resolve(null).then(() => {
          this._zone.run(() => {
            this._animationCallbacksBuffer.forEach(tuple => {
              const [fn, data] = tuple;
              fn(data);
            });
            this._animationCallbacksBuffer = [];
          });
        });
      }
      this._animationCallbacksBuffer.push([fn, data]);
    }
    end() {
      this._cdRecurDepth--;
      // this is to prevent animations from running twice when an inner
      // component does CD when a parent component instead has inserted it
      if (this._cdRecurDepth == 0) {
        this._zone.runOutsideAngular(() => {
          this._scheduleCountTask();
          this.engine.flush(this._microtaskId);
        });
      }
      if (this.delegate.end) {
        this.delegate.end();
      }
    }
    whenRenderingDone() {
      return this.engine.whenRenderingDone();
    }
  }
  AnimationRendererFactory.ɵfac = function AnimationRendererFactory_Factory(t) {
    return new (t || AnimationRendererFactory)(core_js_["ɵɵinject"](core_js_.RendererFactory2), core_js_["ɵɵinject"](browser/* ɵAnimationEngine */.Th), core_js_["ɵɵinject"](core_js_.NgZone));
  };
  AnimationRendererFactory.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: AnimationRendererFactory,
    factory: AnimationRendererFactory.ɵfac
  });
  return AnimationRendererFactory;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
class BaseAnimationRenderer {
  constructor(namespaceId, delegate, engine) {
    this.namespaceId = namespaceId;
    this.delegate = delegate;
    this.engine = engine;
    this.destroyNode = this.delegate.destroyNode ? n => delegate.destroyNode(n) : null;
  }
  get data() {
    return this.delegate.data;
  }
  destroy() {
    this.engine.destroy(this.namespaceId, this.delegate);
    this.delegate.destroy();
  }
  createElement(name, namespace) {
    return this.delegate.createElement(name, namespace);
  }
  createComment(value) {
    return this.delegate.createComment(value);
  }
  createText(value) {
    return this.delegate.createText(value);
  }
  appendChild(parent, newChild) {
    this.delegate.appendChild(parent, newChild);
    this.engine.onInsert(this.namespaceId, newChild, parent, false);
  }
  insertBefore(parent, newChild, refChild, isMove = true) {
    this.delegate.insertBefore(parent, newChild, refChild);
    // If `isMove` true than we should animate this insert.
    this.engine.onInsert(this.namespaceId, newChild, parent, isMove);
  }
  removeChild(parent, oldChild, isHostElement) {
    this.engine.onRemove(this.namespaceId, oldChild, this.delegate, isHostElement);
  }
  selectRootElement(selectorOrNode, preserveContent) {
    return this.delegate.selectRootElement(selectorOrNode, preserveContent);
  }
  parentNode(node) {
    return this.delegate.parentNode(node);
  }
  nextSibling(node) {
    return this.delegate.nextSibling(node);
  }
  setAttribute(el, name, value, namespace) {
    this.delegate.setAttribute(el, name, value, namespace);
  }
  removeAttribute(el, name, namespace) {
    this.delegate.removeAttribute(el, name, namespace);
  }
  addClass(el, name) {
    this.delegate.addClass(el, name);
  }
  removeClass(el, name) {
    this.delegate.removeClass(el, name);
  }
  setStyle(el, style, value, flags) {
    this.delegate.setStyle(el, style, value, flags);
  }
  removeStyle(el, style, flags) {
    this.delegate.removeStyle(el, style, flags);
  }
  setProperty(el, name, value) {
    if (name.charAt(0) == ANIMATION_PREFIX && name == DISABLE_ANIMATIONS_FLAG) {
      this.disableAnimations(el, !!value);
    } else {
      this.delegate.setProperty(el, name, value);
    }
  }
  setValue(node, value) {
    this.delegate.setValue(node, value);
  }
  listen(target, eventName, callback) {
    return this.delegate.listen(target, eventName, callback);
  }
  disableAnimations(element, value) {
    this.engine.disableAnimations(element, value);
  }
}
class AnimationRenderer extends BaseAnimationRenderer {
  constructor(factory, namespaceId, delegate, engine) {
    super(namespaceId, delegate, engine);
    this.factory = factory;
    this.namespaceId = namespaceId;
  }
  setProperty(el, name, value) {
    if (name.charAt(0) == ANIMATION_PREFIX) {
      if (name.charAt(1) == '.' && name == DISABLE_ANIMATIONS_FLAG) {
        value = value === undefined ? true : !!value;
        this.disableAnimations(el, value);
      } else {
        this.engine.process(this.namespaceId, el, name.substr(1), value);
      }
    } else {
      this.delegate.setProperty(el, name, value);
    }
  }
  listen(target, eventName, callback) {
    if (eventName.charAt(0) == ANIMATION_PREFIX) {
      const element = resolveElementFromTarget(target);
      let name = eventName.substr(1);
      let phase = '';
      // @listener.phase is for trigger animation callbacks
      // @@listener is for animation builder callbacks
      if (name.charAt(0) != ANIMATION_PREFIX) {
        [name, phase] = parseTriggerCallbackName(name);
      }
      return this.engine.listen(this.namespaceId, element, name, phase, event => {
        const countId = event['_data'] || -1;
        this.factory.scheduleListenerCallback(countId, callback, event);
      });
    }
    return this.delegate.listen(target, eventName, callback);
  }
}
function resolveElementFromTarget(target) {
  switch (target) {
    case 'body':
      return document.body;
    case 'document':
      return document;
    case 'window':
      return window;
    default:
      return target;
  }
}
function parseTriggerCallbackName(triggerName) {
  const dotIndex = triggerName.indexOf('.');
  const trigger = triggerName.substring(0, dotIndex);
  const phase = triggerName.substr(dotIndex + 1);
  return [trigger, phase];
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
let InjectableAnimationEngine = /*#__PURE__*/(() => {
  class InjectableAnimationEngine extends browser/* ɵAnimationEngine */.Th {
    constructor(doc, driver, normalizer) {
      super(doc.body, driver, normalizer);
    }
    ngOnDestroy() {
      this.flush();
    }
  }
  InjectableAnimationEngine.ɵfac = function InjectableAnimationEngine_Factory(t) {
    return new (t || InjectableAnimationEngine)(core_js_["ɵɵinject"](common_js_.DOCUMENT), core_js_["ɵɵinject"](browser/* AnimationDriver */.Vi), core_js_["ɵɵinject"](browser/* ɵAnimationStyleNormalizer */.NH));
  };
  InjectableAnimationEngine.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: InjectableAnimationEngine,
    factory: InjectableAnimationEngine.ɵfac
  });
  return InjectableAnimationEngine;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
function instantiateSupportedAnimationDriver() {
  return (0,browser/* ɵsupportsWebAnimations */.QN)() ? new browser/* ɵWebAnimationsDriver */.DT() : new browser/* ɵCssKeyframesDriver */.uL();
}
function instantiateDefaultStyleNormalizer() {
  return new browser/* ɵWebAnimationsStyleNormalizer */.Ar();
}
function instantiateRendererFactory(renderer, engine, zone) {
  return new AnimationRendererFactory(renderer, engine, zone);
}
/**
 * @publicApi
 */
const ANIMATION_MODULE_TYPE = /*#__PURE__*/new core_js_.InjectionToken('AnimationModuleType');
const SHARED_ANIMATION_PROVIDERS = [{
  provide: animations/* AnimationBuilder */._j,
  useClass: BrowserAnimationBuilder
}, {
  provide: browser/* ɵAnimationStyleNormalizer */.NH,
  useFactory: instantiateDefaultStyleNormalizer
}, {
  provide: browser/* ɵAnimationEngine */.Th,
  useClass: InjectableAnimationEngine
}, {
  provide: core_js_.RendererFactory2,
  useFactory: instantiateRendererFactory,
  deps: [platform_browser["ɵDomRendererFactory2"], browser/* ɵAnimationEngine */.Th, core_js_.NgZone]
}];
/**
 * Separate providers from the actual module so that we can do a local modification in Google3 to
 * include them in the BrowserModule.
 */
const BROWSER_ANIMATIONS_PROVIDERS = [{
  provide: browser/* AnimationDriver */.Vi,
  useFactory: instantiateSupportedAnimationDriver
}, {
  provide: ANIMATION_MODULE_TYPE,
  useValue: 'BrowserAnimations'
}, ...SHARED_ANIMATION_PROVIDERS];
/**
 * Separate providers from the actual module so that we can do a local modification in Google3 to
 * include them in the BrowserTestingModule.
 */
const BROWSER_NOOP_ANIMATIONS_PROVIDERS = [{
  provide: browser/* AnimationDriver */.Vi,
  useClass: browser/* ɵNoopAnimationDriver */.nV
}, {
  provide: ANIMATION_MODULE_TYPE,
  useValue: 'NoopAnimations'
}, ...SHARED_ANIMATION_PROVIDERS];

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Exports `BrowserModule` with additional [dependency-injection providers](guide/glossary#provider)
 * for use with animations. See [Animations](guide/animations).
 * @publicApi
 */
let BrowserAnimationsModule = /*#__PURE__*/(() => {
  class BrowserAnimationsModule {
    /**
     * Configures the module based on the specified object.
     *
     * @param config Object used to configure the behavior of the `BrowserAnimationsModule`.
     * @see `BrowserAnimationsModuleConfig`
     *
     * @usageNotes
     * When registering the `BrowserAnimationsModule`, you can use the `withConfig`
     * function as follows:
     * ```
     * @NgModule({
     *   imports: [BrowserAnimationsModule.withConfig(config)]
     * })
     * class MyNgModule {}
     * ```
     */
    static withConfig(config) {
      return {
        ngModule: BrowserAnimationsModule,
        providers: config.disableAnimations ? BROWSER_NOOP_ANIMATIONS_PROVIDERS : BROWSER_ANIMATIONS_PROVIDERS
      };
    }
  }
  BrowserAnimationsModule.ɵfac = function BrowserAnimationsModule_Factory(t) {
    return new (t || BrowserAnimationsModule)();
  };
  BrowserAnimationsModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: BrowserAnimationsModule
  });
  BrowserAnimationsModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    providers: BROWSER_ANIMATIONS_PROVIDERS,
    imports: [platform_browser.BrowserModule]
  });
  return BrowserAnimationsModule;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/*#__PURE__*/(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](BrowserAnimationsModule, {
    exports: function () {
      return [platform_browser.BrowserModule];
    }
  });
})();
/**
 * A null player that must be imported to allow disabling of animations.
 * @publicApi
 */
let NoopAnimationsModule = /*#__PURE__*/(() => {
  class NoopAnimationsModule {}
  NoopAnimationsModule.ɵfac = function NoopAnimationsModule_Factory(t) {
    return new (t || NoopAnimationsModule)();
  };
  NoopAnimationsModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: NoopAnimationsModule
  });
  NoopAnimationsModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    providers: BROWSER_NOOP_ANIMATIONS_PROVIDERS,
    imports: [platform_browser.BrowserModule]
  });
  return NoopAnimationsModule;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/*#__PURE__*/(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](NoopAnimationsModule, {
    exports: function () {
      return [platform_browser.BrowserModule];
    }
  });
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=animations.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/addon-doc/fesm2015/taiga-ui-addon-doc.js + 166 modules
var taiga_ui_addon_doc = __webpack_require__(6154);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-link.js
var taiga_ui_core_components_link = __webpack_require__(2847);
;// CONCATENATED MODULE: ./apps/demo/src/app/app.component.ts



let AppComponent = /*#__PURE__*/(() => {
  class AppComponent {}
  AppComponent.ɵfac = function AppComponent_Factory(t) {
    return new (t || AppComponent)();
  };
  AppComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: AppComponent,
    selectors: [["microzord-root"]],
    decls: 5,
    vars: 0,
    consts: [["ngProjectAs", "tuiDocHeader", 5, ["tuiDocHeader"]], ["tuiLink", "", "tuiMode", "onLight", "href", "https://github.com/taiga-family/microzord", "target", "_blank", 1, "link"], ["src", "assets/images/github.svg", "alt", "", 1, "github"]],
    template: function AppComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵelementStart"](0, "tui-doc-main");
        core_js_["ɵɵelementContainerStart"](1, 0);
        core_js_["ɵɵelementStart"](2, "a", 1);
        core_js_["ɵɵelement"](3, "img", 2);
        core_js_["ɵɵtext"](4, " GitHub ");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementContainerEnd"]();
        core_js_["ɵɵelementEnd"]();
      }
    },
    directives: [taiga_ui_addon_doc/* TuiDocMainComponent */.$5, taiga_ui_core_components_link/* TuiLinkComponent */.V],
    styles: ["[_nghost-%COMP%] {\n  font: var(--tui-font-text-m);\n}\n.link[_ngcontent-%COMP%] {\n  font-weight: bold;\n  height: 24px;\n}\n.github[_ngcontent-%COMP%] {\n  width: 24px;\n  height: 24px;\n  margin: 0 4px 0 16px;\n  vertical-align: -6px;\n}"],
    changeDetection: 0
  });
  return AppComponent;
})();
// EXTERNAL MODULE: consume shared module (default) @angular/router@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/router/fesm2015/router.js)
var router_js_ = __webpack_require__(2541);
// EXTERNAL MODULE: ./node_modules/@tinkoff/ng-polymorpheus/fesm2015/tinkoff-ng-polymorpheus.js
var tinkoff_ng_polymorpheus = __webpack_require__(9570);
;// CONCATENATED MODULE: ./apps/demo/src/app/logo/logo.component.ts


let LogoComponent = /*#__PURE__*/(() => {
  class LogoComponent {}
  LogoComponent.ɵfac = function LogoComponent_Factory(t) {
    return new (t || LogoComponent)();
  };
  LogoComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: LogoComponent,
    selectors: [["logo"]],
    decls: 3,
    vars: 0,
    consts: [["src", "assets/images/microzord.png", "alt", "logo", 1, "logo"], ["src", "assets/images/by.svg", "alt", "by Tinkoff", 1, "by"]],
    template: function LogoComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵelement"](0, "img", 0);
        core_js_["ɵɵtext"](1, "\nmicrozord\n");
        core_js_["ɵɵelement"](2, "img", 1);
      }
    },
    styles: ["[_nghost-%COMP%] {\n  display: flex;\n  align-items: center;\n}\n@media screen and (max-width: 37.4625em) {\n  [_nghost-%COMP%] {\n    font-size: 0;\n  }\n}\n.logo[_ngcontent-%COMP%] {\n  width: 30px;\n  margin-right: 10px;\n}\n.by[_ngcontent-%COMP%] {\n  margin-left: 14px;\n}\n@media screen and (max-width: 37.4625em) {\n  .by[_ngcontent-%COMP%] {\n    display: none;\n  }\n}"],
    changeDetection: 0
  });
  return LogoComponent;
})();
const LOGO_CONTENT = new tinkoff_ng_polymorpheus/* PolymorpheusComponent */.Al(LogoComponent);
;// CONCATENATED MODULE: ./apps/demo/src/app/pages.ts
const pages = [{
  section: `Starting`,
  title: `Getting started`,
  keywords: 'intro, how to, guide, main, главная, начало, инструкция',
  route: 'getting-started'
}, {
  section: `Starting`,
  title: `Application entity`,
  keywords: 'intro, how to, guide, main, source, child, host, zord, приложение',
  route: 'application'
}, {
  section: `Native JS`,
  title: `Native JS — Installation`,
  keywords: 'javascript, vanilla, spa',
  route: 'native-installation'
}, {
  section: `Angular`,
  title: `Angular — Installation`,
  keywords: 'angular, spa',
  route: 'angular-installation'
}, {
  section: `Angular`,
  title: `Angular — Host`,
  keywords: 'angular, spa, host',
  route: 'angular-host'
}, {
  section: `Angular`,
  title: `Angular — Child`,
  keywords: 'angular, spa, child',
  route: 'angular-child'
}, {
  section: `React`,
  title: `React — Installation`,
  keywords: 'react, spa',
  route: 'react-installation'
}, {
  section: `React`,
  title: `React — Child`,
  keywords: 'react, spa, child',
  route: 'react-child'
}];
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-notification.js
var taiga_ui_core_components_notification = __webpack_require__(885);
// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.mjs
var tslib_es6 = __webpack_require__(7582);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-decorators.js
var taiga_ui_cdk_decorators = __webpack_require__(4358);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-island.js





const _c0 = ["*"];
let TuiIslandComponent = /*#__PURE__*/(() => {
  let TuiIslandComponent = class TuiIslandComponent {
    constructor() {
      this.size = 'm';
      this.textAlign = 'left';
      this.hoverable = false;
      this.transparent = false;
    }
    get sizeS() {
      return this.size === 's';
    }
    get sizeM() {
      return this.size === 'm';
    }
    get sizeL() {
      return this.size === 'l';
    }
    get textAlignLeft() {
      return this.textAlign === 'left';
    }
    get textAlignCenter() {
      return this.textAlign === 'center';
    }
    get textAlignRight() {
      return this.textAlign === 'right';
    }
  };
  TuiIslandComponent.ɵfac = function TuiIslandComponent_Factory(t) {
    return new (t || TuiIslandComponent)();
  };
  TuiIslandComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiIslandComponent,
    selectors: [["tui-island"], ["a", "tuiIsland", ""]],
    hostAttrs: [1, "tui-island"],
    hostVars: 16,
    hostBindings: function TuiIslandComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("tui-island_hoverable", ctx.hoverable)("tui-island_transparent", ctx.transparent)("tui-island_size_s", ctx.sizeS)("tui-island_size_m", ctx.sizeM)("tui-island_size_l", ctx.sizeL)("tui-island_text-align_left", ctx.textAlignLeft)("tui-island_text-align_center", ctx.textAlignCenter)("tui-island_text-align_right", ctx.textAlignRight);
      }
    },
    inputs: {
      size: "size",
      textAlign: "textAlign",
      hoverable: "hoverable",
      transparent: "transparent"
    },
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function TuiIslandComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵprojection"](0);
      }
    },
    styles: ["[_nghost-%COMP%]{display:block}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiIslandComponent.prototype, "size", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiIslandComponent.prototype, "textAlign", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class.tui-island_hoverable'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiIslandComponent.prototype, "hoverable", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class.tui-island_transparent'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiIslandComponent.prototype, "transparent", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class.tui-island_size_s')], TuiIslandComponent.prototype, "sizeS", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class.tui-island_size_m')], TuiIslandComponent.prototype, "sizeM", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class.tui-island_size_l')], TuiIslandComponent.prototype, "sizeL", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class.tui-island_text-align_left')], TuiIslandComponent.prototype, "textAlignLeft", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class.tui-island_text-align_center')], TuiIslandComponent.prototype, "textAlignCenter", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class.tui-island_text-align_right')], TuiIslandComponent.prototype, "textAlignRight", null);
  return TuiIslandComponent;
})();
let TuiIslandModule = /*#__PURE__*/(() => {
  let TuiIslandModule = class TuiIslandModule {};
  TuiIslandModule.ɵfac = function TuiIslandModule_Factory(t) {
    return new (t || TuiIslandModule)();
  };
  TuiIslandModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiIslandModule
  });
  TuiIslandModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule]]
  });
  return TuiIslandModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiIslandModule, {
    declarations: function () {
      return [TuiIslandComponent];
    },
    imports: function () {
      return [common_js_.CommonModule];
    },
    exports: function () {
      return [TuiIslandComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-island.js.map
// EXTERNAL MODULE: ./apps/demo/src/app/shared/host-child-warning/host-child-warning.module.ts
var host_child_warning_module = __webpack_require__(6099);
;// CONCATENATED MODULE: ./apps/demo/src/app/getting-started/getting-started.module.ts







let GettingStartedModule = /*#__PURE__*/(() => {
  class GettingStartedModule {}
  GettingStartedModule.ɵfac = function GettingStartedModule_Factory(t) {
    return new (t || GettingStartedModule)();
  };
  GettingStartedModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: GettingStartedModule
  });
  GettingStartedModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, taiga_ui_addon_doc/* TuiDocPageModule */.Lq, taiga_ui_core_components_link/* TuiLinkModule */.j, taiga_ui_addon_doc/* TuiDocCodeModule */.JF, router_js_.RouterModule, taiga_ui_core_components_notification/* TuiNotificationModule */.Hi, TuiIslandModule, host_child_warning_module/* HostChildWarningModule */.$]]
  });
  return GettingStartedModule;
})();
;// CONCATENATED MODULE: ./apps/demo/src/app/getting-started/getting-started.component.ts





let GettingStartedComponent = /*#__PURE__*/(() => {
  class GettingStartedComponent {}
  GettingStartedComponent.ɵfac = function GettingStartedComponent_Factory(t) {
    return new (t || GettingStartedComponent)();
  };
  GettingStartedComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: GettingStartedComponent,
    selectors: [["getting-started"]],
    decls: 57,
    vars: 0,
    consts: [["header", "Getting started"], [1, "about"], [1, "about__benefit"], [1, "tui-island__title"], [1, "tui-island__paragraph"], [1, "tui-space_top-4"], ["tuiLink", "", "routerLink", "/application"], ["tuiLink", "", "routerLink", "/todo"], ["tuiLink", "", "routerLink", "/angular-installation"]],
    template: function GettingStartedComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵelementStart"](0, "tui-doc-page", 0);
        core_js_["ɵɵelementStart"](1, "p");
        core_js_["ɵɵelementStart"](2, "strong");
        core_js_["ɵɵtext"](3, "microzord");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtext"](4, " is a small tool that allows you to add and render multiple apps on one page. It has simple ideomatic APIs for some modern frameworks (Vue and Svelte come soon) and builds bridges between them. ");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](5, "section", 1);
        core_js_["ɵɵelementStart"](6, "tui-island", 2);
        core_js_["ɵɵelementStart"](7, "h3", 3);
        core_js_["ɵɵtext"](8, "\uD83E\uDDD9 Framework agnostic");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](9, "p", 4);
        core_js_["ɵɵtext"](10, " You can have an Angular application with a React app header and a Vue app footer. Each app can have endless amount of nested apps inside. There are also wrappers for every modern framework with simple API. ");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](11, "tui-island", 2);
        core_js_["ɵɵelementStart"](12, "h3", 3);
        core_js_["ɵɵtext"](13, "\uD83E\uDDE9 Modular");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](14, "p", 4);
        core_js_["ɵɵtext"](15, " You can insert another app in your app in any place as an ordinary component. Use the same methods to bind data and to handle its events. ");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](16, "section");
        core_js_["ɵɵelementStart"](17, "h2");
        core_js_["ɵɵtext"](18, "What it is about");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](19, "p");
        core_js_["ɵɵtext"](20, "There are two terms that we want to declare first:");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](21, "ul");
        core_js_["ɵɵelementStart"](22, "li");
        core_js_["ɵɵelementStart"](23, "strong");
        core_js_["ɵɵtext"](24, "Child app");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtext"](25, " is any application that is built with microzord and can be inserted into the host app. ");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](26, "li");
        core_js_["ɵɵelementStart"](27, "strong");
        core_js_["ɵɵtext"](28, "Host app");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtext"](29, " is any application that uses microzord to render child apps inside. ");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](30, "tui-notification", 5);
        core_js_["ɵɵtext"](31, " Some application can host any amount of child apps and be a child for other app at the same time ");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](32, "p");
        core_js_["ɵɵtext"](33, " Microzord does not impose any restrictions but just gives more opportunities for your app. All your apps can be still used as separated apps and can be integrated with others with no additional code in application bundle. ");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](34, "p");
        core_js_["ɵɵtext"](35, " It renders your apps right in DOM without any additional elements or iframes and provides some ideomatic ways to control apps and get data from them. ");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](36, "section");
        core_js_["ɵɵelementStart"](37, "h2");
        core_js_["ɵɵtext"](38, "How to start");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](39, "p");
        core_js_["ɵɵtext"](40, "You can read about main concepts of microzord:");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](41, "ul");
        core_js_["ɵɵelementStart"](42, "li");
        core_js_["ɵɵelementStart"](43, "a", 6);
        core_js_["ɵɵtext"](44, "Application entity");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](45, "p");
        core_js_["ɵɵtext"](46, "Or you can just choose your framework and figure it out in the process:");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](47, "ul");
        core_js_["ɵɵelementStart"](48, "li");
        core_js_["ɵɵelementStart"](49, "a", 7);
        core_js_["ɵɵtext"](50, "Native JS installation");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](51, "li");
        core_js_["ɵɵelementStart"](52, "a", 7);
        core_js_["ɵɵtext"](53, "React installation");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](54, "li");
        core_js_["ɵɵelementStart"](55, "a", 8);
        core_js_["ɵɵtext"](56, "Angular installation");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
      }
    },
    directives: [taiga_ui_addon_doc/* TuiDocPageComponent */.qo, TuiIslandComponent, taiga_ui_core_components_notification/* TuiNotificationComponent */.Ls, taiga_ui_core_components_link/* TuiLinkComponent */.V, router_js_.RouterLinkWithHref],
    styles: [".about[_ngcontent-%COMP%] {\n  display: flex;\n  margin-top: 20px;\n  margin-bottom: 20px;\n}\n.about__benefit[_ngcontent-%COMP%] {\n  flex: 1;\n  margin-right: 32px;\n}"],
    changeDetection: 0
  });
  return GettingStartedComponent;
})();
;// CONCATENATED MODULE: ./apps/demo/src/app/routes.ts

const ROUTES = [{
  path: 'getting-started',
  component: GettingStartedComponent,
  data: {
    title: `Getting started`
  }
}, {
  path: 'application',
  loadChildren: () => __webpack_require__.e(/* import() */ 442).then(__webpack_require__.bind(__webpack_require__, 1442)).then(m => m.ApplicationModule),
  data: {
    title: `Application entity`
  }
}, {
  path: 'native-installation',
  loadChildren: () => __webpack_require__.e(/* import() */ 597).then(__webpack_require__.bind(__webpack_require__, 9597)).then(m => m.NativeInstallationModule),
  data: {
    title: `Native Installation`
  }
}, {
  path: 'react-installation',
  loadChildren: () => __webpack_require__.e(/* import() */ 768).then(__webpack_require__.bind(__webpack_require__, 5768)).then(m => m.ReactInstallationModule),
  data: {
    title: `React Installation`
  }
}, {
  path: 'react-child',
  loadChildren: () => __webpack_require__.e(/* import() */ 543).then(__webpack_require__.bind(__webpack_require__, 6543)).then(m => m.ReactChildModule),
  data: {
    title: `React Child`
  }
}, {
  path: 'angular-installation',
  loadChildren: () => __webpack_require__.e(/* import() */ 45).then(__webpack_require__.bind(__webpack_require__, 6045)).then(m => m.AngularInstallationModule),
  data: {
    title: `Angular Installation`
  }
}, {
  path: 'angular-host',
  loadChildren: () => __webpack_require__.e(/* import() */ 871).then(__webpack_require__.bind(__webpack_require__, 4871)).then(m => m.AngularHostModule),
  data: {
    title: `Angular Host`
  }
}, {
  path: 'angular-child',
  loadChildren: () => __webpack_require__.e(/* import() */ 400).then(__webpack_require__.bind(__webpack_require__, 4400)).then(m => m.AngularChildModule),
  data: {
    title: `Angular Child`
  }
}, {
  path: '**',
  redirectTo: 'getting-started'
}];
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/BehaviorSubject.js
var BehaviorSubject = __webpack_require__(6215);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/empty.js
var empty = __webpack_require__(9193);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/throwError.js
var throwError = __webpack_require__(205);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/fromArray.js
var fromArray = __webpack_require__(6693);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isArray.js
var isArray = __webpack_require__(9796);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscriber.js
var Subscriber = __webpack_require__(7393);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/symbol/iterator.js
var iterator = __webpack_require__(377);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/innerSubscribe.js
var innerSubscribe = __webpack_require__(5345);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/observable/zip.js





function zip(...observables) {
  const resultSelector = observables[observables.length - 1];
  if (typeof resultSelector === 'function') {
    observables.pop();
  }
  return (0,fromArray/* fromArray */.n)(observables, undefined).lift(new ZipOperator(resultSelector));
}
class ZipOperator {
  constructor(resultSelector) {
    this.resultSelector = resultSelector;
  }
  call(subscriber, source) {
    return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
  }
}
class ZipSubscriber extends Subscriber/* Subscriber */.L {
  constructor(destination, resultSelector, values = Object.create(null)) {
    super(destination);
    this.resultSelector = resultSelector;
    this.iterators = [];
    this.active = 0;
    this.resultSelector = typeof resultSelector === 'function' ? resultSelector : undefined;
  }
  _next(value) {
    const iterators = this.iterators;
    if ((0,isArray/* isArray */.k)(value)) {
      iterators.push(new StaticArrayIterator(value));
    } else if (typeof value[iterator/* iterator */.hZ] === 'function') {
      iterators.push(new StaticIterator(value[iterator/* iterator */.hZ]()));
    } else {
      iterators.push(new ZipBufferIterator(this.destination, this, value));
    }
  }
  _complete() {
    const iterators = this.iterators;
    const len = iterators.length;
    this.unsubscribe();
    if (len === 0) {
      this.destination.complete();
      return;
    }
    this.active = len;
    for (let i = 0; i < len; i++) {
      let iterator = iterators[i];
      if (iterator.stillUnsubscribed) {
        const destination = this.destination;
        destination.add(iterator.subscribe());
      } else {
        this.active--;
      }
    }
  }
  notifyInactive() {
    this.active--;
    if (this.active === 0) {
      this.destination.complete();
    }
  }
  checkIterators() {
    const iterators = this.iterators;
    const len = iterators.length;
    const destination = this.destination;
    for (let i = 0; i < len; i++) {
      let iterator = iterators[i];
      if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
        return;
      }
    }
    let shouldComplete = false;
    const args = [];
    for (let i = 0; i < len; i++) {
      let iterator = iterators[i];
      let result = iterator.next();
      if (iterator.hasCompleted()) {
        shouldComplete = true;
      }
      if (result.done) {
        destination.complete();
        return;
      }
      args.push(result.value);
    }
    if (this.resultSelector) {
      this._tryresultSelector(args);
    } else {
      destination.next(args);
    }
    if (shouldComplete) {
      destination.complete();
    }
  }
  _tryresultSelector(args) {
    let result;
    try {
      result = this.resultSelector.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  }
}
class StaticIterator {
  constructor(iterator) {
    this.iterator = iterator;
    this.nextResult = iterator.next();
  }
  hasValue() {
    return true;
  }
  next() {
    const result = this.nextResult;
    this.nextResult = this.iterator.next();
    return result;
  }
  hasCompleted() {
    const nextResult = this.nextResult;
    return Boolean(nextResult && nextResult.done);
  }
}
class StaticArrayIterator {
  constructor(array) {
    this.array = array;
    this.index = 0;
    this.length = 0;
    this.length = array.length;
  }
  [iterator/* iterator */.hZ]() {
    return this;
  }
  next(value) {
    const i = this.index++;
    const array = this.array;
    return i < this.length ? {
      value: array[i],
      done: false
    } : {
      value: null,
      done: true
    };
  }
  hasValue() {
    return this.array.length > this.index;
  }
  hasCompleted() {
    return this.array.length === this.index;
  }
}
class ZipBufferIterator extends innerSubscribe/* SimpleOuterSubscriber */.Ds {
  constructor(destination, parent, observable) {
    super(destination);
    this.parent = parent;
    this.observable = observable;
    this.stillUnsubscribed = true;
    this.buffer = [];
    this.isComplete = false;
  }
  [iterator/* iterator */.hZ]() {
    return this;
  }
  next() {
    const buffer = this.buffer;
    if (buffer.length === 0 && this.isComplete) {
      return {
        value: null,
        done: true
      };
    } else {
      return {
        value: buffer.shift(),
        done: false
      };
    }
  }
  hasValue() {
    return this.buffer.length > 0;
  }
  hasCompleted() {
    return this.buffer.length === 0 && this.isComplete;
  }
  notifyComplete() {
    if (this.buffer.length > 0) {
      this.isComplete = true;
      this.parent.notifyInactive();
    } else {
      this.destination.complete();
    }
  }
  notifyNext(innerValue) {
    this.buffer.push(innerValue);
    this.parent.checkIterators();
  }
  subscribe() {
    return (0,innerSubscribe/* innerSubscribe */.ft)(this.observable, new innerSubscribe/* SimpleInnerSubscriber */.IY(this));
  }
}
//# sourceMappingURL=zip.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/from.js + 6 modules
var from = __webpack_require__(4402);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js + 1 modules
var AsyncAction = __webpack_require__(6465);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameAction.js

class AnimationFrameAction extends AsyncAction/* AsyncAction */.o {
  constructor(scheduler, work) {
    super(scheduler, work);
    this.scheduler = scheduler;
    this.work = work;
  }
  requestAsyncId(scheduler, id, delay = 0) {
    if (delay !== null && delay > 0) {
      return super.requestAsyncId(scheduler, id, delay);
    }
    scheduler.actions.push(this);
    return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(() => scheduler.flush(null)));
  }
  recycleAsyncId(scheduler, id, delay = 0) {
    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
      return super.recycleAsyncId(scheduler, id, delay);
    }
    if (scheduler.actions.length === 0) {
      cancelAnimationFrame(id);
      scheduler.scheduled = undefined;
    }
    return undefined;
  }
}
//# sourceMappingURL=AnimationFrameAction.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js + 1 modules
var AsyncScheduler = __webpack_require__(6102);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameScheduler.js

class AnimationFrameScheduler extends AsyncScheduler/* AsyncScheduler */.v {
  flush(action) {
    this.active = true;
    this.scheduled = undefined;
    const {
      actions
    } = this;
    let error;
    let index = -1;
    let count = actions.length;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (++index < count && (action = actions.shift()));
    this.active = false;
    if (error) {
      while (++index < count && (action = actions.shift())) {
        action.unsubscribe();
      }
      throw error;
    }
  }
}
//# sourceMappingURL=AnimationFrameScheduler.js.map
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/animationFrame.js


const animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);
const animationFrame = (/* unused pure expression or super */ null && (animationFrameScheduler));
//# sourceMappingURL=animationFrame.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/filter.js
var filter = __webpack_require__(5435);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js
var map = __webpack_require__(8002);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/take.js
var take = __webpack_require__(5257);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/switchMap.js
var switchMap = __webpack_require__(3190);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/tap.js
var tap = __webpack_require__(8307);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/catchError.js
var catchError = __webpack_require__(5304);
;// CONCATENATED MODULE: ./node_modules/ngx-highlightjs/fesm2015/ngx-highlightjs.js







const HIGHLIGHT_OPTIONS = new core_js_.InjectionToken('HIGHLIGHT_OPTIONS');

// @dynamic
let HighlightLoader = /*#__PURE__*/(() => {
  class HighlightLoader {
    constructor(doc, platformId, _options) {
      this._options = _options;
      // Stream that emits when hljs library is loaded and ready to use
      this._ready = new BehaviorSubject/* BehaviorSubject */.X(null);
      this.ready = this._ready.asObservable().pipe((0,filter/* filter */.h)(hljs => !!hljs), (0,map/* map */.U)(hljs => hljs), (0,take/* take */.q)(1));
      // Check if hljs is already available
      if ((0,common_js_.isPlatformBrowser)(platformId) && doc.defaultView.hljs) {
        this._ready.next(doc.defaultView.hljs);
      } else {
        // Load hljs library
        this._loadLibrary().pipe((0,switchMap/* switchMap */.w)(hljs => {
          if (this._options && this._options.lineNumbersLoader) {
            // Make hljs available on window object (required for the line numbers library)
            doc.defaultView.hljs = hljs;
            // Load line numbers library
            return this.loadLineNumbers().pipe((0,tap/* tap */.b)(() => this._ready.next(hljs)));
          } else {
            this._ready.next(hljs);
            return empty/* EMPTY */.E;
          }
        }), (0,catchError/* catchError */.K)(e => {
          console.error('[HLJS] ', e);
          return empty/* EMPTY */.E;
        })).subscribe();
      }
    }
    /**
     * Lazy-Load highlight.js library
     */
    _loadLibrary() {
      if (this._options) {
        if (this._options.fullLibraryLoader && this._options.coreLibraryLoader) {
          return (0,throwError/* throwError */._)('The full library and the core library were imported, only one of them should be imported!');
        }
        if (this._options.fullLibraryLoader && this._options.languages) {
          return (0,throwError/* throwError */._)('The highlighting languages were imported they are not needed!');
        }
        if (this._options.coreLibraryLoader && !this._options.languages) {
          return (0,throwError/* throwError */._)('The highlighting languages were not imported!');
        }
        if (!this._options.coreLibraryLoader && this._options.languages) {
          return (0,throwError/* throwError */._)('The core library was not imported!');
        }
        if (this._options.fullLibraryLoader) {
          return this.loadFullLibrary();
        }
        if (this._options.coreLibraryLoader && this._options.languages && Object.keys(this._options.languages).length) {
          return this.loadCoreLibrary().pipe((0,switchMap/* switchMap */.w)(hljs => this._loadLanguages(hljs)));
        }
      }
      return (0,throwError/* throwError */._)('Highlight.js library was not imported!');
    }
    /**
     * Lazy-load highlight.js languages
     */
    _loadLanguages(hljs) {
      const languages = Object.entries(this._options.languages).map(([langName, langLoader]) => importModule(langLoader()).pipe((0,tap/* tap */.b)(langFunc => hljs.registerLanguage(langName, langFunc))));
      return zip(...languages).pipe((0,map/* map */.U)(() => hljs));
    }
    /**
     * Import highlight.js core library
     */
    loadCoreLibrary() {
      return importModule(this._options.coreLibraryLoader());
    }
    /**
     * Import highlight.js library with all languages
     */
    loadFullLibrary() {
      return importModule(this._options.fullLibraryLoader());
    }
    /**
     * Import line numbers library
     */
    loadLineNumbers() {
      return importModule(this._options.lineNumbersLoader());
    }
  }
  HighlightLoader.ɵfac = function HighlightLoader_Factory(t) {
    return new (t || HighlightLoader)(core_js_["ɵɵinject"](common_js_.DOCUMENT), core_js_["ɵɵinject"](core_js_.PLATFORM_ID), core_js_["ɵɵinject"](HIGHLIGHT_OPTIONS, 8));
  };
  HighlightLoader.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function HighlightLoader_Factory() {
      return new HighlightLoader((0,core_js_["ɵɵinject"])(common_js_.DOCUMENT), (0,core_js_["ɵɵinject"])(core_js_.PLATFORM_ID), (0,core_js_["ɵɵinject"])(HIGHLIGHT_OPTIONS, 8));
    },
    token: HighlightLoader,
    providedIn: "root"
  });
  return HighlightLoader;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * Map loader response to module object
 */
const importModule = moduleLoader => {
  return (0,from/* from */.D)(moduleLoader).pipe((0,filter/* filter */.h)(module => !!module && !!module.default), (0,map/* map */.U)(module => module.default));
};
const ɵ0 = (/* unused pure expression or super */ null && (importModule));
let HighlightJS = /*#__PURE__*/(() => {
  class HighlightJS {
    constructor(_loader, options) {
      this._loader = _loader;
      this._hljs = null;
      // Load highlight.js library on init
      _loader.ready.pipe().subscribe(hljs => {
        this._hljs = hljs;
        if (options && options.config) {
          // Set global config if present
          hljs.configure(options.config);
          if (hljs.listLanguages().length < 1) {
            console.error('[HighlightJS]: No languages were registered!');
          }
        }
      });
    }
    // A reference for hljs library
    get hljs() {
      return this._hljs;
    }
    /**
     * Core highlighting function.
     * @param name Accepts a language name, or an alias
     * @param value A string with the code to highlight.
     * @param ignore_illegals When present and evaluates to a true value, forces highlighting to finish
     * even in case of detecting illegal syntax for the language instead of throwing an exception.
     * @param continuation An optional mode stack representing unfinished parsing.
     * When present, the function will restart parsing from this state instead of initializing a new one
     */
    highlight(name, value, ignore_illegals, continuation) {
      return this._loader.ready.pipe((0,map/* map */.U)(hljs => hljs.highlight(name, value, ignore_illegals, continuation)));
    }
    /**
     * Highlighting with language detection.
     * @param value Accepts a string with the code to highlight
     * @param languageSubset An optional array of language names and aliases restricting detection to only those languages.
     * The subset can also be set with configure, but the local parameter overrides the option if set.
     */
    highlightAuto(value, languageSubset) {
      return this._loader.ready.pipe((0,map/* map */.U)(hljs => hljs.highlightAuto(value, languageSubset)));
    }
    /**
     * Post-processing of the highlighted markup.
     * Currently consists of replacing indentation TAB characters and using <br> tags instead of new-line characters.
     * Options are set globally with configure.
     * @param value Accepts a string with the highlighted markup
     */
    fixMarkup(value) {
      return this._loader.ready.pipe((0,map/* map */.U)(hljs => hljs.fixMarkup(value)));
    }
    /**
     * Applies highlighting to a DOM node containing code.
     * The function uses language detection by default but you can specify the language in the class attribute of the DOM node.
     * See the class reference for all available language names and aliases.
     * @param block The element to apply highlight on.
     */
    highlightBlock(block) {
      return this._loader.ready.pipe((0,map/* map */.U)(hljs => hljs.highlightBlock(block)));
    }
    /**
     * Configures global options:
     * @param config HighlightJs configuration argument
     */
    configure(config) {
      return this._loader.ready.pipe((0,map/* map */.U)(hljs => hljs.configure(config)));
    }
    /**
     * Applies highlighting to all <pre><code>..</code></pre> blocks on a page.
     */
    initHighlighting() {
      return this._loader.ready.pipe((0,map/* map */.U)(hljs => hljs.initHighlighting()));
    }
    /**
     * Adds new language to the library under the specified name. Used mostly internally.
     * @param name A string with the name of the language being registered
     * @param language A function that returns an object which represents the language definition.
     * The function is passed the hljs object to be able to use common regular expressions defined within it.
     */
    registerLanguage(name, language) {
      return this._loader.ready.pipe((0,tap/* tap */.b)(hljs => hljs.registerLanguage(name, language)));
    }
    /**
     * @return The languages names list.
     */
    listLanguages() {
      return this._loader.ready.pipe((0,map/* map */.U)(hljs => hljs.listLanguages()));
    }
    /**
     * Looks up a language by name or alias.
     * @param name Language name
     * @return The language object if found, undefined otherwise.
     */
    getLanguage(name) {
      return this._loader.ready.pipe((0,map/* map */.U)(hljs => hljs.getLanguage(name)));
    }
    /**
     * Display line numbers
     * @param el Code element
     */
    lineNumbersBlock(el) {
      return this._loader.ready.pipe((0,filter/* filter */.h)(hljs => !!hljs.lineNumbersBlock), (0,tap/* tap */.b)(hljs => hljs.lineNumbersBlock(el)));
    }
  }
  HighlightJS.ɵfac = function HighlightJS_Factory(t) {
    return new (t || HighlightJS)(core_js_["ɵɵinject"](HighlightLoader), core_js_["ɵɵinject"](HIGHLIGHT_OPTIONS, 8));
  };
  HighlightJS.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function HighlightJS_Factory() {
      return new HighlightJS((0,core_js_["ɵɵinject"])(HighlightLoader), (0,core_js_["ɵɵinject"])(HIGHLIGHT_OPTIONS, 8));
    },
    token: HighlightJS,
    providedIn: "root"
  });
  return HighlightJS;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
let Highlight = /*#__PURE__*/(() => {
  class Highlight {
    constructor(el, _hljs, _sanitizer, _options) {
      this._hljs = _hljs;
      this._sanitizer = _sanitizer;
      this._options = _options;
      // Stream that emits when code string is highlighted
      this.highlighted = new core_js_.EventEmitter();
      this._nativeElement = el.nativeElement;
    }
    ngOnChanges(changes) {
      if (this.code && changes.code && typeof changes.code.currentValue !== 'undefined' && changes.code.currentValue !== changes.code.previousValue) {
        this.highlightElement(this.code, this.languages);
      }
    }
    /**
     * Highlighting with language detection and fix markup.
     * @param code Accepts a string with the code to highlight
     * @param languages An optional array of language names and aliases restricting detection to only those languages.
     * The subset can also be set with configure, but the local parameter overrides the option if set.
     */
    highlightElement(code, languages) {
      // Set code text before highlighting
      this.setTextContent(code);
      this._hljs.highlightAuto(code, languages).subscribe(res => {
        // Set highlighted code
        this.setInnerHTML(res.value);
        // Check if user want to show line numbers
        if (this.lineNumbers && this._options && this._options.lineNumbersLoader) {
          this.addLineNumbers();
        }
        // Forward highlight response to the highlighted output
        this.highlighted.emit(res);
      });
    }
    addLineNumbers() {
      // Clean up line numbers observer
      this.destroyLineNumbersObserver();
      animationFrameScheduler.schedule(() => {
        // Add line numbers
        this._hljs.lineNumbersBlock(this._nativeElement).subscribe();
        // If lines count is 1, the line numbers library will not add numbers
        // Observe changes to add 'hljs-line-numbers' class only when line numbers is added to the code element
        this._lineNumbersObs = new MutationObserver(() => {
          if (this._nativeElement.firstElementChild && this._nativeElement.firstElementChild.tagName.toUpperCase() === 'TABLE') {
            this._nativeElement.classList.add('hljs-line-numbers');
          }
          this.destroyLineNumbersObserver();
        });
        this._lineNumbersObs.observe(this._nativeElement, {
          childList: true
        });
      });
    }
    destroyLineNumbersObserver() {
      if (this._lineNumbersObs) {
        this._lineNumbersObs.disconnect();
        this._lineNumbersObs = null;
      }
    }
    setTextContent(content) {
      animationFrameScheduler.schedule(() => this._nativeElement.textContent = content);
    }
    setInnerHTML(content) {
      animationFrameScheduler.schedule(() => this._nativeElement.innerHTML = this._sanitizer.sanitize(core_js_.SecurityContext.HTML, content) || '');
    }
  }
  Highlight.ɵfac = function Highlight_Factory(t) {
    return new (t || Highlight)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](HighlightJS), core_js_["ɵɵdirectiveInject"](platform_browser.DomSanitizer), core_js_["ɵɵdirectiveInject"](HIGHLIGHT_OPTIONS, 8));
  };
  Highlight.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: Highlight,
    selectors: [["", "highlight", ""]],
    hostVars: 2,
    hostBindings: function Highlight_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("hljs", true);
      }
    },
    inputs: {
      code: ["highlight", "code"],
      languages: "languages",
      lineNumbers: "lineNumbers"
    },
    outputs: {
      highlighted: "highlighted"
    },
    features: [core_js_["ɵɵNgOnChangesFeature"]]
  });
  return Highlight;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
let HighlightModule = /*#__PURE__*/(() => {
  class HighlightModule {}
  HighlightModule.ɵfac = function HighlightModule_Factory(t) {
    return new (t || HighlightModule)();
  };
  HighlightModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: HighlightModule
  });
  HighlightModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return HighlightModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](HighlightModule, {
    declarations: [Highlight],
    exports: [Highlight]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=ngx-highlightjs.js.map
;// CONCATENATED MODULE: ./apps/demo/src/app/app.module.ts













const HIGHLIGHT_OPTIONS_VALUE = {
  coreLibraryLoader: () => __webpack_require__.e(/* import() */ 856).then(__webpack_require__.t.bind(__webpack_require__, 7856, 23)),
  lineNumbersLoader: () => __webpack_require__.e(/* import() */ 22).then(__webpack_require__.t.bind(__webpack_require__, 9022, 23)),
  languages: {
    typescript: () => __webpack_require__.e(/* import() */ 433).then(__webpack_require__.t.bind(__webpack_require__, 2433, 23)),
    less: () => __webpack_require__.e(/* import() */ 257).then(__webpack_require__.t.bind(__webpack_require__, 6257, 23)),
    xml: () => __webpack_require__.e(/* import() */ 546).then(__webpack_require__.t.bind(__webpack_require__, 3546, 23))
  }
};
let AppModule = /*#__PURE__*/(() => {
  class AppModule {
    getEntryPoint() {
      return AppComponent;
    }
  }
  AppModule.ɵfac = function AppModule_Factory(t) {
    return new (t || AppModule)();
  };
  AppModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: AppModule,
    bootstrap: [AppComponent]
  });
  AppModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    providers: [{
      provide: taiga_ui_addon_doc/* TUI_DOC_LOGO */.Or,
      useValue: LOGO_CONTENT
    }, {
      provide: taiga_ui_addon_doc/* TUI_DOC_PAGES */.V5,
      useValue: pages
    }, {
      provide: HIGHLIGHT_OPTIONS,
      useValue: HIGHLIGHT_OPTIONS_VALUE
    }],
    imports: [[platform_browser.BrowserModule, BrowserAnimationsModule, taiga_ui_addon_doc/* TuiDocMainModule */.qn, taiga_ui_core_components_link/* TuiLinkModule */.j, GettingStartedModule, router_js_.RouterModule.forRoot(ROUTES, {
      initialNavigation: 'enabled'
    })]]
  });
  return AppModule;
})();
;// CONCATENATED MODULE: ./apps/demo/src/environments/environment.ts
const environment = {
  production: true
};
;// CONCATENATED MODULE: ./apps/demo/src/bootstrap.ts




if (environment.production) {
  (0,core_js_.enableProdMode)();
}
platform_browser.platformBrowser().bootstrapModule(AppModule).catch(err => console.error(err));

/***/ }),

/***/ 6083:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EY: () => (/* binding */ stagger),
/* harmony export */   IO: () => (/* binding */ query),
/* harmony export */   LC: () => (/* binding */ AnimationFactory),
/* harmony export */   X$: () => (/* binding */ trigger),
/* harmony export */   ZE: () => (/* binding */ AnimationGroupPlayer),
/* harmony export */   ZN: () => (/* binding */ NoopAnimationPlayer),
/* harmony export */   _j: () => (/* binding */ AnimationBuilder),
/* harmony export */   eR: () => (/* binding */ transition),
/* harmony export */   jt: () => (/* binding */ animate),
/* harmony export */   k1: () => (/* binding */ ɵPRE_STYLE),
/* harmony export */   l3: () => (/* binding */ AUTO_STYLE),
/* harmony export */   oB: () => (/* binding */ style),
/* harmony export */   pV: () => (/* binding */ animateChild),
/* harmony export */   vP: () => (/* binding */ sequence)
/* harmony export */ });
/* unused harmony exports animation, group, keyframes, state, useAnimation */
/**
 * @license Angular v12.2.17
 * (c) 2010-2021 Google LLC. https://angular.io/
 * License: MIT
 */

/**
 * An injectable service that produces an animation sequence programmatically within an
 * Angular component or directive.
 * Provided by the `BrowserAnimationsModule` or `NoopAnimationsModule`.
 *
 * @usageNotes
 *
 * To use this service, add it to your component or directive as a dependency.
 * The service is instantiated along with your component.
 *
 * Apps do not typically need to create their own animation players, but if you
 * do need to, follow these steps:
 *
 * 1. Use the `build()` method to create a programmatic animation using the
 * `animate()` function. The method returns an `AnimationFactory` instance.
 *
 * 2. Use the factory object to create an `AnimationPlayer` and attach it to a DOM element.
 *
 * 3. Use the player object to control the animation programmatically.
 *
 * For example:
 *
 * ```ts
 * // import the service from BrowserAnimationsModule
 * import {AnimationBuilder} from '@angular/animations';
 * // require the service as a dependency
 * class MyCmp {
 *   constructor(private _builder: AnimationBuilder) {}
 *
 *   makeAnimation(element: any) {
 *     // first define a reusable animation
 *     const myAnimation = this._builder.build([
 *       style({ width: 0 }),
 *       animate(1000, style({ width: '100px' }))
 *     ]);
 *
 *     // use the returned factory object to create a player
 *     const player = myAnimation.create(element);
 *
 *     player.play();
 *   }
 * }
 * ```
 *
 * @publicApi
 */
class AnimationBuilder {}
/**
 * A factory object returned from the `AnimationBuilder`.`build()` method.
 *
 * @publicApi
 */
class AnimationFactory {}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Specifies automatic styling.
 *
 * @publicApi
 */
const AUTO_STYLE = '*';
/**
 * Creates a named animation trigger, containing a  list of `state()`
 * and `transition()` entries to be evaluated when the expression
 * bound to the trigger changes.
 *
 * @param name An identifying string.
 * @param definitions  An animation definition object, containing an array of `state()`
 * and `transition()` declarations.
 *
 * @return An object that encapsulates the trigger data.
 *
 * @usageNotes
 * Define an animation trigger in the `animations` section of `@Component` metadata.
 * In the template, reference the trigger by name and bind it to a trigger expression that
 * evaluates to a defined animation state, using the following format:
 *
 * `[@triggerName]="expression"`
 *
 * Animation trigger bindings convert all values to strings, and then match the
 * previous and current values against any linked transitions.
 * Booleans can be specified as `1` or `true` and `0` or `false`.
 *
 * ### Usage Example
 *
 * The following example creates an animation trigger reference based on the provided
 * name value.
 * The provided animation value is expected to be an array consisting of state and
 * transition declarations.
 *
 * ```typescript
 * @Component({
 *   selector: "my-component",
 *   templateUrl: "my-component-tpl.html",
 *   animations: [
 *     trigger("myAnimationTrigger", [
 *       state(...),
 *       state(...),
 *       transition(...),
 *       transition(...)
 *     ])
 *   ]
 * })
 * class MyComponent {
 *   myStatusExp = "something";
 * }
 * ```
 *
 * The template associated with this component makes use of the defined trigger
 * by binding to an element within its template code.
 *
 * ```html
 * <!-- somewhere inside of my-component-tpl.html -->
 * <div [@myAnimationTrigger]="myStatusExp">...</div>
 * ```
 *
 * ### Using an inline function
 * The `transition` animation method also supports reading an inline function which can decide
 * if its associated animation should be run.
 *
 * ```typescript
 * // this method is run each time the `myAnimationTrigger` trigger value changes.
 * function myInlineMatcherFn(fromState: string, toState: string, element: any, params: {[key:
 string]: any}): boolean {
 *   // notice that `element` and `params` are also available here
 *   return toState == 'yes-please-animate';
 * }
 *
 * @Component({
 *   selector: 'my-component',
 *   templateUrl: 'my-component-tpl.html',
 *   animations: [
 *     trigger('myAnimationTrigger', [
 *       transition(myInlineMatcherFn, [
 *         // the animation sequence code
 *       ]),
 *     ])
 *   ]
 * })
 * class MyComponent {
 *   myStatusExp = "yes-please-animate";
 * }
 * ```
 *
 * ### Disabling Animations
 * When true, the special animation control binding `@.disabled` binding prevents
 * all animations from rendering.
 * Place the  `@.disabled` binding on an element to disable
 * animations on the element itself, as well as any inner animation triggers
 * within the element.
 *
 * The following example shows how to use this feature:
 *
 * ```typescript
 * @Component({
 *   selector: 'my-component',
 *   template: `
 *     <div [@.disabled]="isDisabled">
 *       <div [@childAnimation]="exp"></div>
 *     </div>
 *   `,
 *   animations: [
 *     trigger("childAnimation", [
 *       // ...
 *     ])
 *   ]
 * })
 * class MyComponent {
 *   isDisabled = true;
 *   exp = '...';
 * }
 * ```
 *
 * When `@.disabled` is true, it prevents the `@childAnimation` trigger from animating,
 * along with any inner animations.
 *
 * ### Disable animations application-wide
 * When an area of the template is set to have animations disabled,
 * **all** inner components have their animations disabled as well.
 * This means that you can disable all animations for an app
 * by placing a host binding set on `@.disabled` on the topmost Angular component.
 *
 * ```typescript
 * import {Component, HostBinding} from '@angular/core';
 *
 * @Component({
 *   selector: 'app-component',
 *   templateUrl: 'app.component.html',
 * })
 * class AppComponent {
 *   @HostBinding('@.disabled')
 *   public animationsDisabled = true;
 * }
 * ```
 *
 * ### Overriding disablement of inner animations
 * Despite inner animations being disabled, a parent animation can `query()`
 * for inner elements located in disabled areas of the template and still animate
 * them if needed. This is also the case for when a sub animation is
 * queried by a parent and then later animated using `animateChild()`.
 *
 * ### Detecting when an animation is disabled
 * If a region of the DOM (or the entire application) has its animations disabled, the animation
 * trigger callbacks still fire, but for zero seconds. When the callback fires, it provides
 * an instance of an `AnimationEvent`. If animations are disabled,
 * the `.disabled` flag on the event is true.
 *
 * @publicApi
 */
function trigger(name, definitions) {
  return {
    type: 7 /* Trigger */,
    name,
    definitions,
    options: {}
  };
}
/**
 * Defines an animation step that combines styling information with timing information.
 *
 * @param timings Sets `AnimateTimings` for the parent animation.
 * A string in the format "duration [delay] [easing]".
 *  - Duration and delay are expressed as a number and optional time unit,
 * such as "1s" or "10ms" for one second and 10 milliseconds, respectively.
 * The default unit is milliseconds.
 *  - The easing value controls how the animation accelerates and decelerates
 * during its runtime. Value is one of  `ease`, `ease-in`, `ease-out`,
 * `ease-in-out`, or a `cubic-bezier()` function call.
 * If not supplied, no easing is applied.
 *
 * For example, the string "1s 100ms ease-out" specifies a duration of
 * 1000 milliseconds, and delay of 100 ms, and the "ease-out" easing style,
 * which decelerates near the end of the duration.
 * @param styles Sets AnimationStyles for the parent animation.
 * A function call to either `style()` or `keyframes()`
 * that returns a collection of CSS style entries to be applied to the parent animation.
 * When null, uses the styles from the destination state.
 * This is useful when describing an animation step that will complete an animation;
 * see "Animating to the final state" in `transitions()`.
 * @returns An object that encapsulates the animation step.
 *
 * @usageNotes
 * Call within an animation `sequence()`, `{@link animations/group group()}`, or
 * `transition()` call to specify an animation step
 * that applies given style data to the parent animation for a given amount of time.
 *
 * ### Syntax Examples
 * **Timing examples**
 *
 * The following examples show various `timings` specifications.
 * - `animate(500)` : Duration is 500 milliseconds.
 * - `animate("1s")` : Duration is 1000 milliseconds.
 * - `animate("100ms 0.5s")` : Duration is 100 milliseconds, delay is 500 milliseconds.
 * - `animate("5s ease-in")` : Duration is 5000 milliseconds, easing in.
 * - `animate("5s 10ms cubic-bezier(.17,.67,.88,.1)")` : Duration is 5000 milliseconds, delay is 10
 * milliseconds, easing according to a bezier curve.
 *
 * **Style examples**
 *
 * The following example calls `style()` to set a single CSS style.
 * ```typescript
 * animate(500, style({ background: "red" }))
 * ```
 * The following example calls `keyframes()` to set a CSS style
 * to different values for successive keyframes.
 * ```typescript
 * animate(500, keyframes(
 *  [
 *   style({ background: "blue" }),
 *   style({ background: "red" })
 *  ])
 * ```
 *
 * @publicApi
 */
function animate(timings, styles = null) {
  return {
    type: 4 /* Animate */,
    styles,
    timings
  };
}
/**
 * @description Defines a list of animation steps to be run in parallel.
 *
 * @param steps An array of animation step objects.
 * - When steps are defined by `style()` or `animate()`
 * function calls, each call within the group is executed instantly.
 * - To specify offset styles to be applied at a later time, define steps with
 * `keyframes()`, or use `animate()` calls with a delay value.
 * For example:
 *
 * ```typescript
 * group([
 *   animate("1s", style({ background: "black" })),
 *   animate("2s", style({ color: "white" }))
 * ])
 * ```
 *
 * @param options An options object containing a delay and
 * developer-defined parameters that provide styling defaults and
 * can be overridden on invocation.
 *
 * @return An object that encapsulates the group data.
 *
 * @usageNotes
 * Grouped animations are useful when a series of styles must be
 * animated at different starting times and closed off at different ending times.
 *
 * When called within a `sequence()` or a
 * `transition()` call, does not continue to the next
 * instruction until all of the inner animation steps have completed.
 *
 * @publicApi
 */
function group(steps, options = null) {
  return {
    type: 3 /* Group */,
    steps,
    options
  };
}
/**
 * Defines a list of animation steps to be run sequentially, one by one.
 *
 * @param steps An array of animation step objects.
 * - Steps defined by `style()` calls apply the styling data immediately.
 * - Steps defined by `animate()` calls apply the styling data over time
 *   as specified by the timing data.
 *
 * ```typescript
 * sequence([
 *   style({ opacity: 0 }),
 *   animate("1s", style({ opacity: 1 }))
 * ])
 * ```
 *
 * @param options An options object containing a delay and
 * developer-defined parameters that provide styling defaults and
 * can be overridden on invocation.
 *
 * @return An object that encapsulates the sequence data.
 *
 * @usageNotes
 * When you pass an array of steps to a
 * `transition()` call, the steps run sequentially by default.
 * Compare this to the `{@link animations/group group()}` call, which runs animation steps in
 *parallel.
 *
 * When a sequence is used within a `{@link animations/group group()}` or a `transition()` call,
 * execution continues to the next instruction only after each of the inner animation
 * steps have completed.
 *
 * @publicApi
 **/
function sequence(steps, options = null) {
  return {
    type: 2 /* Sequence */,
    steps,
    options
  };
}
/**
 * Declares a key/value object containing CSS properties/styles that
 * can then be used for an animation `state`, within an animation `sequence`,
 * or as styling data for calls to `animate()` and `keyframes()`.
 *
 * @param tokens A set of CSS styles or HTML styles associated with an animation state.
 * The value can be any of the following:
 * - A key-value style pair associating a CSS property with a value.
 * - An array of key-value style pairs.
 * - An asterisk (*), to use auto-styling, where styles are derived from the element
 * being animated and applied to the animation when it starts.
 *
 * Auto-styling can be used to define a state that depends on layout or other
 * environmental factors.
 *
 * @return An object that encapsulates the style data.
 *
 * @usageNotes
 * The following examples create animation styles that collect a set of
 * CSS property values:
 *
 * ```typescript
 * // string values for CSS properties
 * style({ background: "red", color: "blue" })
 *
 * // numerical pixel values
 * style({ width: 100, height: 0 })
 * ```
 *
 * The following example uses auto-styling to allow a component to animate from
 * a height of 0 up to the height of the parent element:
 *
 * ```
 * style({ height: 0 }),
 * animate("1s", style({ height: "*" }))
 * ```
 *
 * @publicApi
 **/
function style(tokens) {
  return {
    type: 6 /* Style */,
    styles: tokens,
    offset: null
  };
}
/**
 * Declares an animation state within a trigger attached to an element.
 *
 * @param name One or more names for the defined state in a comma-separated string.
 * The following reserved state names can be supplied to define a style for specific use
 * cases:
 *
 * - `void` You can associate styles with this name to be used when
 * the element is detached from the application. For example, when an `ngIf` evaluates
 * to false, the state of the associated element is void.
 *  - `*` (asterisk) Indicates the default state. You can associate styles with this name
 * to be used as the fallback when the state that is being animated is not declared
 * within the trigger.
 *
 * @param styles A set of CSS styles associated with this state, created using the
 * `style()` function.
 * This set of styles persists on the element once the state has been reached.
 * @param options Parameters that can be passed to the state when it is invoked.
 * 0 or more key-value pairs.
 * @return An object that encapsulates the new state data.
 *
 * @usageNotes
 * Use the `trigger()` function to register states to an animation trigger.
 * Use the `transition()` function to animate between states.
 * When a state is active within a component, its associated styles persist on the element,
 * even when the animation ends.
 *
 * @publicApi
 **/
function state(name, styles, options) {
  return {
    type: 0 /* State */,
    name,
    styles,
    options
  };
}
/**
 * Defines a set of animation styles, associating each style with an optional `offset` value.
 *
 * @param steps A set of animation styles with optional offset data.
 * The optional `offset` value for a style specifies a percentage of the total animation
 * time at which that style is applied.
 * @returns An object that encapsulates the keyframes data.
 *
 * @usageNotes
 * Use with the `animate()` call. Instead of applying animations
 * from the current state
 * to the destination state, keyframes describe how each style entry is applied and at what point
 * within the animation arc.
 * Compare [CSS Keyframe Animations](https://www.w3schools.com/css/css3_animations.asp).
 *
 * ### Usage
 *
 * In the following example, the offset values describe
 * when each `backgroundColor` value is applied. The color is red at the start, and changes to
 * blue when 20% of the total time has elapsed.
 *
 * ```typescript
 * // the provided offset values
 * animate("5s", keyframes([
 *   style({ backgroundColor: "red", offset: 0 }),
 *   style({ backgroundColor: "blue", offset: 0.2 }),
 *   style({ backgroundColor: "orange", offset: 0.3 }),
 *   style({ backgroundColor: "black", offset: 1 })
 * ]))
 * ```
 *
 * If there are no `offset` values specified in the style entries, the offsets
 * are calculated automatically.
 *
 * ```typescript
 * animate("5s", keyframes([
 *   style({ backgroundColor: "red" }) // offset = 0
 *   style({ backgroundColor: "blue" }) // offset = 0.33
 *   style({ backgroundColor: "orange" }) // offset = 0.66
 *   style({ backgroundColor: "black" }) // offset = 1
 * ]))
 *```

 * @publicApi
 */
function keyframes(steps) {
  return {
    type: 5 /* Keyframes */,
    steps
  };
}
/**
 * Declares an animation transition as a sequence of animation steps to run when a given
 * condition is satisfied. The condition is a Boolean expression or function that compares
 * the previous and current animation states, and returns true if this transition should occur.
 * When the state criteria of a defined transition are met, the associated animation is
 * triggered.
 *
 * @param stateChangeExpr A Boolean expression or function that compares the previous and current
 * animation states, and returns true if this transition should occur. Note that  "true" and "false"
 * match 1 and 0, respectively. An expression is evaluated each time a state change occurs in the
 * animation trigger element.
 * The animation steps run when the expression evaluates to true.
 *
 * - A state-change string takes the form "state1 => state2", where each side is a defined animation
 * state, or an asterix (*) to refer to a dynamic start or end state.
 *   - The expression string can contain multiple comma-separated statements;
 * for example "state1 => state2, state3 => state4".
 *   - Special values `:enter` and `:leave` initiate a transition on the entry and exit states,
 * equivalent to  "void => *"  and "* => void".
 *   - Special values `:increment` and `:decrement` initiate a transition when a numeric value has
 * increased or decreased in value.
 * - A function is executed each time a state change occurs in the animation trigger element.
 * The animation steps run when the function returns true.
 *
 * @param steps One or more animation objects, as returned by the `animate()` or
 * `sequence()` function, that form a transformation from one state to another.
 * A sequence is used by default when you pass an array.
 * @param options An options object that can contain a delay value for the start of the animation,
 * and additional developer-defined parameters. Provided values for additional parameters are used
 * as defaults, and override values can be passed to the caller on invocation.
 * @returns An object that encapsulates the transition data.
 *
 * @usageNotes
 * The template associated with a component binds an animation trigger to an element.
 *
 * ```HTML
 * <!-- somewhere inside of my-component-tpl.html -->
 * <div [@myAnimationTrigger]="myStatusExp">...</div>
 * ```
 *
 * All transitions are defined within an animation trigger,
 * along with named states that the transitions change to and from.
 *
 * ```typescript
 * trigger("myAnimationTrigger", [
 *  // define states
 *  state("on", style({ background: "green" })),
 *  state("off", style({ background: "grey" })),
 *  ...]
 * ```
 *
 * Note that when you call the `sequence()` function within a `{@link animations/group group()}`
 * or a `transition()` call, execution does not continue to the next instruction
 * until each of the inner animation steps have completed.
 *
 * ### Syntax examples
 *
 * The following examples define transitions between the two defined states (and default states),
 * using various options:
 *
 * ```typescript
 * // Transition occurs when the state value
 * // bound to "myAnimationTrigger" changes from "on" to "off"
 * transition("on => off", animate(500))
 * // Run the same animation for both directions
 * transition("on <=> off", animate(500))
 * // Define multiple state-change pairs separated by commas
 * transition("on => off, off => void", animate(500))
 * ```
 *
 * ### Special values for state-change expressions
 *
 * - Catch-all state change for when an element is inserted into the page and the
 * destination state is unknown:
 *
 * ```typescript
 * transition("void => *", [
 *  style({ opacity: 0 }),
 *  animate(500)
 *  ])
 * ```
 *
 * - Capture a state change between any states:
 *
 *  `transition("* => *", animate("1s 0s"))`
 *
 * - Entry and exit transitions:
 *
 * ```typescript
 * transition(":enter", [
 *   style({ opacity: 0 }),
 *   animate(500, style({ opacity: 1 }))
 *   ]),
 * transition(":leave", [
 *   animate(500, style({ opacity: 0 }))
 *   ])
 * ```
 *
 * - Use `:increment` and `:decrement` to initiate transitions:
 *
 * ```typescript
 * transition(":increment", group([
 *  query(':enter', [
 *     style({ left: '100%' }),
 *     animate('0.5s ease-out', style('*'))
 *   ]),
 *  query(':leave', [
 *     animate('0.5s ease-out', style({ left: '-100%' }))
 *  ])
 * ]))
 *
 * transition(":decrement", group([
 *  query(':enter', [
 *     style({ left: '100%' }),
 *     animate('0.5s ease-out', style('*'))
 *   ]),
 *  query(':leave', [
 *     animate('0.5s ease-out', style({ left: '-100%' }))
 *  ])
 * ]))
 * ```
 *
 * ### State-change functions
 *
 * Here is an example of a `fromState` specified as a state-change function that invokes an
 * animation when true:
 *
 * ```typescript
 * transition((fromState, toState) =>
 *  {
 *   return fromState == "off" && toState == "on";
 *  },
 *  animate("1s 0s"))
 * ```
 *
 * ### Animating to the final state
 *
 * If the final step in a transition is a call to `animate()` that uses a timing value
 * with no style data, that step is automatically considered the final animation arc,
 * for the element to reach the final state. Angular automatically adds or removes
 * CSS styles to ensure that the element is in the correct final state.
 *
 * The following example defines a transition that starts by hiding the element,
 * then makes sure that it animates properly to whatever state is currently active for trigger:
 *
 * ```typescript
 * transition("void => *", [
 *   style({ opacity: 0 }),
 *   animate(500)
 *  ])
 * ```
 * ### Boolean value matching
 * If a trigger binding value is a Boolean, it can be matched using a transition expression
 * that compares true and false or 1 and 0. For example:
 *
 * ```
 * // in the template
 * <div [@openClose]="open ? true : false">...</div>
 * // in the component metadata
 * trigger('openClose', [
 *   state('true', style({ height: '*' })),
 *   state('false', style({ height: '0px' })),
 *   transition('false <=> true', animate(500))
 * ])
 * ```
 *
 * @publicApi
 **/
function transition(stateChangeExpr, steps, options = null) {
  return {
    type: 1 /* Transition */,
    expr: stateChangeExpr,
    animation: steps,
    options
  };
}
/**
 * Produces a reusable animation that can be invoked in another animation or sequence,
 * by calling the `useAnimation()` function.
 *
 * @param steps One or more animation objects, as returned by the `animate()`
 * or `sequence()` function, that form a transformation from one state to another.
 * A sequence is used by default when you pass an array.
 * @param options An options object that can contain a delay value for the start of the
 * animation, and additional developer-defined parameters.
 * Provided values for additional parameters are used as defaults,
 * and override values can be passed to the caller on invocation.
 * @returns An object that encapsulates the animation data.
 *
 * @usageNotes
 * The following example defines a reusable animation, providing some default parameter
 * values.
 *
 * ```typescript
 * var fadeAnimation = animation([
 *   style({ opacity: '{{ start }}' }),
 *   animate('{{ time }}',
 *   style({ opacity: '{{ end }}'}))
 *   ],
 *   { params: { time: '1000ms', start: 0, end: 1 }});
 * ```
 *
 * The following invokes the defined animation with a call to `useAnimation()`,
 * passing in override parameter values.
 *
 * ```js
 * useAnimation(fadeAnimation, {
 *   params: {
 *     time: '2s',
 *     start: 1,
 *     end: 0
 *   }
 * })
 * ```
 *
 * If any of the passed-in parameter values are missing from this call,
 * the default values are used. If one or more parameter values are missing before a step is
 * animated, `useAnimation()` throws an error.
 *
 * @publicApi
 */
function animation(steps, options = null) {
  return {
    type: 8 /* Reference */,
    animation: steps,
    options
  };
}
/**
 * Executes a queried inner animation element within an animation sequence.
 *
 * @param options An options object that can contain a delay value for the start of the
 * animation, and additional override values for developer-defined parameters.
 * @return An object that encapsulates the child animation data.
 *
 * @usageNotes
 * Each time an animation is triggered in Angular, the parent animation
 * has priority and any child animations are blocked. In order
 * for a child animation to run, the parent animation must query each of the elements
 * containing child animations, and run them using this function.
 *
 * Note that this feature is designed to be used with `query()` and it will only work
 * with animations that are assigned using the Angular animation library. CSS keyframes
 * and transitions are not handled by this API.
 *
 * @publicApi
 */
function animateChild(options = null) {
  return {
    type: 9 /* AnimateChild */,
    options
  };
}
/**
 * Starts a reusable animation that is created using the `animation()` function.
 *
 * @param animation The reusable animation to start.
 * @param options An options object that can contain a delay value for the start of
 * the animation, and additional override values for developer-defined parameters.
 * @return An object that contains the animation parameters.
 *
 * @publicApi
 */
function useAnimation(animation, options = null) {
  return {
    type: 10 /* AnimateRef */,
    animation,
    options
  };
}
/**
 * Finds one or more inner elements within the current element that is
 * being animated within a sequence. Use with `animate()`.
 *
 * @param selector The element to query, or a set of elements that contain Angular-specific
 * characteristics, specified with one or more of the following tokens.
 *  - `query(":enter")` or `query(":leave")` : Query for newly inserted/removed elements.
 *  - `query(":animating")` : Query all currently animating elements.
 *  - `query("@triggerName")` : Query elements that contain an animation trigger.
 *  - `query("@*")` : Query all elements that contain an animation triggers.
 *  - `query(":self")` : Include the current element into the animation sequence.
 *
 * @param animation One or more animation steps to apply to the queried element or elements.
 * An array is treated as an animation sequence.
 * @param options An options object. Use the 'limit' field to limit the total number of
 * items to collect.
 * @return An object that encapsulates the query data.
 *
 * @usageNotes
 * Tokens can be merged into a combined query selector string. For example:
 *
 * ```typescript
 *  query(':self, .record:enter, .record:leave, @subTrigger', [...])
 * ```
 *
 * The `query()` function collects multiple elements and works internally by using
 * `element.querySelectorAll`. Use the `limit` field of an options object to limit
 * the total number of items to be collected. For example:
 *
 * ```js
 * query('div', [
 *   animate(...),
 *   animate(...)
 * ], { limit: 1 })
 * ```
 *
 * By default, throws an error when zero items are found. Set the
 * `optional` flag to ignore this error. For example:
 *
 * ```js
 * query('.some-element-that-may-not-be-there', [
 *   animate(...),
 *   animate(...)
 * ], { optional: true })
 * ```
 *
 * ### Usage Example
 *
 * The following example queries for inner elements and animates them
 * individually using `animate()`.
 *
 * ```typescript
 * @Component({
 *   selector: 'inner',
 *   template: `
 *     <div [@queryAnimation]="exp">
 *       <h1>Title</h1>
 *       <div class="content">
 *         Blah blah blah
 *       </div>
 *     </div>
 *   `,
 *   animations: [
 *    trigger('queryAnimation', [
 *      transition('* => goAnimate', [
 *        // hide the inner elements
 *        query('h1', style({ opacity: 0 })),
 *        query('.content', style({ opacity: 0 })),
 *
 *        // animate the inner elements in, one by one
 *        query('h1', animate(1000, style({ opacity: 1 }))),
 *        query('.content', animate(1000, style({ opacity: 1 }))),
 *      ])
 *    ])
 *  ]
 * })
 * class Cmp {
 *   exp = '';
 *
 *   goAnimate() {
 *     this.exp = 'goAnimate';
 *   }
 * }
 * ```
 *
 * @publicApi
 */
function query(selector, animation, options = null) {
  return {
    type: 11 /* Query */,
    selector,
    animation,
    options
  };
}
/**
 * Use within an animation `query()` call to issue a timing gap after
 * each queried item is animated.
 *
 * @param timings A delay value.
 * @param animation One ore more animation steps.
 * @returns An object that encapsulates the stagger data.
 *
 * @usageNotes
 * In the following example, a container element wraps a list of items stamped out
 * by an `ngFor`. The container element contains an animation trigger that will later be set
 * to query for each of the inner items.
 *
 * Each time items are added, the opacity fade-in animation runs,
 * and each removed item is faded out.
 * When either of these animations occur, the stagger effect is
 * applied after each item's animation is started.
 *
 * ```html
 * <!-- list.component.html -->
 * <button (click)="toggle()">Show / Hide Items</button>
 * <hr />
 * <div [@listAnimation]="items.length">
 *   <div *ngFor="let item of items">
 *     {{ item }}
 *   </div>
 * </div>
 * ```
 *
 * Here is the component code:
 *
 * ```typescript
 * import {trigger, transition, style, animate, query, stagger} from '@angular/animations';
 * @Component({
 *   templateUrl: 'list.component.html',
 *   animations: [
 *     trigger('listAnimation', [
 *     ...
 *     ])
 *   ]
 * })
 * class ListComponent {
 *   items = [];
 *
 *   showItems() {
 *     this.items = [0,1,2,3,4];
 *   }
 *
 *   hideItems() {
 *     this.items = [];
 *   }
 *
 *   toggle() {
 *     this.items.length ? this.hideItems() : this.showItems();
 *    }
 *  }
 * ```
 *
 * Here is the animation trigger code:
 *
 * ```typescript
 * trigger('listAnimation', [
 *   transition('* => *', [ // each time the binding value changes
 *     query(':leave', [
 *       stagger(100, [
 *         animate('0.5s', style({ opacity: 0 }))
 *       ])
 *     ]),
 *     query(':enter', [
 *       style({ opacity: 0 }),
 *       stagger(100, [
 *         animate('0.5s', style({ opacity: 1 }))
 *       ])
 *     ])
 *   ])
 * ])
 * ```
 *
 * @publicApi
 */
function stagger(timings, animation) {
  return {
    type: 12 /* Stagger */,
    timings,
    animation
  };
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function scheduleMicroTask(cb) {
  Promise.resolve(null).then(cb);
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * An empty programmatic controller for reusable animations.
 * Used internally when animations are disabled, to avoid
 * checking for the null case when an animation player is expected.
 *
 * @see `animate()`
 * @see `AnimationPlayer`
 * @see `GroupPlayer`
 *
 * @publicApi
 */
class NoopAnimationPlayer {
  constructor(duration = 0, delay = 0) {
    this._onDoneFns = [];
    this._onStartFns = [];
    this._onDestroyFns = [];
    this._started = false;
    this._destroyed = false;
    this._finished = false;
    this._position = 0;
    this.parentPlayer = null;
    this.totalTime = duration + delay;
  }
  _onFinish() {
    if (!this._finished) {
      this._finished = true;
      this._onDoneFns.forEach(fn => fn());
      this._onDoneFns = [];
    }
  }
  onStart(fn) {
    this._onStartFns.push(fn);
  }
  onDone(fn) {
    this._onDoneFns.push(fn);
  }
  onDestroy(fn) {
    this._onDestroyFns.push(fn);
  }
  hasStarted() {
    return this._started;
  }
  init() {}
  play() {
    if (!this.hasStarted()) {
      this._onStart();
      this.triggerMicrotask();
    }
    this._started = true;
  }
  /** @internal */
  triggerMicrotask() {
    scheduleMicroTask(() => this._onFinish());
  }
  _onStart() {
    this._onStartFns.forEach(fn => fn());
    this._onStartFns = [];
  }
  pause() {}
  restart() {}
  finish() {
    this._onFinish();
  }
  destroy() {
    if (!this._destroyed) {
      this._destroyed = true;
      if (!this.hasStarted()) {
        this._onStart();
      }
      this.finish();
      this._onDestroyFns.forEach(fn => fn());
      this._onDestroyFns = [];
    }
  }
  reset() {
    this._started = false;
  }
  setPosition(position) {
    this._position = this.totalTime ? position * this.totalTime : 1;
  }
  getPosition() {
    return this.totalTime ? this._position / this.totalTime : 1;
  }
  /** @internal */
  triggerCallback(phaseName) {
    const methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;
    methods.forEach(fn => fn());
    methods.length = 0;
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A programmatic controller for a group of reusable animations.
 * Used internally to control animations.
 *
 * @see `AnimationPlayer`
 * @see `{@link animations/group group()}`
 *
 */
class AnimationGroupPlayer {
  constructor(_players) {
    this._onDoneFns = [];
    this._onStartFns = [];
    this._finished = false;
    this._started = false;
    this._destroyed = false;
    this._onDestroyFns = [];
    this.parentPlayer = null;
    this.totalTime = 0;
    this.players = _players;
    let doneCount = 0;
    let destroyCount = 0;
    let startCount = 0;
    const total = this.players.length;
    if (total == 0) {
      scheduleMicroTask(() => this._onFinish());
    } else {
      this.players.forEach(player => {
        player.onDone(() => {
          if (++doneCount == total) {
            this._onFinish();
          }
        });
        player.onDestroy(() => {
          if (++destroyCount == total) {
            this._onDestroy();
          }
        });
        player.onStart(() => {
          if (++startCount == total) {
            this._onStart();
          }
        });
      });
    }
    this.totalTime = this.players.reduce((time, player) => Math.max(time, player.totalTime), 0);
  }
  _onFinish() {
    if (!this._finished) {
      this._finished = true;
      this._onDoneFns.forEach(fn => fn());
      this._onDoneFns = [];
    }
  }
  init() {
    this.players.forEach(player => player.init());
  }
  onStart(fn) {
    this._onStartFns.push(fn);
  }
  _onStart() {
    if (!this.hasStarted()) {
      this._started = true;
      this._onStartFns.forEach(fn => fn());
      this._onStartFns = [];
    }
  }
  onDone(fn) {
    this._onDoneFns.push(fn);
  }
  onDestroy(fn) {
    this._onDestroyFns.push(fn);
  }
  hasStarted() {
    return this._started;
  }
  play() {
    if (!this.parentPlayer) {
      this.init();
    }
    this._onStart();
    this.players.forEach(player => player.play());
  }
  pause() {
    this.players.forEach(player => player.pause());
  }
  restart() {
    this.players.forEach(player => player.restart());
  }
  finish() {
    this._onFinish();
    this.players.forEach(player => player.finish());
  }
  destroy() {
    this._onDestroy();
  }
  _onDestroy() {
    if (!this._destroyed) {
      this._destroyed = true;
      this._onFinish();
      this.players.forEach(player => player.destroy());
      this._onDestroyFns.forEach(fn => fn());
      this._onDestroyFns = [];
    }
  }
  reset() {
    this.players.forEach(player => player.reset());
    this._destroyed = false;
    this._finished = false;
    this._started = false;
  }
  setPosition(p) {
    const timeAtPosition = p * this.totalTime;
    this.players.forEach(player => {
      const position = player.totalTime ? Math.min(1, timeAtPosition / player.totalTime) : 1;
      player.setPosition(position);
    });
  }
  getPosition() {
    const longestPlayer = this.players.reduce((longestSoFar, player) => {
      const newPlayerIsLongest = longestSoFar === null || player.totalTime > longestSoFar.totalTime;
      return newPlayerIsLongest ? player : longestSoFar;
    }, null);
    return longestPlayer != null ? longestPlayer.getPosition() : 0;
  }
  beforeDestroy() {
    this.players.forEach(player => {
      if (player.beforeDestroy) {
        player.beforeDestroy();
      }
    });
  }
  /** @internal */
  triggerCallback(phaseName) {
    const methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;
    methods.forEach(fn => fn());
    methods.length = 0;
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const ɵPRE_STYLE = '!';

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=animations.js.map

/***/ }),

/***/ 9221:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ar: () => (/* binding */ WebAnimationsStyleNormalizer),
/* harmony export */   DT: () => (/* binding */ WebAnimationsDriver),
/* harmony export */   NH: () => (/* binding */ AnimationStyleNormalizer),
/* harmony export */   QN: () => (/* binding */ supportsWebAnimations),
/* harmony export */   Th: () => (/* binding */ AnimationEngine),
/* harmony export */   Vi: () => (/* binding */ AnimationDriver),
/* harmony export */   nV: () => (/* binding */ NoopAnimationDriver),
/* harmony export */   uL: () => (/* binding */ CssKeyframesDriver)
/* harmony export */ });
/* unused harmony exports ɵAnimation, ɵCssKeyframesPlayer, ɵNoopAnimationStyleNormalizer, ɵWebAnimationsPlayer, ɵallowPreviousPlayerStylesMerge, ɵangular_packages_animations_browser_browser_a, ɵcontainsElement, ɵinvokeQuery, ɵmatchesElement, ɵvalidateStyleProperty */
/* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6083);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @license Angular v12.2.17
 * (c) 2010-2021 Google LLC. https://angular.io/
 * License: MIT
 */




/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

function isBrowser() {
  return typeof window !== 'undefined' && typeof window.document !== 'undefined';
}
function isNode() {
  // Checking only for `process` isn't enough to identify whether or not we're in a Node
  // environment, because Webpack by default will polyfill the `process`. While we can discern
  // that Webpack polyfilled it by looking at `process.browser`, it's very Webpack-specific and
  // might not be future-proof. Instead we look at the stringified version of `process` which
  // is `[object process]` in Node and `[object Object]` when polyfilled.
  return typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
}
function optimizeGroupPlayer(players) {
  switch (players.length) {
    case 0:
      return new _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .NoopAnimationPlayer */ .ZN();
    case 1:
      return players[0];
    default:
      return new _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* ["ɵAnimationGroupPlayer"] */ .ZE(players);
  }
}
function normalizeKeyframes(driver, normalizer, element, keyframes, preStyles = {}, postStyles = {}) {
  const errors = [];
  const normalizedKeyframes = [];
  let previousOffset = -1;
  let previousKeyframe = null;
  keyframes.forEach(kf => {
    const offset = kf['offset'];
    const isSameOffset = offset == previousOffset;
    const normalizedKeyframe = isSameOffset && previousKeyframe || {};
    Object.keys(kf).forEach(prop => {
      let normalizedProp = prop;
      let normalizedValue = kf[prop];
      if (prop !== 'offset') {
        normalizedProp = normalizer.normalizePropertyName(normalizedProp, errors);
        switch (normalizedValue) {
          case _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* ["ɵPRE_STYLE"] */ .k1:
            normalizedValue = preStyles[prop];
            break;
          case _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .AUTO_STYLE */ .l3:
            normalizedValue = postStyles[prop];
            break;
          default:
            normalizedValue = normalizer.normalizeStyleValue(prop, normalizedProp, normalizedValue, errors);
            break;
        }
      }
      normalizedKeyframe[normalizedProp] = normalizedValue;
    });
    if (!isSameOffset) {
      normalizedKeyframes.push(normalizedKeyframe);
    }
    previousKeyframe = normalizedKeyframe;
    previousOffset = offset;
  });
  if (errors.length) {
    const LINE_START = '\n - ';
    throw new Error(`Unable to animate due to the following errors:${LINE_START}${errors.join(LINE_START)}`);
  }
  return normalizedKeyframes;
}
function listenOnPlayer(player, eventName, event, callback) {
  switch (eventName) {
    case 'start':
      player.onStart(() => callback(event && copyAnimationEvent(event, 'start', player)));
      break;
    case 'done':
      player.onDone(() => callback(event && copyAnimationEvent(event, 'done', player)));
      break;
    case 'destroy':
      player.onDestroy(() => callback(event && copyAnimationEvent(event, 'destroy', player)));
      break;
  }
}
function copyAnimationEvent(e, phaseName, player) {
  const totalTime = player.totalTime;
  const disabled = player.disabled ? true : false;
  const event = makeAnimationEvent(e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName, totalTime == undefined ? e.totalTime : totalTime, disabled);
  const data = e['_data'];
  if (data != null) {
    event['_data'] = data;
  }
  return event;
}
function makeAnimationEvent(element, triggerName, fromState, toState, phaseName = '', totalTime = 0, disabled) {
  return {
    element,
    triggerName,
    fromState,
    toState,
    phaseName,
    totalTime,
    disabled: !!disabled
  };
}
function getOrSetAsInMap(map, key, defaultValue) {
  let value;
  if (map instanceof Map) {
    value = map.get(key);
    if (!value) {
      map.set(key, value = defaultValue);
    }
  } else {
    value = map[key];
    if (!value) {
      value = map[key] = defaultValue;
    }
  }
  return value;
}
function parseTimelineCommand(command) {
  const separatorPos = command.indexOf(':');
  const id = command.substring(1, separatorPos);
  const action = command.substr(separatorPos + 1);
  return [id, action];
}
let _contains = (elm1, elm2) => false;
const ɵ0 = (/* unused pure expression or super */ null && (_contains));
let _matches = (element, selector) => false;
const ɵ1 = (/* unused pure expression or super */ null && (_matches));
let _query = (element, selector, multi) => {
  return [];
};
const ɵ2 = (/* unused pure expression or super */ null && (_query));
// Define utility methods for browsers and platform-server(domino) where Element
// and utility methods exist.
const _isNode = /*#__PURE__*/isNode();
if (_isNode || typeof Element !== 'undefined') {
  if (! /*#__PURE__*/isBrowser()) {
    _contains = (elm1, elm2) => elm1.contains(elm2);
  } else {
    _contains = (elm1, elm2) => {
      while (elm2 && elm2 !== document.documentElement) {
        if (elm2 === elm1) {
          return true;
        }
        elm2 = elm2.parentNode || elm2.host; // consider host to support shadow DOM
      }

      return false;
    };
  }
  _matches = /*#__PURE__*/(() => {
    if (_isNode || Element.prototype.matches) {
      return (element, selector) => element.matches(selector);
    } else {
      const proto = Element.prototype;
      const fn = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
      if (fn) {
        return (element, selector) => fn.apply(element, [selector]);
      } else {
        return _matches;
      }
    }
  })();
  _query = (element, selector, multi) => {
    let results = [];
    if (multi) {
      // DO NOT REFACTOR TO USE SPREAD SYNTAX.
      // For element queries that return sufficiently large NodeList objects,
      // using spread syntax to populate the results array causes a RangeError
      // due to the call stack limit being reached. `Array.from` can not be used
      // as well, since NodeList is not iterable in IE 11, see
      // https://developer.mozilla.org/en-US/docs/Web/API/NodeList
      // More info is available in #38551.
      const elems = element.querySelectorAll(selector);
      for (let i = 0; i < elems.length; i++) {
        results.push(elems[i]);
      }
    } else {
      const elm = element.querySelector(selector);
      if (elm) {
        results.push(elm);
      }
    }
    return results;
  };
}
function containsVendorPrefix(prop) {
  // Webkit is the only real popular vendor prefix nowadays
  // cc: http://shouldiprefix.com/
  return prop.substring(1, 6) == 'ebkit'; // webkit or Webkit
}

let _CACHED_BODY = null;
let _IS_WEBKIT = false;
function validateStyleProperty(prop) {
  if (!_CACHED_BODY) {
    _CACHED_BODY = getBodyNode() || {};
    _IS_WEBKIT = _CACHED_BODY.style ? 'WebkitAppearance' in _CACHED_BODY.style : false;
  }
  let result = true;
  if (_CACHED_BODY.style && !containsVendorPrefix(prop)) {
    result = prop in _CACHED_BODY.style;
    if (!result && _IS_WEBKIT) {
      const camelProp = 'Webkit' + prop.charAt(0).toUpperCase() + prop.substr(1);
      result = camelProp in _CACHED_BODY.style;
    }
  }
  return result;
}
function getBodyNode() {
  if (typeof document != 'undefined') {
    return document.body;
  }
  return null;
}
const matchesElement = _matches;
const containsElement = _contains;
const invokeQuery = _query;
function hypenatePropsObject(object) {
  const newObj = {};
  Object.keys(object).forEach(prop => {
    const newProp = prop.replace(/([a-z])([A-Z])/g, '$1-$2');
    newObj[newProp] = object[prop];
  });
  return newObj;
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @publicApi
 */
let NoopAnimationDriver = /*#__PURE__*/(() => {
  class NoopAnimationDriver {
    validateStyleProperty(prop) {
      return validateStyleProperty(prop);
    }
    matchesElement(element, selector) {
      return matchesElement(element, selector);
    }
    containsElement(elm1, elm2) {
      return containsElement(elm1, elm2);
    }
    query(element, selector, multi) {
      return invokeQuery(element, selector, multi);
    }
    computeStyle(element, prop, defaultValue) {
      return defaultValue || '';
    }
    animate(element, keyframes, duration, delay, easing, previousPlayers = [], scrubberAccessRequested) {
      return new _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .NoopAnimationPlayer */ .ZN(duration, delay);
    }
  }
  NoopAnimationDriver.ɵfac = function NoopAnimationDriver_Factory(t) {
    return new (t || NoopAnimationDriver)();
  };
  NoopAnimationDriver.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: NoopAnimationDriver,
    factory: NoopAnimationDriver.ɵfac
  });
  return NoopAnimationDriver;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @publicApi
 */
let AnimationDriver = /*#__PURE__*/(() => {
  class AnimationDriver {}
  AnimationDriver.NOOP = /* @__PURE__ */new NoopAnimationDriver();

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  return AnimationDriver;
})();
const ONE_SECOND = 1000;
const SUBSTITUTION_EXPR_START = '{{';
const SUBSTITUTION_EXPR_END = '}}';
const ENTER_CLASSNAME = 'ng-enter';
const LEAVE_CLASSNAME = 'ng-leave';
const ENTER_SELECTOR = '.ng-enter';
const LEAVE_SELECTOR = '.ng-leave';
const NG_TRIGGER_CLASSNAME = 'ng-trigger';
const NG_TRIGGER_SELECTOR = '.ng-trigger';
const NG_ANIMATING_CLASSNAME = 'ng-animating';
const NG_ANIMATING_SELECTOR = '.ng-animating';
function resolveTimingValue(value) {
  if (typeof value == 'number') return value;
  const matches = value.match(/^(-?[\.\d]+)(m?s)/);
  if (!matches || matches.length < 2) return 0;
  return _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
}
function _convertTimeValueToMS(value, unit) {
  switch (unit) {
    case 's':
      return value * ONE_SECOND;
    default:
      // ms or something else
      return value;
  }
}
function resolveTiming(timings, errors, allowNegativeValues) {
  return timings.hasOwnProperty('duration') ? timings : parseTimeExpression(timings, errors, allowNegativeValues);
}
function parseTimeExpression(exp, errors, allowNegativeValues) {
  const regex = /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i;
  let duration;
  let delay = 0;
  let easing = '';
  if (typeof exp === 'string') {
    const matches = exp.match(regex);
    if (matches === null) {
      errors.push(`The provided timing value "${exp}" is invalid.`);
      return {
        duration: 0,
        delay: 0,
        easing: ''
      };
    }
    duration = _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
    const delayMatch = matches[3];
    if (delayMatch != null) {
      delay = _convertTimeValueToMS(parseFloat(delayMatch), matches[4]);
    }
    const easingVal = matches[5];
    if (easingVal) {
      easing = easingVal;
    }
  } else {
    duration = exp;
  }
  if (!allowNegativeValues) {
    let containsErrors = false;
    let startIndex = errors.length;
    if (duration < 0) {
      errors.push(`Duration values below 0 are not allowed for this animation step.`);
      containsErrors = true;
    }
    if (delay < 0) {
      errors.push(`Delay values below 0 are not allowed for this animation step.`);
      containsErrors = true;
    }
    if (containsErrors) {
      errors.splice(startIndex, 0, `The provided timing value "${exp}" is invalid.`);
    }
  }
  return {
    duration,
    delay,
    easing
  };
}
function copyObj(obj, destination = {}) {
  Object.keys(obj).forEach(prop => {
    destination[prop] = obj[prop];
  });
  return destination;
}
function normalizeStyles(styles) {
  const normalizedStyles = {};
  if (Array.isArray(styles)) {
    styles.forEach(data => copyStyles(data, false, normalizedStyles));
  } else {
    copyStyles(styles, false, normalizedStyles);
  }
  return normalizedStyles;
}
function copyStyles(styles, readPrototype, destination = {}) {
  if (readPrototype) {
    // we make use of a for-in loop so that the
    // prototypically inherited properties are
    // revealed from the backFill map
    for (let prop in styles) {
      destination[prop] = styles[prop];
    }
  } else {
    copyObj(styles, destination);
  }
  return destination;
}
function getStyleAttributeString(element, key, value) {
  // Return the key-value pair string to be added to the style attribute for the
  // given CSS style key.
  if (value) {
    return key + ':' + value + ';';
  } else {
    return '';
  }
}
function writeStyleAttribute(element) {
  // Read the style property of the element and manually reflect it to the
  // style attribute. This is needed because Domino on platform-server doesn't
  // understand the full set of allowed CSS properties and doesn't reflect some
  // of them automatically.
  let styleAttrValue = '';
  for (let i = 0; i < element.style.length; i++) {
    const key = element.style.item(i);
    styleAttrValue += getStyleAttributeString(element, key, element.style.getPropertyValue(key));
  }
  for (const key in element.style) {
    // Skip internal Domino properties that don't need to be reflected.
    if (!element.style.hasOwnProperty(key) || key.startsWith('_')) {
      continue;
    }
    const dashKey = camelCaseToDashCase(key);
    styleAttrValue += getStyleAttributeString(element, dashKey, element.style[key]);
  }
  element.setAttribute('style', styleAttrValue);
}
function setStyles(element, styles, formerStyles) {
  if (element['style']) {
    Object.keys(styles).forEach(prop => {
      const camelProp = dashCaseToCamelCase(prop);
      if (formerStyles && !formerStyles.hasOwnProperty(prop)) {
        formerStyles[prop] = element.style[camelProp];
      }
      element.style[camelProp] = styles[prop];
    });
    // On the server set the 'style' attribute since it's not automatically reflected.
    if (isNode()) {
      writeStyleAttribute(element);
    }
  }
}
function eraseStyles(element, styles) {
  if (element['style']) {
    Object.keys(styles).forEach(prop => {
      const camelProp = dashCaseToCamelCase(prop);
      element.style[camelProp] = '';
    });
    // On the server set the 'style' attribute since it's not automatically reflected.
    if (isNode()) {
      writeStyleAttribute(element);
    }
  }
}
function normalizeAnimationEntry(steps) {
  if (Array.isArray(steps)) {
    if (steps.length == 1) return steps[0];
    return (0,_angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .sequence */ .vP)(steps);
  }
  return steps;
}
function validateStyleParams(value, options, errors) {
  const params = options.params || {};
  const matches = extractStyleParams(value);
  if (matches.length) {
    matches.forEach(varName => {
      if (!params.hasOwnProperty(varName)) {
        errors.push(`Unable to resolve the local animation param ${varName} in the given list of values`);
      }
    });
  }
}
const PARAM_REGEX = /*#__PURE__*/new RegExp(`${SUBSTITUTION_EXPR_START}\\s*(.+?)\\s*${SUBSTITUTION_EXPR_END}`, 'g');
function extractStyleParams(value) {
  let params = [];
  if (typeof value === 'string') {
    let match;
    while (match = PARAM_REGEX.exec(value)) {
      params.push(match[1]);
    }
    PARAM_REGEX.lastIndex = 0;
  }
  return params;
}
function interpolateParams(value, params, errors) {
  const original = value.toString();
  const str = original.replace(PARAM_REGEX, (_, varName) => {
    let localVal = params[varName];
    // this means that the value was never overridden by the data passed in by the user
    if (!params.hasOwnProperty(varName)) {
      errors.push(`Please provide a value for the animation param ${varName}`);
      localVal = '';
    }
    return localVal.toString();
  });
  // we do this to assert that numeric values stay as they are
  return str == original ? value : str;
}
function iteratorToArray(iterator) {
  const arr = [];
  let item = iterator.next();
  while (!item.done) {
    arr.push(item.value);
    item = iterator.next();
  }
  return arr;
}
const DASH_CASE_REGEXP = /-+([a-z0-9])/g;
function dashCaseToCamelCase(input) {
  return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());
}
function camelCaseToDashCase(input) {
  return input.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function allowPreviousPlayerStylesMerge(duration, delay) {
  return duration === 0 || delay === 0;
}
function balancePreviousStylesIntoKeyframes(element, keyframes, previousStyles) {
  const previousStyleProps = Object.keys(previousStyles);
  if (previousStyleProps.length && keyframes.length) {
    let startingKeyframe = keyframes[0];
    let missingStyleProps = [];
    previousStyleProps.forEach(prop => {
      if (!startingKeyframe.hasOwnProperty(prop)) {
        missingStyleProps.push(prop);
      }
      startingKeyframe[prop] = previousStyles[prop];
    });
    if (missingStyleProps.length) {
      // tslint:disable-next-line
      for (var i = 1; i < keyframes.length; i++) {
        let kf = keyframes[i];
        missingStyleProps.forEach(function (prop) {
          kf[prop] = computeStyle(element, prop);
        });
      }
    }
  }
  return keyframes;
}
function visitDslNode(visitor, node, context) {
  switch (node.type) {
    case 7 /* Trigger */:
      return visitor.visitTrigger(node, context);
    case 0 /* State */:
      return visitor.visitState(node, context);
    case 1 /* Transition */:
      return visitor.visitTransition(node, context);
    case 2 /* Sequence */:
      return visitor.visitSequence(node, context);
    case 3 /* Group */:
      return visitor.visitGroup(node, context);
    case 4 /* Animate */:
      return visitor.visitAnimate(node, context);
    case 5 /* Keyframes */:
      return visitor.visitKeyframes(node, context);
    case 6 /* Style */:
      return visitor.visitStyle(node, context);
    case 8 /* Reference */:
      return visitor.visitReference(node, context);
    case 9 /* AnimateChild */:
      return visitor.visitAnimateChild(node, context);
    case 10 /* AnimateRef */:
      return visitor.visitAnimateRef(node, context);
    case 11 /* Query */:
      return visitor.visitQuery(node, context);
    case 12 /* Stagger */:
      return visitor.visitStagger(node, context);
    default:
      throw new Error(`Unable to resolve animation metadata node #${node.type}`);
  }
}
function computeStyle(element, prop) {
  return window.getComputedStyle(element)[prop];
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const ANY_STATE = '*';
function parseTransitionExpr(transitionValue, errors) {
  const expressions = [];
  if (typeof transitionValue == 'string') {
    transitionValue.split(/\s*,\s*/).forEach(str => parseInnerTransitionStr(str, expressions, errors));
  } else {
    expressions.push(transitionValue);
  }
  return expressions;
}
function parseInnerTransitionStr(eventStr, expressions, errors) {
  if (eventStr[0] == ':') {
    const result = parseAnimationAlias(eventStr, errors);
    if (typeof result == 'function') {
      expressions.push(result);
      return;
    }
    eventStr = result;
  }
  const match = eventStr.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
  if (match == null || match.length < 4) {
    errors.push(`The provided transition expression "${eventStr}" is not supported`);
    return expressions;
  }
  const fromState = match[1];
  const separator = match[2];
  const toState = match[3];
  expressions.push(makeLambdaFromStates(fromState, toState));
  const isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;
  if (separator[0] == '<' && !isFullAnyStateExpr) {
    expressions.push(makeLambdaFromStates(toState, fromState));
  }
}
function parseAnimationAlias(alias, errors) {
  switch (alias) {
    case ':enter':
      return 'void => *';
    case ':leave':
      return '* => void';
    case ':increment':
      return (fromState, toState) => parseFloat(toState) > parseFloat(fromState);
    case ':decrement':
      return (fromState, toState) => parseFloat(toState) < parseFloat(fromState);
    default:
      errors.push(`The transition alias value "${alias}" is not supported`);
      return '* => *';
  }
}
// DO NOT REFACTOR ... keep the follow set instantiations
// with the values intact (closure compiler for some reason
// removes follow-up lines that add the values outside of
// the constructor...
const TRUE_BOOLEAN_VALUES = /*#__PURE__*/new Set(['true', '1']);
const FALSE_BOOLEAN_VALUES = /*#__PURE__*/new Set(['false', '0']);
function makeLambdaFromStates(lhs, rhs) {
  const LHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(lhs) || FALSE_BOOLEAN_VALUES.has(lhs);
  const RHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(rhs) || FALSE_BOOLEAN_VALUES.has(rhs);
  return (fromState, toState) => {
    let lhsMatch = lhs == ANY_STATE || lhs == fromState;
    let rhsMatch = rhs == ANY_STATE || rhs == toState;
    if (!lhsMatch && LHS_MATCH_BOOLEAN && typeof fromState === 'boolean') {
      lhsMatch = fromState ? TRUE_BOOLEAN_VALUES.has(lhs) : FALSE_BOOLEAN_VALUES.has(lhs);
    }
    if (!rhsMatch && RHS_MATCH_BOOLEAN && typeof toState === 'boolean') {
      rhsMatch = toState ? TRUE_BOOLEAN_VALUES.has(rhs) : FALSE_BOOLEAN_VALUES.has(rhs);
    }
    return lhsMatch && rhsMatch;
  };
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const SELF_TOKEN = ':self';
const SELF_TOKEN_REGEX = /*#__PURE__*/new RegExp(`\s*${SELF_TOKEN}\s*,?`, 'g');
/*
 * [Validation]
 * The visitor code below will traverse the animation AST generated by the animation verb functions
 * (the output is a tree of objects) and attempt to perform a series of validations on the data. The
 * following corner-cases will be validated:
 *
 * 1. Overlap of animations
 * Given that a CSS property cannot be animated in more than one place at the same time, it's
 * important that this behavior is detected and validated. The way in which this occurs is that
 * each time a style property is examined, a string-map containing the property will be updated with
 * the start and end times for when the property is used within an animation step.
 *
 * If there are two or more parallel animations that are currently running (these are invoked by the
 * group()) on the same element then the validator will throw an error. Since the start/end timing
 * values are collected for each property then if the current animation step is animating the same
 * property and its timing values fall anywhere into the window of time that the property is
 * currently being animated within then this is what causes an error.
 *
 * 2. Timing values
 * The validator will validate to see if a timing value of `duration delay easing` or
 * `durationNumber` is valid or not.
 *
 * (note that upon validation the code below will replace the timing data with an object containing
 * {duration,delay,easing}.
 *
 * 3. Offset Validation
 * Each of the style() calls are allowed to have an offset value when placed inside of keyframes().
 * Offsets within keyframes() are considered valid when:
 *
 *   - No offsets are used at all
 *   - Each style() entry contains an offset value
 *   - Each offset is between 0 and 1
 *   - Each offset is greater to or equal than the previous one
 *
 * Otherwise an error will be thrown.
 */
function buildAnimationAst(driver, metadata, errors) {
  return new AnimationAstBuilderVisitor(driver).build(metadata, errors);
}
const ROOT_SELECTOR = '';
class AnimationAstBuilderVisitor {
  constructor(_driver) {
    this._driver = _driver;
  }
  build(metadata, errors) {
    const context = new AnimationAstBuilderContext(errors);
    this._resetContextStyleTimingState(context);
    return visitDslNode(this, normalizeAnimationEntry(metadata), context);
  }
  _resetContextStyleTimingState(context) {
    context.currentQuerySelector = ROOT_SELECTOR;
    context.collectedStyles = {};
    context.collectedStyles[ROOT_SELECTOR] = {};
    context.currentTime = 0;
  }
  visitTrigger(metadata, context) {
    let queryCount = context.queryCount = 0;
    let depCount = context.depCount = 0;
    const states = [];
    const transitions = [];
    if (metadata.name.charAt(0) == '@') {
      context.errors.push('animation triggers cannot be prefixed with an `@` sign (e.g. trigger(\'@foo\', [...]))');
    }
    metadata.definitions.forEach(def => {
      this._resetContextStyleTimingState(context);
      if (def.type == 0 /* State */) {
        const stateDef = def;
        const name = stateDef.name;
        name.toString().split(/\s*,\s*/).forEach(n => {
          stateDef.name = n;
          states.push(this.visitState(stateDef, context));
        });
        stateDef.name = name;
      } else if (def.type == 1 /* Transition */) {
        const transition = this.visitTransition(def, context);
        queryCount += transition.queryCount;
        depCount += transition.depCount;
        transitions.push(transition);
      } else {
        context.errors.push('only state() and transition() definitions can sit inside of a trigger()');
      }
    });
    return {
      type: 7 /* Trigger */,
      name: metadata.name,
      states,
      transitions,
      queryCount,
      depCount,
      options: null
    };
  }
  visitState(metadata, context) {
    const styleAst = this.visitStyle(metadata.styles, context);
    const astParams = metadata.options && metadata.options.params || null;
    if (styleAst.containsDynamicStyles) {
      const missingSubs = new Set();
      const params = astParams || {};
      styleAst.styles.forEach(value => {
        if (isObject(value)) {
          const stylesObj = value;
          Object.keys(stylesObj).forEach(prop => {
            extractStyleParams(stylesObj[prop]).forEach(sub => {
              if (!params.hasOwnProperty(sub)) {
                missingSubs.add(sub);
              }
            });
          });
        }
      });
      if (missingSubs.size) {
        const missingSubsArr = iteratorToArray(missingSubs.values());
        context.errors.push(`state("${metadata.name}", ...) must define default values for all the following style substitutions: ${missingSubsArr.join(', ')}`);
      }
    }
    return {
      type: 0 /* State */,
      name: metadata.name,
      style: styleAst,
      options: astParams ? {
        params: astParams
      } : null
    };
  }
  visitTransition(metadata, context) {
    context.queryCount = 0;
    context.depCount = 0;
    const animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);
    const matchers = parseTransitionExpr(metadata.expr, context.errors);
    return {
      type: 1 /* Transition */,
      matchers,
      animation,
      queryCount: context.queryCount,
      depCount: context.depCount,
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitSequence(metadata, context) {
    return {
      type: 2 /* Sequence */,
      steps: metadata.steps.map(s => visitDslNode(this, s, context)),
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitGroup(metadata, context) {
    const currentTime = context.currentTime;
    let furthestTime = 0;
    const steps = metadata.steps.map(step => {
      context.currentTime = currentTime;
      const innerAst = visitDslNode(this, step, context);
      furthestTime = Math.max(furthestTime, context.currentTime);
      return innerAst;
    });
    context.currentTime = furthestTime;
    return {
      type: 3 /* Group */,
      steps,
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitAnimate(metadata, context) {
    const timingAst = constructTimingAst(metadata.timings, context.errors);
    context.currentAnimateTimings = timingAst;
    let styleAst;
    let styleMetadata = metadata.styles ? metadata.styles : (0,_angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .style */ .oB)({});
    if (styleMetadata.type == 5 /* Keyframes */) {
      styleAst = this.visitKeyframes(styleMetadata, context);
    } else {
      let styleMetadata = metadata.styles;
      let isEmpty = false;
      if (!styleMetadata) {
        isEmpty = true;
        const newStyleData = {};
        if (timingAst.easing) {
          newStyleData['easing'] = timingAst.easing;
        }
        styleMetadata = (0,_angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .style */ .oB)(newStyleData);
      }
      context.currentTime += timingAst.duration + timingAst.delay;
      const _styleAst = this.visitStyle(styleMetadata, context);
      _styleAst.isEmptyStep = isEmpty;
      styleAst = _styleAst;
    }
    context.currentAnimateTimings = null;
    return {
      type: 4 /* Animate */,
      timings: timingAst,
      style: styleAst,
      options: null
    };
  }
  visitStyle(metadata, context) {
    const ast = this._makeStyleAst(metadata, context);
    this._validateStyleAst(ast, context);
    return ast;
  }
  _makeStyleAst(metadata, context) {
    const styles = [];
    if (Array.isArray(metadata.styles)) {
      metadata.styles.forEach(styleTuple => {
        if (typeof styleTuple == 'string') {
          if (styleTuple == _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .AUTO_STYLE */ .l3) {
            styles.push(styleTuple);
          } else {
            context.errors.push(`The provided style string value ${styleTuple} is not allowed.`);
          }
        } else {
          styles.push(styleTuple);
        }
      });
    } else {
      styles.push(metadata.styles);
    }
    let containsDynamicStyles = false;
    let collectedEasing = null;
    styles.forEach(styleData => {
      if (isObject(styleData)) {
        const styleMap = styleData;
        const easing = styleMap['easing'];
        if (easing) {
          collectedEasing = easing;
          delete styleMap['easing'];
        }
        if (!containsDynamicStyles) {
          for (let prop in styleMap) {
            const value = styleMap[prop];
            if (value.toString().indexOf(SUBSTITUTION_EXPR_START) >= 0) {
              containsDynamicStyles = true;
              break;
            }
          }
        }
      }
    });
    return {
      type: 6 /* Style */,
      styles,
      easing: collectedEasing,
      offset: metadata.offset,
      containsDynamicStyles,
      options: null
    };
  }
  _validateStyleAst(ast, context) {
    const timings = context.currentAnimateTimings;
    let endTime = context.currentTime;
    let startTime = context.currentTime;
    if (timings && startTime > 0) {
      startTime -= timings.duration + timings.delay;
    }
    ast.styles.forEach(tuple => {
      if (typeof tuple == 'string') return;
      Object.keys(tuple).forEach(prop => {
        if (!this._driver.validateStyleProperty(prop)) {
          context.errors.push(`The provided animation property "${prop}" is not a supported CSS property for animations`);
          return;
        }
        const collectedStyles = context.collectedStyles[context.currentQuerySelector];
        const collectedEntry = collectedStyles[prop];
        let updateCollectedStyle = true;
        if (collectedEntry) {
          if (startTime != endTime && startTime >= collectedEntry.startTime && endTime <= collectedEntry.endTime) {
            context.errors.push(`The CSS property "${prop}" that exists between the times of "${collectedEntry.startTime}ms" and "${collectedEntry.endTime}ms" is also being animated in a parallel animation between the times of "${startTime}ms" and "${endTime}ms"`);
            updateCollectedStyle = false;
          }
          // we always choose the smaller start time value since we
          // want to have a record of the entire animation window where
          // the style property is being animated in between
          startTime = collectedEntry.startTime;
        }
        if (updateCollectedStyle) {
          collectedStyles[prop] = {
            startTime,
            endTime
          };
        }
        if (context.options) {
          validateStyleParams(tuple[prop], context.options, context.errors);
        }
      });
    });
  }
  visitKeyframes(metadata, context) {
    const ast = {
      type: 5 /* Keyframes */,
      styles: [],
      options: null
    };
    if (!context.currentAnimateTimings) {
      context.errors.push(`keyframes() must be placed inside of a call to animate()`);
      return ast;
    }
    const MAX_KEYFRAME_OFFSET = 1;
    let totalKeyframesWithOffsets = 0;
    const offsets = [];
    let offsetsOutOfOrder = false;
    let keyframesOutOfRange = false;
    let previousOffset = 0;
    const keyframes = metadata.steps.map(styles => {
      const style = this._makeStyleAst(styles, context);
      let offsetVal = style.offset != null ? style.offset : consumeOffset(style.styles);
      let offset = 0;
      if (offsetVal != null) {
        totalKeyframesWithOffsets++;
        offset = style.offset = offsetVal;
      }
      keyframesOutOfRange = keyframesOutOfRange || offset < 0 || offset > 1;
      offsetsOutOfOrder = offsetsOutOfOrder || offset < previousOffset;
      previousOffset = offset;
      offsets.push(offset);
      return style;
    });
    if (keyframesOutOfRange) {
      context.errors.push(`Please ensure that all keyframe offsets are between 0 and 1`);
    }
    if (offsetsOutOfOrder) {
      context.errors.push(`Please ensure that all keyframe offsets are in order`);
    }
    const length = metadata.steps.length;
    let generatedOffset = 0;
    if (totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length) {
      context.errors.push(`Not all style() steps within the declared keyframes() contain offsets`);
    } else if (totalKeyframesWithOffsets == 0) {
      generatedOffset = MAX_KEYFRAME_OFFSET / (length - 1);
    }
    const limit = length - 1;
    const currentTime = context.currentTime;
    const currentAnimateTimings = context.currentAnimateTimings;
    const animateDuration = currentAnimateTimings.duration;
    keyframes.forEach((kf, i) => {
      const offset = generatedOffset > 0 ? i == limit ? 1 : generatedOffset * i : offsets[i];
      const durationUpToThisFrame = offset * animateDuration;
      context.currentTime = currentTime + currentAnimateTimings.delay + durationUpToThisFrame;
      currentAnimateTimings.duration = durationUpToThisFrame;
      this._validateStyleAst(kf, context);
      kf.offset = offset;
      ast.styles.push(kf);
    });
    return ast;
  }
  visitReference(metadata, context) {
    return {
      type: 8 /* Reference */,
      animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitAnimateChild(metadata, context) {
    context.depCount++;
    return {
      type: 9 /* AnimateChild */,
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitAnimateRef(metadata, context) {
    return {
      type: 10 /* AnimateRef */,
      animation: this.visitReference(metadata.animation, context),
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitQuery(metadata, context) {
    const parentSelector = context.currentQuerySelector;
    const options = metadata.options || {};
    context.queryCount++;
    context.currentQuery = metadata;
    const [selector, includeSelf] = normalizeSelector(metadata.selector);
    context.currentQuerySelector = parentSelector.length ? parentSelector + ' ' + selector : selector;
    getOrSetAsInMap(context.collectedStyles, context.currentQuerySelector, {});
    const animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);
    context.currentQuery = null;
    context.currentQuerySelector = parentSelector;
    return {
      type: 11 /* Query */,
      selector,
      limit: options.limit || 0,
      optional: !!options.optional,
      includeSelf,
      animation,
      originalSelector: metadata.selector,
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitStagger(metadata, context) {
    if (!context.currentQuery) {
      context.errors.push(`stagger() can only be used inside of query()`);
    }
    const timings = metadata.timings === 'full' ? {
      duration: 0,
      delay: 0,
      easing: 'full'
    } : resolveTiming(metadata.timings, context.errors, true);
    return {
      type: 12 /* Stagger */,
      animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),
      timings,
      options: null
    };
  }
}
function normalizeSelector(selector) {
  const hasAmpersand = selector.split(/\s*,\s*/).find(token => token == SELF_TOKEN) ? true : false;
  if (hasAmpersand) {
    selector = selector.replace(SELF_TOKEN_REGEX, '');
  }
  // the :enter and :leave selectors are filled in at runtime during timeline building
  selector = selector.replace(/@\*/g, NG_TRIGGER_SELECTOR).replace(/@\w+/g, match => NG_TRIGGER_SELECTOR + '-' + match.substr(1)).replace(/:animating/g, NG_ANIMATING_SELECTOR);
  return [selector, hasAmpersand];
}
function normalizeParams(obj) {
  return obj ? copyObj(obj) : null;
}
class AnimationAstBuilderContext {
  constructor(errors) {
    this.errors = errors;
    this.queryCount = 0;
    this.depCount = 0;
    this.currentTransition = null;
    this.currentQuery = null;
    this.currentQuerySelector = null;
    this.currentAnimateTimings = null;
    this.currentTime = 0;
    this.collectedStyles = {};
    this.options = null;
  }
}
function consumeOffset(styles) {
  if (typeof styles == 'string') return null;
  let offset = null;
  if (Array.isArray(styles)) {
    styles.forEach(styleTuple => {
      if (isObject(styleTuple) && styleTuple.hasOwnProperty('offset')) {
        const obj = styleTuple;
        offset = parseFloat(obj['offset']);
        delete obj['offset'];
      }
    });
  } else if (isObject(styles) && styles.hasOwnProperty('offset')) {
    const obj = styles;
    offset = parseFloat(obj['offset']);
    delete obj['offset'];
  }
  return offset;
}
function isObject(value) {
  return !Array.isArray(value) && typeof value == 'object';
}
function constructTimingAst(value, errors) {
  let timings = null;
  if (value.hasOwnProperty('duration')) {
    timings = value;
  } else if (typeof value == 'number') {
    const duration = resolveTiming(value, errors).duration;
    return makeTimingAst(duration, 0, '');
  }
  const strValue = value;
  const isDynamic = strValue.split(/\s+/).some(v => v.charAt(0) == '{' && v.charAt(1) == '{');
  if (isDynamic) {
    const ast = makeTimingAst(0, 0, '');
    ast.dynamic = true;
    ast.strValue = strValue;
    return ast;
  }
  timings = timings || resolveTiming(strValue, errors);
  return makeTimingAst(timings.duration, timings.delay, timings.easing);
}
function normalizeAnimationOptions(options) {
  if (options) {
    options = copyObj(options);
    if (options['params']) {
      options['params'] = normalizeParams(options['params']);
    }
  } else {
    options = {};
  }
  return options;
}
function makeTimingAst(duration, delay, easing) {
  return {
    duration,
    delay,
    easing
  };
}
function createTimelineInstruction(element, keyframes, preStyleProps, postStyleProps, duration, delay, easing = null, subTimeline = false) {
  return {
    type: 1 /* TimelineAnimation */,
    element,
    keyframes,
    preStyleProps,
    postStyleProps,
    duration,
    delay,
    totalTime: duration + delay,
    easing,
    subTimeline
  };
}
class ElementInstructionMap {
  constructor() {
    this._map = new Map();
  }
  consume(element) {
    let instructions = this._map.get(element);
    if (instructions) {
      this._map.delete(element);
    } else {
      instructions = [];
    }
    return instructions;
  }
  append(element, instructions) {
    let existingInstructions = this._map.get(element);
    if (!existingInstructions) {
      this._map.set(element, existingInstructions = []);
    }
    existingInstructions.push(...instructions);
  }
  has(element) {
    return this._map.has(element);
  }
  clear() {
    this._map.clear();
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const ONE_FRAME_IN_MILLISECONDS = 1;
const ENTER_TOKEN = ':enter';
const ENTER_TOKEN_REGEX = /*#__PURE__*/new RegExp(ENTER_TOKEN, 'g');
const LEAVE_TOKEN = ':leave';
const LEAVE_TOKEN_REGEX = /*#__PURE__*/new RegExp(LEAVE_TOKEN, 'g');
/*
 * The code within this file aims to generate web-animations-compatible keyframes from Angular's
 * animation DSL code.
 *
 * The code below will be converted from:
 *
 * ```
 * sequence([
 *   style({ opacity: 0 }),
 *   animate(1000, style({ opacity: 0 }))
 * ])
 * ```
 *
 * To:
 * ```
 * keyframes = [{ opacity: 0, offset: 0 }, { opacity: 1, offset: 1 }]
 * duration = 1000
 * delay = 0
 * easing = ''
 * ```
 *
 * For this operation to cover the combination of animation verbs (style, animate, group, etc...) a
 * combination of prototypical inheritance, AST traversal and merge-sort-like algorithms are used.
 *
 * [AST Traversal]
 * Each of the animation verbs, when executed, will return an string-map object representing what
 * type of action it is (style, animate, group, etc...) and the data associated with it. This means
 * that when functional composition mix of these functions is evaluated (like in the example above)
 * then it will end up producing a tree of objects representing the animation itself.
 *
 * When this animation object tree is processed by the visitor code below it will visit each of the
 * verb statements within the visitor. And during each visit it will build the context of the
 * animation keyframes by interacting with the `TimelineBuilder`.
 *
 * [TimelineBuilder]
 * This class is responsible for tracking the styles and building a series of keyframe objects for a
 * timeline between a start and end time. The builder starts off with an initial timeline and each
 * time the AST comes across a `group()`, `keyframes()` or a combination of the two wihtin a
 * `sequence()` then it will generate a sub timeline for each step as well as a new one after
 * they are complete.
 *
 * As the AST is traversed, the timing state on each of the timelines will be incremented. If a sub
 * timeline was created (based on one of the cases above) then the parent timeline will attempt to
 * merge the styles used within the sub timelines into itself (only with group() this will happen).
 * This happens with a merge operation (much like how the merge works in mergesort) and it will only
 * copy the most recently used styles from the sub timelines into the parent timeline. This ensures
 * that if the styles are used later on in another phase of the animation then they will be the most
 * up-to-date values.
 *
 * [How Missing Styles Are Updated]
 * Each timeline has a `backFill` property which is responsible for filling in new styles into
 * already processed keyframes if a new style shows up later within the animation sequence.
 *
 * ```
 * sequence([
 *   style({ width: 0 }),
 *   animate(1000, style({ width: 100 })),
 *   animate(1000, style({ width: 200 })),
 *   animate(1000, style({ width: 300 }))
 *   animate(1000, style({ width: 400, height: 400 })) // notice how `height` doesn't exist anywhere
 * else
 * ])
 * ```
 *
 * What is happening here is that the `height` value is added later in the sequence, but is missing
 * from all previous animation steps. Therefore when a keyframe is created it would also be missing
 * from all previous keyframes up until where it is first used. For the timeline keyframe generation
 * to properly fill in the style it will place the previous value (the value from the parent
 * timeline) or a default value of `*` into the backFill object. Given that each of the keyframe
 * styles are objects that prototypically inhert from the backFill object, this means that if a
 * value is added into the backFill then it will automatically propagate any missing values to all
 * keyframes. Therefore the missing `height` value will be properly filled into the already
 * processed keyframes.
 *
 * When a sub-timeline is created it will have its own backFill property. This is done so that
 * styles present within the sub-timeline do not accidentally seep into the previous/future timeline
 * keyframes
 *
 * (For prototypically-inherited contents to be detected a `for(i in obj)` loop must be used.)
 *
 * [Validation]
 * The code in this file is not responsible for validation. That functionality happens with within
 * the `AnimationValidatorVisitor` code.
 */
function buildAnimationTimelines(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles = {}, finalStyles = {}, options, subInstructions, errors = []) {
  return new AnimationTimelineBuilderVisitor().buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors);
}
class AnimationTimelineBuilderVisitor {
  buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors = []) {
    subInstructions = subInstructions || new ElementInstructionMap();
    const context = new AnimationTimelineContext(driver, rootElement, subInstructions, enterClassName, leaveClassName, errors, []);
    context.options = options;
    context.currentTimeline.setStyles([startingStyles], null, context.errors, options);
    visitDslNode(this, ast, context);
    // this checks to see if an actual animation happened
    const timelines = context.timelines.filter(timeline => timeline.containsAnimation());
    if (timelines.length && Object.keys(finalStyles).length) {
      const tl = timelines[timelines.length - 1];
      if (!tl.allowOnlyTimelineStyles()) {
        tl.setStyles([finalStyles], null, context.errors, options);
      }
    }
    return timelines.length ? timelines.map(timeline => timeline.buildKeyframes()) : [createTimelineInstruction(rootElement, [], [], [], 0, 0, '', false)];
  }
  visitTrigger(ast, context) {
    // these values are not visited in this AST
  }
  visitState(ast, context) {
    // these values are not visited in this AST
  }
  visitTransition(ast, context) {
    // these values are not visited in this AST
  }
  visitAnimateChild(ast, context) {
    const elementInstructions = context.subInstructions.consume(context.element);
    if (elementInstructions) {
      const innerContext = context.createSubContext(ast.options);
      const startTime = context.currentTimeline.currentTime;
      const endTime = this._visitSubInstructions(elementInstructions, innerContext, innerContext.options);
      if (startTime != endTime) {
        // we do this on the upper context because we created a sub context for
        // the sub child animations
        context.transformIntoNewTimeline(endTime);
      }
    }
    context.previousNode = ast;
  }
  visitAnimateRef(ast, context) {
    const innerContext = context.createSubContext(ast.options);
    innerContext.transformIntoNewTimeline();
    this.visitReference(ast.animation, innerContext);
    context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime);
    context.previousNode = ast;
  }
  _visitSubInstructions(instructions, context, options) {
    const startTime = context.currentTimeline.currentTime;
    let furthestTime = startTime;
    // this is a special-case for when a user wants to skip a sub
    // animation from being fired entirely.
    const duration = options.duration != null ? resolveTimingValue(options.duration) : null;
    const delay = options.delay != null ? resolveTimingValue(options.delay) : null;
    if (duration !== 0) {
      instructions.forEach(instruction => {
        const instructionTimings = context.appendInstructionToTimeline(instruction, duration, delay);
        furthestTime = Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);
      });
    }
    return furthestTime;
  }
  visitReference(ast, context) {
    context.updateOptions(ast.options, true);
    visitDslNode(this, ast.animation, context);
    context.previousNode = ast;
  }
  visitSequence(ast, context) {
    const subContextCount = context.subContextCount;
    let ctx = context;
    const options = ast.options;
    if (options && (options.params || options.delay)) {
      ctx = context.createSubContext(options);
      ctx.transformIntoNewTimeline();
      if (options.delay != null) {
        if (ctx.previousNode.type == 6 /* Style */) {
          ctx.currentTimeline.snapshotCurrentStyles();
          ctx.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
        }
        const delay = resolveTimingValue(options.delay);
        ctx.delayNextStep(delay);
      }
    }
    if (ast.steps.length) {
      ast.steps.forEach(s => visitDslNode(this, s, ctx));
      // this is here just incase the inner steps only contain or end with a style() call
      ctx.currentTimeline.applyStylesToKeyframe();
      // this means that some animation function within the sequence
      // ended up creating a sub timeline (which means the current
      // timeline cannot overlap with the contents of the sequence)
      if (ctx.subContextCount > subContextCount) {
        ctx.transformIntoNewTimeline();
      }
    }
    context.previousNode = ast;
  }
  visitGroup(ast, context) {
    const innerTimelines = [];
    let furthestTime = context.currentTimeline.currentTime;
    const delay = ast.options && ast.options.delay ? resolveTimingValue(ast.options.delay) : 0;
    ast.steps.forEach(s => {
      const innerContext = context.createSubContext(ast.options);
      if (delay) {
        innerContext.delayNextStep(delay);
      }
      visitDslNode(this, s, innerContext);
      furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);
      innerTimelines.push(innerContext.currentTimeline);
    });
    // this operation is run after the AST loop because otherwise
    // if the parent timeline's collected styles were updated then
    // it would pass in invalid data into the new-to-be forked items
    innerTimelines.forEach(timeline => context.currentTimeline.mergeTimelineCollectedStyles(timeline));
    context.transformIntoNewTimeline(furthestTime);
    context.previousNode = ast;
  }
  _visitTiming(ast, context) {
    if (ast.dynamic) {
      const strValue = ast.strValue;
      const timingValue = context.params ? interpolateParams(strValue, context.params, context.errors) : strValue;
      return resolveTiming(timingValue, context.errors);
    } else {
      return {
        duration: ast.duration,
        delay: ast.delay,
        easing: ast.easing
      };
    }
  }
  visitAnimate(ast, context) {
    const timings = context.currentAnimateTimings = this._visitTiming(ast.timings, context);
    const timeline = context.currentTimeline;
    if (timings.delay) {
      context.incrementTime(timings.delay);
      timeline.snapshotCurrentStyles();
    }
    const style = ast.style;
    if (style.type == 5 /* Keyframes */) {
      this.visitKeyframes(style, context);
    } else {
      context.incrementTime(timings.duration);
      this.visitStyle(style, context);
      timeline.applyStylesToKeyframe();
    }
    context.currentAnimateTimings = null;
    context.previousNode = ast;
  }
  visitStyle(ast, context) {
    const timeline = context.currentTimeline;
    const timings = context.currentAnimateTimings;
    // this is a special case for when a style() call
    // directly follows  an animate() call (but not inside of an animate() call)
    if (!timings && timeline.getCurrentStyleProperties().length) {
      timeline.forwardFrame();
    }
    const easing = timings && timings.easing || ast.easing;
    if (ast.isEmptyStep) {
      timeline.applyEmptyStep(easing);
    } else {
      timeline.setStyles(ast.styles, easing, context.errors, context.options);
    }
    context.previousNode = ast;
  }
  visitKeyframes(ast, context) {
    const currentAnimateTimings = context.currentAnimateTimings;
    const startTime = context.currentTimeline.duration;
    const duration = currentAnimateTimings.duration;
    const innerContext = context.createSubContext();
    const innerTimeline = innerContext.currentTimeline;
    innerTimeline.easing = currentAnimateTimings.easing;
    ast.styles.forEach(step => {
      const offset = step.offset || 0;
      innerTimeline.forwardTime(offset * duration);
      innerTimeline.setStyles(step.styles, step.easing, context.errors, context.options);
      innerTimeline.applyStylesToKeyframe();
    });
    // this will ensure that the parent timeline gets all the styles from
    // the child even if the new timeline below is not used
    context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline);
    // we do this because the window between this timeline and the sub timeline
    // should ensure that the styles within are exactly the same as they were before
    context.transformIntoNewTimeline(startTime + duration);
    context.previousNode = ast;
  }
  visitQuery(ast, context) {
    // in the event that the first step before this is a style step we need
    // to ensure the styles are applied before the children are animated
    const startTime = context.currentTimeline.currentTime;
    const options = ast.options || {};
    const delay = options.delay ? resolveTimingValue(options.delay) : 0;
    if (delay && (context.previousNode.type === 6 /* Style */ || startTime == 0 && context.currentTimeline.getCurrentStyleProperties().length)) {
      context.currentTimeline.snapshotCurrentStyles();
      context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
    }
    let furthestTime = startTime;
    const elms = context.invokeQuery(ast.selector, ast.originalSelector, ast.limit, ast.includeSelf, options.optional ? true : false, context.errors);
    context.currentQueryTotal = elms.length;
    let sameElementTimeline = null;
    elms.forEach((element, i) => {
      context.currentQueryIndex = i;
      const innerContext = context.createSubContext(ast.options, element);
      if (delay) {
        innerContext.delayNextStep(delay);
      }
      if (element === context.element) {
        sameElementTimeline = innerContext.currentTimeline;
      }
      visitDslNode(this, ast.animation, innerContext);
      // this is here just incase the inner steps only contain or end
      // with a style() call (which is here to signal that this is a preparatory
      // call to style an element before it is animated again)
      innerContext.currentTimeline.applyStylesToKeyframe();
      const endTime = innerContext.currentTimeline.currentTime;
      furthestTime = Math.max(furthestTime, endTime);
    });
    context.currentQueryIndex = 0;
    context.currentQueryTotal = 0;
    context.transformIntoNewTimeline(furthestTime);
    if (sameElementTimeline) {
      context.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline);
      context.currentTimeline.snapshotCurrentStyles();
    }
    context.previousNode = ast;
  }
  visitStagger(ast, context) {
    const parentContext = context.parentContext;
    const tl = context.currentTimeline;
    const timings = ast.timings;
    const duration = Math.abs(timings.duration);
    const maxTime = duration * (context.currentQueryTotal - 1);
    let delay = duration * context.currentQueryIndex;
    let staggerTransformer = timings.duration < 0 ? 'reverse' : timings.easing;
    switch (staggerTransformer) {
      case 'reverse':
        delay = maxTime - delay;
        break;
      case 'full':
        delay = parentContext.currentStaggerTime;
        break;
    }
    const timeline = context.currentTimeline;
    if (delay) {
      timeline.delayNextStep(delay);
    }
    const startingTime = timeline.currentTime;
    visitDslNode(this, ast.animation, context);
    context.previousNode = ast;
    // time = duration + delay
    // the reason why this computation is so complex is because
    // the inner timeline may either have a delay value or a stretched
    // keyframe depending on if a subtimeline is not used or is used.
    parentContext.currentStaggerTime = tl.currentTime - startingTime + (tl.startTime - parentContext.currentTimeline.startTime);
  }
}
const DEFAULT_NOOP_PREVIOUS_NODE = {};
class AnimationTimelineContext {
  constructor(_driver, element, subInstructions, _enterClassName, _leaveClassName, errors, timelines, initialTimeline) {
    this._driver = _driver;
    this.element = element;
    this.subInstructions = subInstructions;
    this._enterClassName = _enterClassName;
    this._leaveClassName = _leaveClassName;
    this.errors = errors;
    this.timelines = timelines;
    this.parentContext = null;
    this.currentAnimateTimings = null;
    this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
    this.subContextCount = 0;
    this.options = {};
    this.currentQueryIndex = 0;
    this.currentQueryTotal = 0;
    this.currentStaggerTime = 0;
    this.currentTimeline = initialTimeline || new TimelineBuilder(this._driver, element, 0);
    timelines.push(this.currentTimeline);
  }
  get params() {
    return this.options.params;
  }
  updateOptions(options, skipIfExists) {
    if (!options) return;
    const newOptions = options;
    let optionsToUpdate = this.options;
    // NOTE: this will get patched up when other animation methods support duration overrides
    if (newOptions.duration != null) {
      optionsToUpdate.duration = resolveTimingValue(newOptions.duration);
    }
    if (newOptions.delay != null) {
      optionsToUpdate.delay = resolveTimingValue(newOptions.delay);
    }
    const newParams = newOptions.params;
    if (newParams) {
      let paramsToUpdate = optionsToUpdate.params;
      if (!paramsToUpdate) {
        paramsToUpdate = this.options.params = {};
      }
      Object.keys(newParams).forEach(name => {
        if (!skipIfExists || !paramsToUpdate.hasOwnProperty(name)) {
          paramsToUpdate[name] = interpolateParams(newParams[name], paramsToUpdate, this.errors);
        }
      });
    }
  }
  _copyOptions() {
    const options = {};
    if (this.options) {
      const oldParams = this.options.params;
      if (oldParams) {
        const params = options['params'] = {};
        Object.keys(oldParams).forEach(name => {
          params[name] = oldParams[name];
        });
      }
    }
    return options;
  }
  createSubContext(options = null, element, newTime) {
    const target = element || this.element;
    const context = new AnimationTimelineContext(this._driver, target, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(target, newTime || 0));
    context.previousNode = this.previousNode;
    context.currentAnimateTimings = this.currentAnimateTimings;
    context.options = this._copyOptions();
    context.updateOptions(options);
    context.currentQueryIndex = this.currentQueryIndex;
    context.currentQueryTotal = this.currentQueryTotal;
    context.parentContext = this;
    this.subContextCount++;
    return context;
  }
  transformIntoNewTimeline(newTime) {
    this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
    this.currentTimeline = this.currentTimeline.fork(this.element, newTime);
    this.timelines.push(this.currentTimeline);
    return this.currentTimeline;
  }
  appendInstructionToTimeline(instruction, duration, delay) {
    const updatedTimings = {
      duration: duration != null ? duration : instruction.duration,
      delay: this.currentTimeline.currentTime + (delay != null ? delay : 0) + instruction.delay,
      easing: ''
    };
    const builder = new SubTimelineBuilder(this._driver, instruction.element, instruction.keyframes, instruction.preStyleProps, instruction.postStyleProps, updatedTimings, instruction.stretchStartingKeyframe);
    this.timelines.push(builder);
    return updatedTimings;
  }
  incrementTime(time) {
    this.currentTimeline.forwardTime(this.currentTimeline.duration + time);
  }
  delayNextStep(delay) {
    // negative delays are not yet supported
    if (delay > 0) {
      this.currentTimeline.delayNextStep(delay);
    }
  }
  invokeQuery(selector, originalSelector, limit, includeSelf, optional, errors) {
    let results = [];
    if (includeSelf) {
      results.push(this.element);
    }
    if (selector.length > 0) {
      // if :self is only used then the selector is empty
      selector = selector.replace(ENTER_TOKEN_REGEX, '.' + this._enterClassName);
      selector = selector.replace(LEAVE_TOKEN_REGEX, '.' + this._leaveClassName);
      const multi = limit != 1;
      let elements = this._driver.query(this.element, selector, multi);
      if (limit !== 0) {
        elements = limit < 0 ? elements.slice(elements.length + limit, elements.length) : elements.slice(0, limit);
      }
      results.push(...elements);
    }
    if (!optional && results.length == 0) {
      errors.push(`\`query("${originalSelector}")\` returned zero elements. (Use \`query("${originalSelector}", { optional: true })\` if you wish to allow this.)`);
    }
    return results;
  }
}
class TimelineBuilder {
  constructor(_driver, element, startTime, _elementTimelineStylesLookup) {
    this._driver = _driver;
    this.element = element;
    this.startTime = startTime;
    this._elementTimelineStylesLookup = _elementTimelineStylesLookup;
    this.duration = 0;
    this._previousKeyframe = {};
    this._currentKeyframe = {};
    this._keyframes = new Map();
    this._styleSummary = {};
    this._pendingStyles = {};
    this._backFill = {};
    this._currentEmptyStepKeyframe = null;
    if (!this._elementTimelineStylesLookup) {
      this._elementTimelineStylesLookup = new Map();
    }
    this._localTimelineStyles = Object.create(this._backFill, {});
    this._globalTimelineStyles = this._elementTimelineStylesLookup.get(element);
    if (!this._globalTimelineStyles) {
      this._globalTimelineStyles = this._localTimelineStyles;
      this._elementTimelineStylesLookup.set(element, this._localTimelineStyles);
    }
    this._loadKeyframe();
  }
  containsAnimation() {
    switch (this._keyframes.size) {
      case 0:
        return false;
      case 1:
        return this.getCurrentStyleProperties().length > 0;
      default:
        return true;
    }
  }
  getCurrentStyleProperties() {
    return Object.keys(this._currentKeyframe);
  }
  get currentTime() {
    return this.startTime + this.duration;
  }
  delayNextStep(delay) {
    // in the event that a style() step is placed right before a stagger()
    // and that style() step is the very first style() value in the animation
    // then we need to make a copy of the keyframe [0, copy, 1] so that the delay
    // properly applies the style() values to work with the stagger...
    const hasPreStyleStep = this._keyframes.size == 1 && Object.keys(this._pendingStyles).length;
    if (this.duration || hasPreStyleStep) {
      this.forwardTime(this.currentTime + delay);
      if (hasPreStyleStep) {
        this.snapshotCurrentStyles();
      }
    } else {
      this.startTime += delay;
    }
  }
  fork(element, currentTime) {
    this.applyStylesToKeyframe();
    return new TimelineBuilder(this._driver, element, currentTime || this.currentTime, this._elementTimelineStylesLookup);
  }
  _loadKeyframe() {
    if (this._currentKeyframe) {
      this._previousKeyframe = this._currentKeyframe;
    }
    this._currentKeyframe = this._keyframes.get(this.duration);
    if (!this._currentKeyframe) {
      this._currentKeyframe = Object.create(this._backFill, {});
      this._keyframes.set(this.duration, this._currentKeyframe);
    }
  }
  forwardFrame() {
    this.duration += ONE_FRAME_IN_MILLISECONDS;
    this._loadKeyframe();
  }
  forwardTime(time) {
    this.applyStylesToKeyframe();
    this.duration = time;
    this._loadKeyframe();
  }
  _updateStyle(prop, value) {
    this._localTimelineStyles[prop] = value;
    this._globalTimelineStyles[prop] = value;
    this._styleSummary[prop] = {
      time: this.currentTime,
      value
    };
  }
  allowOnlyTimelineStyles() {
    return this._currentEmptyStepKeyframe !== this._currentKeyframe;
  }
  applyEmptyStep(easing) {
    if (easing) {
      this._previousKeyframe['easing'] = easing;
    }
    // special case for animate(duration):
    // all missing styles are filled with a `*` value then
    // if any destination styles are filled in later on the same
    // keyframe then they will override the overridden styles
    // We use `_globalTimelineStyles` here because there may be
    // styles in previous keyframes that are not present in this timeline
    Object.keys(this._globalTimelineStyles).forEach(prop => {
      this._backFill[prop] = this._globalTimelineStyles[prop] || _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .AUTO_STYLE */ .l3;
      this._currentKeyframe[prop] = _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .AUTO_STYLE */ .l3;
    });
    this._currentEmptyStepKeyframe = this._currentKeyframe;
  }
  setStyles(input, easing, errors, options) {
    if (easing) {
      this._previousKeyframe['easing'] = easing;
    }
    const params = options && options.params || {};
    const styles = flattenStyles(input, this._globalTimelineStyles);
    Object.keys(styles).forEach(prop => {
      const val = interpolateParams(styles[prop], params, errors);
      this._pendingStyles[prop] = val;
      if (!this._localTimelineStyles.hasOwnProperty(prop)) {
        this._backFill[prop] = this._globalTimelineStyles.hasOwnProperty(prop) ? this._globalTimelineStyles[prop] : _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .AUTO_STYLE */ .l3;
      }
      this._updateStyle(prop, val);
    });
  }
  applyStylesToKeyframe() {
    const styles = this._pendingStyles;
    const props = Object.keys(styles);
    if (props.length == 0) return;
    this._pendingStyles = {};
    props.forEach(prop => {
      const val = styles[prop];
      this._currentKeyframe[prop] = val;
    });
    Object.keys(this._localTimelineStyles).forEach(prop => {
      if (!this._currentKeyframe.hasOwnProperty(prop)) {
        this._currentKeyframe[prop] = this._localTimelineStyles[prop];
      }
    });
  }
  snapshotCurrentStyles() {
    Object.keys(this._localTimelineStyles).forEach(prop => {
      const val = this._localTimelineStyles[prop];
      this._pendingStyles[prop] = val;
      this._updateStyle(prop, val);
    });
  }
  getFinalKeyframe() {
    return this._keyframes.get(this.duration);
  }
  get properties() {
    const properties = [];
    for (let prop in this._currentKeyframe) {
      properties.push(prop);
    }
    return properties;
  }
  mergeTimelineCollectedStyles(timeline) {
    Object.keys(timeline._styleSummary).forEach(prop => {
      const details0 = this._styleSummary[prop];
      const details1 = timeline._styleSummary[prop];
      if (!details0 || details1.time > details0.time) {
        this._updateStyle(prop, details1.value);
      }
    });
  }
  buildKeyframes() {
    this.applyStylesToKeyframe();
    const preStyleProps = new Set();
    const postStyleProps = new Set();
    const isEmpty = this._keyframes.size === 1 && this.duration === 0;
    let finalKeyframes = [];
    this._keyframes.forEach((keyframe, time) => {
      const finalKeyframe = copyStyles(keyframe, true);
      Object.keys(finalKeyframe).forEach(prop => {
        const value = finalKeyframe[prop];
        if (value == _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* ["ɵPRE_STYLE"] */ .k1) {
          preStyleProps.add(prop);
        } else if (value == _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .AUTO_STYLE */ .l3) {
          postStyleProps.add(prop);
        }
      });
      if (!isEmpty) {
        finalKeyframe['offset'] = time / this.duration;
      }
      finalKeyframes.push(finalKeyframe);
    });
    const preProps = preStyleProps.size ? iteratorToArray(preStyleProps.values()) : [];
    const postProps = postStyleProps.size ? iteratorToArray(postStyleProps.values()) : [];
    // special case for a 0-second animation (which is designed just to place styles onscreen)
    if (isEmpty) {
      const kf0 = finalKeyframes[0];
      const kf1 = copyObj(kf0);
      kf0['offset'] = 0;
      kf1['offset'] = 1;
      finalKeyframes = [kf0, kf1];
    }
    return createTimelineInstruction(this.element, finalKeyframes, preProps, postProps, this.duration, this.startTime, this.easing, false);
  }
}
class SubTimelineBuilder extends TimelineBuilder {
  constructor(driver, element, keyframes, preStyleProps, postStyleProps, timings, _stretchStartingKeyframe = false) {
    super(driver, element, timings.delay);
    this.keyframes = keyframes;
    this.preStyleProps = preStyleProps;
    this.postStyleProps = postStyleProps;
    this._stretchStartingKeyframe = _stretchStartingKeyframe;
    this.timings = {
      duration: timings.duration,
      delay: timings.delay,
      easing: timings.easing
    };
  }
  containsAnimation() {
    return this.keyframes.length > 1;
  }
  buildKeyframes() {
    let keyframes = this.keyframes;
    let {
      delay,
      duration,
      easing
    } = this.timings;
    if (this._stretchStartingKeyframe && delay) {
      const newKeyframes = [];
      const totalTime = duration + delay;
      const startingGap = delay / totalTime;
      // the original starting keyframe now starts once the delay is done
      const newFirstKeyframe = copyStyles(keyframes[0], false);
      newFirstKeyframe['offset'] = 0;
      newKeyframes.push(newFirstKeyframe);
      const oldFirstKeyframe = copyStyles(keyframes[0], false);
      oldFirstKeyframe['offset'] = roundOffset(startingGap);
      newKeyframes.push(oldFirstKeyframe);
      /*
        When the keyframe is stretched then it means that the delay before the animation
        starts is gone. Instead the first keyframe is placed at the start of the animation
        and it is then copied to where it starts when the original delay is over. This basically
        means nothing animates during that delay, but the styles are still renderered. For this
        to work the original offset values that exist in the original keyframes must be "warped"
        so that they can take the new keyframe + delay into account.
               delay=1000, duration=1000, keyframes = 0 .5 1
               turns into
               delay=0, duration=2000, keyframes = 0 .33 .66 1
       */
      // offsets between 1 ... n -1 are all warped by the keyframe stretch
      const limit = keyframes.length - 1;
      for (let i = 1; i <= limit; i++) {
        let kf = copyStyles(keyframes[i], false);
        const oldOffset = kf['offset'];
        const timeAtKeyframe = delay + oldOffset * duration;
        kf['offset'] = roundOffset(timeAtKeyframe / totalTime);
        newKeyframes.push(kf);
      }
      // the new starting keyframe should be added at the start
      duration = totalTime;
      delay = 0;
      easing = '';
      keyframes = newKeyframes;
    }
    return createTimelineInstruction(this.element, keyframes, this.preStyleProps, this.postStyleProps, duration, delay, easing, true);
  }
}
function roundOffset(offset, decimalPoints = 3) {
  const mult = Math.pow(10, decimalPoints - 1);
  return Math.round(offset * mult) / mult;
}
function flattenStyles(input, allStyles) {
  const styles = {};
  let allProperties;
  input.forEach(token => {
    if (token === '*') {
      allProperties = allProperties || Object.keys(allStyles);
      allProperties.forEach(prop => {
        styles[prop] = _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .AUTO_STYLE */ .l3;
      });
    } else {
      copyStyles(token, false, styles);
    }
  });
  return styles;
}
class Animation {
  constructor(_driver, input) {
    this._driver = _driver;
    const errors = [];
    const ast = buildAnimationAst(_driver, input, errors);
    if (errors.length) {
      const errorMessage = `animation validation failed:\n${errors.join('\n')}`;
      throw new Error(errorMessage);
    }
    this._animationAst = ast;
  }
  buildTimelines(element, startingStyles, destinationStyles, options, subInstructions) {
    const start = Array.isArray(startingStyles) ? normalizeStyles(startingStyles) : startingStyles;
    const dest = Array.isArray(destinationStyles) ? normalizeStyles(destinationStyles) : destinationStyles;
    const errors = [];
    subInstructions = subInstructions || new ElementInstructionMap();
    const result = buildAnimationTimelines(this._driver, element, this._animationAst, ENTER_CLASSNAME, LEAVE_CLASSNAME, start, dest, options, subInstructions, errors);
    if (errors.length) {
      const errorMessage = `animation building failed:\n${errors.join('\n')}`;
      throw new Error(errorMessage);
    }
    return result;
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @publicApi
 */
class AnimationStyleNormalizer {}
/**
 * @publicApi
 */
class NoopAnimationStyleNormalizer {
  normalizePropertyName(propertyName, errors) {
    return propertyName;
  }
  normalizeStyleValue(userProvidedProperty, normalizedProperty, value, errors) {
    return value;
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class WebAnimationsStyleNormalizer extends AnimationStyleNormalizer {
  normalizePropertyName(propertyName, errors) {
    return dashCaseToCamelCase(propertyName);
  }
  normalizeStyleValue(userProvidedProperty, normalizedProperty, value, errors) {
    let unit = '';
    const strVal = value.toString().trim();
    if (DIMENSIONAL_PROP_MAP[normalizedProperty] && value !== 0 && value !== '0') {
      if (typeof value === 'number') {
        unit = 'px';
      } else {
        const valAndSuffixMatch = value.match(/^[+-]?[\d\.]+([a-z]*)$/);
        if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
          errors.push(`Please provide a CSS unit value for ${userProvidedProperty}:${value}`);
        }
      }
    }
    return strVal + unit;
  }
}
const ɵ0$1 = () => makeBooleanMap('width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective'.split(','));
const DIMENSIONAL_PROP_MAP = /*#__PURE__*/ɵ0$1();
function makeBooleanMap(keys) {
  const map = {};
  keys.forEach(key => map[key] = true);
  return map;
}
function createTransitionInstruction(element, triggerName, fromState, toState, isRemovalTransition, fromStyles, toStyles, timelines, queriedElements, preStyleProps, postStyleProps, totalTime, errors) {
  return {
    type: 0 /* TransitionAnimation */,
    element,
    triggerName,
    isRemovalTransition,
    fromState,
    fromStyles,
    toState,
    toStyles,
    timelines,
    queriedElements,
    preStyleProps,
    postStyleProps,
    totalTime,
    errors
  };
}
const EMPTY_OBJECT = {};
class AnimationTransitionFactory {
  constructor(_triggerName, ast, _stateStyles) {
    this._triggerName = _triggerName;
    this.ast = ast;
    this._stateStyles = _stateStyles;
  }
  match(currentState, nextState, element, params) {
    return oneOrMoreTransitionsMatch(this.ast.matchers, currentState, nextState, element, params);
  }
  buildStyles(stateName, params, errors) {
    const backupStateStyler = this._stateStyles['*'];
    const stateStyler = this._stateStyles[stateName];
    const backupStyles = backupStateStyler ? backupStateStyler.buildStyles(params, errors) : {};
    return stateStyler ? stateStyler.buildStyles(params, errors) : backupStyles;
  }
  build(driver, element, currentState, nextState, enterClassName, leaveClassName, currentOptions, nextOptions, subInstructions, skipAstBuild) {
    const errors = [];
    const transitionAnimationParams = this.ast.options && this.ast.options.params || EMPTY_OBJECT;
    const currentAnimationParams = currentOptions && currentOptions.params || EMPTY_OBJECT;
    const currentStateStyles = this.buildStyles(currentState, currentAnimationParams, errors);
    const nextAnimationParams = nextOptions && nextOptions.params || EMPTY_OBJECT;
    const nextStateStyles = this.buildStyles(nextState, nextAnimationParams, errors);
    const queriedElements = new Set();
    const preStyleMap = new Map();
    const postStyleMap = new Map();
    const isRemoval = nextState === 'void';
    const animationOptions = {
      params: Object.assign(Object.assign({}, transitionAnimationParams), nextAnimationParams)
    };
    const timelines = skipAstBuild ? [] : buildAnimationTimelines(driver, element, this.ast.animation, enterClassName, leaveClassName, currentStateStyles, nextStateStyles, animationOptions, subInstructions, errors);
    let totalTime = 0;
    timelines.forEach(tl => {
      totalTime = Math.max(tl.duration + tl.delay, totalTime);
    });
    if (errors.length) {
      return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, [], [], preStyleMap, postStyleMap, totalTime, errors);
    }
    timelines.forEach(tl => {
      const elm = tl.element;
      const preProps = getOrSetAsInMap(preStyleMap, elm, {});
      tl.preStyleProps.forEach(prop => preProps[prop] = true);
      const postProps = getOrSetAsInMap(postStyleMap, elm, {});
      tl.postStyleProps.forEach(prop => postProps[prop] = true);
      if (elm !== element) {
        queriedElements.add(elm);
      }
    });
    const queriedElementsList = iteratorToArray(queriedElements.values());
    return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, timelines, queriedElementsList, preStyleMap, postStyleMap, totalTime);
  }
}
function oneOrMoreTransitionsMatch(matchFns, currentState, nextState, element, params) {
  return matchFns.some(fn => fn(currentState, nextState, element, params));
}
class AnimationStateStyles {
  constructor(styles, defaultParams, normalizer) {
    this.styles = styles;
    this.defaultParams = defaultParams;
    this.normalizer = normalizer;
  }
  buildStyles(params, errors) {
    const finalStyles = {};
    const combinedParams = copyObj(this.defaultParams);
    Object.keys(params).forEach(key => {
      const value = params[key];
      if (value != null) {
        combinedParams[key] = value;
      }
    });
    this.styles.styles.forEach(value => {
      if (typeof value !== 'string') {
        const styleObj = value;
        Object.keys(styleObj).forEach(prop => {
          let val = styleObj[prop];
          if (val.length > 1) {
            val = interpolateParams(val, combinedParams, errors);
          }
          const normalizedProp = this.normalizer.normalizePropertyName(prop, errors);
          val = this.normalizer.normalizeStyleValue(prop, normalizedProp, val, errors);
          finalStyles[normalizedProp] = val;
        });
      }
    });
    return finalStyles;
  }
}
function buildTrigger(name, ast, normalizer) {
  return new AnimationTrigger(name, ast, normalizer);
}
class AnimationTrigger {
  constructor(name, ast, _normalizer) {
    this.name = name;
    this.ast = ast;
    this._normalizer = _normalizer;
    this.transitionFactories = [];
    this.states = {};
    ast.states.forEach(ast => {
      const defaultParams = ast.options && ast.options.params || {};
      this.states[ast.name] = new AnimationStateStyles(ast.style, defaultParams, _normalizer);
    });
    balanceProperties(this.states, 'true', '1');
    balanceProperties(this.states, 'false', '0');
    ast.transitions.forEach(ast => {
      this.transitionFactories.push(new AnimationTransitionFactory(name, ast, this.states));
    });
    this.fallbackTransition = createFallbackTransition(name, this.states, this._normalizer);
  }
  get containsQueries() {
    return this.ast.queryCount > 0;
  }
  matchTransition(currentState, nextState, element, params) {
    const entry = this.transitionFactories.find(f => f.match(currentState, nextState, element, params));
    return entry || null;
  }
  matchStyles(currentState, params, errors) {
    return this.fallbackTransition.buildStyles(currentState, params, errors);
  }
}
function createFallbackTransition(triggerName, states, normalizer) {
  const matchers = [(fromState, toState) => true];
  const animation = {
    type: 2 /* Sequence */,
    steps: [],
    options: null
  };
  const transition = {
    type: 1 /* Transition */,
    animation,
    matchers,
    options: null,
    queryCount: 0,
    depCount: 0
  };
  return new AnimationTransitionFactory(triggerName, transition, states);
}
function balanceProperties(obj, key1, key2) {
  if (obj.hasOwnProperty(key1)) {
    if (!obj.hasOwnProperty(key2)) {
      obj[key2] = obj[key1];
    }
  } else if (obj.hasOwnProperty(key2)) {
    obj[key1] = obj[key2];
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const EMPTY_INSTRUCTION_MAP = /*#__PURE__*/new ElementInstructionMap();
class TimelineAnimationEngine {
  constructor(bodyNode, _driver, _normalizer) {
    this.bodyNode = bodyNode;
    this._driver = _driver;
    this._normalizer = _normalizer;
    this._animations = {};
    this._playersById = {};
    this.players = [];
  }
  register(id, metadata) {
    const errors = [];
    const ast = buildAnimationAst(this._driver, metadata, errors);
    if (errors.length) {
      throw new Error(`Unable to build the animation due to the following errors: ${errors.join('\n')}`);
    } else {
      this._animations[id] = ast;
    }
  }
  _buildPlayer(i, preStyles, postStyles) {
    const element = i.element;
    const keyframes = normalizeKeyframes(this._driver, this._normalizer, element, i.keyframes, preStyles, postStyles);
    return this._driver.animate(element, keyframes, i.duration, i.delay, i.easing, [], true);
  }
  create(id, element, options = {}) {
    const errors = [];
    const ast = this._animations[id];
    let instructions;
    const autoStylesMap = new Map();
    if (ast) {
      instructions = buildAnimationTimelines(this._driver, element, ast, ENTER_CLASSNAME, LEAVE_CLASSNAME, {}, {}, options, EMPTY_INSTRUCTION_MAP, errors);
      instructions.forEach(inst => {
        const styles = getOrSetAsInMap(autoStylesMap, inst.element, {});
        inst.postStyleProps.forEach(prop => styles[prop] = null);
      });
    } else {
      errors.push('The requested animation doesn\'t exist or has already been destroyed');
      instructions = [];
    }
    if (errors.length) {
      throw new Error(`Unable to create the animation due to the following errors: ${errors.join('\n')}`);
    }
    autoStylesMap.forEach((styles, element) => {
      Object.keys(styles).forEach(prop => {
        styles[prop] = this._driver.computeStyle(element, prop, _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .AUTO_STYLE */ .l3);
      });
    });
    const players = instructions.map(i => {
      const styles = autoStylesMap.get(i.element);
      return this._buildPlayer(i, {}, styles);
    });
    const player = optimizeGroupPlayer(players);
    this._playersById[id] = player;
    player.onDestroy(() => this.destroy(id));
    this.players.push(player);
    return player;
  }
  destroy(id) {
    const player = this._getPlayer(id);
    player.destroy();
    delete this._playersById[id];
    const index = this.players.indexOf(player);
    if (index >= 0) {
      this.players.splice(index, 1);
    }
  }
  _getPlayer(id) {
    const player = this._playersById[id];
    if (!player) {
      throw new Error(`Unable to find the timeline player referenced by ${id}`);
    }
    return player;
  }
  listen(id, element, eventName, callback) {
    // triggerName, fromState, toState are all ignored for timeline animations
    const baseEvent = makeAnimationEvent(element, '', '', '');
    listenOnPlayer(this._getPlayer(id), eventName, baseEvent, callback);
    return () => {};
  }
  command(id, element, command, args) {
    if (command == 'register') {
      this.register(id, args[0]);
      return;
    }
    if (command == 'create') {
      const options = args[0] || {};
      this.create(id, element, options);
      return;
    }
    const player = this._getPlayer(id);
    switch (command) {
      case 'play':
        player.play();
        break;
      case 'pause':
        player.pause();
        break;
      case 'reset':
        player.reset();
        break;
      case 'restart':
        player.restart();
        break;
      case 'finish':
        player.finish();
        break;
      case 'init':
        player.init();
        break;
      case 'setPosition':
        player.setPosition(parseFloat(args[0]));
        break;
      case 'destroy':
        this.destroy(id);
        break;
    }
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const QUEUED_CLASSNAME = 'ng-animate-queued';
const QUEUED_SELECTOR = '.ng-animate-queued';
const DISABLED_CLASSNAME = 'ng-animate-disabled';
const DISABLED_SELECTOR = '.ng-animate-disabled';
const STAR_CLASSNAME = 'ng-star-inserted';
const STAR_SELECTOR = '.ng-star-inserted';
const EMPTY_PLAYER_ARRAY = [];
const NULL_REMOVAL_STATE = {
  namespaceId: '',
  setForRemoval: false,
  setForMove: false,
  hasAnimation: false,
  removedBeforeQueried: false
};
const NULL_REMOVED_QUERIED_STATE = {
  namespaceId: '',
  setForMove: false,
  setForRemoval: false,
  hasAnimation: false,
  removedBeforeQueried: true
};
const REMOVAL_FLAG = '__ng_removed';
class StateValue {
  constructor(input, namespaceId = '') {
    this.namespaceId = namespaceId;
    const isObj = input && input.hasOwnProperty('value');
    const value = isObj ? input['value'] : input;
    this.value = normalizeTriggerValue(value);
    if (isObj) {
      const options = copyObj(input);
      delete options['value'];
      this.options = options;
    } else {
      this.options = {};
    }
    if (!this.options.params) {
      this.options.params = {};
    }
  }
  get params() {
    return this.options.params;
  }
  absorbOptions(options) {
    const newParams = options.params;
    if (newParams) {
      const oldParams = this.options.params;
      Object.keys(newParams).forEach(prop => {
        if (oldParams[prop] == null) {
          oldParams[prop] = newParams[prop];
        }
      });
    }
  }
}
const VOID_VALUE = 'void';
const DEFAULT_STATE_VALUE = /*#__PURE__*/new StateValue(VOID_VALUE);
class AnimationTransitionNamespace {
  constructor(id, hostElement, _engine) {
    this.id = id;
    this.hostElement = hostElement;
    this._engine = _engine;
    this.players = [];
    this._triggers = {};
    this._queue = [];
    this._elementListeners = new Map();
    this._hostClassName = 'ng-tns-' + id;
    addClass(hostElement, this._hostClassName);
  }
  listen(element, name, phase, callback) {
    if (!this._triggers.hasOwnProperty(name)) {
      throw new Error(`Unable to listen on the animation trigger event "${phase}" because the animation trigger "${name}" doesn\'t exist!`);
    }
    if (phase == null || phase.length == 0) {
      throw new Error(`Unable to listen on the animation trigger "${name}" because the provided event is undefined!`);
    }
    if (!isTriggerEventValid(phase)) {
      throw new Error(`The provided animation trigger event "${phase}" for the animation trigger "${name}" is not supported!`);
    }
    const listeners = getOrSetAsInMap(this._elementListeners, element, []);
    const data = {
      name,
      phase,
      callback
    };
    listeners.push(data);
    const triggersWithStates = getOrSetAsInMap(this._engine.statesByElement, element, {});
    if (!triggersWithStates.hasOwnProperty(name)) {
      addClass(element, NG_TRIGGER_CLASSNAME);
      addClass(element, NG_TRIGGER_CLASSNAME + '-' + name);
      triggersWithStates[name] = DEFAULT_STATE_VALUE;
    }
    return () => {
      // the event listener is removed AFTER the flush has occurred such
      // that leave animations callbacks can fire (otherwise if the node
      // is removed in between then the listeners would be deregistered)
      this._engine.afterFlush(() => {
        const index = listeners.indexOf(data);
        if (index >= 0) {
          listeners.splice(index, 1);
        }
        if (!this._triggers[name]) {
          delete triggersWithStates[name];
        }
      });
    };
  }
  register(name, ast) {
    if (this._triggers[name]) {
      // throw
      return false;
    } else {
      this._triggers[name] = ast;
      return true;
    }
  }
  _getTrigger(name) {
    const trigger = this._triggers[name];
    if (!trigger) {
      throw new Error(`The provided animation trigger "${name}" has not been registered!`);
    }
    return trigger;
  }
  trigger(element, triggerName, value, defaultToFallback = true) {
    const trigger = this._getTrigger(triggerName);
    const player = new TransitionAnimationPlayer(this.id, triggerName, element);
    let triggersWithStates = this._engine.statesByElement.get(element);
    if (!triggersWithStates) {
      addClass(element, NG_TRIGGER_CLASSNAME);
      addClass(element, NG_TRIGGER_CLASSNAME + '-' + triggerName);
      this._engine.statesByElement.set(element, triggersWithStates = {});
    }
    let fromState = triggersWithStates[triggerName];
    const toState = new StateValue(value, this.id);
    const isObj = value && value.hasOwnProperty('value');
    if (!isObj && fromState) {
      toState.absorbOptions(fromState.options);
    }
    triggersWithStates[triggerName] = toState;
    if (!fromState) {
      fromState = DEFAULT_STATE_VALUE;
    }
    const isRemoval = toState.value === VOID_VALUE;
    // normally this isn't reached by here, however, if an object expression
    // is passed in then it may be a new object each time. Comparing the value
    // is important since that will stay the same despite there being a new object.
    // The removal arc here is special cased because the same element is triggered
    // twice in the event that it contains animations on the outer/inner portions
    // of the host container
    if (!isRemoval && fromState.value === toState.value) {
      // this means that despite the value not changing, some inner params
      // have changed which means that the animation final styles need to be applied
      if (!objEquals(fromState.params, toState.params)) {
        const errors = [];
        const fromStyles = trigger.matchStyles(fromState.value, fromState.params, errors);
        const toStyles = trigger.matchStyles(toState.value, toState.params, errors);
        if (errors.length) {
          this._engine.reportError(errors);
        } else {
          this._engine.afterFlush(() => {
            eraseStyles(element, fromStyles);
            setStyles(element, toStyles);
          });
        }
      }
      return;
    }
    const playersOnElement = getOrSetAsInMap(this._engine.playersByElement, element, []);
    playersOnElement.forEach(player => {
      // only remove the player if it is queued on the EXACT same trigger/namespace
      // we only also deal with queued players here because if the animation has
      // started then we want to keep the player alive until the flush happens
      // (which is where the previousPlayers are passed into the new palyer)
      if (player.namespaceId == this.id && player.triggerName == triggerName && player.queued) {
        player.destroy();
      }
    });
    let transition = trigger.matchTransition(fromState.value, toState.value, element, toState.params);
    let isFallbackTransition = false;
    if (!transition) {
      if (!defaultToFallback) return;
      transition = trigger.fallbackTransition;
      isFallbackTransition = true;
    }
    this._engine.totalQueuedPlayers++;
    this._queue.push({
      element,
      triggerName,
      transition,
      fromState,
      toState,
      player,
      isFallbackTransition
    });
    if (!isFallbackTransition) {
      addClass(element, QUEUED_CLASSNAME);
      player.onStart(() => {
        removeClass(element, QUEUED_CLASSNAME);
      });
    }
    player.onDone(() => {
      let index = this.players.indexOf(player);
      if (index >= 0) {
        this.players.splice(index, 1);
      }
      const players = this._engine.playersByElement.get(element);
      if (players) {
        let index = players.indexOf(player);
        if (index >= 0) {
          players.splice(index, 1);
        }
      }
    });
    this.players.push(player);
    playersOnElement.push(player);
    return player;
  }
  deregister(name) {
    delete this._triggers[name];
    this._engine.statesByElement.forEach((stateMap, element) => {
      delete stateMap[name];
    });
    this._elementListeners.forEach((listeners, element) => {
      this._elementListeners.set(element, listeners.filter(entry => {
        return entry.name != name;
      }));
    });
  }
  clearElementCache(element) {
    this._engine.statesByElement.delete(element);
    this._elementListeners.delete(element);
    const elementPlayers = this._engine.playersByElement.get(element);
    if (elementPlayers) {
      elementPlayers.forEach(player => player.destroy());
      this._engine.playersByElement.delete(element);
    }
  }
  _signalRemovalForInnerTriggers(rootElement, context) {
    const elements = this._engine.driver.query(rootElement, NG_TRIGGER_SELECTOR, true);
    // emulate a leave animation for all inner nodes within this node.
    // If there are no animations found for any of the nodes then clear the cache
    // for the element.
    elements.forEach(elm => {
      // this means that an inner remove() operation has already kicked off
      // the animation on this element...
      if (elm[REMOVAL_FLAG]) return;
      const namespaces = this._engine.fetchNamespacesByElement(elm);
      if (namespaces.size) {
        namespaces.forEach(ns => ns.triggerLeaveAnimation(elm, context, false, true));
      } else {
        this.clearElementCache(elm);
      }
    });
    // If the child elements were removed along with the parent, their animations might not
    // have completed. Clear all the elements from the cache so we don't end up with a memory leak.
    this._engine.afterFlushAnimationsDone(() => elements.forEach(elm => this.clearElementCache(elm)));
  }
  triggerLeaveAnimation(element, context, destroyAfterComplete, defaultToFallback) {
    const triggerStates = this._engine.statesByElement.get(element);
    if (triggerStates) {
      const players = [];
      Object.keys(triggerStates).forEach(triggerName => {
        // this check is here in the event that an element is removed
        // twice (both on the host level and the component level)
        if (this._triggers[triggerName]) {
          const player = this.trigger(element, triggerName, VOID_VALUE, defaultToFallback);
          if (player) {
            players.push(player);
          }
        }
      });
      if (players.length) {
        this._engine.markElementAsRemoved(this.id, element, true, context);
        if (destroyAfterComplete) {
          optimizeGroupPlayer(players).onDone(() => this._engine.processLeaveNode(element));
        }
        return true;
      }
    }
    return false;
  }
  prepareLeaveAnimationListeners(element) {
    const listeners = this._elementListeners.get(element);
    const elementStates = this._engine.statesByElement.get(element);
    // if this statement fails then it means that the element was picked up
    // by an earlier flush (or there are no listeners at all to track the leave).
    if (listeners && elementStates) {
      const visitedTriggers = new Set();
      listeners.forEach(listener => {
        const triggerName = listener.name;
        if (visitedTriggers.has(triggerName)) return;
        visitedTriggers.add(triggerName);
        const trigger = this._triggers[triggerName];
        const transition = trigger.fallbackTransition;
        const fromState = elementStates[triggerName] || DEFAULT_STATE_VALUE;
        const toState = new StateValue(VOID_VALUE);
        const player = new TransitionAnimationPlayer(this.id, triggerName, element);
        this._engine.totalQueuedPlayers++;
        this._queue.push({
          element,
          triggerName,
          transition,
          fromState,
          toState,
          player,
          isFallbackTransition: true
        });
      });
    }
  }
  removeNode(element, context) {
    const engine = this._engine;
    if (element.childElementCount) {
      this._signalRemovalForInnerTriggers(element, context);
    }
    // this means that a * => VOID animation was detected and kicked off
    if (this.triggerLeaveAnimation(element, context, true)) return;
    // find the player that is animating and make sure that the
    // removal is delayed until that player has completed
    let containsPotentialParentTransition = false;
    if (engine.totalAnimations) {
      const currentPlayers = engine.players.length ? engine.playersByQueriedElement.get(element) : [];
      // when this `if statement` does not continue forward it means that
      // a previous animation query has selected the current element and
      // is animating it. In this situation want to continue forwards and
      // allow the element to be queued up for animation later.
      if (currentPlayers && currentPlayers.length) {
        containsPotentialParentTransition = true;
      } else {
        let parent = element;
        while (parent = parent.parentNode) {
          const triggers = engine.statesByElement.get(parent);
          if (triggers) {
            containsPotentialParentTransition = true;
            break;
          }
        }
      }
    }
    // at this stage we know that the element will either get removed
    // during flush or will be picked up by a parent query. Either way
    // we need to fire the listeners for this element when it DOES get
    // removed (once the query parent animation is done or after flush)
    this.prepareLeaveAnimationListeners(element);
    // whether or not a parent has an animation we need to delay the deferral of the leave
    // operation until we have more information (which we do after flush() has been called)
    if (containsPotentialParentTransition) {
      engine.markElementAsRemoved(this.id, element, false, context);
    } else {
      const removalFlag = element[REMOVAL_FLAG];
      if (!removalFlag || removalFlag === NULL_REMOVAL_STATE) {
        // we do this after the flush has occurred such
        // that the callbacks can be fired
        engine.afterFlush(() => this.clearElementCache(element));
        engine.destroyInnerAnimations(element);
        engine._onRemovalComplete(element, context);
      }
    }
  }
  insertNode(element, parent) {
    addClass(element, this._hostClassName);
  }
  drainQueuedTransitions(microtaskId) {
    const instructions = [];
    this._queue.forEach(entry => {
      const player = entry.player;
      if (player.destroyed) return;
      const element = entry.element;
      const listeners = this._elementListeners.get(element);
      if (listeners) {
        listeners.forEach(listener => {
          if (listener.name == entry.triggerName) {
            const baseEvent = makeAnimationEvent(element, entry.triggerName, entry.fromState.value, entry.toState.value);
            baseEvent['_data'] = microtaskId;
            listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);
          }
        });
      }
      if (player.markedForDestroy) {
        this._engine.afterFlush(() => {
          // now we can destroy the element properly since the event listeners have
          // been bound to the player
          player.destroy();
        });
      } else {
        instructions.push(entry);
      }
    });
    this._queue = [];
    return instructions.sort((a, b) => {
      // if depCount == 0 them move to front
      // otherwise if a contains b then move back
      const d0 = a.transition.ast.depCount;
      const d1 = b.transition.ast.depCount;
      if (d0 == 0 || d1 == 0) {
        return d0 - d1;
      }
      return this._engine.driver.containsElement(a.element, b.element) ? 1 : -1;
    });
  }
  destroy(context) {
    this.players.forEach(p => p.destroy());
    this._signalRemovalForInnerTriggers(this.hostElement, context);
  }
  elementContainsData(element) {
    let containsData = false;
    if (this._elementListeners.has(element)) containsData = true;
    containsData = (this._queue.find(entry => entry.element === element) ? true : false) || containsData;
    return containsData;
  }
}
class TransitionAnimationEngine {
  constructor(bodyNode, driver, _normalizer) {
    this.bodyNode = bodyNode;
    this.driver = driver;
    this._normalizer = _normalizer;
    this.players = [];
    this.newHostElements = new Map();
    this.playersByElement = new Map();
    this.playersByQueriedElement = new Map();
    this.statesByElement = new Map();
    this.disabledNodes = new Set();
    this.totalAnimations = 0;
    this.totalQueuedPlayers = 0;
    this._namespaceLookup = {};
    this._namespaceList = [];
    this._flushFns = [];
    this._whenQuietFns = [];
    this.namespacesByHostElement = new Map();
    this.collectedEnterElements = [];
    this.collectedLeaveElements = [];
    // this method is designed to be overridden by the code that uses this engine
    this.onRemovalComplete = (element, context) => {};
  }
  /** @internal */
  _onRemovalComplete(element, context) {
    this.onRemovalComplete(element, context);
  }
  get queuedPlayers() {
    const players = [];
    this._namespaceList.forEach(ns => {
      ns.players.forEach(player => {
        if (player.queued) {
          players.push(player);
        }
      });
    });
    return players;
  }
  createNamespace(namespaceId, hostElement) {
    const ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);
    if (this.bodyNode && this.driver.containsElement(this.bodyNode, hostElement)) {
      this._balanceNamespaceList(ns, hostElement);
    } else {
      // defer this later until flush during when the host element has
      // been inserted so that we know exactly where to place it in
      // the namespace list
      this.newHostElements.set(hostElement, ns);
      // given that this host element is apart of the animation code, it
      // may or may not be inserted by a parent node that is of an
      // animation renderer type. If this happens then we can still have
      // access to this item when we query for :enter nodes. If the parent
      // is a renderer then the set data-structure will normalize the entry
      this.collectEnterElement(hostElement);
    }
    return this._namespaceLookup[namespaceId] = ns;
  }
  _balanceNamespaceList(ns, hostElement) {
    const limit = this._namespaceList.length - 1;
    if (limit >= 0) {
      let found = false;
      for (let i = limit; i >= 0; i--) {
        const nextNamespace = this._namespaceList[i];
        if (this.driver.containsElement(nextNamespace.hostElement, hostElement)) {
          this._namespaceList.splice(i + 1, 0, ns);
          found = true;
          break;
        }
      }
      if (!found) {
        this._namespaceList.splice(0, 0, ns);
      }
    } else {
      this._namespaceList.push(ns);
    }
    this.namespacesByHostElement.set(hostElement, ns);
    return ns;
  }
  register(namespaceId, hostElement) {
    let ns = this._namespaceLookup[namespaceId];
    if (!ns) {
      ns = this.createNamespace(namespaceId, hostElement);
    }
    return ns;
  }
  registerTrigger(namespaceId, name, trigger) {
    let ns = this._namespaceLookup[namespaceId];
    if (ns && ns.register(name, trigger)) {
      this.totalAnimations++;
    }
  }
  destroy(namespaceId, context) {
    if (!namespaceId) return;
    const ns = this._fetchNamespace(namespaceId);
    this.afterFlush(() => {
      this.namespacesByHostElement.delete(ns.hostElement);
      delete this._namespaceLookup[namespaceId];
      const index = this._namespaceList.indexOf(ns);
      if (index >= 0) {
        this._namespaceList.splice(index, 1);
      }
    });
    this.afterFlushAnimationsDone(() => ns.destroy(context));
  }
  _fetchNamespace(id) {
    return this._namespaceLookup[id];
  }
  fetchNamespacesByElement(element) {
    // normally there should only be one namespace per element, however
    // if @triggers are placed on both the component element and then
    // its host element (within the component code) then there will be
    // two namespaces returned. We use a set here to simply the dedupe
    // of namespaces incase there are multiple triggers both the elm and host
    const namespaces = new Set();
    const elementStates = this.statesByElement.get(element);
    if (elementStates) {
      const keys = Object.keys(elementStates);
      for (let i = 0; i < keys.length; i++) {
        const nsId = elementStates[keys[i]].namespaceId;
        if (nsId) {
          const ns = this._fetchNamespace(nsId);
          if (ns) {
            namespaces.add(ns);
          }
        }
      }
    }
    return namespaces;
  }
  trigger(namespaceId, element, name, value) {
    if (isElementNode(element)) {
      const ns = this._fetchNamespace(namespaceId);
      if (ns) {
        ns.trigger(element, name, value);
        return true;
      }
    }
    return false;
  }
  insertNode(namespaceId, element, parent, insertBefore) {
    if (!isElementNode(element)) return;
    // special case for when an element is removed and reinserted (move operation)
    // when this occurs we do not want to use the element for deletion later
    const details = element[REMOVAL_FLAG];
    if (details && details.setForRemoval) {
      details.setForRemoval = false;
      details.setForMove = true;
      const index = this.collectedLeaveElements.indexOf(element);
      if (index >= 0) {
        this.collectedLeaveElements.splice(index, 1);
      }
    }
    // in the event that the namespaceId is blank then the caller
    // code does not contain any animation code in it, but it is
    // just being called so that the node is marked as being inserted
    if (namespaceId) {
      const ns = this._fetchNamespace(namespaceId);
      // This if-statement is a workaround for router issue #21947.
      // The router sometimes hits a race condition where while a route
      // is being instantiated a new navigation arrives, triggering leave
      // animation of DOM that has not been fully initialized, until this
      // is resolved, we need to handle the scenario when DOM is not in a
      // consistent state during the animation.
      if (ns) {
        ns.insertNode(element, parent);
      }
    }
    // only *directives and host elements are inserted before
    if (insertBefore) {
      this.collectEnterElement(element);
    }
  }
  collectEnterElement(element) {
    this.collectedEnterElements.push(element);
  }
  markElementAsDisabled(element, value) {
    if (value) {
      if (!this.disabledNodes.has(element)) {
        this.disabledNodes.add(element);
        addClass(element, DISABLED_CLASSNAME);
      }
    } else if (this.disabledNodes.has(element)) {
      this.disabledNodes.delete(element);
      removeClass(element, DISABLED_CLASSNAME);
    }
  }
  removeNode(namespaceId, element, isHostElement, context) {
    if (isElementNode(element)) {
      const ns = namespaceId ? this._fetchNamespace(namespaceId) : null;
      if (ns) {
        ns.removeNode(element, context);
      } else {
        this.markElementAsRemoved(namespaceId, element, false, context);
      }
      if (isHostElement) {
        const hostNS = this.namespacesByHostElement.get(element);
        if (hostNS && hostNS.id !== namespaceId) {
          hostNS.removeNode(element, context);
        }
      }
    } else {
      this._onRemovalComplete(element, context);
    }
  }
  markElementAsRemoved(namespaceId, element, hasAnimation, context) {
    this.collectedLeaveElements.push(element);
    element[REMOVAL_FLAG] = {
      namespaceId,
      setForRemoval: context,
      hasAnimation,
      removedBeforeQueried: false
    };
  }
  listen(namespaceId, element, name, phase, callback) {
    if (isElementNode(element)) {
      return this._fetchNamespace(namespaceId).listen(element, name, phase, callback);
    }
    return () => {};
  }
  _buildInstruction(entry, subTimelines, enterClassName, leaveClassName, skipBuildAst) {
    return entry.transition.build(this.driver, entry.element, entry.fromState.value, entry.toState.value, enterClassName, leaveClassName, entry.fromState.options, entry.toState.options, subTimelines, skipBuildAst);
  }
  destroyInnerAnimations(containerElement) {
    let elements = this.driver.query(containerElement, NG_TRIGGER_SELECTOR, true);
    elements.forEach(element => this.destroyActiveAnimationsForElement(element));
    if (this.playersByQueriedElement.size == 0) return;
    elements = this.driver.query(containerElement, NG_ANIMATING_SELECTOR, true);
    elements.forEach(element => this.finishActiveQueriedAnimationOnElement(element));
  }
  destroyActiveAnimationsForElement(element) {
    const players = this.playersByElement.get(element);
    if (players) {
      players.forEach(player => {
        // special case for when an element is set for destruction, but hasn't started.
        // in this situation we want to delay the destruction until the flush occurs
        // so that any event listeners attached to the player are triggered.
        if (player.queued) {
          player.markedForDestroy = true;
        } else {
          player.destroy();
        }
      });
    }
  }
  finishActiveQueriedAnimationOnElement(element) {
    const players = this.playersByQueriedElement.get(element);
    if (players) {
      players.forEach(player => player.finish());
    }
  }
  whenRenderingDone() {
    return new Promise(resolve => {
      if (this.players.length) {
        return optimizeGroupPlayer(this.players).onDone(() => resolve());
      } else {
        resolve();
      }
    });
  }
  processLeaveNode(element) {
    const details = element[REMOVAL_FLAG];
    if (details && details.setForRemoval) {
      // this will prevent it from removing it twice
      element[REMOVAL_FLAG] = NULL_REMOVAL_STATE;
      if (details.namespaceId) {
        this.destroyInnerAnimations(element);
        const ns = this._fetchNamespace(details.namespaceId);
        if (ns) {
          ns.clearElementCache(element);
        }
      }
      this._onRemovalComplete(element, details.setForRemoval);
    }
    if (this.driver.matchesElement(element, DISABLED_SELECTOR)) {
      this.markElementAsDisabled(element, false);
    }
    this.driver.query(element, DISABLED_SELECTOR, true).forEach(node => {
      this.markElementAsDisabled(node, false);
    });
  }
  flush(microtaskId = -1) {
    let players = [];
    if (this.newHostElements.size) {
      this.newHostElements.forEach((ns, element) => this._balanceNamespaceList(ns, element));
      this.newHostElements.clear();
    }
    if (this.totalAnimations && this.collectedEnterElements.length) {
      for (let i = 0; i < this.collectedEnterElements.length; i++) {
        const elm = this.collectedEnterElements[i];
        addClass(elm, STAR_CLASSNAME);
      }
    }
    if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {
      const cleanupFns = [];
      try {
        players = this._flushAnimations(cleanupFns, microtaskId);
      } finally {
        for (let i = 0; i < cleanupFns.length; i++) {
          cleanupFns[i]();
        }
      }
    } else {
      for (let i = 0; i < this.collectedLeaveElements.length; i++) {
        const element = this.collectedLeaveElements[i];
        this.processLeaveNode(element);
      }
    }
    this.totalQueuedPlayers = 0;
    this.collectedEnterElements.length = 0;
    this.collectedLeaveElements.length = 0;
    this._flushFns.forEach(fn => fn());
    this._flushFns = [];
    if (this._whenQuietFns.length) {
      // we move these over to a variable so that
      // if any new callbacks are registered in another
      // flush they do not populate the existing set
      const quietFns = this._whenQuietFns;
      this._whenQuietFns = [];
      if (players.length) {
        optimizeGroupPlayer(players).onDone(() => {
          quietFns.forEach(fn => fn());
        });
      } else {
        quietFns.forEach(fn => fn());
      }
    }
  }
  reportError(errors) {
    throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${errors.join('\n')}`);
  }
  _flushAnimations(cleanupFns, microtaskId) {
    const subTimelines = new ElementInstructionMap();
    const skippedPlayers = [];
    const skippedPlayersMap = new Map();
    const queuedInstructions = [];
    const queriedElements = new Map();
    const allPreStyleElements = new Map();
    const allPostStyleElements = new Map();
    const disabledElementsSet = new Set();
    this.disabledNodes.forEach(node => {
      disabledElementsSet.add(node);
      const nodesThatAreDisabled = this.driver.query(node, QUEUED_SELECTOR, true);
      for (let i = 0; i < nodesThatAreDisabled.length; i++) {
        disabledElementsSet.add(nodesThatAreDisabled[i]);
      }
    });
    const bodyNode = this.bodyNode;
    const allTriggerElements = Array.from(this.statesByElement.keys());
    const enterNodeMap = buildRootMap(allTriggerElements, this.collectedEnterElements);
    // this must occur before the instructions are built below such that
    // the :enter queries match the elements (since the timeline queries
    // are fired during instruction building).
    const enterNodeMapIds = new Map();
    let i = 0;
    enterNodeMap.forEach((nodes, root) => {
      const className = ENTER_CLASSNAME + i++;
      enterNodeMapIds.set(root, className);
      nodes.forEach(node => addClass(node, className));
    });
    const allLeaveNodes = [];
    const mergedLeaveNodes = new Set();
    const leaveNodesWithoutAnimations = new Set();
    for (let i = 0; i < this.collectedLeaveElements.length; i++) {
      const element = this.collectedLeaveElements[i];
      const details = element[REMOVAL_FLAG];
      if (details && details.setForRemoval) {
        allLeaveNodes.push(element);
        mergedLeaveNodes.add(element);
        if (details.hasAnimation) {
          this.driver.query(element, STAR_SELECTOR, true).forEach(elm => mergedLeaveNodes.add(elm));
        } else {
          leaveNodesWithoutAnimations.add(element);
        }
      }
    }
    const leaveNodeMapIds = new Map();
    const leaveNodeMap = buildRootMap(allTriggerElements, Array.from(mergedLeaveNodes));
    leaveNodeMap.forEach((nodes, root) => {
      const className = LEAVE_CLASSNAME + i++;
      leaveNodeMapIds.set(root, className);
      nodes.forEach(node => addClass(node, className));
    });
    cleanupFns.push(() => {
      enterNodeMap.forEach((nodes, root) => {
        const className = enterNodeMapIds.get(root);
        nodes.forEach(node => removeClass(node, className));
      });
      leaveNodeMap.forEach((nodes, root) => {
        const className = leaveNodeMapIds.get(root);
        nodes.forEach(node => removeClass(node, className));
      });
      allLeaveNodes.forEach(element => {
        this.processLeaveNode(element);
      });
    });
    const allPlayers = [];
    const erroneousTransitions = [];
    for (let i = this._namespaceList.length - 1; i >= 0; i--) {
      const ns = this._namespaceList[i];
      ns.drainQueuedTransitions(microtaskId).forEach(entry => {
        const player = entry.player;
        const element = entry.element;
        allPlayers.push(player);
        if (this.collectedEnterElements.length) {
          const details = element[REMOVAL_FLAG];
          // move animations are currently not supported...
          if (details && details.setForMove) {
            player.destroy();
            return;
          }
        }
        const nodeIsOrphaned = !bodyNode || !this.driver.containsElement(bodyNode, element);
        const leaveClassName = leaveNodeMapIds.get(element);
        const enterClassName = enterNodeMapIds.get(element);
        const instruction = this._buildInstruction(entry, subTimelines, enterClassName, leaveClassName, nodeIsOrphaned);
        if (instruction.errors && instruction.errors.length) {
          erroneousTransitions.push(instruction);
          return;
        }
        // even though the element may not be apart of the DOM, it may
        // still be added at a later point (due to the mechanics of content
        // projection and/or dynamic component insertion) therefore it's
        // important we still style the element.
        if (nodeIsOrphaned) {
          player.onStart(() => eraseStyles(element, instruction.fromStyles));
          player.onDestroy(() => setStyles(element, instruction.toStyles));
          skippedPlayers.push(player);
          return;
        }
        // if a unmatched transition is queued to go then it SHOULD NOT render
        // an animation and cancel the previously running animations.
        if (entry.isFallbackTransition) {
          player.onStart(() => eraseStyles(element, instruction.fromStyles));
          player.onDestroy(() => setStyles(element, instruction.toStyles));
          skippedPlayers.push(player);
          return;
        }
        // this means that if a parent animation uses this animation as a sub trigger
        // then it will instruct the timeline builder to not add a player delay, but
        // instead stretch the first keyframe gap up until the animation starts. The
        // reason this is important is to prevent extra initialization styles from being
        // required by the user in the animation.
        instruction.timelines.forEach(tl => tl.stretchStartingKeyframe = true);
        subTimelines.append(element, instruction.timelines);
        const tuple = {
          instruction,
          player,
          element
        };
        queuedInstructions.push(tuple);
        instruction.queriedElements.forEach(element => getOrSetAsInMap(queriedElements, element, []).push(player));
        instruction.preStyleProps.forEach((stringMap, element) => {
          const props = Object.keys(stringMap);
          if (props.length) {
            let setVal = allPreStyleElements.get(element);
            if (!setVal) {
              allPreStyleElements.set(element, setVal = new Set());
            }
            props.forEach(prop => setVal.add(prop));
          }
        });
        instruction.postStyleProps.forEach((stringMap, element) => {
          const props = Object.keys(stringMap);
          let setVal = allPostStyleElements.get(element);
          if (!setVal) {
            allPostStyleElements.set(element, setVal = new Set());
          }
          props.forEach(prop => setVal.add(prop));
        });
      });
    }
    if (erroneousTransitions.length) {
      const errors = [];
      erroneousTransitions.forEach(instruction => {
        errors.push(`@${instruction.triggerName} has failed due to:\n`);
        instruction.errors.forEach(error => errors.push(`- ${error}\n`));
      });
      allPlayers.forEach(player => player.destroy());
      this.reportError(errors);
    }
    const allPreviousPlayersMap = new Map();
    // this map works to tell which element in the DOM tree is contained by
    // which animation. Further down below this map will get populated once
    // the players are built and in doing so it can efficiently figure out
    // if a sub player is skipped due to a parent player having priority.
    const animationElementMap = new Map();
    queuedInstructions.forEach(entry => {
      const element = entry.element;
      if (subTimelines.has(element)) {
        animationElementMap.set(element, element);
        this._beforeAnimationBuild(entry.player.namespaceId, entry.instruction, allPreviousPlayersMap);
      }
    });
    skippedPlayers.forEach(player => {
      const element = player.element;
      const previousPlayers = this._getPreviousPlayers(element, false, player.namespaceId, player.triggerName, null);
      previousPlayers.forEach(prevPlayer => {
        getOrSetAsInMap(allPreviousPlayersMap, element, []).push(prevPlayer);
        prevPlayer.destroy();
      });
    });
    // this is a special case for nodes that will be removed (either by)
    // having their own leave animations or by being queried in a container
    // that will be removed once a parent animation is complete. The idea
    // here is that * styles must be identical to ! styles because of
    // backwards compatibility (* is also filled in by default in many places).
    // Otherwise * styles will return an empty value or auto since the element
    // that is being getComputedStyle'd will not be visible (since * = destination)
    const replaceNodes = allLeaveNodes.filter(node => {
      return replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements);
    });
    // POST STAGE: fill the * styles
    const postStylesMap = new Map();
    const allLeaveQueriedNodes = cloakAndComputeStyles(postStylesMap, this.driver, leaveNodesWithoutAnimations, allPostStyleElements, _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .AUTO_STYLE */ .l3);
    allLeaveQueriedNodes.forEach(node => {
      if (replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements)) {
        replaceNodes.push(node);
      }
    });
    // PRE STAGE: fill the ! styles
    const preStylesMap = new Map();
    enterNodeMap.forEach((nodes, root) => {
      cloakAndComputeStyles(preStylesMap, this.driver, new Set(nodes), allPreStyleElements, _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* ["ɵPRE_STYLE"] */ .k1);
    });
    replaceNodes.forEach(node => {
      const post = postStylesMap.get(node);
      const pre = preStylesMap.get(node);
      postStylesMap.set(node, Object.assign(Object.assign({}, post), pre));
    });
    const rootPlayers = [];
    const subPlayers = [];
    const NO_PARENT_ANIMATION_ELEMENT_DETECTED = {};
    queuedInstructions.forEach(entry => {
      const {
        element,
        player,
        instruction
      } = entry;
      // this means that it was never consumed by a parent animation which
      // means that it is independent and therefore should be set for animation
      if (subTimelines.has(element)) {
        if (disabledElementsSet.has(element)) {
          player.onDestroy(() => setStyles(element, instruction.toStyles));
          player.disabled = true;
          player.overrideTotalTime(instruction.totalTime);
          skippedPlayers.push(player);
          return;
        }
        // this will flow up the DOM and query the map to figure out
        // if a parent animation has priority over it. In the situation
        // that a parent is detected then it will cancel the loop. If
        // nothing is detected, or it takes a few hops to find a parent,
        // then it will fill in the missing nodes and signal them as having
        // a detected parent (or a NO_PARENT value via a special constant).
        let parentWithAnimation = NO_PARENT_ANIMATION_ELEMENT_DETECTED;
        if (animationElementMap.size > 1) {
          let elm = element;
          const parentsToAdd = [];
          while (elm = elm.parentNode) {
            const detectedParent = animationElementMap.get(elm);
            if (detectedParent) {
              parentWithAnimation = detectedParent;
              break;
            }
            parentsToAdd.push(elm);
          }
          parentsToAdd.forEach(parent => animationElementMap.set(parent, parentWithAnimation));
        }
        const innerPlayer = this._buildAnimation(player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap);
        player.setRealPlayer(innerPlayer);
        if (parentWithAnimation === NO_PARENT_ANIMATION_ELEMENT_DETECTED) {
          rootPlayers.push(player);
        } else {
          const parentPlayers = this.playersByElement.get(parentWithAnimation);
          if (parentPlayers && parentPlayers.length) {
            player.parentPlayer = optimizeGroupPlayer(parentPlayers);
          }
          skippedPlayers.push(player);
        }
      } else {
        eraseStyles(element, instruction.fromStyles);
        player.onDestroy(() => setStyles(element, instruction.toStyles));
        // there still might be a ancestor player animating this
        // element therefore we will still add it as a sub player
        // even if its animation may be disabled
        subPlayers.push(player);
        if (disabledElementsSet.has(element)) {
          skippedPlayers.push(player);
        }
      }
    });
    // find all of the sub players' corresponding inner animation player
    subPlayers.forEach(player => {
      // even if any players are not found for a sub animation then it
      // will still complete itself after the next tick since it's Noop
      const playersForElement = skippedPlayersMap.get(player.element);
      if (playersForElement && playersForElement.length) {
        const innerPlayer = optimizeGroupPlayer(playersForElement);
        player.setRealPlayer(innerPlayer);
      }
    });
    // the reason why we don't actually play the animation is
    // because all that a skipped player is designed to do is to
    // fire the start/done transition callback events
    skippedPlayers.forEach(player => {
      if (player.parentPlayer) {
        player.syncPlayerEvents(player.parentPlayer);
      } else {
        player.destroy();
      }
    });
    // run through all of the queued removals and see if they
    // were picked up by a query. If not then perform the removal
    // operation right away unless a parent animation is ongoing.
    for (let i = 0; i < allLeaveNodes.length; i++) {
      const element = allLeaveNodes[i];
      const details = element[REMOVAL_FLAG];
      removeClass(element, LEAVE_CLASSNAME);
      // this means the element has a removal animation that is being
      // taken care of and therefore the inner elements will hang around
      // until that animation is over (or the parent queried animation)
      if (details && details.hasAnimation) continue;
      let players = [];
      // if this element is queried or if it contains queried children
      // then we want for the element not to be removed from the page
      // until the queried animations have finished
      if (queriedElements.size) {
        let queriedPlayerResults = queriedElements.get(element);
        if (queriedPlayerResults && queriedPlayerResults.length) {
          players.push(...queriedPlayerResults);
        }
        let queriedInnerElements = this.driver.query(element, NG_ANIMATING_SELECTOR, true);
        for (let j = 0; j < queriedInnerElements.length; j++) {
          let queriedPlayers = queriedElements.get(queriedInnerElements[j]);
          if (queriedPlayers && queriedPlayers.length) {
            players.push(...queriedPlayers);
          }
        }
      }
      const activePlayers = players.filter(p => !p.destroyed);
      if (activePlayers.length) {
        removeNodesAfterAnimationDone(this, element, activePlayers);
      } else {
        this.processLeaveNode(element);
      }
    }
    // this is required so the cleanup method doesn't remove them
    allLeaveNodes.length = 0;
    rootPlayers.forEach(player => {
      this.players.push(player);
      player.onDone(() => {
        player.destroy();
        const index = this.players.indexOf(player);
        this.players.splice(index, 1);
      });
      player.play();
    });
    return rootPlayers;
  }
  elementContainsData(namespaceId, element) {
    let containsData = false;
    const details = element[REMOVAL_FLAG];
    if (details && details.setForRemoval) containsData = true;
    if (this.playersByElement.has(element)) containsData = true;
    if (this.playersByQueriedElement.has(element)) containsData = true;
    if (this.statesByElement.has(element)) containsData = true;
    return this._fetchNamespace(namespaceId).elementContainsData(element) || containsData;
  }
  afterFlush(callback) {
    this._flushFns.push(callback);
  }
  afterFlushAnimationsDone(callback) {
    this._whenQuietFns.push(callback);
  }
  _getPreviousPlayers(element, isQueriedElement, namespaceId, triggerName, toStateValue) {
    let players = [];
    if (isQueriedElement) {
      const queriedElementPlayers = this.playersByQueriedElement.get(element);
      if (queriedElementPlayers) {
        players = queriedElementPlayers;
      }
    } else {
      const elementPlayers = this.playersByElement.get(element);
      if (elementPlayers) {
        const isRemovalAnimation = !toStateValue || toStateValue == VOID_VALUE;
        elementPlayers.forEach(player => {
          if (player.queued) return;
          if (!isRemovalAnimation && player.triggerName != triggerName) return;
          players.push(player);
        });
      }
    }
    if (namespaceId || triggerName) {
      players = players.filter(player => {
        if (namespaceId && namespaceId != player.namespaceId) return false;
        if (triggerName && triggerName != player.triggerName) return false;
        return true;
      });
    }
    return players;
  }
  _beforeAnimationBuild(namespaceId, instruction, allPreviousPlayersMap) {
    const triggerName = instruction.triggerName;
    const rootElement = instruction.element;
    // when a removal animation occurs, ALL previous players are collected
    // and destroyed (even if they are outside of the current namespace)
    const targetNameSpaceId = instruction.isRemovalTransition ? undefined : namespaceId;
    const targetTriggerName = instruction.isRemovalTransition ? undefined : triggerName;
    for (const timelineInstruction of instruction.timelines) {
      const element = timelineInstruction.element;
      const isQueriedElement = element !== rootElement;
      const players = getOrSetAsInMap(allPreviousPlayersMap, element, []);
      const previousPlayers = this._getPreviousPlayers(element, isQueriedElement, targetNameSpaceId, targetTriggerName, instruction.toState);
      previousPlayers.forEach(player => {
        const realPlayer = player.getRealPlayer();
        if (realPlayer.beforeDestroy) {
          realPlayer.beforeDestroy();
        }
        player.destroy();
        players.push(player);
      });
    }
    // this needs to be done so that the PRE/POST styles can be
    // computed properly without interfering with the previous animation
    eraseStyles(rootElement, instruction.fromStyles);
  }
  _buildAnimation(namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap) {
    const triggerName = instruction.triggerName;
    const rootElement = instruction.element;
    // we first run this so that the previous animation player
    // data can be passed into the successive animation players
    const allQueriedPlayers = [];
    const allConsumedElements = new Set();
    const allSubElements = new Set();
    const allNewPlayers = instruction.timelines.map(timelineInstruction => {
      const element = timelineInstruction.element;
      allConsumedElements.add(element);
      // FIXME (matsko): make sure to-be-removed animations are removed properly
      const details = element[REMOVAL_FLAG];
      if (details && details.removedBeforeQueried) return new _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .NoopAnimationPlayer */ .ZN(timelineInstruction.duration, timelineInstruction.delay);
      const isQueriedElement = element !== rootElement;
      const previousPlayers = flattenGroupPlayers((allPreviousPlayersMap.get(element) || EMPTY_PLAYER_ARRAY).map(p => p.getRealPlayer())).filter(p => {
        // the `element` is not apart of the AnimationPlayer definition, but
        // Mock/WebAnimations
        // use the element within their implementation. This will be added in Angular5 to
        // AnimationPlayer
        const pp = p;
        return pp.element ? pp.element === element : false;
      });
      const preStyles = preStylesMap.get(element);
      const postStyles = postStylesMap.get(element);
      const keyframes = normalizeKeyframes(this.driver, this._normalizer, element, timelineInstruction.keyframes, preStyles, postStyles);
      const player = this._buildPlayer(timelineInstruction, keyframes, previousPlayers);
      // this means that this particular player belongs to a sub trigger. It is
      // important that we match this player up with the corresponding (@trigger.listener)
      if (timelineInstruction.subTimeline && skippedPlayersMap) {
        allSubElements.add(element);
      }
      if (isQueriedElement) {
        const wrappedPlayer = new TransitionAnimationPlayer(namespaceId, triggerName, element);
        wrappedPlayer.setRealPlayer(player);
        allQueriedPlayers.push(wrappedPlayer);
      }
      return player;
    });
    allQueriedPlayers.forEach(player => {
      getOrSetAsInMap(this.playersByQueriedElement, player.element, []).push(player);
      player.onDone(() => deleteOrUnsetInMap(this.playersByQueriedElement, player.element, player));
    });
    allConsumedElements.forEach(element => addClass(element, NG_ANIMATING_CLASSNAME));
    const player = optimizeGroupPlayer(allNewPlayers);
    player.onDestroy(() => {
      allConsumedElements.forEach(element => removeClass(element, NG_ANIMATING_CLASSNAME));
      setStyles(rootElement, instruction.toStyles);
    });
    // this basically makes all of the callbacks for sub element animations
    // be dependent on the upper players for when they finish
    allSubElements.forEach(element => {
      getOrSetAsInMap(skippedPlayersMap, element, []).push(player);
    });
    return player;
  }
  _buildPlayer(instruction, keyframes, previousPlayers) {
    if (keyframes.length > 0) {
      return this.driver.animate(instruction.element, keyframes, instruction.duration, instruction.delay, instruction.easing, previousPlayers);
    }
    // special case for when an empty transition|definition is provided
    // ... there is no point in rendering an empty animation
    return new _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .NoopAnimationPlayer */ .ZN(instruction.duration, instruction.delay);
  }
}
class TransitionAnimationPlayer {
  constructor(namespaceId, triggerName, element) {
    this.namespaceId = namespaceId;
    this.triggerName = triggerName;
    this.element = element;
    this._player = new _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .NoopAnimationPlayer */ .ZN();
    this._containsRealPlayer = false;
    this._queuedCallbacks = {};
    this.destroyed = false;
    this.markedForDestroy = false;
    this.disabled = false;
    this.queued = true;
    this.totalTime = 0;
  }
  setRealPlayer(player) {
    if (this._containsRealPlayer) return;
    this._player = player;
    Object.keys(this._queuedCallbacks).forEach(phase => {
      this._queuedCallbacks[phase].forEach(callback => listenOnPlayer(player, phase, undefined, callback));
    });
    this._queuedCallbacks = {};
    this._containsRealPlayer = true;
    this.overrideTotalTime(player.totalTime);
    this.queued = false;
  }
  getRealPlayer() {
    return this._player;
  }
  overrideTotalTime(totalTime) {
    this.totalTime = totalTime;
  }
  syncPlayerEvents(player) {
    const p = this._player;
    if (p.triggerCallback) {
      player.onStart(() => p.triggerCallback('start'));
    }
    player.onDone(() => this.finish());
    player.onDestroy(() => this.destroy());
  }
  _queueEvent(name, callback) {
    getOrSetAsInMap(this._queuedCallbacks, name, []).push(callback);
  }
  onDone(fn) {
    if (this.queued) {
      this._queueEvent('done', fn);
    }
    this._player.onDone(fn);
  }
  onStart(fn) {
    if (this.queued) {
      this._queueEvent('start', fn);
    }
    this._player.onStart(fn);
  }
  onDestroy(fn) {
    if (this.queued) {
      this._queueEvent('destroy', fn);
    }
    this._player.onDestroy(fn);
  }
  init() {
    this._player.init();
  }
  hasStarted() {
    return this.queued ? false : this._player.hasStarted();
  }
  play() {
    !this.queued && this._player.play();
  }
  pause() {
    !this.queued && this._player.pause();
  }
  restart() {
    !this.queued && this._player.restart();
  }
  finish() {
    this._player.finish();
  }
  destroy() {
    this.destroyed = true;
    this._player.destroy();
  }
  reset() {
    !this.queued && this._player.reset();
  }
  setPosition(p) {
    if (!this.queued) {
      this._player.setPosition(p);
    }
  }
  getPosition() {
    return this.queued ? 0 : this._player.getPosition();
  }
  /** @internal */
  triggerCallback(phaseName) {
    const p = this._player;
    if (p.triggerCallback) {
      p.triggerCallback(phaseName);
    }
  }
}
function deleteOrUnsetInMap(map, key, value) {
  let currentValues;
  if (map instanceof Map) {
    currentValues = map.get(key);
    if (currentValues) {
      if (currentValues.length) {
        const index = currentValues.indexOf(value);
        currentValues.splice(index, 1);
      }
      if (currentValues.length == 0) {
        map.delete(key);
      }
    }
  } else {
    currentValues = map[key];
    if (currentValues) {
      if (currentValues.length) {
        const index = currentValues.indexOf(value);
        currentValues.splice(index, 1);
      }
      if (currentValues.length == 0) {
        delete map[key];
      }
    }
  }
  return currentValues;
}
function normalizeTriggerValue(value) {
  // we use `!= null` here because it's the most simple
  // way to test against a "falsy" value without mixing
  // in empty strings or a zero value. DO NOT OPTIMIZE.
  return value != null ? value : null;
}
function isElementNode(node) {
  return node && node['nodeType'] === 1;
}
function isTriggerEventValid(eventName) {
  return eventName == 'start' || eventName == 'done';
}
function cloakElement(element, value) {
  const oldValue = element.style.display;
  element.style.display = value != null ? value : 'none';
  return oldValue;
}
function cloakAndComputeStyles(valuesMap, driver, elements, elementPropsMap, defaultStyle) {
  const cloakVals = [];
  elements.forEach(element => cloakVals.push(cloakElement(element)));
  const failedElements = [];
  elementPropsMap.forEach((props, element) => {
    const styles = {};
    props.forEach(prop => {
      const value = styles[prop] = driver.computeStyle(element, prop, defaultStyle);
      // there is no easy way to detect this because a sub element could be removed
      // by a parent animation element being detached.
      if (!value || value.length == 0) {
        element[REMOVAL_FLAG] = NULL_REMOVED_QUERIED_STATE;
        failedElements.push(element);
      }
    });
    valuesMap.set(element, styles);
  });
  // we use a index variable here since Set.forEach(a, i) does not return
  // an index value for the closure (but instead just the value)
  let i = 0;
  elements.forEach(element => cloakElement(element, cloakVals[i++]));
  return failedElements;
}
/*
Since the Angular renderer code will return a collection of inserted
nodes in all areas of a DOM tree, it's up to this algorithm to figure
out which nodes are roots for each animation @trigger.

By placing each inserted node into a Set and traversing upwards, it
is possible to find the @trigger elements and well any direct *star
insertion nodes, if a @trigger root is found then the enter element
is placed into the Map[@trigger] spot.
 */
function buildRootMap(roots, nodes) {
  const rootMap = new Map();
  roots.forEach(root => rootMap.set(root, []));
  if (nodes.length == 0) return rootMap;
  const NULL_NODE = 1;
  const nodeSet = new Set(nodes);
  const localRootMap = new Map();
  function getRoot(node) {
    if (!node) return NULL_NODE;
    let root = localRootMap.get(node);
    if (root) return root;
    const parent = node.parentNode;
    if (rootMap.has(parent)) {
      // ngIf inside @trigger
      root = parent;
    } else if (nodeSet.has(parent)) {
      // ngIf inside ngIf
      root = NULL_NODE;
    } else {
      // recurse upwards
      root = getRoot(parent);
    }
    localRootMap.set(node, root);
    return root;
  }
  nodes.forEach(node => {
    const root = getRoot(node);
    if (root !== NULL_NODE) {
      rootMap.get(root).push(node);
    }
  });
  return rootMap;
}
const CLASSES_CACHE_KEY = '$$classes';
function containsClass(element, className) {
  if (element.classList) {
    return element.classList.contains(className);
  } else {
    const classes = element[CLASSES_CACHE_KEY];
    return classes && classes[className];
  }
}
function addClass(element, className) {
  if (element.classList) {
    element.classList.add(className);
  } else {
    let classes = element[CLASSES_CACHE_KEY];
    if (!classes) {
      classes = element[CLASSES_CACHE_KEY] = {};
    }
    classes[className] = true;
  }
}
function removeClass(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else {
    let classes = element[CLASSES_CACHE_KEY];
    if (classes) {
      delete classes[className];
    }
  }
}
function removeNodesAfterAnimationDone(engine, element, players) {
  optimizeGroupPlayer(players).onDone(() => engine.processLeaveNode(element));
}
function flattenGroupPlayers(players) {
  const finalPlayers = [];
  _flattenGroupPlayersRecur(players, finalPlayers);
  return finalPlayers;
}
function _flattenGroupPlayersRecur(players, finalPlayers) {
  for (let i = 0; i < players.length; i++) {
    const player = players[i];
    if (player instanceof _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* ["ɵAnimationGroupPlayer"] */ .ZE) {
      _flattenGroupPlayersRecur(player.players, finalPlayers);
    } else {
      finalPlayers.push(player);
    }
  }
}
function objEquals(a, b) {
  const k1 = Object.keys(a);
  const k2 = Object.keys(b);
  if (k1.length != k2.length) return false;
  for (let i = 0; i < k1.length; i++) {
    const prop = k1[i];
    if (!b.hasOwnProperty(prop) || a[prop] !== b[prop]) return false;
  }
  return true;
}
function replacePostStylesAsPre(element, allPreStyleElements, allPostStyleElements) {
  const postEntry = allPostStyleElements.get(element);
  if (!postEntry) return false;
  let preEntry = allPreStyleElements.get(element);
  if (preEntry) {
    postEntry.forEach(data => preEntry.add(data));
  } else {
    allPreStyleElements.set(element, postEntry);
  }
  allPostStyleElements.delete(element);
  return true;
}
class AnimationEngine {
  constructor(bodyNode, _driver, _normalizer) {
    this.bodyNode = bodyNode;
    this._driver = _driver;
    this._normalizer = _normalizer;
    this._triggerCache = {};
    // this method is designed to be overridden by the code that uses this engine
    this.onRemovalComplete = (element, context) => {};
    this._transitionEngine = new TransitionAnimationEngine(bodyNode, _driver, _normalizer);
    this._timelineEngine = new TimelineAnimationEngine(bodyNode, _driver, _normalizer);
    this._transitionEngine.onRemovalComplete = (element, context) => this.onRemovalComplete(element, context);
  }
  registerTrigger(componentId, namespaceId, hostElement, name, metadata) {
    const cacheKey = componentId + '-' + name;
    let trigger = this._triggerCache[cacheKey];
    if (!trigger) {
      const errors = [];
      const ast = buildAnimationAst(this._driver, metadata, errors);
      if (errors.length) {
        throw new Error(`The animation trigger "${name}" has failed to build due to the following errors:\n - ${errors.join('\n - ')}`);
      }
      trigger = buildTrigger(name, ast, this._normalizer);
      this._triggerCache[cacheKey] = trigger;
    }
    this._transitionEngine.registerTrigger(namespaceId, name, trigger);
  }
  register(namespaceId, hostElement) {
    this._transitionEngine.register(namespaceId, hostElement);
  }
  destroy(namespaceId, context) {
    this._transitionEngine.destroy(namespaceId, context);
  }
  onInsert(namespaceId, element, parent, insertBefore) {
    this._transitionEngine.insertNode(namespaceId, element, parent, insertBefore);
  }
  onRemove(namespaceId, element, context, isHostElement) {
    this._transitionEngine.removeNode(namespaceId, element, isHostElement || false, context);
  }
  disableAnimations(element, disable) {
    this._transitionEngine.markElementAsDisabled(element, disable);
  }
  process(namespaceId, element, property, value) {
    if (property.charAt(0) == '@') {
      const [id, action] = parseTimelineCommand(property);
      const args = value;
      this._timelineEngine.command(id, element, action, args);
    } else {
      this._transitionEngine.trigger(namespaceId, element, property, value);
    }
  }
  listen(namespaceId, element, eventName, eventPhase, callback) {
    // @@listen
    if (eventName.charAt(0) == '@') {
      const [id, action] = parseTimelineCommand(eventName);
      return this._timelineEngine.listen(id, element, action, callback);
    }
    return this._transitionEngine.listen(namespaceId, element, eventName, eventPhase, callback);
  }
  flush(microtaskId = -1) {
    this._transitionEngine.flush(microtaskId);
  }
  get players() {
    return this._transitionEngine.players.concat(this._timelineEngine.players);
  }
  whenRenderingDone() {
    return this._transitionEngine.whenRenderingDone();
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Returns an instance of `SpecialCasedStyles` if and when any special (non animateable) styles are
 * detected.
 *
 * In CSS there exist properties that cannot be animated within a keyframe animation
 * (whether it be via CSS keyframes or web-animations) and the animation implementation
 * will ignore them. This function is designed to detect those special cased styles and
 * return a container that will be executed at the start and end of the animation.
 *
 * @returns an instance of `SpecialCasedStyles` if any special styles are detected otherwise `null`
 */
function packageNonAnimatableStyles(element, styles) {
  let startStyles = null;
  let endStyles = null;
  if (Array.isArray(styles) && styles.length) {
    startStyles = filterNonAnimatableStyles(styles[0]);
    if (styles.length > 1) {
      endStyles = filterNonAnimatableStyles(styles[styles.length - 1]);
    }
  } else if (styles) {
    startStyles = filterNonAnimatableStyles(styles);
  }
  return startStyles || endStyles ? new SpecialCasedStyles(element, startStyles, endStyles) : null;
}
/**
 * Designed to be executed during a keyframe-based animation to apply any special-cased styles.
 *
 * When started (when the `start()` method is run) then the provided `startStyles`
 * will be applied. When finished (when the `finish()` method is called) the
 * `endStyles` will be applied as well any any starting styles. Finally when
 * `destroy()` is called then all styles will be removed.
 */
let SpecialCasedStyles = /*#__PURE__*/(() => {
  class SpecialCasedStyles {
    constructor(_element, _startStyles, _endStyles) {
      this._element = _element;
      this._startStyles = _startStyles;
      this._endStyles = _endStyles;
      this._state = 0 /* Pending */;
      let initialStyles = SpecialCasedStyles.initialStylesByElement.get(_element);
      if (!initialStyles) {
        SpecialCasedStyles.initialStylesByElement.set(_element, initialStyles = {});
      }
      this._initialStyles = initialStyles;
    }
    start() {
      if (this._state < 1 /* Started */) {
        if (this._startStyles) {
          setStyles(this._element, this._startStyles, this._initialStyles);
        }
        this._state = 1 /* Started */;
      }
    }

    finish() {
      this.start();
      if (this._state < 2 /* Finished */) {
        setStyles(this._element, this._initialStyles);
        if (this._endStyles) {
          setStyles(this._element, this._endStyles);
          this._endStyles = null;
        }
        this._state = 1 /* Started */;
      }
    }

    destroy() {
      this.finish();
      if (this._state < 3 /* Destroyed */) {
        SpecialCasedStyles.initialStylesByElement.delete(this._element);
        if (this._startStyles) {
          eraseStyles(this._element, this._startStyles);
          this._endStyles = null;
        }
        if (this._endStyles) {
          eraseStyles(this._element, this._endStyles);
          this._endStyles = null;
        }
        setStyles(this._element, this._initialStyles);
        this._state = 3 /* Destroyed */;
      }
    }
  }

  SpecialCasedStyles.initialStylesByElement = /* @__PURE__ */new WeakMap();
  return SpecialCasedStyles;
})();
function filterNonAnimatableStyles(styles) {
  let result = null;
  const props = Object.keys(styles);
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (isNonAnimatableStyle(prop)) {
      result = result || {};
      result[prop] = styles[prop];
    }
  }
  return result;
}
function isNonAnimatableStyle(prop) {
  return prop === 'display' || prop === 'position';
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
const ANIMATION_PROP = 'animation';
const ANIMATIONEND_EVENT = 'animationend';
const ONE_SECOND$1 = 1000;
class ElementAnimationStyleHandler {
  constructor(_element, _name, _duration, _delay, _easing, _fillMode, _onDoneFn) {
    this._element = _element;
    this._name = _name;
    this._duration = _duration;
    this._delay = _delay;
    this._easing = _easing;
    this._fillMode = _fillMode;
    this._onDoneFn = _onDoneFn;
    this._finished = false;
    this._destroyed = false;
    this._startTime = 0;
    this._position = 0;
    this._eventFn = e => this._handleCallback(e);
  }
  apply() {
    applyKeyframeAnimation(this._element, `${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`);
    addRemoveAnimationEvent(this._element, this._eventFn, false);
    this._startTime = Date.now();
  }
  pause() {
    playPauseAnimation(this._element, this._name, 'paused');
  }
  resume() {
    playPauseAnimation(this._element, this._name, 'running');
  }
  setPosition(position) {
    const index = findIndexForAnimation(this._element, this._name);
    this._position = position * this._duration;
    setAnimationStyle(this._element, 'Delay', `-${this._position}ms`, index);
  }
  getPosition() {
    return this._position;
  }
  _handleCallback(event) {
    const timestamp = event._ngTestManualTimestamp || Date.now();
    const elapsedTime = parseFloat(event.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES)) * ONE_SECOND$1;
    if (event.animationName == this._name && Math.max(timestamp - this._startTime, 0) >= this._delay && elapsedTime >= this._duration) {
      this.finish();
    }
  }
  finish() {
    if (this._finished) return;
    this._finished = true;
    this._onDoneFn();
    addRemoveAnimationEvent(this._element, this._eventFn, true);
  }
  destroy() {
    if (this._destroyed) return;
    this._destroyed = true;
    this.finish();
    removeKeyframeAnimation(this._element, this._name);
  }
}
function playPauseAnimation(element, name, status) {
  const index = findIndexForAnimation(element, name);
  setAnimationStyle(element, 'PlayState', status, index);
}
function applyKeyframeAnimation(element, value) {
  const anim = getAnimationStyle(element, '').trim();
  let index = 0;
  if (anim.length) {
    index = countChars(anim, ',') + 1;
    value = `${anim}, ${value}`;
  }
  setAnimationStyle(element, '', value);
  return index;
}
function removeKeyframeAnimation(element, name) {
  const anim = getAnimationStyle(element, '');
  const tokens = anim.split(',');
  const index = findMatchingTokenIndex(tokens, name);
  if (index >= 0) {
    tokens.splice(index, 1);
    const newValue = tokens.join(',');
    setAnimationStyle(element, '', newValue);
  }
}
function findIndexForAnimation(element, value) {
  const anim = getAnimationStyle(element, '');
  if (anim.indexOf(',') > 0) {
    const tokens = anim.split(',');
    return findMatchingTokenIndex(tokens, value);
  }
  return findMatchingTokenIndex([anim], value);
}
function findMatchingTokenIndex(tokens, searchToken) {
  for (let i = 0; i < tokens.length; i++) {
    if (tokens[i].indexOf(searchToken) >= 0) {
      return i;
    }
  }
  return -1;
}
function addRemoveAnimationEvent(element, fn, doRemove) {
  doRemove ? element.removeEventListener(ANIMATIONEND_EVENT, fn) : element.addEventListener(ANIMATIONEND_EVENT, fn);
}
function setAnimationStyle(element, name, value, index) {
  const prop = ANIMATION_PROP + name;
  if (index != null) {
    const oldValue = element.style[prop];
    if (oldValue.length) {
      const tokens = oldValue.split(',');
      tokens[index] = value;
      value = tokens.join(',');
    }
  }
  element.style[prop] = value;
}
function getAnimationStyle(element, name) {
  return element.style[ANIMATION_PROP + name] || '';
}
function countChars(value, char) {
  let count = 0;
  for (let i = 0; i < value.length; i++) {
    const c = value.charAt(i);
    if (c === char) count++;
  }
  return count;
}
const DEFAULT_FILL_MODE = 'forwards';
const DEFAULT_EASING = 'linear';
class CssKeyframesPlayer {
  constructor(element, keyframes, animationName, _duration, _delay, easing, _finalStyles, _specialStyles) {
    this.element = element;
    this.keyframes = keyframes;
    this.animationName = animationName;
    this._duration = _duration;
    this._delay = _delay;
    this._finalStyles = _finalStyles;
    this._specialStyles = _specialStyles;
    this._onDoneFns = [];
    this._onStartFns = [];
    this._onDestroyFns = [];
    this.currentSnapshot = {};
    this._state = 0;
    this.easing = easing || DEFAULT_EASING;
    this.totalTime = _duration + _delay;
    this._buildStyler();
  }
  onStart(fn) {
    this._onStartFns.push(fn);
  }
  onDone(fn) {
    this._onDoneFns.push(fn);
  }
  onDestroy(fn) {
    this._onDestroyFns.push(fn);
  }
  destroy() {
    this.init();
    if (this._state >= 4 /* DESTROYED */) return;
    this._state = 4 /* DESTROYED */;
    this._styler.destroy();
    this._flushStartFns();
    this._flushDoneFns();
    if (this._specialStyles) {
      this._specialStyles.destroy();
    }
    this._onDestroyFns.forEach(fn => fn());
    this._onDestroyFns = [];
  }
  _flushDoneFns() {
    this._onDoneFns.forEach(fn => fn());
    this._onDoneFns = [];
  }
  _flushStartFns() {
    this._onStartFns.forEach(fn => fn());
    this._onStartFns = [];
  }
  finish() {
    this.init();
    if (this._state >= 3 /* FINISHED */) return;
    this._state = 3 /* FINISHED */;
    this._styler.finish();
    this._flushStartFns();
    if (this._specialStyles) {
      this._specialStyles.finish();
    }
    this._flushDoneFns();
  }
  setPosition(value) {
    this._styler.setPosition(value);
  }
  getPosition() {
    return this._styler.getPosition();
  }
  hasStarted() {
    return this._state >= 2 /* STARTED */;
  }

  init() {
    if (this._state >= 1 /* INITIALIZED */) return;
    this._state = 1 /* INITIALIZED */;
    const elm = this.element;
    this._styler.apply();
    if (this._delay) {
      this._styler.pause();
    }
  }
  play() {
    this.init();
    if (!this.hasStarted()) {
      this._flushStartFns();
      this._state = 2 /* STARTED */;
      if (this._specialStyles) {
        this._specialStyles.start();
      }
    }
    this._styler.resume();
  }
  pause() {
    this.init();
    this._styler.pause();
  }
  restart() {
    this.reset();
    this.play();
  }
  reset() {
    this._state = 0 /* RESET */;
    this._styler.destroy();
    this._buildStyler();
    this._styler.apply();
  }
  _buildStyler() {
    this._styler = new ElementAnimationStyleHandler(this.element, this.animationName, this._duration, this._delay, this.easing, DEFAULT_FILL_MODE, () => this.finish());
  }
  /** @internal */
  triggerCallback(phaseName) {
    const methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;
    methods.forEach(fn => fn());
    methods.length = 0;
  }
  beforeDestroy() {
    this.init();
    const styles = {};
    if (this.hasStarted()) {
      const finished = this._state >= 3 /* FINISHED */;
      Object.keys(this._finalStyles).forEach(prop => {
        if (prop != 'offset') {
          styles[prop] = finished ? this._finalStyles[prop] : computeStyle(this.element, prop);
        }
      });
    }
    this.currentSnapshot = styles;
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class DirectStylePlayer extends _angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .NoopAnimationPlayer */ .ZN {
  constructor(element, styles) {
    super();
    this.element = element;
    this._startingStyles = {};
    this.__initialized = false;
    this._styles = hypenatePropsObject(styles);
  }
  init() {
    if (this.__initialized || !this._startingStyles) return;
    this.__initialized = true;
    Object.keys(this._styles).forEach(prop => {
      this._startingStyles[prop] = this.element.style[prop];
    });
    super.init();
  }
  play() {
    if (!this._startingStyles) return;
    this.init();
    Object.keys(this._styles).forEach(prop => this.element.style.setProperty(prop, this._styles[prop]));
    super.play();
  }
  destroy() {
    if (!this._startingStyles) return;
    Object.keys(this._startingStyles).forEach(prop => {
      const value = this._startingStyles[prop];
      if (value) {
        this.element.style.setProperty(prop, value);
      } else {
        this.element.style.removeProperty(prop);
      }
    });
    this._startingStyles = null;
    super.destroy();
  }
}
const KEYFRAMES_NAME_PREFIX = 'gen_css_kf_';
const TAB_SPACE = ' ';
class CssKeyframesDriver {
  constructor() {
    this._count = 0;
  }
  validateStyleProperty(prop) {
    return validateStyleProperty(prop);
  }
  matchesElement(element, selector) {
    return matchesElement(element, selector);
  }
  containsElement(elm1, elm2) {
    return containsElement(elm1, elm2);
  }
  query(element, selector, multi) {
    return invokeQuery(element, selector, multi);
  }
  computeStyle(element, prop, defaultValue) {
    return window.getComputedStyle(element)[prop];
  }
  buildKeyframeElement(element, name, keyframes) {
    keyframes = keyframes.map(kf => hypenatePropsObject(kf));
    let keyframeStr = `@keyframes ${name} {\n`;
    let tab = '';
    keyframes.forEach(kf => {
      tab = TAB_SPACE;
      const offset = parseFloat(kf['offset']);
      keyframeStr += `${tab}${offset * 100}% {\n`;
      tab += TAB_SPACE;
      Object.keys(kf).forEach(prop => {
        const value = kf[prop];
        switch (prop) {
          case 'offset':
            return;
          case 'easing':
            if (value) {
              keyframeStr += `${tab}animation-timing-function: ${value};\n`;
            }
            return;
          default:
            keyframeStr += `${tab}${prop}: ${value};\n`;
            return;
        }
      });
      keyframeStr += `${tab}}\n`;
    });
    keyframeStr += `}\n`;
    const kfElm = document.createElement('style');
    kfElm.textContent = keyframeStr;
    return kfElm;
  }
  animate(element, keyframes, duration, delay, easing, previousPlayers = [], scrubberAccessRequested) {
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && scrubberAccessRequested) {
      notifyFaultyScrubber();
    }
    const previousCssKeyframePlayers = previousPlayers.filter(player => player instanceof CssKeyframesPlayer);
    const previousStyles = {};
    if (allowPreviousPlayerStylesMerge(duration, delay)) {
      previousCssKeyframePlayers.forEach(player => {
        let styles = player.currentSnapshot;
        Object.keys(styles).forEach(prop => previousStyles[prop] = styles[prop]);
      });
    }
    keyframes = balancePreviousStylesIntoKeyframes(element, keyframes, previousStyles);
    const finalStyles = flattenKeyframesIntoStyles(keyframes);
    // if there is no animation then there is no point in applying
    // styles and waiting for an event to get fired. This causes lag.
    // It's better to just directly apply the styles to the element
    // via the direct styling animation player.
    if (duration == 0) {
      return new DirectStylePlayer(element, finalStyles);
    }
    const animationName = `${KEYFRAMES_NAME_PREFIX}${this._count++}`;
    const kfElm = this.buildKeyframeElement(element, animationName, keyframes);
    const nodeToAppendKfElm = findNodeToAppendKeyframeElement(element);
    nodeToAppendKfElm.appendChild(kfElm);
    const specialStyles = packageNonAnimatableStyles(element, keyframes);
    const player = new CssKeyframesPlayer(element, keyframes, animationName, duration, delay, easing, finalStyles, specialStyles);
    player.onDestroy(() => removeElement(kfElm));
    return player;
  }
}
function findNodeToAppendKeyframeElement(element) {
  var _a;
  const rootNode = (_a = element.getRootNode) === null || _a === void 0 ? void 0 : _a.call(element);
  if (typeof ShadowRoot !== 'undefined' && rootNode instanceof ShadowRoot) {
    return rootNode;
  }
  return document.head;
}
function flattenKeyframesIntoStyles(keyframes) {
  let flatKeyframes = {};
  if (keyframes) {
    const kfs = Array.isArray(keyframes) ? keyframes : [keyframes];
    kfs.forEach(kf => {
      Object.keys(kf).forEach(prop => {
        if (prop == 'offset' || prop == 'easing') return;
        flatKeyframes[prop] = kf[prop];
      });
    });
  }
  return flatKeyframes;
}
function removeElement(node) {
  node.parentNode.removeChild(node);
}
let warningIssued = false;
function notifyFaultyScrubber() {
  if (warningIssued) return;
  console.warn('@angular/animations: please load the web-animations.js polyfill to allow programmatic access...\n', '  visit https://bit.ly/IWukam to learn more about using the web-animation-js polyfill.');
  warningIssued = true;
}
class WebAnimationsPlayer {
  constructor(element, keyframes, options, _specialStyles) {
    this.element = element;
    this.keyframes = keyframes;
    this.options = options;
    this._specialStyles = _specialStyles;
    this._onDoneFns = [];
    this._onStartFns = [];
    this._onDestroyFns = [];
    this._initialized = false;
    this._finished = false;
    this._started = false;
    this._destroyed = false;
    this.time = 0;
    this.parentPlayer = null;
    this.currentSnapshot = {};
    this._duration = options['duration'];
    this._delay = options['delay'] || 0;
    this.time = this._duration + this._delay;
  }
  _onFinish() {
    if (!this._finished) {
      this._finished = true;
      this._onDoneFns.forEach(fn => fn());
      this._onDoneFns = [];
    }
  }
  init() {
    this._buildPlayer();
    this._preparePlayerBeforeStart();
  }
  _buildPlayer() {
    if (this._initialized) return;
    this._initialized = true;
    const keyframes = this.keyframes;
    this.domPlayer = this._triggerWebAnimation(this.element, keyframes, this.options);
    this._finalKeyframe = keyframes.length ? keyframes[keyframes.length - 1] : {};
    this.domPlayer.addEventListener('finish', () => this._onFinish());
  }
  _preparePlayerBeforeStart() {
    // this is required so that the player doesn't start to animate right away
    if (this._delay) {
      this._resetDomPlayerState();
    } else {
      this.domPlayer.pause();
    }
  }
  /** @internal */
  _triggerWebAnimation(element, keyframes, options) {
    // jscompiler doesn't seem to know animate is a native property because it's not fully
    // supported yet across common browsers (we polyfill it for Edge/Safari) [CL #143630929]
    return element['animate'](keyframes, options);
  }
  onStart(fn) {
    this._onStartFns.push(fn);
  }
  onDone(fn) {
    this._onDoneFns.push(fn);
  }
  onDestroy(fn) {
    this._onDestroyFns.push(fn);
  }
  play() {
    this._buildPlayer();
    if (!this.hasStarted()) {
      this._onStartFns.forEach(fn => fn());
      this._onStartFns = [];
      this._started = true;
      if (this._specialStyles) {
        this._specialStyles.start();
      }
    }
    this.domPlayer.play();
  }
  pause() {
    this.init();
    this.domPlayer.pause();
  }
  finish() {
    this.init();
    if (this._specialStyles) {
      this._specialStyles.finish();
    }
    this._onFinish();
    this.domPlayer.finish();
  }
  reset() {
    this._resetDomPlayerState();
    this._destroyed = false;
    this._finished = false;
    this._started = false;
  }
  _resetDomPlayerState() {
    if (this.domPlayer) {
      this.domPlayer.cancel();
    }
  }
  restart() {
    this.reset();
    this.play();
  }
  hasStarted() {
    return this._started;
  }
  destroy() {
    if (!this._destroyed) {
      this._destroyed = true;
      this._resetDomPlayerState();
      this._onFinish();
      if (this._specialStyles) {
        this._specialStyles.destroy();
      }
      this._onDestroyFns.forEach(fn => fn());
      this._onDestroyFns = [];
    }
  }
  setPosition(p) {
    if (this.domPlayer === undefined) {
      this.init();
    }
    this.domPlayer.currentTime = p * this.time;
  }
  getPosition() {
    return this.domPlayer.currentTime / this.time;
  }
  get totalTime() {
    return this._delay + this._duration;
  }
  beforeDestroy() {
    const styles = {};
    if (this.hasStarted()) {
      Object.keys(this._finalKeyframe).forEach(prop => {
        if (prop != 'offset') {
          styles[prop] = this._finished ? this._finalKeyframe[prop] : computeStyle(this.element, prop);
        }
      });
    }
    this.currentSnapshot = styles;
  }
  /** @internal */
  triggerCallback(phaseName) {
    const methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;
    methods.forEach(fn => fn());
    methods.length = 0;
  }
}
class WebAnimationsDriver {
  constructor() {
    this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(getElementAnimateFn().toString());
    this._cssKeyframesDriver = new CssKeyframesDriver();
  }
  validateStyleProperty(prop) {
    return validateStyleProperty(prop);
  }
  matchesElement(element, selector) {
    return matchesElement(element, selector);
  }
  containsElement(elm1, elm2) {
    return containsElement(elm1, elm2);
  }
  query(element, selector, multi) {
    return invokeQuery(element, selector, multi);
  }
  computeStyle(element, prop, defaultValue) {
    return window.getComputedStyle(element)[prop];
  }
  overrideWebAnimationsSupport(supported) {
    this._isNativeImpl = supported;
  }
  animate(element, keyframes, duration, delay, easing, previousPlayers = [], scrubberAccessRequested) {
    const useKeyframes = !scrubberAccessRequested && !this._isNativeImpl;
    if (useKeyframes) {
      return this._cssKeyframesDriver.animate(element, keyframes, duration, delay, easing, previousPlayers);
    }
    const fill = delay == 0 ? 'both' : 'forwards';
    const playerOptions = {
      duration,
      delay,
      fill
    };
    // we check for this to avoid having a null|undefined value be present
    // for the easing (which results in an error for certain browsers #9752)
    if (easing) {
      playerOptions['easing'] = easing;
    }
    const previousStyles = {};
    const previousWebAnimationPlayers = previousPlayers.filter(player => player instanceof WebAnimationsPlayer);
    if (allowPreviousPlayerStylesMerge(duration, delay)) {
      previousWebAnimationPlayers.forEach(player => {
        let styles = player.currentSnapshot;
        Object.keys(styles).forEach(prop => previousStyles[prop] = styles[prop]);
      });
    }
    keyframes = keyframes.map(styles => copyStyles(styles, false));
    keyframes = balancePreviousStylesIntoKeyframes(element, keyframes, previousStyles);
    const specialStyles = packageNonAnimatableStyles(element, keyframes);
    return new WebAnimationsPlayer(element, keyframes, playerOptions, specialStyles);
  }
}
function supportsWebAnimations() {
  return typeof getElementAnimateFn() === 'function';
}
function getElementAnimateFn() {
  return isBrowser() && Element.prototype['animate'] || {};
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=browser.js.map

/***/ }),

/***/ 3738:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AbstractControl: () => (/* binding */ AbstractControl),
  AbstractControlDirective: () => (/* binding */ AbstractControlDirective),
  AbstractFormGroupDirective: () => (/* binding */ AbstractFormGroupDirective),
  COMPOSITION_BUFFER_MODE: () => (/* binding */ COMPOSITION_BUFFER_MODE),
  CheckboxControlValueAccessor: () => (/* binding */ CheckboxControlValueAccessor),
  CheckboxRequiredValidator: () => (/* binding */ CheckboxRequiredValidator),
  ControlContainer: () => (/* binding */ ControlContainer),
  DefaultValueAccessor: () => (/* binding */ DefaultValueAccessor),
  EmailValidator: () => (/* binding */ EmailValidator),
  FormArray: () => (/* binding */ FormArray),
  FormArrayName: () => (/* binding */ FormArrayName),
  FormBuilder: () => (/* binding */ FormBuilder),
  FormControl: () => (/* binding */ FormControl),
  FormControlDirective: () => (/* binding */ FormControlDirective),
  FormControlName: () => (/* binding */ FormControlName),
  FormGroup: () => (/* binding */ FormGroup),
  FormGroupDirective: () => (/* binding */ FormGroupDirective),
  FormGroupName: () => (/* binding */ FormGroupName),
  FormsModule: () => (/* binding */ FormsModule),
  MaxLengthValidator: () => (/* binding */ MaxLengthValidator),
  MaxValidator: () => (/* binding */ MaxValidator),
  MinLengthValidator: () => (/* binding */ MinLengthValidator),
  MinValidator: () => (/* binding */ MinValidator),
  NG_ASYNC_VALIDATORS: () => (/* binding */ NG_ASYNC_VALIDATORS),
  NG_VALIDATORS: () => (/* binding */ NG_VALIDATORS),
  NG_VALUE_ACCESSOR: () => (/* binding */ NG_VALUE_ACCESSOR),
  NgControl: () => (/* binding */ NgControl),
  NgControlStatus: () => (/* binding */ NgControlStatus),
  NgControlStatusGroup: () => (/* binding */ NgControlStatusGroup),
  NgForm: () => (/* binding */ NgForm),
  NgModel: () => (/* binding */ NgModel),
  NgModelGroup: () => (/* binding */ NgModelGroup),
  NgSelectOption: () => (/* binding */ NgSelectOption),
  NumberValueAccessor: () => (/* binding */ NumberValueAccessor),
  PatternValidator: () => (/* binding */ PatternValidator),
  RadioControlValueAccessor: () => (/* binding */ RadioControlValueAccessor),
  RangeValueAccessor: () => (/* binding */ RangeValueAccessor),
  ReactiveFormsModule: () => (/* binding */ ReactiveFormsModule),
  RequiredValidator: () => (/* binding */ RequiredValidator),
  SelectControlValueAccessor: () => (/* binding */ SelectControlValueAccessor),
  SelectMultipleControlValueAccessor: () => (/* binding */ SelectMultipleControlValueAccessor),
  VERSION: () => (/* binding */ VERSION),
  Validators: () => (/* binding */ Validators),
  "ɵInternalFormsSharedModule": () => (/* binding */ ɵInternalFormsSharedModule),
  "ɵNgNoValidate": () => (/* binding */ ɵNgNoValidate),
  "ɵNgSelectMultipleOption": () => (/* binding */ ɵNgSelectMultipleOption),
  "ɵangular_packages_forms_forms_a": () => (/* binding */ SHARED_FORM_DIRECTIVES),
  "ɵangular_packages_forms_forms_b": () => (/* binding */ TEMPLATE_DRIVEN_DIRECTIVES),
  "ɵangular_packages_forms_forms_ba": () => (/* binding */ SELECT_MULTIPLE_VALUE_ACCESSOR),
  "ɵangular_packages_forms_forms_bb": () => (/* binding */ ɵNgSelectMultipleOption),
  "ɵangular_packages_forms_forms_bc": () => (/* binding */ ɵNgNoValidate),
  "ɵangular_packages_forms_forms_bd": () => (/* binding */ MAX_VALIDATOR),
  "ɵangular_packages_forms_forms_be": () => (/* binding */ MIN_VALIDATOR),
  "ɵangular_packages_forms_forms_bf": () => (/* binding */ REQUIRED_VALIDATOR),
  "ɵangular_packages_forms_forms_bg": () => (/* binding */ CHECKBOX_REQUIRED_VALIDATOR),
  "ɵangular_packages_forms_forms_bh": () => (/* binding */ EMAIL_VALIDATOR),
  "ɵangular_packages_forms_forms_bi": () => (/* binding */ MIN_LENGTH_VALIDATOR),
  "ɵangular_packages_forms_forms_bj": () => (/* binding */ MAX_LENGTH_VALIDATOR),
  "ɵangular_packages_forms_forms_bk": () => (/* binding */ PATTERN_VALIDATOR),
  "ɵangular_packages_forms_forms_bl": () => (/* binding */ minValidator),
  "ɵangular_packages_forms_forms_bm": () => (/* binding */ maxValidator),
  "ɵangular_packages_forms_forms_bn": () => (/* binding */ requiredValidator),
  "ɵangular_packages_forms_forms_bo": () => (/* binding */ requiredTrueValidator),
  "ɵangular_packages_forms_forms_bp": () => (/* binding */ emailValidator),
  "ɵangular_packages_forms_forms_bq": () => (/* binding */ minLengthValidator),
  "ɵangular_packages_forms_forms_br": () => (/* binding */ maxLengthValidator),
  "ɵangular_packages_forms_forms_bs": () => (/* binding */ patternValidator),
  "ɵangular_packages_forms_forms_bt": () => (/* binding */ nullValidator),
  "ɵangular_packages_forms_forms_c": () => (/* binding */ REACTIVE_DRIVEN_DIRECTIVES),
  "ɵangular_packages_forms_forms_d": () => (/* binding */ ɵInternalFormsSharedModule),
  "ɵangular_packages_forms_forms_e": () => (/* binding */ CHECKBOX_VALUE_ACCESSOR),
  "ɵangular_packages_forms_forms_f": () => (/* binding */ BaseControlValueAccessor),
  "ɵangular_packages_forms_forms_g": () => (/* binding */ BuiltInControlValueAccessor),
  "ɵangular_packages_forms_forms_h": () => (/* binding */ DEFAULT_VALUE_ACCESSOR),
  "ɵangular_packages_forms_forms_i": () => (/* binding */ AbstractControlStatus),
  "ɵangular_packages_forms_forms_j": () => (/* binding */ ngControlStatusHost),
  "ɵangular_packages_forms_forms_k": () => (/* binding */ ngGroupStatusHost),
  "ɵangular_packages_forms_forms_l": () => (/* binding */ formDirectiveProvider),
  "ɵangular_packages_forms_forms_m": () => (/* binding */ formControlBinding),
  "ɵangular_packages_forms_forms_n": () => (/* binding */ modelGroupProvider),
  "ɵangular_packages_forms_forms_o": () => (/* binding */ NUMBER_VALUE_ACCESSOR),
  "ɵangular_packages_forms_forms_p": () => (/* binding */ RADIO_VALUE_ACCESSOR),
  "ɵangular_packages_forms_forms_q": () => (/* binding */ RadioControlRegistryModule),
  "ɵangular_packages_forms_forms_r": () => (/* binding */ RadioControlRegistry),
  "ɵangular_packages_forms_forms_s": () => (/* binding */ RANGE_VALUE_ACCESSOR),
  "ɵangular_packages_forms_forms_t": () => (/* binding */ NG_MODEL_WITH_FORM_CONTROL_WARNING),
  "ɵangular_packages_forms_forms_u": () => (/* binding */ formControlBinding$1),
  "ɵangular_packages_forms_forms_v": () => (/* binding */ controlNameBinding),
  "ɵangular_packages_forms_forms_w": () => (/* binding */ formDirectiveProvider$1),
  "ɵangular_packages_forms_forms_x": () => (/* binding */ formGroupNameProvider),
  "ɵangular_packages_forms_forms_y": () => (/* binding */ formArrayNameProvider),
  "ɵangular_packages_forms_forms_z": () => (/* binding */ SELECT_VALUE_ACCESSOR)
});

// EXTERNAL MODULE: consume shared module (default) @angular/core@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/core/fesm2015/core.js)
var core_js_ = __webpack_require__(8312);
// EXTERNAL MODULE: consume shared module (default) @angular/common@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/common/fesm2015/common.js)
var common_js_ = __webpack_require__(3008);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/from.js + 6 modules
var from = __webpack_require__(4402);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Observable.js + 2 modules
var Observable = __webpack_require__(8891);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isArray.js
var isArray = __webpack_require__(9796);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js
var map = __webpack_require__(8002);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isObject.js
var isObject = __webpack_require__(1555);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/observable/forkJoin.js





function forkJoin(...sources) {
  if (sources.length === 1) {
    const first = sources[0];
    if ((0,isArray/* isArray */.k)(first)) {
      return forkJoinInternal(first, null);
    }
    if ((0,isObject/* isObject */.K)(first) && Object.getPrototypeOf(first) === Object.prototype) {
      const keys = Object.keys(first);
      return forkJoinInternal(keys.map(key => first[key]), keys);
    }
  }
  if (typeof sources[sources.length - 1] === 'function') {
    const resultSelector = sources.pop();
    sources = sources.length === 1 && (0,isArray/* isArray */.k)(sources[0]) ? sources[0] : sources;
    return forkJoinInternal(sources, null).pipe((0,map/* map */.U)(args => resultSelector(...args)));
  }
  return forkJoinInternal(sources, null);
}
function forkJoinInternal(sources, keys) {
  return new Observable/* Observable */.y(subscriber => {
    const len = sources.length;
    if (len === 0) {
      subscriber.complete();
      return;
    }
    const values = new Array(len);
    let completed = 0;
    let emitted = 0;
    for (let i = 0; i < len; i++) {
      const source = (0,from/* from */.D)(sources[i]);
      let hasValue = false;
      subscriber.add(source.subscribe({
        next: value => {
          if (!hasValue) {
            hasValue = true;
            emitted++;
          }
          values[i] = value;
        },
        error: err => subscriber.error(err),
        complete: () => {
          completed++;
          if (completed === len || !hasValue) {
            if (emitted === len) {
              subscriber.next(keys ? keys.reduce((result, key, i) => (result[key] = values[i], result), {}) : values);
            }
            subscriber.complete();
          }
        }
      }));
    }
  });
}
//# sourceMappingURL=forkJoin.js.map
;// CONCATENATED MODULE: ./node_modules/@angular/forms/fesm2015/forms.js
/**
 * @license Angular v12.2.17
 * (c) 2010-2021 Google LLC. https://angular.io/
 * License: MIT
 */






/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Base class for all ControlValueAccessor classes defined in Forms package.
 * Contains common logic and utility functions.
 *
 * Note: this is an *internal-only* class and should not be extended or used directly in
 * applications code.
 */

let BaseControlValueAccessor = /*#__PURE__*/(() => {
  class BaseControlValueAccessor {
    constructor(_renderer, _elementRef) {
      this._renderer = _renderer;
      this._elementRef = _elementRef;
      /**
       * The registered callback function called when a change or input event occurs on the input
       * element.
       * @nodoc
       */
      this.onChange = _ => {};
      /**
       * The registered callback function called when a blur event occurs on the input element.
       * @nodoc
       */
      this.onTouched = () => {};
    }
    /**
     * Helper method that sets a property on a target element using the current Renderer
     * implementation.
     * @nodoc
     */
    setProperty(key, value) {
      this._renderer.setProperty(this._elementRef.nativeElement, key, value);
    }
    /**
     * Registers a function called when the control is touched.
     * @nodoc
     */
    registerOnTouched(fn) {
      this.onTouched = fn;
    }
    /**
     * Registers a function called when the control value changes.
     * @nodoc
     */
    registerOnChange(fn) {
      this.onChange = fn;
    }
    /**
     * Sets the "disabled" property on the range input element.
     * @nodoc
     */
    setDisabledState(isDisabled) {
      this.setProperty('disabled', isDisabled);
    }
  }
  BaseControlValueAccessor.ɵfac = function BaseControlValueAccessor_Factory(t) {
    return new (t || BaseControlValueAccessor)(core_js_["ɵɵdirectiveInject"](core_js_.Renderer2), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef));
  };
  BaseControlValueAccessor.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: BaseControlValueAccessor
  });
  return BaseControlValueAccessor;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * Base class for all built-in ControlValueAccessor classes (except DefaultValueAccessor, which is
 * used in case no other CVAs can be found). We use this class to distinguish between default CVA,
 * built-in CVAs and custom CVAs, so that Forms logic can recognize built-in CVAs and treat custom
 * ones with higher priority (when both built-in and custom CVAs are present).
 *
 * Note: this is an *internal-only* class and should not be extended or used directly in
 * applications code.
 */
let BuiltInControlValueAccessor = /*#__PURE__*/(() => {
  class BuiltInControlValueAccessor extends BaseControlValueAccessor {}
  BuiltInControlValueAccessor.ɵfac = /*@__PURE__*/function () {
    let ɵBuiltInControlValueAccessor_BaseFactory;
    return function BuiltInControlValueAccessor_Factory(t) {
      return (ɵBuiltInControlValueAccessor_BaseFactory || (ɵBuiltInControlValueAccessor_BaseFactory = core_js_["ɵɵgetInheritedFactory"](BuiltInControlValueAccessor)))(t || BuiltInControlValueAccessor);
    };
  }();
  BuiltInControlValueAccessor.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: BuiltInControlValueAccessor,
    features: [core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return BuiltInControlValueAccessor;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * Used to provide a `ControlValueAccessor` for form controls.
 *
 * See `DefaultValueAccessor` for how to implement one.
 *
 * @publicApi
 */
const NG_VALUE_ACCESSOR = /*#__PURE__*/new core_js_.InjectionToken('NgValueAccessor');

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const CHECKBOX_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => CheckboxControlValueAccessor),
  multi: true
};
/**
 * @description
 * A `ControlValueAccessor` for writing a value and listening to changes on a checkbox input
 * element.
 *
 * @usageNotes
 *
 * ### Using a checkbox with a reactive form.
 *
 * The following example shows how to use a checkbox with a reactive form.
 *
 * ```ts
 * const rememberLoginControl = new FormControl();
 * ```
 *
 * ```
 * <input type="checkbox" [formControl]="rememberLoginControl">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let CheckboxControlValueAccessor = /*#__PURE__*/(() => {
  class CheckboxControlValueAccessor extends BuiltInControlValueAccessor {
    /**
     * Sets the "checked" property on the input element.
     * @nodoc
     */
    writeValue(value) {
      this.setProperty('checked', value);
    }
  }
  CheckboxControlValueAccessor.ɵfac = /*@__PURE__*/function () {
    let ɵCheckboxControlValueAccessor_BaseFactory;
    return function CheckboxControlValueAccessor_Factory(t) {
      return (ɵCheckboxControlValueAccessor_BaseFactory || (ɵCheckboxControlValueAccessor_BaseFactory = core_js_["ɵɵgetInheritedFactory"](CheckboxControlValueAccessor)))(t || CheckboxControlValueAccessor);
    };
  }();
  CheckboxControlValueAccessor.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: CheckboxControlValueAccessor,
    selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]],
    hostBindings: function CheckboxControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("change", function CheckboxControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.checked);
        })("blur", function CheckboxControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    features: [core_js_["ɵɵProvidersFeature"]([CHECKBOX_VALUE_ACCESSOR]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return CheckboxControlValueAccessor;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const DEFAULT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => DefaultValueAccessor),
  multi: true
};
/**
 * We must check whether the agent is Android because composition events
 * behave differently between iOS and Android.
 */
function _isAndroid() {
  const userAgent = (0,common_js_["ɵgetDOM"])() ? (0,common_js_["ɵgetDOM"])().getUserAgent() : '';
  return /android (\d+)/.test(userAgent.toLowerCase());
}
/**
 * @description
 * Provide this token to control if form directives buffer IME input until
 * the "compositionend" event occurs.
 * @publicApi
 */
const COMPOSITION_BUFFER_MODE = /*#__PURE__*/new core_js_.InjectionToken('CompositionEventMode');
/**
 * The default `ControlValueAccessor` for writing a value and listening to changes on input
 * elements. The accessor is used by the `FormControlDirective`, `FormControlName`, and
 * `NgModel` directives.
 *
 * {@searchKeywords ngDefaultControl}
 *
 * @usageNotes
 *
 * ### Using the default value accessor
 *
 * The following example shows how to use an input element that activates the default value accessor
 * (in this case, a text field).
 *
 * ```ts
 * const firstNameControl = new FormControl();
 * ```
 *
 * ```
 * <input type="text" [formControl]="firstNameControl">
 * ```
 *
 * This value accessor is used by default for `<input type="text">` and `<textarea>` elements, but
 * you could also use it for custom components that have similar behavior and do not require special
 * processing. In order to attach the default value accessor to a custom element, add the
 * `ngDefaultControl` attribute as shown below.
 *
 * ```
 * <custom-input-component ngDefaultControl [(ngModel)]="value"></custom-input-component>
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let DefaultValueAccessor = /*#__PURE__*/(() => {
  class DefaultValueAccessor extends BaseControlValueAccessor {
    constructor(renderer, elementRef, _compositionMode) {
      super(renderer, elementRef);
      this._compositionMode = _compositionMode;
      /** Whether the user is creating a composition string (IME events). */
      this._composing = false;
      if (this._compositionMode == null) {
        this._compositionMode = !_isAndroid();
      }
    }
    /**
     * Sets the "value" property on the input element.
     * @nodoc
     */
    writeValue(value) {
      const normalizedValue = value == null ? '' : value;
      this.setProperty('value', normalizedValue);
    }
    /** @internal */
    _handleInput(value) {
      if (!this._compositionMode || this._compositionMode && !this._composing) {
        this.onChange(value);
      }
    }
    /** @internal */
    _compositionStart() {
      this._composing = true;
    }
    /** @internal */
    _compositionEnd(value) {
      this._composing = false;
      this._compositionMode && this.onChange(value);
    }
  }
  DefaultValueAccessor.ɵfac = function DefaultValueAccessor_Factory(t) {
    return new (t || DefaultValueAccessor)(core_js_["ɵɵdirectiveInject"](core_js_.Renderer2), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](COMPOSITION_BUFFER_MODE, 8));
  };
  DefaultValueAccessor.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: DefaultValueAccessor,
    selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]],
    hostBindings: function DefaultValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("input", function DefaultValueAccessor_input_HostBindingHandler($event) {
          return ctx._handleInput($event.target.value);
        })("blur", function DefaultValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        })("compositionstart", function DefaultValueAccessor_compositionstart_HostBindingHandler() {
          return ctx._compositionStart();
        })("compositionend", function DefaultValueAccessor_compositionend_HostBindingHandler($event) {
          return ctx._compositionEnd($event.target.value);
        });
      }
    },
    features: [core_js_["ɵɵProvidersFeature"]([DEFAULT_VALUE_ACCESSOR]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return DefaultValueAccessor;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function isEmptyInputValue(value) {
  // we don't check for string here so it also works with arrays
  return value == null || value.length === 0;
}
function hasValidLength(value) {
  // non-strict comparison is intentional, to check for both `null` and `undefined` values
  return value != null && typeof value.length === 'number';
}
/**
 * @description
 * An `InjectionToken` for registering additional synchronous validators used with
 * `AbstractControl`s.
 *
 * @see `NG_ASYNC_VALIDATORS`
 *
 * @usageNotes
 *
 * ### Providing a custom validator
 *
 * The following example registers a custom validator directive. Adding the validator to the
 * existing collection of validators requires the `multi: true` option.
 *
 * ```typescript
 * @Directive({
 *   selector: '[customValidator]',
 *   providers: [{provide: NG_VALIDATORS, useExisting: CustomValidatorDirective, multi: true}]
 * })
 * class CustomValidatorDirective implements Validator {
 *   validate(control: AbstractControl): ValidationErrors | null {
 *     return { 'custom': true };
 *   }
 * }
 * ```
 *
 * @publicApi
 */
const NG_VALIDATORS = /*#__PURE__*/new core_js_.InjectionToken('NgValidators');
/**
 * @description
 * An `InjectionToken` for registering additional asynchronous validators used with
 * `AbstractControl`s.
 *
 * @see `NG_VALIDATORS`
 *
 * @publicApi
 */
const NG_ASYNC_VALIDATORS = /*#__PURE__*/new core_js_.InjectionToken('NgAsyncValidators');
/**
 * A regular expression that matches valid e-mail addresses.
 *
 * At a high level, this regexp matches e-mail addresses of the format `local-part@tld`, where:
 * - `local-part` consists of one or more of the allowed characters (alphanumeric and some
 *   punctuation symbols).
 * - `local-part` cannot begin or end with a period (`.`).
 * - `local-part` cannot be longer than 64 characters.
 * - `tld` consists of one or more `labels` separated by periods (`.`). For example `localhost` or
 *   `foo.com`.
 * - A `label` consists of one or more of the allowed characters (alphanumeric, dashes (`-`) and
 *   periods (`.`)).
 * - A `label` cannot begin or end with a dash (`-`) or a period (`.`).
 * - A `label` cannot be longer than 63 characters.
 * - The whole address cannot be longer than 254 characters.
 *
 * ## Implementation background
 *
 * This regexp was ported over from AngularJS (see there for git history):
 * https://github.com/angular/angular.js/blob/c133ef836/src/ng/directive/input.js#L27
 * It is based on the
 * [WHATWG version](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with
 * some enhancements to incorporate more RFC rules (such as rules related to domain names and the
 * lengths of different parts of the address). The main differences from the WHATWG version are:
 *   - Disallow `local-part` to begin or end with a period (`.`).
 *   - Disallow `local-part` length to exceed 64 characters.
 *   - Disallow total address length to exceed 254 characters.
 *
 * See [this commit](https://github.com/angular/angular.js/commit/f3f5cf72e) for more details.
 */
const EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
/**
 * @description
 * Provides a set of built-in validators that can be used by form controls.
 *
 * A validator is a function that processes a `FormControl` or collection of
 * controls and returns an error map or null. A null map means that validation has passed.
 *
 * @see [Form Validation](/guide/form-validation)
 *
 * @publicApi
 */
class Validators {
  /**
   * @description
   * Validator that requires the control's value to be greater than or equal to the provided number.
   *
   * @usageNotes
   *
   * ### Validate against a minimum of 3
   *
   * ```typescript
   * const control = new FormControl(2, Validators.min(3));
   *
   * console.log(control.errors); // {min: {min: 3, actual: 2}}
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `min` property if the validation check fails, otherwise `null`.
   *
   * @see `updateValueAndValidity()`
   *
   */
  static min(min) {
    return minValidator(min);
  }
  /**
   * @description
   * Validator that requires the control's value to be less than or equal to the provided number.
   *
   * @usageNotes
   *
   * ### Validate against a maximum of 15
   *
   * ```typescript
   * const control = new FormControl(16, Validators.max(15));
   *
   * console.log(control.errors); // {max: {max: 15, actual: 16}}
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `max` property if the validation check fails, otherwise `null`.
   *
   * @see `updateValueAndValidity()`
   *
   */
  static max(max) {
    return maxValidator(max);
  }
  /**
   * @description
   * Validator that requires the control have a non-empty value.
   *
   * @usageNotes
   *
   * ### Validate that the field is non-empty
   *
   * ```typescript
   * const control = new FormControl('', Validators.required);
   *
   * console.log(control.errors); // {required: true}
   * ```
   *
   * @returns An error map with the `required` property
   * if the validation check fails, otherwise `null`.
   *
   * @see `updateValueAndValidity()`
   *
   */
  static required(control) {
    return requiredValidator(control);
  }
  /**
   * @description
   * Validator that requires the control's value be true. This validator is commonly
   * used for required checkboxes.
   *
   * @usageNotes
   *
   * ### Validate that the field value is true
   *
   * ```typescript
   * const control = new FormControl('', Validators.requiredTrue);
   *
   * console.log(control.errors); // {required: true}
   * ```
   *
   * @returns An error map that contains the `required` property
   * set to `true` if the validation check fails, otherwise `null`.
   *
   * @see `updateValueAndValidity()`
   *
   */
  static requiredTrue(control) {
    return requiredTrueValidator(control);
  }
  /**
   * @description
   * Validator that requires the control's value pass an email validation test.
   *
   * Tests the value using a [regular
   * expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
   * pattern suitable for common usecases. The pattern is based on the definition of a valid email
   * address in the [WHATWG HTML
   * specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with
   * some enhancements to incorporate more RFC rules (such as rules related to domain names and the
   * lengths of different parts of the address).
   *
   * The differences from the WHATWG version include:
   * - Disallow `local-part` (the part before the `@` symbol) to begin or end with a period (`.`).
   * - Disallow `local-part` to be longer than 64 characters.
   * - Disallow the whole address to be longer than 254 characters.
   *
   * If this pattern does not satisfy your business needs, you can use `Validators.pattern()` to
   * validate the value against a different pattern.
   *
   * @usageNotes
   *
   * ### Validate that the field matches a valid email pattern
   *
   * ```typescript
   * const control = new FormControl('bad@', Validators.email);
   *
   * console.log(control.errors); // {email: true}
   * ```
   *
   * @returns An error map with the `email` property
   * if the validation check fails, otherwise `null`.
   *
   * @see `updateValueAndValidity()`
   *
   */
  static email(control) {
    return emailValidator(control);
  }
  /**
   * @description
   * Validator that requires the length of the control's value to be greater than or equal
   * to the provided minimum length. This validator is also provided by default if you use the
   * the HTML5 `minlength` attribute. Note that the `minLength` validator is intended to be used
   * only for types that have a numeric `length` property, such as strings or arrays. The
   * `minLength` validator logic is also not invoked for values when their `length` property is 0
   * (for example in case of an empty string or an empty array), to support optional controls. You
   * can use the standard `required` validator if empty values should not be considered valid.
   *
   * @usageNotes
   *
   * ### Validate that the field has a minimum of 3 characters
   *
   * ```typescript
   * const control = new FormControl('ng', Validators.minLength(3));
   *
   * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}
   * ```
   *
   * ```html
   * <input minlength="5">
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `minlength` property if the validation check fails, otherwise `null`.
   *
   * @see `updateValueAndValidity()`
   *
   */
  static minLength(minLength) {
    return minLengthValidator(minLength);
  }
  /**
   * @description
   * Validator that requires the length of the control's value to be less than or equal
   * to the provided maximum length. This validator is also provided by default if you use the
   * the HTML5 `maxlength` attribute. Note that the `maxLength` validator is intended to be used
   * only for types that have a numeric `length` property, such as strings or arrays.
   *
   * @usageNotes
   *
   * ### Validate that the field has maximum of 5 characters
   *
   * ```typescript
   * const control = new FormControl('Angular', Validators.maxLength(5));
   *
   * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}
   * ```
   *
   * ```html
   * <input maxlength="5">
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `maxlength` property if the validation check fails, otherwise `null`.
   *
   * @see `updateValueAndValidity()`
   *
   */
  static maxLength(maxLength) {
    return maxLengthValidator(maxLength);
  }
  /**
   * @description
   * Validator that requires the control's value to match a regex pattern. This validator is also
   * provided by default if you use the HTML5 `pattern` attribute.
   *
   * @usageNotes
   *
   * ### Validate that the field only contains letters or spaces
   *
   * ```typescript
   * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));
   *
   * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}
   * ```
   *
   * ```html
   * <input pattern="[a-zA-Z ]*">
   * ```
   *
   * ### Pattern matching with the global or sticky flag
   *
   * `RegExp` objects created with the `g` or `y` flags that are passed into `Validators.pattern`
   * can produce different results on the same input when validations are run consecutively. This is
   * due to how the behavior of `RegExp.prototype.test` is
   * specified in [ECMA-262](https://tc39.es/ecma262/#sec-regexpbuiltinexec)
   * (`RegExp` preserves the index of the last match when the global or sticky flag is used).
   * Due to this behavior, it is recommended that when using
   * `Validators.pattern` you **do not** pass in a `RegExp` object with either the global or sticky
   * flag enabled.
   *
   * ```typescript
   * // Not recommended (since the `g` flag is used)
   * const controlOne = new FormControl('1', Validators.pattern(/foo/g));
   *
   * // Good
   * const controlTwo = new FormControl('1', Validators.pattern(/foo/));
   * ```
   *
   * @param pattern A regular expression to be used as is to test the values, or a string.
   * If a string is passed, the `^` character is prepended and the `$` character is
   * appended to the provided string (if not already present), and the resulting regular
   * expression is used to test the values.
   *
   * @returns A validator function that returns an error map with the
   * `pattern` property if the validation check fails, otherwise `null`.
   *
   * @see `updateValueAndValidity()`
   *
   */
  static pattern(pattern) {
    return patternValidator(pattern);
  }
  /**
   * @description
   * Validator that performs no operation.
   *
   * @see `updateValueAndValidity()`
   *
   */
  static nullValidator(control) {
    return nullValidator(control);
  }
  static compose(validators) {
    return compose(validators);
  }
  /**
   * @description
   * Compose multiple async validators into a single function that returns the union
   * of the individual error objects for the provided control.
   *
   * @returns A validator function that returns an error map with the
   * merged error objects of the async validators if the validation check fails, otherwise `null`.
   *
   * @see `updateValueAndValidity()`
   *
   */
  static composeAsync(validators) {
    return composeAsync(validators);
  }
}
/**
 * Validator that requires the control's value to be greater than or equal to the provided number.
 * See `Validators.min` for additional information.
 */
function minValidator(min) {
  return control => {
    if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {
      return null; // don't validate empty values to allow optional controls
    }

    const value = parseFloat(control.value);
    // Controls with NaN values after parsing should be treated as not having a
    // minimum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-min
    return !isNaN(value) && value < min ? {
      'min': {
        'min': min,
        'actual': control.value
      }
    } : null;
  };
}
/**
 * Validator that requires the control's value to be less than or equal to the provided number.
 * See `Validators.max` for additional information.
 */
function maxValidator(max) {
  return control => {
    if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) {
      return null; // don't validate empty values to allow optional controls
    }

    const value = parseFloat(control.value);
    // Controls with NaN values after parsing should be treated as not having a
    // maximum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-max
    return !isNaN(value) && value > max ? {
      'max': {
        'max': max,
        'actual': control.value
      }
    } : null;
  };
}
/**
 * Validator that requires the control have a non-empty value.
 * See `Validators.required` for additional information.
 */
function requiredValidator(control) {
  return isEmptyInputValue(control.value) ? {
    'required': true
  } : null;
}
/**
 * Validator that requires the control's value be true. This validator is commonly
 * used for required checkboxes.
 * See `Validators.requiredTrue` for additional information.
 */
function requiredTrueValidator(control) {
  return control.value === true ? null : {
    'required': true
  };
}
/**
 * Validator that requires the control's value pass an email validation test.
 * See `Validators.email` for additional information.
 */
function emailValidator(control) {
  if (isEmptyInputValue(control.value)) {
    return null; // don't validate empty values to allow optional controls
  }

  return EMAIL_REGEXP.test(control.value) ? null : {
    'email': true
  };
}
/**
 * Validator that requires the length of the control's value to be greater than or equal
 * to the provided minimum length. See `Validators.minLength` for additional information.
 */
function minLengthValidator(minLength) {
  return control => {
    if (isEmptyInputValue(control.value) || !hasValidLength(control.value)) {
      // don't validate empty values to allow optional controls
      // don't validate values without `length` property
      return null;
    }
    return control.value.length < minLength ? {
      'minlength': {
        'requiredLength': minLength,
        'actualLength': control.value.length
      }
    } : null;
  };
}
/**
 * Validator that requires the length of the control's value to be less than or equal
 * to the provided maximum length. See `Validators.maxLength` for additional information.
 */
function maxLengthValidator(maxLength) {
  return control => {
    return hasValidLength(control.value) && control.value.length > maxLength ? {
      'maxlength': {
        'requiredLength': maxLength,
        'actualLength': control.value.length
      }
    } : null;
  };
}
/**
 * Validator that requires the control's value to match a regex pattern.
 * See `Validators.pattern` for additional information.
 */
function patternValidator(pattern) {
  if (!pattern) return nullValidator;
  let regex;
  let regexStr;
  if (typeof pattern === 'string') {
    regexStr = '';
    if (pattern.charAt(0) !== '^') regexStr += '^';
    regexStr += pattern;
    if (pattern.charAt(pattern.length - 1) !== '$') regexStr += '$';
    regex = new RegExp(regexStr);
  } else {
    regexStr = pattern.toString();
    regex = pattern;
  }
  return control => {
    if (isEmptyInputValue(control.value)) {
      return null; // don't validate empty values to allow optional controls
    }

    const value = control.value;
    return regex.test(value) ? null : {
      'pattern': {
        'requiredPattern': regexStr,
        'actualValue': value
      }
    };
  };
}
/**
 * Function that has `ValidatorFn` shape, but performs no operation.
 */
function nullValidator(control) {
  return null;
}
function isPresent(o) {
  return o != null;
}
function toObservable(r) {
  const obs = (0,core_js_["ɵisPromise"])(r) ? (0,from/* from */.D)(r) : r;
  if (!(0,core_js_["ɵisObservable"])(obs) && (typeof ngDevMode === 'undefined' || ngDevMode)) {
    throw new Error(`Expected validator to return Promise or Observable.`);
  }
  return obs;
}
function mergeErrors(arrayOfErrors) {
  let res = {};
  // Not using Array.reduce here due to a Chrome 80 bug
  // https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
  arrayOfErrors.forEach(errors => {
    res = errors != null ? Object.assign(Object.assign({}, res), errors) : res;
  });
  return Object.keys(res).length === 0 ? null : res;
}
function executeValidators(control, validators) {
  return validators.map(validator => validator(control));
}
function isValidatorFn(validator) {
  return !validator.validate;
}
/**
 * Given the list of validators that may contain both functions as well as classes, return the list
 * of validator functions (convert validator classes into validator functions). This is needed to
 * have consistent structure in validators list before composing them.
 *
 * @param validators The set of validators that may contain validators both in plain function form
 *     as well as represented as a validator class.
 */
function normalizeValidators(validators) {
  return validators.map(validator => {
    return isValidatorFn(validator) ? validator : c => validator.validate(c);
  });
}
/**
 * Merges synchronous validators into a single validator function.
 * See `Validators.compose` for additional information.
 */
function compose(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function (control) {
    return mergeErrors(executeValidators(control, presentValidators));
  };
}
/**
 * Accepts a list of validators of different possible shapes (`Validator` and `ValidatorFn`),
 * normalizes the list (converts everything to `ValidatorFn`) and merges them into a single
 * validator function.
 */
function composeValidators(validators) {
  return validators != null ? compose(normalizeValidators(validators)) : null;
}
/**
 * Merges asynchronous validators into a single validator function.
 * See `Validators.composeAsync` for additional information.
 */
function composeAsync(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function (control) {
    const observables = executeValidators(control, presentValidators).map(toObservable);
    return forkJoin(observables).pipe((0,map/* map */.U)(mergeErrors));
  };
}
/**
 * Accepts a list of async validators of different possible shapes (`AsyncValidator` and
 * `AsyncValidatorFn`), normalizes the list (converts everything to `AsyncValidatorFn`) and merges
 * them into a single validator function.
 */
function composeAsyncValidators(validators) {
  return validators != null ? composeAsync(normalizeValidators(validators)) : null;
}
/**
 * Merges raw control validators with a given directive validator and returns the combined list of
 * validators as an array.
 */
function mergeValidators(controlValidators, dirValidator) {
  if (controlValidators === null) return [dirValidator];
  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] : [controlValidators, dirValidator];
}
/**
 * Retrieves the list of raw synchronous validators attached to a given control.
 */
function getControlValidators(control) {
  return control._rawValidators;
}
/**
 * Retrieves the list of raw asynchronous validators attached to a given control.
 */
function getControlAsyncValidators(control) {
  return control._rawAsyncValidators;
}
/**
 * Accepts a singleton validator, an array, or null, and returns an array type with the provided
 * validators.
 *
 * @param validators A validator, validators, or null.
 * @returns A validators array.
 */
function makeValidatorsArray(validators) {
  if (!validators) return [];
  return Array.isArray(validators) ? validators : [validators];
}
/**
 * Determines whether a validator or validators array has a given validator.
 *
 * @param validators The validator or validators to compare against.
 * @param validator The validator to check.
 * @returns Whether the validator is present.
 */
function hasValidator(validators, validator) {
  return Array.isArray(validators) ? validators.includes(validator) : validators === validator;
}
/**
 * Combines two arrays of validators into one. If duplicates are provided, only one will be added.
 *
 * @param validators The new validators.
 * @param currentValidators The base array of currrent validators.
 * @returns An array of validators.
 */
function addValidators(validators, currentValidators) {
  const current = makeValidatorsArray(currentValidators);
  const validatorsToAdd = makeValidatorsArray(validators);
  validatorsToAdd.forEach(v => {
    // Note: if there are duplicate entries in the new validators array,
    // only the first one would be added to the current list of validarors.
    // Duplicate ones would be ignored since `hasValidator` would detect
    // the presence of a validator function and we update the current list in place.
    if (!hasValidator(current, v)) {
      current.push(v);
    }
  });
  return current;
}
function removeValidators(validators, currentValidators) {
  return makeValidatorsArray(currentValidators).filter(v => !hasValidator(validators, v));
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @description
 * Base class for control directives.
 *
 * This class is only used internally in the `ReactiveFormsModule` and the `FormsModule`.
 *
 * @publicApi
 */
let AbstractControlDirective = /*#__PURE__*/(() => {
  class AbstractControlDirective {
    constructor() {
      /**
       * Set of synchronous validators as they were provided while calling `setValidators` function.
       * @internal
       */
      this._rawValidators = [];
      /**
       * Set of asynchronous validators as they were provided while calling `setAsyncValidators`
       * function.
       * @internal
       */
      this._rawAsyncValidators = [];
      /*
       * The set of callbacks to be invoked when directive instance is being destroyed.
       */
      this._onDestroyCallbacks = [];
    }
    /**
     * @description
     * Reports the value of the control if it is present, otherwise null.
     */
    get value() {
      return this.control ? this.control.value : null;
    }
    /**
     * @description
     * Reports whether the control is valid. A control is considered valid if no
     * validation errors exist with the current value.
     * If the control is not present, null is returned.
     */
    get valid() {
      return this.control ? this.control.valid : null;
    }
    /**
     * @description
     * Reports whether the control is invalid, meaning that an error exists in the input value.
     * If the control is not present, null is returned.
     */
    get invalid() {
      return this.control ? this.control.invalid : null;
    }
    /**
     * @description
     * Reports whether a control is pending, meaning that that async validation is occurring and
     * errors are not yet available for the input value. If the control is not present, null is
     * returned.
     */
    get pending() {
      return this.control ? this.control.pending : null;
    }
    /**
     * @description
     * Reports whether the control is disabled, meaning that the control is disabled
     * in the UI and is exempt from validation checks and excluded from aggregate
     * values of ancestor controls. If the control is not present, null is returned.
     */
    get disabled() {
      return this.control ? this.control.disabled : null;
    }
    /**
     * @description
     * Reports whether the control is enabled, meaning that the control is included in ancestor
     * calculations of validity or value. If the control is not present, null is returned.
     */
    get enabled() {
      return this.control ? this.control.enabled : null;
    }
    /**
     * @description
     * Reports the control's validation errors. If the control is not present, null is returned.
     */
    get errors() {
      return this.control ? this.control.errors : null;
    }
    /**
     * @description
     * Reports whether the control is pristine, meaning that the user has not yet changed
     * the value in the UI. If the control is not present, null is returned.
     */
    get pristine() {
      return this.control ? this.control.pristine : null;
    }
    /**
     * @description
     * Reports whether the control is dirty, meaning that the user has changed
     * the value in the UI. If the control is not present, null is returned.
     */
    get dirty() {
      return this.control ? this.control.dirty : null;
    }
    /**
     * @description
     * Reports whether the control is touched, meaning that the user has triggered
     * a `blur` event on it. If the control is not present, null is returned.
     */
    get touched() {
      return this.control ? this.control.touched : null;
    }
    /**
     * @description
     * Reports the validation status of the control. Possible values include:
     * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.
     * If the control is not present, null is returned.
     */
    get status() {
      return this.control ? this.control.status : null;
    }
    /**
     * @description
     * Reports whether the control is untouched, meaning that the user has not yet triggered
     * a `blur` event on it. If the control is not present, null is returned.
     */
    get untouched() {
      return this.control ? this.control.untouched : null;
    }
    /**
     * @description
     * Returns a multicasting observable that emits a validation status whenever it is
     * calculated for the control. If the control is not present, null is returned.
     */
    get statusChanges() {
      return this.control ? this.control.statusChanges : null;
    }
    /**
     * @description
     * Returns a multicasting observable of value changes for the control that emits every time the
     * value of the control changes in the UI or programmatically.
     * If the control is not present, null is returned.
     */
    get valueChanges() {
      return this.control ? this.control.valueChanges : null;
    }
    /**
     * @description
     * Returns an array that represents the path from the top-level form to this control.
     * Each index is the string name of the control on that level.
     */
    get path() {
      return null;
    }
    /**
     * Sets synchronous validators for this directive.
     * @internal
     */
    _setValidators(validators) {
      this._rawValidators = validators || [];
      this._composedValidatorFn = composeValidators(this._rawValidators);
    }
    /**
     * Sets asynchronous validators for this directive.
     * @internal
     */
    _setAsyncValidators(validators) {
      this._rawAsyncValidators = validators || [];
      this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);
    }
    /**
     * @description
     * Synchronous validator function composed of all the synchronous validators registered with this
     * directive.
     */
    get validator() {
      return this._composedValidatorFn || null;
    }
    /**
     * @description
     * Asynchronous validator function composed of all the asynchronous validators registered with
     * this directive.
     */
    get asyncValidator() {
      return this._composedAsyncValidatorFn || null;
    }
    /**
     * Internal function to register callbacks that should be invoked
     * when directive instance is being destroyed.
     * @internal
     */
    _registerOnDestroy(fn) {
      this._onDestroyCallbacks.push(fn);
    }
    /**
     * Internal function to invoke all registered "on destroy" callbacks.
     * Note: calling this function also clears the list of callbacks.
     * @internal
     */
    _invokeOnDestroyCallbacks() {
      this._onDestroyCallbacks.forEach(fn => fn());
      this._onDestroyCallbacks = [];
    }
    /**
     * @description
     * Resets the control with the provided value if the control is present.
     */
    reset(value = undefined) {
      if (this.control) this.control.reset(value);
    }
    /**
     * @description
     * Reports whether the control with the given path has the error specified.
     *
     * @param errorCode The code of the error to check
     * @param path A list of control names that designates how to move from the current control
     * to the control that should be queried for errors.
     *
     * @usageNotes
     * For example, for the following `FormGroup`:
     *
     * ```
     * form = new FormGroup({
     *   address: new FormGroup({ street: new FormControl() })
     * });
     * ```
     *
     * The path to the 'street' control from the root form would be 'address' -> 'street'.
     *
     * It can be provided to this method in one of two formats:
     *
     * 1. An array of string control names, e.g. `['address', 'street']`
     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
     *
     * If no path is given, this method checks for the error on the current control.
     *
     * @returns whether the given error is present in the control at the given path.
     *
     * If the control is not present, false is returned.
     */
    hasError(errorCode, path) {
      return this.control ? this.control.hasError(errorCode, path) : false;
    }
    /**
     * @description
     * Reports error data for the control with the given path.
     *
     * @param errorCode The code of the error to check
     * @param path A list of control names that designates how to move from the current control
     * to the control that should be queried for errors.
     *
     * @usageNotes
     * For example, for the following `FormGroup`:
     *
     * ```
     * form = new FormGroup({
     *   address: new FormGroup({ street: new FormControl() })
     * });
     * ```
     *
     * The path to the 'street' control from the root form would be 'address' -> 'street'.
     *
     * It can be provided to this method in one of two formats:
     *
     * 1. An array of string control names, e.g. `['address', 'street']`
     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
     *
     * @returns error data for that particular error. If the control or error is not present,
     * null is returned.
     */
    getError(errorCode, path) {
      return this.control ? this.control.getError(errorCode, path) : null;
    }
  }
  AbstractControlDirective.ɵfac = function AbstractControlDirective_Factory(t) {
    return new (t || AbstractControlDirective)();
  };
  AbstractControlDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: AbstractControlDirective
  });

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @description
   * A base class for directives that contain multiple registered instances of `NgControl`.
   * Only used by the forms module.
   *
   * @publicApi
   */
  return AbstractControlDirective;
})();
let ControlContainer = /*#__PURE__*/(() => {
  class ControlContainer extends AbstractControlDirective {
    /**
     * @description
     * The top-level form directive for the control.
     */
    get formDirective() {
      return null;
    }
    /**
     * @description
     * The path to this group.
     */
    get path() {
      return null;
    }
  }
  ControlContainer.ɵfac = /*@__PURE__*/function () {
    let ɵControlContainer_BaseFactory;
    return function ControlContainer_Factory(t) {
      return (ɵControlContainer_BaseFactory || (ɵControlContainer_BaseFactory = core_js_["ɵɵgetInheritedFactory"](ControlContainer)))(t || ControlContainer);
    };
  }();
  ControlContainer.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: ControlContainer,
    features: [core_js_["ɵɵInheritDefinitionFeature"]]
  });

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @description
   * A base class that all `FormControl`-based directives extend. It binds a `FormControl`
   * object to a DOM element.
   *
   * @publicApi
   */
  return ControlContainer;
})();
class NgControl extends AbstractControlDirective {
  constructor() {
    super(...arguments);
    /**
     * @description
     * The parent form for the control.
     *
     * @internal
     */
    this._parent = null;
    /**
     * @description
     * The name for the control
     */
    this.name = null;
    /**
     * @description
     * The value accessor for the control
     */
    this.valueAccessor = null;
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class AbstractControlStatus {
  constructor(cd) {
    this._cd = cd;
  }
  is(status) {
    var _a, _b, _c;
    // Currently with ViewEngine (in AOT mode) it's not possible to use private methods in host
    // bindings.
    // TODO: once ViewEngine is removed, this function should be refactored:
    //  - make the `is` method `protected`, so it's not accessible publicly
    //  - move the `submitted` status logic to the `NgControlStatusGroup` class
    //    and make it `private` or `protected` too.
    if (status === 'submitted') {
      // We check for the `submitted` field from `NgForm` and `FormGroupDirective` classes, but
      // we avoid instanceof checks to prevent non-tree-shakable references to those types.
      return !!((_a = this._cd) === null || _a === void 0 ? void 0 : _a.submitted);
    }
    return !!((_c = (_b = this._cd) === null || _b === void 0 ? void 0 : _b.control) === null || _c === void 0 ? void 0 : _c[status]);
  }
}
const ngControlStatusHost = {
  '[class.ng-untouched]': 'is("untouched")',
  '[class.ng-touched]': 'is("touched")',
  '[class.ng-pristine]': 'is("pristine")',
  '[class.ng-dirty]': 'is("dirty")',
  '[class.ng-valid]': 'is("valid")',
  '[class.ng-invalid]': 'is("invalid")',
  '[class.ng-pending]': 'is("pending")'
};
const ngGroupStatusHost = {
  '[class.ng-untouched]': 'is("untouched")',
  '[class.ng-touched]': 'is("touched")',
  '[class.ng-pristine]': 'is("pristine")',
  '[class.ng-dirty]': 'is("dirty")',
  '[class.ng-valid]': 'is("valid")',
  '[class.ng-invalid]': 'is("invalid")',
  '[class.ng-pending]': 'is("pending")',
  '[class.ng-submitted]': 'is("submitted")'
};
/**
 * @description
 * Directive automatically applied to Angular form controls that sets CSS classes
 * based on control status.
 *
 * @usageNotes
 *
 * ### CSS classes applied
 *
 * The following classes are applied as the properties become true:
 *
 * * ng-valid
 * * ng-invalid
 * * ng-pending
 * * ng-pristine
 * * ng-dirty
 * * ng-untouched
 * * ng-touched
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let NgControlStatus = /*#__PURE__*/(() => {
  class NgControlStatus extends AbstractControlStatus {
    constructor(cd) {
      super(cd);
    }
  }
  NgControlStatus.ɵfac = function NgControlStatus_Factory(t) {
    return new (t || NgControlStatus)(core_js_["ɵɵdirectiveInject"](NgControl, 2));
  };
  NgControlStatus.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: NgControlStatus,
    selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]],
    hostVars: 14,
    hostBindings: function NgControlStatus_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("ng-untouched", ctx.is("untouched"))("ng-touched", ctx.is("touched"))("ng-pristine", ctx.is("pristine"))("ng-dirty", ctx.is("dirty"))("ng-valid", ctx.is("valid"))("ng-invalid", ctx.is("invalid"))("ng-pending", ctx.is("pending"));
      }
    },
    features: [core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return NgControlStatus;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Directive automatically applied to Angular form groups that sets CSS classes
 * based on control status (valid/invalid/dirty/etc). On groups, this includes the additional
 * class ng-submitted.
 *
 * @see `NgControlStatus`
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let NgControlStatusGroup = /*#__PURE__*/(() => {
  class NgControlStatusGroup extends AbstractControlStatus {
    constructor(cd) {
      super(cd);
    }
  }
  NgControlStatusGroup.ɵfac = function NgControlStatusGroup_Factory(t) {
    return new (t || NgControlStatusGroup)(core_js_["ɵɵdirectiveInject"](ControlContainer, 10));
  };
  NgControlStatusGroup.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: NgControlStatusGroup,
    selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]],
    hostVars: 16,
    hostBindings: function NgControlStatusGroup_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("ng-untouched", ctx.is("untouched"))("ng-touched", ctx.is("touched"))("ng-pristine", ctx.is("pristine"))("ng-dirty", ctx.is("dirty"))("ng-valid", ctx.is("valid"))("ng-invalid", ctx.is("invalid"))("ng-pending", ctx.is("pending"))("ng-submitted", ctx.is("submitted"));
      }
    },
    features: [core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return NgControlStatusGroup;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const formControlNameExample = `
  <div [formGroup]="myGroup">
    <input formControlName="firstName">
  </div>

  In your class:

  this.myGroup = new FormGroup({
      firstName: new FormControl()
  });`;
const formGroupNameExample = `
  <div [formGroup]="myGroup">
      <div formGroupName="person">
        <input formControlName="firstName">
      </div>
  </div>

  In your class:

  this.myGroup = new FormGroup({
      person: new FormGroup({ firstName: new FormControl() })
  });`;
const formArrayNameExample = `
  <div [formGroup]="myGroup">
    <div formArrayName="cities">
      <div *ngFor="let city of cityArray.controls; index as i">
        <input [formControlName]="i">
      </div>
    </div>
  </div>

  In your class:

  this.cityArray = new FormArray([new FormControl('SF')]);
  this.myGroup = new FormGroup({
    cities: this.cityArray
  });`;
const ngModelGroupExample = `
  <form>
      <div ngModelGroup="person">
        <input [(ngModel)]="person.name" name="firstName">
      </div>
  </form>`;
const ngModelWithFormGroupExample = `
  <div [formGroup]="myGroup">
      <input formControlName="firstName">
      <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">
  </div>
`;

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function controlParentException() {
  return new Error(`formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formControlNameExample}`);
}
function ngModelGroupException() {
  return new Error(`formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents
      that also have a "form" prefix: formGroupName, formArrayName, or formGroup.

      Option 1:  Update the parent to be formGroupName (reactive form strategy)

      ${formGroupNameExample}

      Option 2: Use ngModel instead of formControlName (template-driven strategy)

      ${ngModelGroupExample}`);
}
function missingFormException() {
  return new Error(`formGroup expects a FormGroup instance. Please pass one in.

      Example:

      ${formControlNameExample}`);
}
function groupParentException() {
  return new Error(`formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup
    directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formGroupNameExample}`);
}
function arrayParentException() {
  return new Error(`formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      Example:

      ${formArrayNameExample}`);
}
const disabledAttrWarning = `
  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true
  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for
  you. We recommend using this approach to avoid 'changed after checked' errors.

  Example:
  form = new FormGroup({
    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),
    last: new FormControl('Drew', Validators.required)
  });
`;
function ngModelWarning(directiveName) {
  return `
  It looks like you're using ngModel on the same form field as ${directiveName}.
  Support for using the ngModel input property and ngModelChange event with
  reactive form directives has been deprecated in Angular v6 and will be removed
  in a future version of Angular.

  For more information on this, see our API docs here:
  https://angular.io/api/forms/${directiveName === 'formControl' ? 'FormControlDirective' : 'FormControlName'}#use-with-ngmodel
  `;
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function controlPath(name, parent) {
  return [...parent.path, name];
}
/**
 * Links a Form control and a Form directive by setting up callbacks (such as `onChange`) on both
 * instances. This function is typically invoked when form directive is being initialized.
 *
 * @param control Form control instance that should be linked.
 * @param dir Directive that should be linked with a given control.
 */
function setUpControl(control, dir) {
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    if (!control) _throwError(dir, 'Cannot find control with');
    if (!dir.valueAccessor) _throwError(dir, 'No value accessor for form control with');
  }
  setUpValidators(control, dir);
  dir.valueAccessor.writeValue(control.value);
  setUpViewChangePipeline(control, dir);
  setUpModelChangePipeline(control, dir);
  setUpBlurPipeline(control, dir);
  setUpDisabledChangeHandler(control, dir);
}
/**
 * Reverts configuration performed by the `setUpControl` control function.
 * Effectively disconnects form control with a given form directive.
 * This function is typically invoked when corresponding form directive is being destroyed.
 *
 * @param control Form control which should be cleaned up.
 * @param dir Directive that should be disconnected from a given control.
 * @param validateControlPresenceOnChange Flag that indicates whether onChange handler should
 *     contain asserts to verify that it's not called once directive is destroyed. We need this flag
 *     to avoid potentially breaking changes caused by better control cleanup introduced in #39235.
 */
function cleanUpControl(control, dir, validateControlPresenceOnChange = true) {
  const noop = () => {
    if (validateControlPresenceOnChange && (typeof ngDevMode === 'undefined' || ngDevMode)) {
      _noControlError(dir);
    }
  };
  // The `valueAccessor` field is typically defined on FromControl and FormControlName directive
  // instances and there is a logic in `selectValueAccessor` function that throws if it's not the
  // case. We still check the presence of `valueAccessor` before invoking its methods to make sure
  // that cleanup works correctly if app code or tests are setup to ignore the error thrown from
  // `selectValueAccessor`. See https://github.com/angular/angular/issues/40521.
  if (dir.valueAccessor) {
    dir.valueAccessor.registerOnChange(noop);
    dir.valueAccessor.registerOnTouched(noop);
  }
  cleanUpValidators(control, dir);
  if (control) {
    dir._invokeOnDestroyCallbacks();
    control._registerOnCollectionChange(() => {});
  }
}
function registerOnValidatorChange(validators, onChange) {
  validators.forEach(validator => {
    if (validator.registerOnValidatorChange) validator.registerOnValidatorChange(onChange);
  });
}
/**
 * Sets up disabled change handler function on a given form control if ControlValueAccessor
 * associated with a given directive instance supports the `setDisabledState` call.
 *
 * @param control Form control where disabled change handler should be setup.
 * @param dir Corresponding directive instance associated with this control.
 */
function setUpDisabledChangeHandler(control, dir) {
  if (dir.valueAccessor.setDisabledState) {
    const onDisabledChange = isDisabled => {
      dir.valueAccessor.setDisabledState(isDisabled);
    };
    control.registerOnDisabledChange(onDisabledChange);
    // Register a callback function to cleanup disabled change handler
    // from a control instance when a directive is destroyed.
    dir._registerOnDestroy(() => {
      control._unregisterOnDisabledChange(onDisabledChange);
    });
  }
}
/**
 * Sets up sync and async directive validators on provided form control.
 * This function merges validators from the directive into the validators of the control.
 *
 * @param control Form control where directive validators should be setup.
 * @param dir Directive instance that contains validators to be setup.
 */
function setUpValidators(control, dir) {
  const validators = getControlValidators(control);
  if (dir.validator !== null) {
    control.setValidators(mergeValidators(validators, dir.validator));
  } else if (typeof validators === 'function') {
    // If sync validators are represented by a single validator function, we force the
    // `Validators.compose` call to happen by executing the `setValidators` function with
    // an array that contains that function. We need this to avoid possible discrepancies in
    // validators behavior, so sync validators are always processed by the `Validators.compose`.
    // Note: we should consider moving this logic inside the `setValidators` function itself, so we
    // have consistent behavior on AbstractControl API level. The same applies to the async
    // validators logic below.
    control.setValidators([validators]);
  }
  const asyncValidators = getControlAsyncValidators(control);
  if (dir.asyncValidator !== null) {
    control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));
  } else if (typeof asyncValidators === 'function') {
    control.setAsyncValidators([asyncValidators]);
  }
  // Re-run validation when validator binding changes, e.g. minlength=3 -> minlength=4
  const onValidatorChange = () => control.updateValueAndValidity();
  registerOnValidatorChange(dir._rawValidators, onValidatorChange);
  registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);
}
/**
 * Cleans up sync and async directive validators on provided form control.
 * This function reverts the setup performed by the `setUpValidators` function, i.e.
 * removes directive-specific validators from a given control instance.
 *
 * @param control Form control from where directive validators should be removed.
 * @param dir Directive instance that contains validators to be removed.
 * @returns true if a control was updated as a result of this action.
 */
function cleanUpValidators(control, dir) {
  let isControlUpdated = false;
  if (control !== null) {
    if (dir.validator !== null) {
      const validators = getControlValidators(control);
      if (Array.isArray(validators) && validators.length > 0) {
        // Filter out directive validator function.
        const updatedValidators = validators.filter(validator => validator !== dir.validator);
        if (updatedValidators.length !== validators.length) {
          isControlUpdated = true;
          control.setValidators(updatedValidators);
        }
      }
    }
    if (dir.asyncValidator !== null) {
      const asyncValidators = getControlAsyncValidators(control);
      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {
        // Filter out directive async validator function.
        const updatedAsyncValidators = asyncValidators.filter(asyncValidator => asyncValidator !== dir.asyncValidator);
        if (updatedAsyncValidators.length !== asyncValidators.length) {
          isControlUpdated = true;
          control.setAsyncValidators(updatedAsyncValidators);
        }
      }
    }
  }
  // Clear onValidatorChange callbacks by providing a noop function.
  const noop = () => {};
  registerOnValidatorChange(dir._rawValidators, noop);
  registerOnValidatorChange(dir._rawAsyncValidators, noop);
  return isControlUpdated;
}
function setUpViewChangePipeline(control, dir) {
  dir.valueAccessor.registerOnChange(newValue => {
    control._pendingValue = newValue;
    control._pendingChange = true;
    control._pendingDirty = true;
    if (control.updateOn === 'change') updateControl(control, dir);
  });
}
function setUpBlurPipeline(control, dir) {
  dir.valueAccessor.registerOnTouched(() => {
    control._pendingTouched = true;
    if (control.updateOn === 'blur' && control._pendingChange) updateControl(control, dir);
    if (control.updateOn !== 'submit') control.markAsTouched();
  });
}
function updateControl(control, dir) {
  if (control._pendingDirty) control.markAsDirty();
  control.setValue(control._pendingValue, {
    emitModelToViewChange: false
  });
  dir.viewToModelUpdate(control._pendingValue);
  control._pendingChange = false;
}
function setUpModelChangePipeline(control, dir) {
  const onChange = (newValue, emitModelEvent) => {
    // control -> view
    dir.valueAccessor.writeValue(newValue);
    // control -> ngModel
    if (emitModelEvent) dir.viewToModelUpdate(newValue);
  };
  control.registerOnChange(onChange);
  // Register a callback function to cleanup onChange handler
  // from a control instance when a directive is destroyed.
  dir._registerOnDestroy(() => {
    control._unregisterOnChange(onChange);
  });
}
/**
 * Links a FormGroup or FormArray instance and corresponding Form directive by setting up validators
 * present in the view.
 *
 * @param control FormGroup or FormArray instance that should be linked.
 * @param dir Directive that provides view validators.
 */
function setUpFormContainer(control, dir) {
  if (control == null && (typeof ngDevMode === 'undefined' || ngDevMode)) _throwError(dir, 'Cannot find control with');
  setUpValidators(control, dir);
}
/**
 * Reverts the setup performed by the `setUpFormContainer` function.
 *
 * @param control FormGroup or FormArray instance that should be cleaned up.
 * @param dir Directive that provided view validators.
 * @returns true if a control was updated as a result of this action.
 */
function cleanUpFormContainer(control, dir) {
  return cleanUpValidators(control, dir);
}
function _noControlError(dir) {
  return _throwError(dir, 'There is no FormControl instance attached to form control element with');
}
function _throwError(dir, message) {
  let messageEnd;
  if (dir.path.length > 1) {
    messageEnd = `path: '${dir.path.join(' -> ')}'`;
  } else if (dir.path[0]) {
    messageEnd = `name: '${dir.path}'`;
  } else {
    messageEnd = 'unspecified name attribute';
  }
  throw new Error(`${message} ${messageEnd}`);
}
function isPropertyUpdated(changes, viewModel) {
  if (!changes.hasOwnProperty('model')) return false;
  const change = changes['model'];
  if (change.isFirstChange()) return true;
  return !Object.is(viewModel, change.currentValue);
}
function isBuiltInAccessor(valueAccessor) {
  // Check if a given value accessor is an instance of a class that directly extends
  // `BuiltInControlValueAccessor` one.
  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;
}
function syncPendingControls(form, directives) {
  form._syncPendingControls();
  directives.forEach(dir => {
    const control = dir.control;
    if (control.updateOn === 'submit' && control._pendingChange) {
      dir.viewToModelUpdate(control._pendingValue);
      control._pendingChange = false;
    }
  });
}
// TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented
function selectValueAccessor(dir, valueAccessors) {
  if (!valueAccessors) return null;
  if (!Array.isArray(valueAccessors) && (typeof ngDevMode === 'undefined' || ngDevMode)) _throwError(dir, 'Value accessor was not provided as an array for form control with');
  let defaultAccessor = undefined;
  let builtinAccessor = undefined;
  let customAccessor = undefined;
  valueAccessors.forEach(v => {
    if (v.constructor === DefaultValueAccessor) {
      defaultAccessor = v;
    } else if (isBuiltInAccessor(v)) {
      if (builtinAccessor && (typeof ngDevMode === 'undefined' || ngDevMode)) _throwError(dir, 'More than one built-in value accessor matches form control with');
      builtinAccessor = v;
    } else {
      if (customAccessor && (typeof ngDevMode === 'undefined' || ngDevMode)) _throwError(dir, 'More than one custom value accessor matches form control with');
      customAccessor = v;
    }
  });
  if (customAccessor) return customAccessor;
  if (builtinAccessor) return builtinAccessor;
  if (defaultAccessor) return defaultAccessor;
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    _throwError(dir, 'No valid value accessor for form control with');
  }
  return null;
}
function removeListItem(list, el) {
  const index = list.indexOf(el);
  if (index > -1) list.splice(index, 1);
}
// TODO(kara): remove after deprecation period
function _ngModelWarning(name, type, instance, warningConfig) {
  if (warningConfig === 'never') return;
  if ((warningConfig === null || warningConfig === 'once') && !type._ngModelWarningSentOnce || warningConfig === 'always' && !instance._ngModelWarningSent) {
    console.warn(ngModelWarning(name));
    type._ngModelWarningSentOnce = true;
    instance._ngModelWarningSent = true;
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Reports that a FormControl is valid, meaning that no errors exist in the input value.
 *
 * @see `status`
 */
const VALID = 'VALID';
/**
 * Reports that a FormControl is invalid, meaning that an error exists in the input value.
 *
 * @see `status`
 */
const INVALID = 'INVALID';
/**
 * Reports that a FormControl is pending, meaning that that async validation is occurring and
 * errors are not yet available for the input value.
 *
 * @see `markAsPending`
 * @see `status`
 */
const PENDING = 'PENDING';
/**
 * Reports that a FormControl is disabled, meaning that the control is exempt from ancestor
 * calculations of validity or value.
 *
 * @see `markAsDisabled`
 * @see `status`
 */
const DISABLED = 'DISABLED';
function _find(control, path, delimiter) {
  if (path == null) return null;
  if (!Array.isArray(path)) {
    path = path.split(delimiter);
  }
  if (Array.isArray(path) && path.length === 0) return null;
  // Not using Array.reduce here due to a Chrome 80 bug
  // https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
  let controlToFind = control;
  path.forEach(name => {
    if (controlToFind instanceof FormGroup) {
      controlToFind = controlToFind.controls.hasOwnProperty(name) ? controlToFind.controls[name] : null;
    } else if (controlToFind instanceof FormArray) {
      controlToFind = controlToFind.at(name) || null;
    } else {
      controlToFind = null;
    }
  });
  return controlToFind;
}
/**
 * Gets validators from either an options object or given validators.
 */
function pickValidators(validatorOrOpts) {
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;
}
/**
 * Creates validator function by combining provided validators.
 */
function coerceToValidator(validator) {
  return Array.isArray(validator) ? composeValidators(validator) : validator || null;
}
/**
 * Gets async validators from either an options object or given validators.
 */
function pickAsyncValidators(asyncValidator, validatorOrOpts) {
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;
}
/**
 * Creates async validator function by combining provided async validators.
 */
function coerceToAsyncValidator(asyncValidator) {
  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator || null;
}
function isOptionsObj(validatorOrOpts) {
  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) && typeof validatorOrOpts === 'object';
}
/**
 * This is the base class for `FormControl`, `FormGroup`, and `FormArray`.
 *
 * It provides some of the shared behavior that all controls and groups of controls have, like
 * running validators, calculating status, and resetting state. It also defines the properties
 * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be
 * instantiated directly.
 *
 * @see [Forms Guide](/guide/forms)
 * @see [Reactive Forms Guide](/guide/reactive-forms)
 * @see [Dynamic Forms Guide](/guide/dynamic-form)
 *
 * @publicApi
 */
class AbstractControl {
  /**
   * Initialize the AbstractControl instance.
   *
   * @param validators The function or array of functions that is used to determine the validity of
   *     this control synchronously.
   * @param asyncValidators The function or array of functions that is used to determine validity of
   *     this control asynchronously.
   */
  constructor(validators, asyncValidators) {
    /**
     * Indicates that a control has its own pending asynchronous validation in progress.
     *
     * @internal
     */
    this._hasOwnPendingAsyncValidator = false;
    /** @internal */
    this._onCollectionChange = () => {};
    this._parent = null;
    /**
     * A control is `pristine` if the user has not yet changed
     * the value in the UI.
     *
     * @returns True if the user has not yet changed the value in the UI; compare `dirty`.
     * Programmatic changes to a control's value do not mark it dirty.
     */
    this.pristine = true;
    /**
     * True if the control is marked as `touched`.
     *
     * A control is marked `touched` once the user has triggered
     * a `blur` event on it.
     */
    this.touched = false;
    /** @internal */
    this._onDisabledChange = [];
    this._rawValidators = validators;
    this._rawAsyncValidators = asyncValidators;
    this._composedValidatorFn = coerceToValidator(this._rawValidators);
    this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);
  }
  /**
   * Returns the function that is used to determine the validity of this control synchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get validator() {
    return this._composedValidatorFn;
  }
  set validator(validatorFn) {
    this._rawValidators = this._composedValidatorFn = validatorFn;
  }
  /**
   * Returns the function that is used to determine the validity of this control asynchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get asyncValidator() {
    return this._composedAsyncValidatorFn;
  }
  set asyncValidator(asyncValidatorFn) {
    this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;
  }
  /**
   * The parent control.
   */
  get parent() {
    return this._parent;
  }
  /**
   * A control is `valid` when its `status` is `VALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control has passed all of its validation tests,
   * false otherwise.
   */
  get valid() {
    return this.status === VALID;
  }
  /**
   * A control is `invalid` when its `status` is `INVALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control has failed one or more of its validation checks,
   * false otherwise.
   */
  get invalid() {
    return this.status === INVALID;
  }
  /**
   * A control is `pending` when its `status` is `PENDING`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control is in the process of conducting a validation check,
   * false otherwise.
   */
  get pending() {
    return this.status == PENDING;
  }
  /**
   * A control is `disabled` when its `status` is `DISABLED`.
   *
   * Disabled controls are exempt from validation checks and
   * are not included in the aggregate value of their ancestor
   * controls.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control is disabled, false otherwise.
   */
  get disabled() {
    return this.status === DISABLED;
  }
  /**
   * A control is `enabled` as long as its `status` is not `DISABLED`.
   *
   * @returns True if the control has any status other than 'DISABLED',
   * false if the status is 'DISABLED'.
   *
   * @see {@link AbstractControl.status}
   *
   */
  get enabled() {
    return this.status !== DISABLED;
  }
  /**
   * A control is `dirty` if the user has changed the value
   * in the UI.
   *
   * @returns True if the user has changed the value of this control in the UI; compare `pristine`.
   * Programmatic changes to a control's value do not mark it dirty.
   */
  get dirty() {
    return !this.pristine;
  }
  /**
   * True if the control has not been marked as touched
   *
   * A control is `untouched` if the user has not yet triggered
   * a `blur` event on it.
   */
  get untouched() {
    return !this.touched;
  }
  /**
   * Reports the update strategy of the `AbstractControl` (meaning
   * the event on which the control updates itself).
   * Possible values: `'change'` | `'blur'` | `'submit'`
   * Default value: `'change'`
   */
  get updateOn() {
    return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : 'change';
  }
  /**
   * Sets the synchronous validators that are active on this control.  Calling
   * this overwrites any existing synchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addValidators()` method instead.
   */
  setValidators(validators) {
    this._rawValidators = validators;
    this._composedValidatorFn = coerceToValidator(validators);
  }
  /**
   * Sets the asynchronous validators that are active on this control. Calling this
   * overwrites any existing asynchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addAsyncValidators()` method instead.
   */
  setAsyncValidators(validators) {
    this._rawAsyncValidators = validators;
    this._composedAsyncValidatorFn = coerceToAsyncValidator(validators);
  }
  /**
   * Add a synchronous validator or validators to this control, without affecting other validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect. If duplicate validator functions
   * are present in the `validators` array, only the first instance would be added to a form
   * control.
   *
   * @param validators The new validator function or functions to add to this control.
   */
  addValidators(validators) {
    this.setValidators(addValidators(validators, this._rawValidators));
  }
  /**
   * Add an asynchronous validator or validators to this control, without affecting other
   * validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect.
   *
   * @param validators The new asynchronous validator function or functions to add to this control.
   */
  addAsyncValidators(validators) {
    this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Remove a synchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found,
   * it is ignored.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The validator or validators to remove.
   */
  removeValidators(validators) {
    this.setValidators(removeValidators(validators, this._rawValidators));
  }
  /**
   * Remove an asynchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found, it
   * is ignored.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The asynchronous validator or validators to remove.
   */
  removeAsyncValidators(validators) {
    this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Check whether a synchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @param validator The validator to check for presence. Compared by function reference.
   * @returns Whether the provided validator was found on this control.
   */
  hasValidator(validator) {
    return hasValidator(this._rawValidators, validator);
  }
  /**
   * Check whether an asynchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @param validator The asynchronous validator to check for presence. Compared by function
   *     reference.
   * @returns Whether the provided asynchronous validator was found on this control.
   */
  hasAsyncValidator(validator) {
    return hasValidator(this._rawAsyncValidators, validator);
  }
  /**
   * Empties out the synchronous validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearValidators() {
    this.validator = null;
  }
  /**
   * Empties out the async validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearAsyncValidators() {
    this.asyncValidator = null;
  }
  /**
   * Marks the control as `touched`. A control is touched by focus and
   * blur events that do not change the value.
   *
   * @see `markAsUntouched()`
   * @see `markAsDirty()`
   * @see `markAsPristine()`
   *
   * @param opts Configuration options that determine how the control propagates changes
   * and emits events after marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsTouched(opts = {}) {
    this.touched = true;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsTouched(opts);
    }
  }
  /**
   * Marks the control and all its descendant controls as `touched`.
   * @see `markAsTouched()`
   */
  markAllAsTouched() {
    this.markAsTouched({
      onlySelf: true
    });
    this._forEachChild(control => control.markAllAsTouched());
  }
  /**
   * Marks the control as `untouched`.
   *
   * If the control has any children, also marks all children as `untouched`
   * and recalculates the `touched` status of all parent controls.
   *
   * @see `markAsTouched()`
   * @see `markAsDirty()`
   * @see `markAsPristine()`
   *
   * @param opts Configuration options that determine how the control propagates changes
   * and emits events after the marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsUntouched(opts = {}) {
    this.touched = false;
    this._pendingTouched = false;
    this._forEachChild(control => {
      control.markAsUntouched({
        onlySelf: true
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts);
    }
  }
  /**
   * Marks the control as `dirty`. A control becomes dirty when
   * the control's value is changed through the UI; compare `markAsTouched`.
   *
   * @see `markAsTouched()`
   * @see `markAsUntouched()`
   * @see `markAsPristine()`
   *
   * @param opts Configuration options that determine how the control propagates changes
   * and emits events after marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsDirty(opts = {}) {
    this.pristine = false;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsDirty(opts);
    }
  }
  /**
   * Marks the control as `pristine`.
   *
   * If the control has any children, marks all children as `pristine`,
   * and recalculates the `pristine` status of all parent
   * controls.
   *
   * @see `markAsTouched()`
   * @see `markAsUntouched()`
   * @see `markAsDirty()`
   *
   * @param opts Configuration options that determine how the control emits events after
   * marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsPristine(opts = {}) {
    this.pristine = true;
    this._pendingDirty = false;
    this._forEachChild(control => {
      control.markAsPristine({
        onlySelf: true
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts);
    }
  }
  /**
   * Marks the control as `pending`.
   *
   * A control is pending while the control performs async validation.
   *
   * @see {@link AbstractControl.status}
   *
   * @param opts Configuration options that determine how the control propagates changes and
   * emits events after marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`
   * observable emits an event with the latest status the control is marked pending.
   * When false, no events are emitted.
   *
   */
  markAsPending(opts = {}) {
    this.status = PENDING;
    if (opts.emitEvent !== false) {
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsPending(opts);
    }
  }
  /**
   * Disables the control. This means the control is exempt from validation checks and
   * excluded from the aggregate value of any parent. Its status is `DISABLED`.
   *
   * If the control has children, all children are also disabled.
   *
   * @see {@link AbstractControl.status}
   *
   * @param opts Configuration options that determine how the control propagates
   * changes and emits events after the control is disabled.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is disabled.
   * When false, no events are emitted.
   */
  disable(opts = {}) {
    // If parent has been marked artificially dirty we don't want to re-calculate the
    // parent's dirtiness based on the children.
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = DISABLED;
    this.errors = null;
    this._forEachChild(control => {
      control.disable(Object.assign(Object.assign({}, opts), {
        onlySelf: true
      }));
    });
    this._updateValue();
    if (opts.emitEvent !== false) {
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    this._updateAncestors(Object.assign(Object.assign({}, opts), {
      skipPristineCheck
    }));
    this._onDisabledChange.forEach(changeFn => changeFn(true));
  }
  /**
   * Enables the control. This means the control is included in validation checks and
   * the aggregate value of its parent. Its status recalculates based on its value and
   * its validators.
   *
   * By default, if the control has children, all children are enabled.
   *
   * @see {@link AbstractControl.status}
   *
   * @param opts Configure options that control how the control propagates changes and
   * emits events when marked as untouched
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is enabled.
   * When false, no events are emitted.
   */
  enable(opts = {}) {
    // If parent has been marked artificially dirty we don't want to re-calculate the
    // parent's dirtiness based on the children.
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = VALID;
    this._forEachChild(control => {
      control.enable(Object.assign(Object.assign({}, opts), {
        onlySelf: true
      }));
    });
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
    this._updateAncestors(Object.assign(Object.assign({}, opts), {
      skipPristineCheck
    }));
    this._onDisabledChange.forEach(changeFn => changeFn(false));
  }
  _updateAncestors(opts) {
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(opts);
      if (!opts.skipPristineCheck) {
        this._parent._updatePristine();
      }
      this._parent._updateTouched();
    }
  }
  /**
   * @param parent Sets the parent of the control
   */
  setParent(parent) {
    this._parent = parent;
  }
  /**
   * Recalculates the value and validation status of the control.
   *
   * By default, it also updates the value and validity of its ancestors.
   *
   * @param opts Configuration options determine how the control propagates changes and emits events
   * after updates and validity checks are applied.
   * * `onlySelf`: When true, only update this control. When false or not supplied,
   * update all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is updated.
   * When false, no events are emitted.
   */
  updateValueAndValidity(opts = {}) {
    this._setInitialStatus();
    this._updateValue();
    if (this.enabled) {
      this._cancelExistingSubscription();
      this.errors = this._runValidator();
      this.status = this._calculateStatus();
      if (this.status === VALID || this.status === PENDING) {
        this._runAsyncValidator(opts.emitEvent);
      }
    }
    if (opts.emitEvent !== false) {
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(opts);
    }
  }
  /** @internal */
  _updateTreeValidity(opts = {
    emitEvent: true
  }) {
    this._forEachChild(ctrl => ctrl._updateTreeValidity(opts));
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
  }
  _setInitialStatus() {
    this.status = this._allControlsDisabled() ? DISABLED : VALID;
  }
  _runValidator() {
    return this.validator ? this.validator(this) : null;
  }
  _runAsyncValidator(emitEvent) {
    if (this.asyncValidator) {
      this.status = PENDING;
      this._hasOwnPendingAsyncValidator = true;
      const obs = toObservable(this.asyncValidator(this));
      this._asyncValidationSubscription = obs.subscribe(errors => {
        this._hasOwnPendingAsyncValidator = false;
        // This will trigger the recalculation of the validation status, which depends on
        // the state of the asynchronous validation (whether it is in progress or not). So, it is
        // necessary that we have updated the `_hasOwnPendingAsyncValidator` boolean flag first.
        this.setErrors(errors, {
          emitEvent
        });
      });
    }
  }
  _cancelExistingSubscription() {
    if (this._asyncValidationSubscription) {
      this._asyncValidationSubscription.unsubscribe();
      this._hasOwnPendingAsyncValidator = false;
    }
  }
  /**
   * Sets errors on a form control when running validations manually, rather than automatically.
   *
   * Calling `setErrors` also updates the validity of the parent control.
   *
   * @usageNotes
   *
   * ### Manually set the errors for a control
   *
   * ```
   * const login = new FormControl('someLogin');
   * login.setErrors({
   *   notUnique: true
   * });
   *
   * expect(login.valid).toEqual(false);
   * expect(login.errors).toEqual({ notUnique: true });
   *
   * login.setValue('someOtherLogin');
   *
   * expect(login.valid).toEqual(true);
   * ```
   */
  setErrors(errors, opts = {}) {
    this.errors = errors;
    this._updateControlsErrors(opts.emitEvent !== false);
  }
  /**
   * Retrieves a child control given the control's name or path.
   *
   * @param path A dot-delimited string or array of string/number values that define the path to the
   * control.
   *
   * @usageNotes
   * ### Retrieve a nested control
   *
   * For example, to get a `name` control nested within a `person` sub-group:
   *
   * * `this.form.get('person.name');`
   *
   * -OR-
   *
   * * `this.form.get(['person', 'name']);`
   *
   * ### Retrieve a control in a FormArray
   *
   * When accessing an element inside a FormArray, you can use an element index.
   * For example, to get a `price` control from the first element in an `items` array you can use:
   *
   * * `this.form.get('items.0.price');`
   *
   * -OR-
   *
   * * `this.form.get(['items', 0, 'price']);`
   */
  get(path) {
    return _find(this, path, '.');
  }
  /**
   * @description
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * @returns error data for that particular error. If the control or error is not present,
   * null is returned.
   */
  getError(errorCode, path) {
    const control = path ? this.get(path) : this;
    return control && control.errors ? control.errors[errorCode] : null;
  }
  /**
   * @description
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * If no path is given, this method checks for the error on the current control.
   *
   * @returns whether the given error is present in the control at the given path.
   *
   * If the control is not present, false is returned.
   */
  hasError(errorCode, path) {
    return !!this.getError(errorCode, path);
  }
  /**
   * Retrieves the top-level ancestor of this control.
   */
  get root() {
    let x = this;
    while (x._parent) {
      x = x._parent;
    }
    return x;
  }
  /** @internal */
  _updateControlsErrors(emitEvent) {
    this.status = this._calculateStatus();
    if (emitEvent) {
      this.statusChanges.emit(this.status);
    }
    if (this._parent) {
      this._parent._updateControlsErrors(emitEvent);
    }
  }
  /** @internal */
  _initObservables() {
    this.valueChanges = new core_js_.EventEmitter();
    this.statusChanges = new core_js_.EventEmitter();
  }
  _calculateStatus() {
    if (this._allControlsDisabled()) return DISABLED;
    if (this.errors) return INVALID;
    if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING)) return PENDING;
    if (this._anyControlsHaveStatus(INVALID)) return INVALID;
    return VALID;
  }
  /** @internal */
  _anyControlsHaveStatus(status) {
    return this._anyControls(control => control.status === status);
  }
  /** @internal */
  _anyControlsDirty() {
    return this._anyControls(control => control.dirty);
  }
  /** @internal */
  _anyControlsTouched() {
    return this._anyControls(control => control.touched);
  }
  /** @internal */
  _updatePristine(opts = {}) {
    this.pristine = !this._anyControlsDirty();
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts);
    }
  }
  /** @internal */
  _updateTouched(opts = {}) {
    this.touched = this._anyControlsTouched();
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts);
    }
  }
  /** @internal */
  _isBoxedValue(formState) {
    return typeof formState === 'object' && formState !== null && Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;
  }
  /** @internal */
  _registerOnCollectionChange(fn) {
    this._onCollectionChange = fn;
  }
  /** @internal */
  _setUpdateStrategy(opts) {
    if (isOptionsObj(opts) && opts.updateOn != null) {
      this._updateOn = opts.updateOn;
    }
  }
  /**
   * Check to see if parent has been marked artificially dirty.
   *
   * @internal
   */
  _parentMarkedDirty(onlySelf) {
    const parentDirty = this._parent && this._parent.dirty;
    return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();
  }
}
/**
 * Tracks the value and validation status of an individual form control.
 *
 * This is one of the three fundamental building blocks of Angular forms, along with
 * `FormGroup` and `FormArray`. It extends the `AbstractControl` class that
 * implements most of the base functionality for accessing the value, validation status,
 * user interactions and events. See [usage examples below](#usage-notes).
 *
 * @see `AbstractControl`
 * @see [Reactive Forms Guide](guide/reactive-forms)
 * @see [Usage Notes](#usage-notes)
 *
 * @usageNotes
 *
 * ### Initializing Form Controls
 *
 * Instantiate a `FormControl`, with an initial value.
 *
 * ```ts
 * const control = new FormControl('some value');
 * console.log(control.value);     // 'some value'
 *```
 *
 * The following example initializes the control with a form state object. The `value`
 * and `disabled` keys are required in this case.
 *
 * ```ts
 * const control = new FormControl({ value: 'n/a', disabled: true });
 * console.log(control.value);     // 'n/a'
 * console.log(control.status);    // 'DISABLED'
 * ```
 *
 * The following example initializes the control with a synchronous validator.
 *
 * ```ts
 * const control = new FormControl('', Validators.required);
 * console.log(control.value);      // ''
 * console.log(control.status);     // 'INVALID'
 * ```
 *
 * The following example initializes the control using an options object.
 *
 * ```ts
 * const control = new FormControl('', {
 *    validators: Validators.required,
 *    asyncValidators: myAsyncValidator
 * });
 * ```
 *
 * ### Configure the control to update on a blur event
 *
 * Set the `updateOn` option to `'blur'` to update on the blur `event`.
 *
 * ```ts
 * const control = new FormControl('', { updateOn: 'blur' });
 * ```
 *
 * ### Configure the control to update on a submit event
 *
 * Set the `updateOn` option to `'submit'` to update on a submit `event`.
 *
 * ```ts
 * const control = new FormControl('', { updateOn: 'submit' });
 * ```
 *
 * ### Reset the control back to an initial value
 *
 * You reset to a specific form state by passing through a standalone
 * value or a form state object that contains both a value and a disabled state
 * (these are the only two properties that cannot be calculated).
 *
 * ```ts
 * const control = new FormControl('Nancy');
 *
 * console.log(control.value); // 'Nancy'
 *
 * control.reset('Drew');
 *
 * console.log(control.value); // 'Drew'
 * ```
 *
 * ### Reset the control back to an initial value and disabled
 *
 * ```
 * const control = new FormControl('Nancy');
 *
 * console.log(control.value); // 'Nancy'
 * console.log(control.status); // 'VALID'
 *
 * control.reset({ value: 'Drew', disabled: true });
 *
 * console.log(control.value); // 'Drew'
 * console.log(control.status); // 'DISABLED'
 * ```
 *
 * @publicApi
 */
class FormControl extends AbstractControl {
  /**
   * Creates a new `FormControl` instance.
   *
   * @param formState Initializes the control with an initial value,
   * or an object that defines the initial value and disabled state.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(formState = null, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    /** @internal */
    this._onChange = [];
    this._applyFormState(formState);
    this._setUpdateStrategy(validatorOrOpts);
    this._initObservables();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`
      // to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  /**
   * Sets a new value for the form control.
   *
   * @param value The new value for the control.
   * @param options Configuration options that determine how the control propagates changes
   * and emits events when the value changes.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   * * `emitModelToViewChange`: When true or not supplied  (the default), each change triggers an
   * `onChange` event to
   * update the view.
   * * `emitViewToModelChange`: When true or not supplied (the default), each change triggers an
   * `ngModelChange`
   * event to update the model.
   *
   */
  setValue(value, options = {}) {
    this.value = this._pendingValue = value;
    if (this._onChange.length && options.emitModelToViewChange !== false) {
      this._onChange.forEach(changeFn => changeFn(this.value, options.emitViewToModelChange !== false));
    }
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of a control.
   *
   * This function is functionally the same as {@link FormControl#setValue setValue} at this level.
   * It exists for symmetry with {@link FormGroup#patchValue patchValue} on `FormGroups` and
   * `FormArrays`, where it does behave differently.
   *
   * @see `setValue` for options
   */
  patchValue(value, options = {}) {
    this.setValue(value, options);
  }
  /**
   * Resets the form control, marking it `pristine` and `untouched`, and setting
   * the value to null.
   *
   * @param formState Resets the control with an initial value,
   * or an object that defines the initial value and disabled state.
   *
   * @param options Configuration options that determine how the control propagates changes
   * and emits events after the value changes.
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   *
   */
  reset(formState = null, options = {}) {
    this._applyFormState(formState);
    this.markAsPristine(options);
    this.markAsUntouched(options);
    this.setValue(this.value, options);
    this._pendingChange = false;
  }
  /**
   * @internal
   */
  _updateValue() {}
  /**
   * @internal
   */
  _anyControls(condition) {
    return false;
  }
  /**
   * @internal
   */
  _allControlsDisabled() {
    return this.disabled;
  }
  /**
   * Register a listener for change events.
   *
   * @param fn The method that is called when the value changes
   */
  registerOnChange(fn) {
    this._onChange.push(fn);
  }
  /**
   * Internal function to unregister a change events listener.
   * @internal
   */
  _unregisterOnChange(fn) {
    removeListItem(this._onChange, fn);
  }
  /**
   * Register a listener for disabled events.
   *
   * @param fn The method that is called when the disabled status changes.
   */
  registerOnDisabledChange(fn) {
    this._onDisabledChange.push(fn);
  }
  /**
   * Internal function to unregister a disabled event listener.
   * @internal
   */
  _unregisterOnDisabledChange(fn) {
    removeListItem(this._onDisabledChange, fn);
  }
  /**
   * @internal
   */
  _forEachChild(cb) {}
  /** @internal */
  _syncPendingControls() {
    if (this.updateOn === 'submit') {
      if (this._pendingDirty) this.markAsDirty();
      if (this._pendingTouched) this.markAsTouched();
      if (this._pendingChange) {
        this.setValue(this._pendingValue, {
          onlySelf: true,
          emitModelToViewChange: false
        });
        return true;
      }
    }
    return false;
  }
  _applyFormState(formState) {
    if (this._isBoxedValue(formState)) {
      this.value = this._pendingValue = formState.value;
      formState.disabled ? this.disable({
        onlySelf: true,
        emitEvent: false
      }) : this.enable({
        onlySelf: true,
        emitEvent: false
      });
    } else {
      this.value = this._pendingValue = formState;
    }
  }
}
/**
 * Tracks the value and validity state of a group of `FormControl` instances.
 *
 * A `FormGroup` aggregates the values of each child `FormControl` into one object,
 * with each control name as the key.  It calculates its status by reducing the status values
 * of its children. For example, if one of the controls in a group is invalid, the entire
 * group becomes invalid.
 *
 * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,
 * along with `FormControl` and `FormArray`.
 *
 * When instantiating a `FormGroup`, pass in a collection of child controls as the first
 * argument. The key for each child registers the name for the control.
 *
 * @usageNotes
 *
 * ### Create a form group with 2 controls
 *
 * ```
 * const form = new FormGroup({
 *   first: new FormControl('Nancy', Validators.minLength(2)),
 *   last: new FormControl('Drew'),
 * });
 *
 * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}
 * console.log(form.status);  // 'VALID'
 * ```
 *
 * ### Create a form group with a group-level validator
 *
 * You include group-level validators as the second arg, or group-level async
 * validators as the third arg. These come in handy when you want to perform validation
 * that considers the value of more than one child control.
 *
 * ```
 * const form = new FormGroup({
 *   password: new FormControl('', Validators.minLength(2)),
 *   passwordConfirm: new FormControl('', Validators.minLength(2)),
 * }, passwordMatchValidator);
 *
 *
 * function passwordMatchValidator(g: FormGroup) {
 *    return g.get('password').value === g.get('passwordConfirm').value
 *       ? null : {'mismatch': true};
 * }
 * ```
 *
 * Like `FormControl` instances, you choose to pass in
 * validators and async validators as part of an options object.
 *
 * ```
 * const form = new FormGroup({
 *   password: new FormControl('')
 *   passwordConfirm: new FormControl('')
 * }, { validators: passwordMatchValidator, asyncValidators: otherValidator });
 * ```
 *
 * ### Set the updateOn property for all controls in a form group
 *
 * The options object is used to set a default value for each child
 * control's `updateOn` property. If you set `updateOn` to `'blur'` at the
 * group level, all child controls default to 'blur', unless the child
 * has explicitly specified a different `updateOn` value.
 *
 * ```ts
 * const c = new FormGroup({
 *   one: new FormControl()
 * }, { updateOn: 'blur' });
 * ```
 *
 * @publicApi
 */
class FormGroup extends AbstractControl {
  /**
   * Creates a new `FormGroup` instance.
   *
   * @param controls A collection of child controls. The key for each child is the name
   * under which it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,
      // so we set `emitEvent` to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  /**
   * Registers a control with the group's list of controls.
   *
   * This method does not update the value or validity of the control.
   * Use {@link FormGroup#addControl addControl} instead.
   *
   * @param name The control name to register in the collection
   * @param control Provides the control for the given name
   */
  registerControl(name, control) {
    if (this.controls[name]) return this.controls[name];
    this.controls[name] = control;
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
    return control;
  }
  /**
   * Add a control to this group.
   *
   * If a control with a given name already exists, it would *not* be replaced with a new one.
   * If you want to replace an existing control, use the {@link FormGroup#setControl setControl}
   * method instead. This method also updates the value and validity of the control.
   *
   * @param name The control name to add to the collection
   * @param control Provides the control for the given name
   * @param options Specifies whether this FormGroup instance should emit events after a new
   *     control is added.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * added. When false, no events are emitted.
   */
  addControl(name, control, options = {}) {
    this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Remove a control from this group.
   *
   * This method also updates the value and validity of the control.
   *
   * @param name The control name to remove from the collection
   * @param options Specifies whether this FormGroup instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeControl(name, options = {}) {
    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});
    delete this.controls[name];
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Replace an existing control.
   *
   * If a control with a given name does not exist in this `FormGroup`, it will be added.
   *
   * @param name The control name to replace in the collection
   * @param control Provides the control for the given name
   * @param options Specifies whether this FormGroup instance should emit events after an
   *     existing control is replaced.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * replaced with a new one. When false, no events are emitted.
   */
  setControl(name, control, options = {}) {
    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});
    delete this.controls[name];
    if (control) this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Check whether there is an enabled control with the given name in the group.
   *
   * Reports false for disabled controls. If you'd like to check for existence in the group
   * only, use {@link AbstractControl#get get} instead.
   *
   * @param controlName The control name to check for existence in the collection
   *
   * @returns false for disabled controls, true otherwise.
   */
  contains(controlName) {
    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
  }
  /**
   * Sets the value of the `FormGroup`. It accepts an object that matches
   * the structure of the group, with control names as keys.
   *
   * @usageNotes
   * ### Set the complete value for the form group
   *
   * ```
   * const form = new FormGroup({
   *   first: new FormControl(),
   *   last: new FormControl()
   * });
   *
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.setValue({first: 'Nancy', last: 'Drew'});
   * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
   * ```
   *
   * @throws When strict checks fail, such as setting the value of a control
   * that doesn't exist or if you exclude a value of a control that does exist.
   *
   * @param value The new value for the control that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes
   * and emits events after the value changes.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   */
  setValue(value, options = {}) {
    this._checkAllValuesPresent(value);
    Object.keys(value).forEach(name => {
      this._throwIfControlMissing(name);
      this.controls[name].setValue(value[name], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormGroup`. It accepts an object with control
   * names as keys, and does its best to match the values to the correct controls
   * in the group.
   *
   * It accepts both super-sets and sub-sets of the group without throwing an error.
   *
   * @usageNotes
   * ### Patch the value for a form group
   *
   * ```
   * const form = new FormGroup({
   *    first: new FormControl(),
   *    last: new FormControl()
   * });
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.patchValue({first: 'Nancy'});
   * console.log(form.value);   // {first: 'Nancy', last: null}
   * ```
   *
   * @param value The object that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes and
   * emits events after the value is patched.
   * * `onlySelf`: When true, each change only affects this control and not its parent. Default is
   * true.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control value
   * is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value, options = {}) {
    // Even though the `value` argument type doesn't allow `null` and `undefined` values, the
    // `patchValue` can be called recursively and inner data structures might have these values, so
    // we just ignore such cases when a field containing FormGroup instance receives `null` or
    // `undefined` as a value.
    if (value == null /* both `null` and `undefined` */) return;
    Object.keys(value).forEach(name => {
      if (this.controls[name]) {
        this.controls[name].patchValue(value[name], {
          onlySelf: true,
          emitEvent: options.emitEvent
        });
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets
   * the value of all descendants to null.
   *
   * You reset to a specific form state by passing in a map of states
   * that matches the structure of your form, with control names as keys. The state
   * is a standalone value or a form state object with both a value and a disabled
   * status.
   *
   * @param value Resets the control with an initial value,
   * or an object that defines the initial value and disabled state.
   *
   * @param options Configuration options that determine how the control propagates changes
   * and emits events when the group is reset.
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * @usageNotes
   *
   * ### Reset the form group values
   *
   * ```ts
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * console.log(form.value);  // {first: 'first name', last: 'last name'}
   *
   * form.reset({ first: 'name', last: 'last name' });
   *
   * console.log(form.value);  // {first: 'name', last: 'last name'}
   * ```
   *
   * ### Reset the form group values and disabled status
   *
   * ```
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * form.reset({
   *   first: {value: 'name', disabled: true},
   *   last: 'last'
   * });
   *
   * console.log(form.value);  // {last: 'last'}
   * console.log(form.get('first').status);  // 'DISABLED'
   * ```
   */
  reset(value = {}, options = {}) {
    this._forEachChild((control, name) => {
      control.reset(value[name], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options);
    this._updateTouched(options);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the `FormGroup`, including any disabled controls.
   *
   * Retrieves all values regardless of disabled status.
   * The `value` property is the best way to get the value of the group, because
   * it excludes disabled controls in the `FormGroup`.
   */
  getRawValue() {
    return this._reduceChildren({}, (acc, control, name) => {
      acc[name] = control instanceof FormControl ? control.value : control.getRawValue();
      return acc;
    });
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this._reduceChildren(false, (updated, child) => {
      return child._syncPendingControls() ? true : updated;
    });
    if (subtreeUpdated) this.updateValueAndValidity({
      onlySelf: true
    });
    return subtreeUpdated;
  }
  /** @internal */
  _throwIfControlMissing(name) {
    if (!Object.keys(this.controls).length) {
      throw new Error(`
        There are no form controls registered with this group yet. If you're using ngModel,
        you may want to check next tick (e.g. use setTimeout).
      `);
    }
    if (!this.controls[name]) {
      throw new Error(`Cannot find form control with name: ${name}.`);
    }
  }
  /** @internal */
  _forEachChild(cb) {
    Object.keys(this.controls).forEach(key => {
      // The list of controls can change (for ex. controls might be removed) while the loop
      // is running (as a result of invoking Forms API in `valueChanges` subscription), so we
      // have to null check before invoking the callback.
      const control = this.controls[key];
      control && cb(control, key);
    });
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild(control => {
      control.setParent(this);
      control._registerOnCollectionChange(this._onCollectionChange);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this._reduceValue();
  }
  /** @internal */
  _anyControls(condition) {
    for (const controlName of Object.keys(this.controls)) {
      const control = this.controls[controlName];
      if (this.contains(controlName) && condition(control)) {
        return true;
      }
    }
    return false;
  }
  /** @internal */
  _reduceValue() {
    return this._reduceChildren({}, (acc, control, name) => {
      if (control.enabled || this.disabled) {
        acc[name] = control.value;
      }
      return acc;
    });
  }
  /** @internal */
  _reduceChildren(initValue, fn) {
    let res = initValue;
    this._forEachChild((control, name) => {
      res = fn(res, control, name);
    });
    return res;
  }
  /** @internal */
  _allControlsDisabled() {
    for (const controlName of Object.keys(this.controls)) {
      if (this.controls[controlName].enabled) {
        return false;
      }
    }
    return Object.keys(this.controls).length > 0 || this.disabled;
  }
  /** @internal */
  _checkAllValuesPresent(value) {
    this._forEachChild((control, name) => {
      if (value[name] === undefined) {
        throw new Error(`Must supply a value for form control with name: '${name}'.`);
      }
    });
  }
}
/**
 * Tracks the value and validity state of an array of `FormControl`,
 * `FormGroup` or `FormArray` instances.
 *
 * A `FormArray` aggregates the values of each child `FormControl` into an array.
 * It calculates its status by reducing the status values of its children. For example, if one of
 * the controls in a `FormArray` is invalid, the entire array becomes invalid.
 *
 * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,
 * along with `FormControl` and `FormGroup`.
 *
 * @usageNotes
 *
 * ### Create an array of form controls
 *
 * ```
 * const arr = new FormArray([
 *   new FormControl('Nancy', Validators.minLength(2)),
 *   new FormControl('Drew'),
 * ]);
 *
 * console.log(arr.value);   // ['Nancy', 'Drew']
 * console.log(arr.status);  // 'VALID'
 * ```
 *
 * ### Create a form array with array-level validators
 *
 * You include array-level validators and async validators. These come in handy
 * when you want to perform validation that considers the value of more than one child
 * control.
 *
 * The two types of validators are passed in separately as the second and third arg
 * respectively, or together as part of an options object.
 *
 * ```
 * const arr = new FormArray([
 *   new FormControl('Nancy'),
 *   new FormControl('Drew')
 * ], {validators: myValidator, asyncValidators: myAsyncValidator});
 * ```
 *
 * ### Set the updateOn property for all controls in a form array
 *
 * The options object is used to set a default value for each child
 * control's `updateOn` property. If you set `updateOn` to `'blur'` at the
 * array level, all child controls default to 'blur', unless the child
 * has explicitly specified a different `updateOn` value.
 *
 * ```ts
 * const arr = new FormArray([
 *    new FormControl()
 * ], {updateOn: 'blur'});
 * ```
 *
 * ### Adding or removing controls from a form array
 *
 * To change the controls in the array, use the `push`, `insert`, `removeAt` or `clear` methods
 * in `FormArray` itself. These methods ensure the controls are properly tracked in the
 * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate
 * the `FormArray` directly, as that result in strange and unexpected behavior such
 * as broken change detection.
 *
 * @publicApi
 */
class FormArray extends AbstractControl {
  /**
   * Creates a new `FormArray` instance.
   *
   * @param controls An array of child controls. Each child control is given an index
   * where it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`
      // to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  /**
   * Get the `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to retrieve the control
   */
  at(index) {
    return this.controls[index];
  }
  /**
   * Insert a new `AbstractControl` at the end of the array.
   *
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is added.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  push(control, options = {}) {
    this.controls.push(control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Insert a new `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to insert the control
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is inserted.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  insert(index, control, options = {}) {
    this.controls.splice(index, 0, control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Remove the control at the given `index` in the array.
   *
   * @param index Index in the array to remove the control
   * @param options Specifies whether this FormArray instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeAt(index, options = {}) {
    if (this.controls[index]) this.controls[index]._registerOnCollectionChange(() => {});
    this.controls.splice(index, 1);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Replace an existing control.
   *
   * @param index Index in the array to replace the control
   * @param control The `AbstractControl` control to replace the existing control
   * @param options Specifies whether this FormArray instance should emit events after an
   *     existing control is replaced with a new one.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * replaced with a new one. When false, no events are emitted.
   */
  setControl(index, control, options = {}) {
    if (this.controls[index]) this.controls[index]._registerOnCollectionChange(() => {});
    this.controls.splice(index, 1);
    if (control) {
      this.controls.splice(index, 0, control);
      this._registerControl(control);
    }
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Length of the control array.
   */
  get length() {
    return this.controls.length;
  }
  /**
   * Sets the value of the `FormArray`. It accepts an array that matches
   * the structure of the control.
   *
   * This method performs strict checks, and throws an error if you try
   * to set the value of a control that doesn't exist or if you exclude the
   * value of a control.
   *
   * @usageNotes
   * ### Set the values for the controls in the form array
   *
   * ```
   * const arr = new FormArray([
   *   new FormControl(),
   *   new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.setValue(['Nancy', 'Drew']);
   * console.log(arr.value);   // ['Nancy', 'Drew']
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  setValue(value, options = {}) {
    this._checkAllValuesPresent(value);
    value.forEach((newValue, index) => {
      this._throwIfControlMissing(index);
      this.at(index).setValue(newValue, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormArray`. It accepts an array that matches the
   * structure of the control, and does its best to match the values to the correct
   * controls in the group.
   *
   * It accepts both super-sets and sub-sets of the array without throwing an error.
   *
   * @usageNotes
   * ### Patch the values for controls in a form array
   *
   * ```
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.patchValue(['Nancy']);
   * console.log(arr.value);   // ['Nancy', null]
   * ```
   *
   * @param value Array of latest values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control value
   * is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value, options = {}) {
    // Even though the `value` argument type doesn't allow `null` and `undefined` values, the
    // `patchValue` can be called recursively and inner data structures might have these values, so
    // we just ignore such cases when a field containing FormArray instance receives `null` or
    // `undefined` as a value.
    if (value == null /* both `null` and `undefined` */) return;
    value.forEach((newValue, index) => {
      if (this.at(index)) {
        this.at(index).patchValue(newValue, {
          onlySelf: true,
          emitEvent: options.emitEvent
        });
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the
   * value of all descendants to null or null maps.
   *
   * You reset to a specific form state by passing in an array of states
   * that matches the structure of the control. The state is a standalone value
   * or a form state object with both a value and a disabled status.
   *
   * @usageNotes
   * ### Reset the values in a form array
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * arr.reset(['name', 'last name']);
   *
   * console.log(arr.value);  // ['name', 'last name']
   * ```
   *
   * ### Reset the values in a form array and the disabled status for the first control
   *
   * ```
   * arr.reset([
   *   {value: 'name', disabled: true},
   *   'last'
   * ]);
   *
   * console.log(arr.value);  // ['last']
   * console.log(arr.at(0).status);  // 'DISABLED'
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  reset(value = [], options = {}) {
    this._forEachChild((control, index) => {
      control.reset(value[index], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options);
    this._updateTouched(options);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the array, including any disabled controls.
   *
   * Reports all values regardless of disabled status.
   * For enabled controls only, the `value` property is the best way to get the value of the array.
   */
  getRawValue() {
    return this.controls.map(control => {
      return control instanceof FormControl ? control.value : control.getRawValue();
    });
  }
  /**
   * Remove all controls in the `FormArray`.
   *
   * @param options Specifies whether this FormArray instance should emit events after all
   *     controls are removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when all controls
   * in this FormArray instance are removed. When false, no events are emitted.
   *
   * @usageNotes
   * ### Remove all elements from a FormArray
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.length);  // 2
   *
   * arr.clear();
   * console.log(arr.length);  // 0
   * ```
   *
   * It's a simpler and more efficient alternative to removing all elements one by one:
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   *
   * while (arr.length) {
   *    arr.removeAt(0);
   * }
   * ```
   */
  clear(options = {}) {
    if (this.controls.length < 1) return;
    this._forEachChild(control => control._registerOnCollectionChange(() => {}));
    this.controls.splice(0);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this.controls.reduce((updated, child) => {
      return child._syncPendingControls() ? true : updated;
    }, false);
    if (subtreeUpdated) this.updateValueAndValidity({
      onlySelf: true
    });
    return subtreeUpdated;
  }
  /** @internal */
  _throwIfControlMissing(index) {
    if (!this.controls.length) {
      throw new Error(`
        There are no form controls registered with this array yet. If you're using ngModel,
        you may want to check next tick (e.g. use setTimeout).
      `);
    }
    if (!this.at(index)) {
      throw new Error(`Cannot find form control at index ${index}`);
    }
  }
  /** @internal */
  _forEachChild(cb) {
    this.controls.forEach((control, index) => {
      cb(control, index);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this.controls.filter(control => control.enabled || this.disabled).map(control => control.value);
  }
  /** @internal */
  _anyControls(condition) {
    return this.controls.some(control => control.enabled && condition(control));
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild(control => this._registerControl(control));
  }
  /** @internal */
  _checkAllValuesPresent(value) {
    this._forEachChild((control, i) => {
      if (value[i] === undefined) {
        throw new Error(`Must supply a value for form control at index: ${i}.`);
      }
    });
  }
  /** @internal */
  _allControlsDisabled() {
    for (const control of this.controls) {
      if (control.enabled) return false;
    }
    return this.controls.length > 0 || this.disabled;
  }
  _registerControl(control) {
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const formDirectiveProvider = {
  provide: ControlContainer,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => NgForm)
};
const ɵ0 = () => Promise.resolve(null);
const resolvedPromise = /*#__PURE__*/ɵ0();
/**
 * @description
 * Creates a top-level `FormGroup` instance and binds it to a form
 * to track aggregate form value and validation status.
 *
 * As soon as you import the `FormsModule`, this directive becomes active by default on
 * all `<form>` tags.  You don't need to add a special selector.
 *
 * You optionally export the directive into a local template variable using `ngForm` as the key
 * (ex: `#myForm="ngForm"`). This is optional, but useful.  Many properties from the underlying
 * `FormGroup` instance are duplicated on the directive itself, so a reference to it
 * gives you access to the aggregate value and validity status of the form, as well as
 * user interaction properties like `dirty` and `touched`.
 *
 * To register child controls with the form, use `NgModel` with a `name`
 * attribute. You may use `NgModelGroup` to create sub-groups within the form.
 *
 * If necessary, listen to the directive's `ngSubmit` event to be notified when the user has
 * triggered a form submission. The `ngSubmit` event emits the original form
 * submission event.
 *
 * In template driven forms, all `<form>` tags are automatically tagged as `NgForm`.
 * To import the `FormsModule` but skip its usage in some forms,
 * for example, to use native HTML5 validation, add the `ngNoForm` and the `<form>`
 * tags won't create an `NgForm` directive. In reactive forms, using `ngNoForm` is
 * unnecessary because the `<form>` tags are inert. In that case, you would
 * refrain from using the `formGroup` directive.
 *
 * @usageNotes
 *
 * ### Listening for form submission
 *
 * The following example shows how to capture the form values from the "ngSubmit" event.
 *
 * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
 *
 * ### Setting the update options
 *
 * The following example shows you how to change the "updateOn" option from its default using
 * ngFormOptions.
 *
 * ```html
 * <form [ngFormOptions]="{updateOn: 'blur'}">
 *    <input name="one" ngModel>  <!-- this ngModel will update on blur -->
 * </form>
 * ```
 *
 * ### Native DOM validation UI
 *
 * In order to prevent the native DOM form validation UI from interfering with Angular's form
 * validation, Angular automatically adds the `novalidate` attribute on any `<form>` whenever
 * `FormModule` or `ReactiveFormModule` are imported into the application.
 * If you want to explicitly enable native DOM validation UI with Angular forms, you can add the
 * `ngNativeValidate` attribute to the `<form>` element:
 *
 * ```html
 * <form ngNativeValidate>
 *   ...
 * </form>
 * ```
 *
 * @ngModule FormsModule
 * @publicApi
 */
let NgForm = /*#__PURE__*/(() => {
  class NgForm extends ControlContainer {
    constructor(validators, asyncValidators) {
      super();
      /**
       * @description
       * Returns whether the form submission has been triggered.
       */
      this.submitted = false;
      this._directives = [];
      /**
       * @description
       * Event emitter for the "ngSubmit" event
       */
      this.ngSubmit = new core_js_.EventEmitter();
      this.form = new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
    }
    /** @nodoc */
    ngAfterViewInit() {
      this._setUpdateStrategy();
    }
    /**
     * @description
     * The directive instance.
     */
    get formDirective() {
      return this;
    }
    /**
     * @description
     * The internal `FormGroup` instance.
     */
    get control() {
      return this.form;
    }
    /**
     * @description
     * Returns an array representing the path to this group. Because this directive
     * always lives at the top level of a form, it is always an empty array.
     */
    get path() {
      return [];
    }
    /**
     * @description
     * Returns a map of the controls in this group.
     */
    get controls() {
      return this.form.controls;
    }
    /**
     * @description
     * Method that sets up the control directive in this group, re-calculates its value
     * and validity, and adds the instance to the internal list of directives.
     *
     * @param dir The `NgModel` directive instance.
     */
    addControl(dir) {
      resolvedPromise.then(() => {
        const container = this._findContainer(dir.path);
        dir.control = container.registerControl(dir.name, dir.control);
        setUpControl(dir.control, dir);
        dir.control.updateValueAndValidity({
          emitEvent: false
        });
        this._directives.push(dir);
      });
    }
    /**
     * @description
     * Retrieves the `FormControl` instance from the provided `NgModel` directive.
     *
     * @param dir The `NgModel` directive instance.
     */
    getControl(dir) {
      return this.form.get(dir.path);
    }
    /**
     * @description
     * Removes the `NgModel` instance from the internal list of directives
     *
     * @param dir The `NgModel` directive instance.
     */
    removeControl(dir) {
      resolvedPromise.then(() => {
        const container = this._findContainer(dir.path);
        if (container) {
          container.removeControl(dir.name);
        }
        removeListItem(this._directives, dir);
      });
    }
    /**
     * @description
     * Adds a new `NgModelGroup` directive instance to the form.
     *
     * @param dir The `NgModelGroup` directive instance.
     */
    addFormGroup(dir) {
      resolvedPromise.then(() => {
        const container = this._findContainer(dir.path);
        const group = new FormGroup({});
        setUpFormContainer(group, dir);
        container.registerControl(dir.name, group);
        group.updateValueAndValidity({
          emitEvent: false
        });
      });
    }
    /**
     * @description
     * Removes the `NgModelGroup` directive instance from the form.
     *
     * @param dir The `NgModelGroup` directive instance.
     */
    removeFormGroup(dir) {
      resolvedPromise.then(() => {
        const container = this._findContainer(dir.path);
        if (container) {
          container.removeControl(dir.name);
        }
      });
    }
    /**
     * @description
     * Retrieves the `FormGroup` for a provided `NgModelGroup` directive instance
     *
     * @param dir The `NgModelGroup` directive instance.
     */
    getFormGroup(dir) {
      return this.form.get(dir.path);
    }
    /**
     * Sets the new value for the provided `NgControl` directive.
     *
     * @param dir The `NgControl` directive instance.
     * @param value The new value for the directive's control.
     */
    updateModel(dir, value) {
      resolvedPromise.then(() => {
        const ctrl = this.form.get(dir.path);
        ctrl.setValue(value);
      });
    }
    /**
     * @description
     * Sets the value for this `FormGroup`.
     *
     * @param value The new value
     */
    setValue(value) {
      this.control.setValue(value);
    }
    /**
     * @description
     * Method called when the "submit" event is triggered on the form.
     * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
     *
     * @param $event The "submit" event object
     */
    onSubmit($event) {
      this.submitted = true;
      syncPendingControls(this.form, this._directives);
      this.ngSubmit.emit($event);
      return false;
    }
    /**
     * @description
     * Method called when the "reset" event is triggered on the form.
     */
    onReset() {
      this.resetForm();
    }
    /**
     * @description
     * Resets the form to an initial value and resets its submitted status.
     *
     * @param value The new value for the form.
     */
    resetForm(value = undefined) {
      this.form.reset(value);
      this.submitted = false;
    }
    _setUpdateStrategy() {
      if (this.options && this.options.updateOn != null) {
        this.form._updateOn = this.options.updateOn;
      }
    }
    /** @internal */
    _findContainer(path) {
      path.pop();
      return path.length ? this.form.get(path) : this.form;
    }
  }
  NgForm.ɵfac = function NgForm_Factory(t) {
    return new (t || NgForm)(core_js_["ɵɵdirectiveInject"](NG_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10));
  };
  NgForm.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: NgForm,
    selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]],
    hostBindings: function NgForm_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("submit", function NgForm_submit_HostBindingHandler($event) {
          return ctx.onSubmit($event);
        })("reset", function NgForm_reset_HostBindingHandler() {
          return ctx.onReset();
        });
      }
    },
    inputs: {
      options: ["ngFormOptions", "options"]
    },
    outputs: {
      ngSubmit: "ngSubmit"
    },
    exportAs: ["ngForm"],
    features: [core_js_["ɵɵProvidersFeature"]([formDirectiveProvider]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return NgForm;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @description
 * A base class for code shared between the `NgModelGroup` and `FormGroupName` directives.
 *
 * @publicApi
 */
let AbstractFormGroupDirective = /*#__PURE__*/(() => {
  class AbstractFormGroupDirective extends ControlContainer {
    /** @nodoc */
    ngOnInit() {
      this._checkParentType();
      // Register the group with its parent group.
      this.formDirective.addFormGroup(this);
    }
    /** @nodoc */
    ngOnDestroy() {
      if (this.formDirective) {
        // Remove the group from its parent group.
        this.formDirective.removeFormGroup(this);
      }
    }
    /**
     * @description
     * The `FormGroup` bound to this directive.
     */
    get control() {
      return this.formDirective.getFormGroup(this);
    }
    /**
     * @description
     * The path to this group from the top-level directive.
     */
    get path() {
      return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
    }
    /**
     * @description
     * The top-level directive for this group if present, otherwise null.
     */
    get formDirective() {
      return this._parent ? this._parent.formDirective : null;
    }
    /** @internal */
    _checkParentType() {}
  }
  AbstractFormGroupDirective.ɵfac = /*@__PURE__*/function () {
    let ɵAbstractFormGroupDirective_BaseFactory;
    return function AbstractFormGroupDirective_Factory(t) {
      return (ɵAbstractFormGroupDirective_BaseFactory || (ɵAbstractFormGroupDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](AbstractFormGroupDirective)))(t || AbstractFormGroupDirective);
    };
  }();
  AbstractFormGroupDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: AbstractFormGroupDirective,
    features: [core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return AbstractFormGroupDirective;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function modelParentException() {
  return new Error(`
    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using
    formGroup's partner directive "formControlName" instead.  Example:

    ${formControlNameExample}

    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:

    Example:

    ${ngModelWithFormGroupExample}`);
}
function formGroupNameException() {
  return new Error(`
    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.

    Option 1: Use formControlName instead of ngModel (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):

    ${ngModelGroupExample}`);
}
function missingNameException() {
  return new Error(`If ngModel is used within a form tag, either the name attribute must be set or the form
    control must be defined as 'standalone' in ngModelOptions.

    Example 1: <input [(ngModel)]="person.firstName" name="first">
    Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">`);
}
function modelGroupParentException() {
  return new Error(`
    ngModelGroup cannot be used with a parent formGroup directive.

    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):

    ${ngModelGroupExample}`);
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const modelGroupProvider = {
  provide: ControlContainer,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => NgModelGroup)
};
/**
 * @description
 * Creates and binds a `FormGroup` instance to a DOM element.
 *
 * This directive can only be used as a child of `NgForm` (within `<form>` tags).
 *
 * Use this directive to validate a sub-group of your form separately from the
 * rest of your form, or if some values in your domain model make more sense
 * to consume together in a nested object.
 *
 * Provide a name for the sub-group and it will become the key
 * for the sub-group in the form's full value. If you need direct access, export the directive into
 * a local template variable using `ngModelGroup` (ex: `#myGroup="ngModelGroup"`).
 *
 * @usageNotes
 *
 * ### Consuming controls in a grouping
 *
 * The following example shows you how to combine controls together in a sub-group
 * of the form.
 *
 * {@example forms/ts/ngModelGroup/ng_model_group_example.ts region='Component'}
 *
 * @ngModule FormsModule
 * @publicApi
 */
let NgModelGroup = /*#__PURE__*/(() => {
  class NgModelGroup extends AbstractFormGroupDirective {
    constructor(parent, validators, asyncValidators) {
      super();
      this._parent = parent;
      this._setValidators(validators);
      this._setAsyncValidators(asyncValidators);
    }
    /** @internal */
    _checkParentType() {
      if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm) && (typeof ngDevMode === 'undefined' || ngDevMode)) {
        throw modelGroupParentException();
      }
    }
  }
  NgModelGroup.ɵfac = function NgModelGroup_Factory(t) {
    return new (t || NgModelGroup)(core_js_["ɵɵdirectiveInject"](ControlContainer, 5), core_js_["ɵɵdirectiveInject"](NG_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10));
  };
  NgModelGroup.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: NgModelGroup,
    selectors: [["", "ngModelGroup", ""]],
    inputs: {
      name: ["ngModelGroup", "name"]
    },
    exportAs: ["ngModelGroup"],
    features: [core_js_["ɵɵProvidersFeature"]([modelGroupProvider]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return NgModelGroup;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const formControlBinding = {
  provide: NgControl,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => NgModel)
};
const ɵ0$1 = () => Promise.resolve(null);
/**
 * `ngModel` forces an additional change detection run when its inputs change:
 * E.g.:
 * ```
 * <div>{{myModel.valid}}</div>
 * <input [(ngModel)]="myValue" #myModel="ngModel">
 * ```
 * I.e. `ngModel` can export itself on the element and then be used in the template.
 * Normally, this would result in expressions before the `input` that use the exported directive
 * to have an old value as they have been
 * dirty checked before. As this is a very common case for `ngModel`, we added this second change
 * detection run.
 *
 * Notes:
 * - this is just one extra run no matter how many `ngModel`s have been changed.
 * - this is a general problem when using `exportAs` for directives!
 */
const resolvedPromise$1 = /*#__PURE__*/ɵ0$1();
/**
 * @description
 * Creates a `FormControl` instance from a domain model and binds it
 * to a form control element.
 *
 * The `FormControl` instance tracks the value, user interaction, and
 * validation status of the control and keeps the view synced with the model. If used
 * within a parent form, the directive also registers itself with the form as a child
 * control.
 *
 * This directive is used by itself or as part of a larger form. Use the
 * `ngModel` selector to activate it.
 *
 * It accepts a domain model as an optional `Input`. If you have a one-way binding
 * to `ngModel` with `[]` syntax, changing the domain model's value in the component
 * class sets the value in the view. If you have a two-way binding with `[()]` syntax
 * (also known as 'banana-in-a-box syntax'), the value in the UI always syncs back to
 * the domain model in your class.
 *
 * To inspect the properties of the associated `FormControl` (like the validity state),
 * export the directive into a local template variable using `ngModel` as the key (ex:
 * `#myVar="ngModel"`). You can then access the control using the directive's `control` property.
 * However, the most commonly used properties (like `valid` and `dirty`) also exist on the control
 * for direct access. See a full list of properties directly available in
 * `AbstractControlDirective`.
 *
 * @see `RadioControlValueAccessor`
 * @see `SelectControlValueAccessor`
 *
 * @usageNotes
 *
 * ### Using ngModel on a standalone control
 *
 * The following examples show a simple standalone control using `ngModel`:
 *
 * {@example forms/ts/simpleNgModel/simple_ng_model_example.ts region='Component'}
 *
 * When using the `ngModel` within `<form>` tags, you'll also need to supply a `name` attribute
 * so that the control can be registered with the parent form under that name.
 *
 * In the context of a parent form, it's often unnecessary to include one-way or two-way binding,
 * as the parent form syncs the value for you. You access its properties by exporting it into a
 * local template variable using `ngForm` such as (`#f="ngForm"`). Use the variable where
 * needed on form submission.
 *
 * If you do need to populate initial values into your form, using a one-way binding for
 * `ngModel` tends to be sufficient as long as you use the exported form's value rather
 * than the domain model's value on submit.
 *
 * ### Using ngModel within a form
 *
 * The following example shows controls using `ngModel` within a form:
 *
 * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
 *
 * ### Using a standalone ngModel within a group
 *
 * The following example shows you how to use a standalone ngModel control
 * within a form. This controls the display of the form, but doesn't contain form data.
 *
 * ```html
 * <form>
 *   <input name="login" ngModel placeholder="Login">
 *   <input type="checkbox" ngModel [ngModelOptions]="{standalone: true}"> Show more options?
 * </form>
 * <!-- form value: {login: ''} -->
 * ```
 *
 * ### Setting the ngModel `name` attribute through options
 *
 * The following example shows you an alternate way to set the name attribute. Here,
 * an attribute identified as name is used within a custom form control component. To still be able
 * to specify the NgModel's name, you must specify it using the `ngModelOptions` input instead.
 *
 * ```html
 * <form>
 *   <my-custom-form-control name="Nancy" ngModel [ngModelOptions]="{name: 'user'}">
 *   </my-custom-form-control>
 * </form>
 * <!-- form value: {user: ''} -->
 * ```
 *
 * @ngModule FormsModule
 * @publicApi
 */
let NgModel = /*#__PURE__*/(() => {
  class NgModel extends NgControl {
    constructor(parent, validators, asyncValidators, valueAccessors) {
      super();
      this.control = new FormControl();
      /** @internal */
      this._registered = false;
      /**
       * @description
       * Event emitter for producing the `ngModelChange` event after
       * the view model updates.
       */
      this.update = new core_js_.EventEmitter();
      this._parent = parent;
      this._setValidators(validators);
      this._setAsyncValidators(asyncValidators);
      this.valueAccessor = selectValueAccessor(this, valueAccessors);
    }
    /** @nodoc */
    ngOnChanges(changes) {
      this._checkForErrors();
      if (!this._registered) this._setUpControl();
      if ('isDisabled' in changes) {
        this._updateDisabled(changes);
      }
      if (isPropertyUpdated(changes, this.viewModel)) {
        this._updateValue(this.model);
        this.viewModel = this.model;
      }
    }
    /** @nodoc */
    ngOnDestroy() {
      this.formDirective && this.formDirective.removeControl(this);
    }
    /**
     * @description
     * Returns an array that represents the path from the top-level form to this control.
     * Each index is the string name of the control on that level.
     */
    get path() {
      return this._parent ? controlPath(this.name, this._parent) : [this.name];
    }
    /**
     * @description
     * The top-level directive for this control if present, otherwise null.
     */
    get formDirective() {
      return this._parent ? this._parent.formDirective : null;
    }
    /**
     * @description
     * Sets the new value for the view model and emits an `ngModelChange` event.
     *
     * @param newValue The new value emitted by `ngModelChange`.
     */
    viewToModelUpdate(newValue) {
      this.viewModel = newValue;
      this.update.emit(newValue);
    }
    _setUpControl() {
      this._setUpdateStrategy();
      this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);
      this._registered = true;
    }
    _setUpdateStrategy() {
      if (this.options && this.options.updateOn != null) {
        this.control._updateOn = this.options.updateOn;
      }
    }
    _isStandalone() {
      return !this._parent || !!(this.options && this.options.standalone);
    }
    _setUpStandalone() {
      setUpControl(this.control, this);
      this.control.updateValueAndValidity({
        emitEvent: false
      });
    }
    _checkForErrors() {
      if (!this._isStandalone()) {
        this._checkParentType();
      }
      this._checkName();
    }
    _checkParentType() {
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
        if (!(this._parent instanceof NgModelGroup) && this._parent instanceof AbstractFormGroupDirective) {
          throw formGroupNameException();
        } else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
          throw modelParentException();
        }
      }
    }
    _checkName() {
      if (this.options && this.options.name) this.name = this.options.name;
      if (!this._isStandalone() && !this.name && (typeof ngDevMode === 'undefined' || ngDevMode)) {
        throw missingNameException();
      }
    }
    _updateValue(value) {
      resolvedPromise$1.then(() => {
        this.control.setValue(value, {
          emitViewToModelChange: false
        });
      });
    }
    _updateDisabled(changes) {
      const disabledValue = changes['isDisabled'].currentValue;
      const isDisabled = disabledValue === '' || disabledValue && disabledValue !== 'false';
      resolvedPromise$1.then(() => {
        if (isDisabled && !this.control.disabled) {
          this.control.disable();
        } else if (!isDisabled && this.control.disabled) {
          this.control.enable();
        }
      });
    }
  }
  NgModel.ɵfac = function NgModel_Factory(t) {
    return new (t || NgModel)(core_js_["ɵɵdirectiveInject"](ControlContainer, 9), core_js_["ɵɵdirectiveInject"](NG_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_VALUE_ACCESSOR, 10));
  };
  NgModel.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: NgModel,
    selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]],
    inputs: {
      name: "name",
      isDisabled: ["disabled", "isDisabled"],
      model: ["ngModel", "model"],
      options: ["ngModelOptions", "options"]
    },
    outputs: {
      update: "ngModelChange"
    },
    exportAs: ["ngModel"],
    features: [core_js_["ɵɵProvidersFeature"]([formControlBinding]), core_js_["ɵɵInheritDefinitionFeature"], core_js_["ɵɵNgOnChangesFeature"]]
  });
  return NgModel;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @description
 *
 * Adds `novalidate` attribute to all forms by default.
 *
 * `novalidate` is used to disable browser's native form validation.
 *
 * If you want to use native validation with Angular forms, just add `ngNativeValidate` attribute:
 *
 * ```
 * <form ngNativeValidate></form>
 * ```
 *
 * @publicApi
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 */
let ɵNgNoValidate = /*#__PURE__*/(() => {
  class ɵNgNoValidate {}
  ɵNgNoValidate.ɵfac = function ɵNgNoValidate_Factory(t) {
    return new (t || ɵNgNoValidate)();
  };
  ɵNgNoValidate.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: ɵNgNoValidate,
    selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]],
    hostAttrs: ["novalidate", ""]
  });
  return ɵNgNoValidate;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const NUMBER_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => NumberValueAccessor),
  multi: true
};
/**
 * @description
 * The `ControlValueAccessor` for writing a number value and listening to number input changes.
 * The value accessor is used by the `FormControlDirective`, `FormControlName`, and `NgModel`
 * directives.
 *
 * @usageNotes
 *
 * ### Using a number input with a reactive form.
 *
 * The following example shows how to use a number input with a reactive form.
 *
 * ```ts
 * const totalCountControl = new FormControl();
 * ```
 *
 * ```
 * <input type="number" [formControl]="totalCountControl">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let NumberValueAccessor = /*#__PURE__*/(() => {
  class NumberValueAccessor extends BuiltInControlValueAccessor {
    /**
     * Sets the "value" property on the input element.
     * @nodoc
     */
    writeValue(value) {
      // The value needs to be normalized for IE9, otherwise it is set to 'null' when null
      const normalizedValue = value == null ? '' : value;
      this.setProperty('value', normalizedValue);
    }
    /**
     * Registers a function called when the control value changes.
     * @nodoc
     */
    registerOnChange(fn) {
      this.onChange = value => {
        fn(value == '' ? null : parseFloat(value));
      };
    }
  }
  NumberValueAccessor.ɵfac = /*@__PURE__*/function () {
    let ɵNumberValueAccessor_BaseFactory;
    return function NumberValueAccessor_Factory(t) {
      return (ɵNumberValueAccessor_BaseFactory || (ɵNumberValueAccessor_BaseFactory = core_js_["ɵɵgetInheritedFactory"](NumberValueAccessor)))(t || NumberValueAccessor);
    };
  }();
  NumberValueAccessor.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: NumberValueAccessor,
    selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]],
    hostBindings: function NumberValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("input", function NumberValueAccessor_input_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function NumberValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    features: [core_js_["ɵɵProvidersFeature"]([NUMBER_VALUE_ACCESSOR]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return NumberValueAccessor;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const RADIO_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => RadioControlValueAccessor),
  multi: true
};
function throwNameError() {
  throw new Error(`
      If you define both a name and a formControlName attribute on your radio button, their values
      must match. Ex: <input type="radio" formControlName="food" name="food">
    `);
}
/**
 * Internal-only NgModule that works as a host for the `RadioControlRegistry` tree-shakable
 * provider. Note: the `InternalFormsSharedModule` can not be used here directly, since it's
 * declared *after* the `RadioControlRegistry` class and the `providedIn` doesn't support
 * `forwardRef` logic.
 */
let RadioControlRegistryModule = /*#__PURE__*/(() => {
  class RadioControlRegistryModule {}
  RadioControlRegistryModule.ɵfac = function RadioControlRegistryModule_Factory(t) {
    return new (t || RadioControlRegistryModule)();
  };
  RadioControlRegistryModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: RadioControlRegistryModule
  });
  RadioControlRegistryModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return RadioControlRegistryModule;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Class used by Angular to track radio buttons. For internal use only.
 */
let RadioControlRegistry = /*#__PURE__*/(() => {
  class RadioControlRegistry {
    constructor() {
      this._accessors = [];
    }
    /**
     * @description
     * Adds a control to the internal registry. For internal use only.
     */
    add(control, accessor) {
      this._accessors.push([control, accessor]);
    }
    /**
     * @description
     * Removes a control from the internal registry. For internal use only.
     */
    remove(accessor) {
      for (let i = this._accessors.length - 1; i >= 0; --i) {
        if (this._accessors[i][1] === accessor) {
          this._accessors.splice(i, 1);
          return;
        }
      }
    }
    /**
     * @description
     * Selects a radio button. For internal use only.
     */
    select(accessor) {
      this._accessors.forEach(c => {
        if (this._isSameGroup(c, accessor) && c[1] !== accessor) {
          c[1].fireUncheck(accessor.value);
        }
      });
    }
    _isSameGroup(controlPair, accessor) {
      if (!controlPair[0].control) return false;
      return controlPair[0]._parent === accessor._control._parent && controlPair[1].name === accessor.name;
    }
  }
  RadioControlRegistry.ɵfac = function RadioControlRegistry_Factory(t) {
    return new (t || RadioControlRegistry)();
  };
  RadioControlRegistry.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function RadioControlRegistry_Factory() {
      return new RadioControlRegistry();
    },
    token: RadioControlRegistry,
    providedIn: RadioControlRegistryModule
  });
  return RadioControlRegistry;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * The `ControlValueAccessor` for writing radio control values and listening to radio control
 * changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and
 * `NgModel` directives.
 *
 * @usageNotes
 *
 * ### Using radio buttons with reactive form directives
 *
 * The follow example shows how to use radio buttons in a reactive form. When using radio buttons in
 * a reactive form, radio buttons in the same group should have the same `formControlName`.
 * Providing a `name` attribute is optional.
 *
 * {@example forms/ts/reactiveRadioButtons/reactive_radio_button_example.ts region='Reactive'}
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let RadioControlValueAccessor = /*#__PURE__*/(() => {
  class RadioControlValueAccessor extends BuiltInControlValueAccessor {
    constructor(renderer, elementRef, _registry, _injector) {
      super(renderer, elementRef);
      this._registry = _registry;
      this._injector = _injector;
      /**
       * The registered callback function called when a change event occurs on the input element.
       * Note: we declare `onChange` here (also used as host listener) as a function with no arguments
       * to override the `onChange` function (which expects 1 argument) in the parent
       * `BaseControlValueAccessor` class.
       * @nodoc
       */
      this.onChange = () => {};
    }
    /** @nodoc */
    ngOnInit() {
      this._control = this._injector.get(NgControl);
      this._checkName();
      this._registry.add(this._control, this);
    }
    /** @nodoc */
    ngOnDestroy() {
      this._registry.remove(this);
    }
    /**
     * Sets the "checked" property value on the radio input element.
     * @nodoc
     */
    writeValue(value) {
      this._state = value === this.value;
      this.setProperty('checked', this._state);
    }
    /**
     * Registers a function called when the control value changes.
     * @nodoc
     */
    registerOnChange(fn) {
      this._fn = fn;
      this.onChange = () => {
        fn(this.value);
        this._registry.select(this);
      };
    }
    /**
     * Sets the "value" on the radio input element and unchecks it.
     *
     * @param value
     */
    fireUncheck(value) {
      this.writeValue(value);
    }
    _checkName() {
      if (this.name && this.formControlName && this.name !== this.formControlName && (typeof ngDevMode === 'undefined' || ngDevMode)) {
        throwNameError();
      }
      if (!this.name && this.formControlName) this.name = this.formControlName;
    }
  }
  RadioControlValueAccessor.ɵfac = function RadioControlValueAccessor_Factory(t) {
    return new (t || RadioControlValueAccessor)(core_js_["ɵɵdirectiveInject"](core_js_.Renderer2), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](RadioControlRegistry), core_js_["ɵɵdirectiveInject"](core_js_.Injector));
  };
  RadioControlValueAccessor.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: RadioControlValueAccessor,
    selectors: [["input", "type", "radio", "formControlName", ""], ["input", "type", "radio", "formControl", ""], ["input", "type", "radio", "ngModel", ""]],
    hostBindings: function RadioControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("change", function RadioControlValueAccessor_change_HostBindingHandler() {
          return ctx.onChange();
        })("blur", function RadioControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      name: "name",
      formControlName: "formControlName",
      value: "value"
    },
    features: [core_js_["ɵɵProvidersFeature"]([RADIO_VALUE_ACCESSOR]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return RadioControlValueAccessor;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const RANGE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => RangeValueAccessor),
  multi: true
};
/**
 * @description
 * The `ControlValueAccessor` for writing a range value and listening to range input changes.
 * The value accessor is used by the `FormControlDirective`, `FormControlName`, and  `NgModel`
 * directives.
 *
 * @usageNotes
 *
 * ### Using a range input with a reactive form
 *
 * The following example shows how to use a range input with a reactive form.
 *
 * ```ts
 * const ageControl = new FormControl();
 * ```
 *
 * ```
 * <input type="range" [formControl]="ageControl">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let RangeValueAccessor = /*#__PURE__*/(() => {
  class RangeValueAccessor extends BuiltInControlValueAccessor {
    /**
     * Sets the "value" property on the input element.
     * @nodoc
     */
    writeValue(value) {
      this.setProperty('value', parseFloat(value));
    }
    /**
     * Registers a function called when the control value changes.
     * @nodoc
     */
    registerOnChange(fn) {
      this.onChange = value => {
        fn(value == '' ? null : parseFloat(value));
      };
    }
  }
  RangeValueAccessor.ɵfac = /*@__PURE__*/function () {
    let ɵRangeValueAccessor_BaseFactory;
    return function RangeValueAccessor_Factory(t) {
      return (ɵRangeValueAccessor_BaseFactory || (ɵRangeValueAccessor_BaseFactory = core_js_["ɵɵgetInheritedFactory"](RangeValueAccessor)))(t || RangeValueAccessor);
    };
  }();
  RangeValueAccessor.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: RangeValueAccessor,
    selectors: [["input", "type", "range", "formControlName", ""], ["input", "type", "range", "formControl", ""], ["input", "type", "range", "ngModel", ""]],
    hostBindings: function RangeValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("change", function RangeValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("input", function RangeValueAccessor_input_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function RangeValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    features: [core_js_["ɵɵProvidersFeature"]([RANGE_VALUE_ACCESSOR]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return RangeValueAccessor;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Token to provide to turn off the ngModel warning on formControl and formControlName.
 */
const NG_MODEL_WITH_FORM_CONTROL_WARNING = /*#__PURE__*/new core_js_.InjectionToken('NgModelWithFormControlWarning');
const formControlBinding$1 = {
  provide: NgControl,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => FormControlDirective)
};
/**
 * @description
 * Synchronizes a standalone `FormControl` instance to a form control element.
 *
 * Note that support for using the `ngModel` input property and `ngModelChange` event with reactive
 * form directives was deprecated in Angular v6 and is scheduled for removal in
 * a future version of Angular.
 * For details, see [Deprecated features](guide/deprecations#ngmodel-with-reactive-forms).
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 * @see `FormControl`
 * @see `AbstractControl`
 *
 * @usageNotes
 *
 * The following example shows how to register a standalone control and set its value.
 *
 * {@example forms/ts/simpleFormControl/simple_form_control_example.ts region='Component'}
 *
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
let FormControlDirective = /*#__PURE__*/(() => {
  class FormControlDirective extends NgControl {
    constructor(validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
      super();
      this._ngModelWarningConfig = _ngModelWarningConfig;
      /** @deprecated as of v6 */
      this.update = new core_js_.EventEmitter();
      /**
       * @description
       * Instance property used to track whether an ngModel warning has been sent out for this
       * particular `FormControlDirective` instance. Used to support warning config of "always".
       *
       * @internal
       */
      this._ngModelWarningSent = false;
      this._setValidators(validators);
      this._setAsyncValidators(asyncValidators);
      this.valueAccessor = selectValueAccessor(this, valueAccessors);
    }
    /**
     * @description
     * Triggers a warning in dev mode that this input should not be used with reactive forms.
     */
    set isDisabled(isDisabled) {
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
        console.warn(disabledAttrWarning);
      }
    }
    /** @nodoc */
    ngOnChanges(changes) {
      if (this._isControlChanged(changes)) {
        const previousForm = changes['form'].previousValue;
        if (previousForm) {
          cleanUpControl(previousForm, this, /* validateControlPresenceOnChange */false);
        }
        setUpControl(this.form, this);
        if (this.control.disabled && this.valueAccessor.setDisabledState) {
          this.valueAccessor.setDisabledState(true);
        }
        this.form.updateValueAndValidity({
          emitEvent: false
        });
      }
      if (isPropertyUpdated(changes, this.viewModel)) {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
          _ngModelWarning('formControl', FormControlDirective, this, this._ngModelWarningConfig);
        }
        this.form.setValue(this.model);
        this.viewModel = this.model;
      }
    }
    /** @nodoc */
    ngOnDestroy() {
      if (this.form) {
        cleanUpControl(this.form, this, /* validateControlPresenceOnChange */false);
      }
    }
    /**
     * @description
     * Returns an array that represents the path from the top-level form to this control.
     * Each index is the string name of the control on that level.
     */
    get path() {
      return [];
    }
    /**
     * @description
     * The `FormControl` bound to this directive.
     */
    get control() {
      return this.form;
    }
    /**
     * @description
     * Sets the new value for the view model and emits an `ngModelChange` event.
     *
     * @param newValue The new value for the view model.
     */
    viewToModelUpdate(newValue) {
      this.viewModel = newValue;
      this.update.emit(newValue);
    }
    _isControlChanged(changes) {
      return changes.hasOwnProperty('form');
    }
  }
  FormControlDirective.ɵfac = function FormControlDirective_Factory(t) {
    return new (t || FormControlDirective)(core_js_["ɵɵdirectiveInject"](NG_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_VALUE_ACCESSOR, 10), core_js_["ɵɵdirectiveInject"](NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));
  };
  FormControlDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: FormControlDirective,
    selectors: [["", "formControl", ""]],
    inputs: {
      isDisabled: ["disabled", "isDisabled"],
      form: ["formControl", "form"],
      model: ["ngModel", "model"]
    },
    outputs: {
      update: "ngModelChange"
    },
    exportAs: ["ngForm"],
    features: [core_js_["ɵɵProvidersFeature"]([formControlBinding$1]), core_js_["ɵɵInheritDefinitionFeature"], core_js_["ɵɵNgOnChangesFeature"]]
  });
  /**
   * @description
   * Static property used to track whether any ngModel warnings have been sent across
   * all instances of FormControlDirective. Used to support warning config of "once".
   *
   * @internal
   */
  FormControlDirective._ngModelWarningSentOnce = false;
  return FormControlDirective;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const formDirectiveProvider$1 = {
  provide: ControlContainer,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => FormGroupDirective)
};
/**
 * @description
 *
 * Binds an existing `FormGroup` to a DOM element.
 *
 * This directive accepts an existing `FormGroup` instance. It will then use this
 * `FormGroup` instance to match any child `FormControl`, `FormGroup`,
 * and `FormArray` instances to child `FormControlName`, `FormGroupName`,
 * and `FormArrayName` directives.
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 * @see `AbstractControl`
 *
 * @usageNotes
 * ### Register Form Group
 *
 * The following example registers a `FormGroup` with first name and last name controls,
 * and listens for the *ngSubmit* event when the button is clicked.
 *
 * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
 *
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
let FormGroupDirective = /*#__PURE__*/(() => {
  class FormGroupDirective extends ControlContainer {
    constructor(validators, asyncValidators) {
      super();
      this.validators = validators;
      this.asyncValidators = asyncValidators;
      /**
       * @description
       * Reports whether the form submission has been triggered.
       */
      this.submitted = false;
      /**
       * Callback that should be invoked when controls in FormGroup or FormArray collection change
       * (added or removed). This callback triggers corresponding DOM updates.
       */
      this._onCollectionChange = () => this._updateDomValue();
      /**
       * @description
       * Tracks the list of added `FormControlName` instances
       */
      this.directives = [];
      /**
       * @description
       * Tracks the `FormGroup` bound to this directive.
       */
      this.form = null;
      /**
       * @description
       * Emits an event when the form submission has been triggered.
       */
      this.ngSubmit = new core_js_.EventEmitter();
      this._setValidators(validators);
      this._setAsyncValidators(asyncValidators);
    }
    /** @nodoc */
    ngOnChanges(changes) {
      this._checkFormPresent();
      if (changes.hasOwnProperty('form')) {
        this._updateValidators();
        this._updateDomValue();
        this._updateRegistrations();
        this._oldForm = this.form;
      }
    }
    /** @nodoc */
    ngOnDestroy() {
      if (this.form) {
        cleanUpValidators(this.form, this);
        // Currently the `onCollectionChange` callback is rewritten each time the
        // `_registerOnCollectionChange` function is invoked. The implication is that cleanup should
        // happen *only* when the `onCollectionChange` callback was set by this directive instance.
        // Otherwise it might cause overriding a callback of some other directive instances. We should
        // consider updating this logic later to make it similar to how `onChange` callbacks are
        // handled, see https://github.com/angular/angular/issues/39732 for additional info.
        if (this.form._onCollectionChange === this._onCollectionChange) {
          this.form._registerOnCollectionChange(() => {});
        }
      }
    }
    /**
     * @description
     * Returns this directive's instance.
     */
    get formDirective() {
      return this;
    }
    /**
     * @description
     * Returns the `FormGroup` bound to this directive.
     */
    get control() {
      return this.form;
    }
    /**
     * @description
     * Returns an array representing the path to this group. Because this directive
     * always lives at the top level of a form, it always an empty array.
     */
    get path() {
      return [];
    }
    /**
     * @description
     * Method that sets up the control directive in this group, re-calculates its value
     * and validity, and adds the instance to the internal list of directives.
     *
     * @param dir The `FormControlName` directive instance.
     */
    addControl(dir) {
      const ctrl = this.form.get(dir.path);
      setUpControl(ctrl, dir);
      ctrl.updateValueAndValidity({
        emitEvent: false
      });
      this.directives.push(dir);
      return ctrl;
    }
    /**
     * @description
     * Retrieves the `FormControl` instance from the provided `FormControlName` directive
     *
     * @param dir The `FormControlName` directive instance.
     */
    getControl(dir) {
      return this.form.get(dir.path);
    }
    /**
     * @description
     * Removes the `FormControlName` instance from the internal list of directives
     *
     * @param dir The `FormControlName` directive instance.
     */
    removeControl(dir) {
      cleanUpControl(dir.control || null, dir, /* validateControlPresenceOnChange */false);
      removeListItem(this.directives, dir);
    }
    /**
     * Adds a new `FormGroupName` directive instance to the form.
     *
     * @param dir The `FormGroupName` directive instance.
     */
    addFormGroup(dir) {
      this._setUpFormContainer(dir);
    }
    /**
     * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the
     * view.
     *
     * @param dir The `FormGroupName` directive instance.
     */
    removeFormGroup(dir) {
      this._cleanUpFormContainer(dir);
    }
    /**
     * @description
     * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance
     *
     * @param dir The `FormGroupName` directive instance.
     */
    getFormGroup(dir) {
      return this.form.get(dir.path);
    }
    /**
     * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.
     *
     * @param dir The `FormArrayName` directive instance.
     */
    addFormArray(dir) {
      this._setUpFormContainer(dir);
    }
    /**
     * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the
     * view.
     *
     * @param dir The `FormArrayName` directive instance.
     */
    removeFormArray(dir) {
      this._cleanUpFormContainer(dir);
    }
    /**
     * @description
     * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.
     *
     * @param dir The `FormArrayName` directive instance.
     */
    getFormArray(dir) {
      return this.form.get(dir.path);
    }
    /**
     * Sets the new value for the provided `FormControlName` directive.
     *
     * @param dir The `FormControlName` directive instance.
     * @param value The new value for the directive's control.
     */
    updateModel(dir, value) {
      const ctrl = this.form.get(dir.path);
      ctrl.setValue(value);
    }
    /**
     * @description
     * Method called with the "submit" event is triggered on the form.
     * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
     *
     * @param $event The "submit" event object
     */
    onSubmit($event) {
      this.submitted = true;
      syncPendingControls(this.form, this.directives);
      this.ngSubmit.emit($event);
      return false;
    }
    /**
     * @description
     * Method called when the "reset" event is triggered on the form.
     */
    onReset() {
      this.resetForm();
    }
    /**
     * @description
     * Resets the form to an initial value and resets its submitted status.
     *
     * @param value The new value for the form.
     */
    resetForm(value = undefined) {
      this.form.reset(value);
      this.submitted = false;
    }
    /** @internal */
    _updateDomValue() {
      this.directives.forEach(dir => {
        const oldCtrl = dir.control;
        const newCtrl = this.form.get(dir.path);
        if (oldCtrl !== newCtrl) {
          // Note: the value of the `dir.control` may not be defined, for example when it's a first
          // `FormControl` that is added to a `FormGroup` instance (via `addControl` call).
          cleanUpControl(oldCtrl || null, dir);
          // Check whether new control at the same location inside the corresponding `FormGroup` is an
          // instance of `FormControl` and perform control setup only if that's the case.
          // Note: we don't need to clear the list of directives (`this.directives`) here, it would be
          // taken care of in the `removeControl` method invoked when corresponding `formControlName`
          // directive instance is being removed (invoked from `FormControlName.ngOnDestroy`).
          if (newCtrl instanceof FormControl) {
            setUpControl(newCtrl, dir);
            dir.control = newCtrl;
          }
        }
      });
      this.form._updateTreeValidity({
        emitEvent: false
      });
    }
    _setUpFormContainer(dir) {
      const ctrl = this.form.get(dir.path);
      setUpFormContainer(ctrl, dir);
      // NOTE: this operation looks unnecessary in case no new validators were added in
      // `setUpFormContainer` call. Consider updating this code to match the logic in
      // `_cleanUpFormContainer` function.
      ctrl.updateValueAndValidity({
        emitEvent: false
      });
    }
    _cleanUpFormContainer(dir) {
      if (this.form) {
        const ctrl = this.form.get(dir.path);
        if (ctrl) {
          const isControlUpdated = cleanUpFormContainer(ctrl, dir);
          if (isControlUpdated) {
            // Run validity check only in case a control was updated (i.e. view validators were
            // removed) as removing view validators might cause validity to change.
            ctrl.updateValueAndValidity({
              emitEvent: false
            });
          }
        }
      }
    }
    _updateRegistrations() {
      this.form._registerOnCollectionChange(this._onCollectionChange);
      if (this._oldForm) {
        this._oldForm._registerOnCollectionChange(() => {});
      }
    }
    _updateValidators() {
      setUpValidators(this.form, this);
      if (this._oldForm) {
        cleanUpValidators(this._oldForm, this);
      }
    }
    _checkFormPresent() {
      if (!this.form && (typeof ngDevMode === 'undefined' || ngDevMode)) {
        throw missingFormException();
      }
    }
  }
  FormGroupDirective.ɵfac = function FormGroupDirective_Factory(t) {
    return new (t || FormGroupDirective)(core_js_["ɵɵdirectiveInject"](NG_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10));
  };
  FormGroupDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: FormGroupDirective,
    selectors: [["", "formGroup", ""]],
    hostBindings: function FormGroupDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("submit", function FormGroupDirective_submit_HostBindingHandler($event) {
          return ctx.onSubmit($event);
        })("reset", function FormGroupDirective_reset_HostBindingHandler() {
          return ctx.onReset();
        });
      }
    },
    inputs: {
      form: ["formGroup", "form"]
    },
    outputs: {
      ngSubmit: "ngSubmit"
    },
    exportAs: ["ngForm"],
    features: [core_js_["ɵɵProvidersFeature"]([formDirectiveProvider$1]), core_js_["ɵɵInheritDefinitionFeature"], core_js_["ɵɵNgOnChangesFeature"]]
  });
  return FormGroupDirective;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const formGroupNameProvider = {
  provide: ControlContainer,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => FormGroupName)
};
/**
 * @description
 *
 * Syncs a nested `FormGroup` to a DOM element.
 *
 * This directive can only be used with a parent `FormGroupDirective`.
 *
 * It accepts the string name of the nested `FormGroup` to link, and
 * looks for a `FormGroup` registered with that name in the parent
 * `FormGroup` instance you passed into `FormGroupDirective`.
 *
 * Use nested form groups to validate a sub-group of a
 * form separately from the rest or to group the values of certain
 * controls into their own nested object.
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 *
 * @usageNotes
 *
 * ### Access the group by name
 *
 * The following example uses the {@link AbstractControl#get get} method to access the
 * associated `FormGroup`
 *
 * ```ts
 *   this.form.get('name');
 * ```
 *
 * ### Access individual controls in the group
 *
 * The following example uses the {@link AbstractControl#get get} method to access
 * individual controls within the group using dot syntax.
 *
 * ```ts
 *   this.form.get('name.first');
 * ```
 *
 * ### Register a nested `FormGroup`.
 *
 * The following example registers a nested *name* `FormGroup` within an existing `FormGroup`,
 * and provides methods to retrieve the nested `FormGroup` and individual controls.
 *
 * {@example forms/ts/nestedFormGroup/nested_form_group_example.ts region='Component'}
 *
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
let FormGroupName = /*#__PURE__*/(() => {
  class FormGroupName extends AbstractFormGroupDirective {
    constructor(parent, validators, asyncValidators) {
      super();
      this._parent = parent;
      this._setValidators(validators);
      this._setAsyncValidators(asyncValidators);
    }
    /** @internal */
    _checkParentType() {
      if (_hasInvalidParent(this._parent) && (typeof ngDevMode === 'undefined' || ngDevMode)) {
        throw groupParentException();
      }
    }
  }
  FormGroupName.ɵfac = function FormGroupName_Factory(t) {
    return new (t || FormGroupName)(core_js_["ɵɵdirectiveInject"](ControlContainer, 13), core_js_["ɵɵdirectiveInject"](NG_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10));
  };
  FormGroupName.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: FormGroupName,
    selectors: [["", "formGroupName", ""]],
    inputs: {
      name: ["formGroupName", "name"]
    },
    features: [core_js_["ɵɵProvidersFeature"]([formGroupNameProvider]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return FormGroupName;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
const formArrayNameProvider = {
  provide: ControlContainer,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => FormArrayName)
};
/**
 * @description
 *
 * Syncs a nested `FormArray` to a DOM element.
 *
 * This directive is designed to be used with a parent `FormGroupDirective` (selector:
 * `[formGroup]`).
 *
 * It accepts the string name of the nested `FormArray` you want to link, and
 * will look for a `FormArray` registered with that name in the parent
 * `FormGroup` instance you passed into `FormGroupDirective`.
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 * @see `AbstractControl`
 *
 * @usageNotes
 *
 * ### Example
 *
 * {@example forms/ts/nestedFormArray/nested_form_array_example.ts region='Component'}
 *
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
let FormArrayName = /*#__PURE__*/(() => {
  class FormArrayName extends ControlContainer {
    constructor(parent, validators, asyncValidators) {
      super();
      this._parent = parent;
      this._setValidators(validators);
      this._setAsyncValidators(asyncValidators);
    }
    /**
     * A lifecycle method called when the directive's inputs are initialized. For internal use only.
     * @throws If the directive does not have a valid parent.
     * @nodoc
     */
    ngOnInit() {
      this._checkParentType();
      this.formDirective.addFormArray(this);
    }
    /**
     * A lifecycle method called before the directive's instance is destroyed. For internal use only.
     * @nodoc
     */
    ngOnDestroy() {
      if (this.formDirective) {
        this.formDirective.removeFormArray(this);
      }
    }
    /**
     * @description
     * The `FormArray` bound to this directive.
     */
    get control() {
      return this.formDirective.getFormArray(this);
    }
    /**
     * @description
     * The top-level directive for this group if present, otherwise null.
     */
    get formDirective() {
      return this._parent ? this._parent.formDirective : null;
    }
    /**
     * @description
     * Returns an array that represents the path from the top-level form to this control.
     * Each index is the string name of the control on that level.
     */
    get path() {
      return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
    }
    _checkParentType() {
      if (_hasInvalidParent(this._parent) && (typeof ngDevMode === 'undefined' || ngDevMode)) {
        throw arrayParentException();
      }
    }
  }
  FormArrayName.ɵfac = function FormArrayName_Factory(t) {
    return new (t || FormArrayName)(core_js_["ɵɵdirectiveInject"](ControlContainer, 13), core_js_["ɵɵdirectiveInject"](NG_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10));
  };
  FormArrayName.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: FormArrayName,
    selectors: [["", "formArrayName", ""]],
    inputs: {
      name: ["formArrayName", "name"]
    },
    features: [core_js_["ɵɵProvidersFeature"]([formArrayNameProvider]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return FormArrayName;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
function _hasInvalidParent(parent) {
  return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName);
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const controlNameBinding = {
  provide: NgControl,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => FormControlName)
};
/**
 * @description
 * Syncs a `FormControl` in an existing `FormGroup` to a form control
 * element by name.
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 * @see `FormControl`
 * @see `AbstractControl`
 *
 * @usageNotes
 *
 * ### Register `FormControl` within a group
 *
 * The following example shows how to register multiple form controls within a form group
 * and set their value.
 *
 * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
 *
 * To see `formControlName` examples with different form control types, see:
 *
 * * Radio buttons: `RadioControlValueAccessor`
 * * Selects: `SelectControlValueAccessor`
 *
 * ### Use with ngModel is deprecated
 *
 * Support for using the `ngModel` input property and `ngModelChange` event with reactive
 * form directives has been deprecated in Angular v6 and is scheduled for removal in
 * a future version of Angular.
 *
 * For details, see [Deprecated features](guide/deprecations#ngmodel-with-reactive-forms).
 *
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
let FormControlName = /*#__PURE__*/(() => {
  class FormControlName extends NgControl {
    constructor(parent, validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
      super();
      this._ngModelWarningConfig = _ngModelWarningConfig;
      this._added = false;
      /** @deprecated as of v6 */
      this.update = new core_js_.EventEmitter();
      /**
       * @description
       * Instance property used to track whether an ngModel warning has been sent out for this
       * particular FormControlName instance. Used to support warning config of "always".
       *
       * @internal
       */
      this._ngModelWarningSent = false;
      this._parent = parent;
      this._setValidators(validators);
      this._setAsyncValidators(asyncValidators);
      this.valueAccessor = selectValueAccessor(this, valueAccessors);
    }
    /**
     * @description
     * Triggers a warning in dev mode that this input should not be used with reactive forms.
     */
    set isDisabled(isDisabled) {
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
        console.warn(disabledAttrWarning);
      }
    }
    /** @nodoc */
    ngOnChanges(changes) {
      if (!this._added) this._setUpControl();
      if (isPropertyUpdated(changes, this.viewModel)) {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
          _ngModelWarning('formControlName', FormControlName, this, this._ngModelWarningConfig);
        }
        this.viewModel = this.model;
        this.formDirective.updateModel(this, this.model);
      }
    }
    /** @nodoc */
    ngOnDestroy() {
      if (this.formDirective) {
        this.formDirective.removeControl(this);
      }
    }
    /**
     * @description
     * Sets the new value for the view model and emits an `ngModelChange` event.
     *
     * @param newValue The new value for the view model.
     */
    viewToModelUpdate(newValue) {
      this.viewModel = newValue;
      this.update.emit(newValue);
    }
    /**
     * @description
     * Returns an array that represents the path from the top-level form to this control.
     * Each index is the string name of the control on that level.
     */
    get path() {
      return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
    }
    /**
     * @description
     * The top-level directive for this group if present, otherwise null.
     */
    get formDirective() {
      return this._parent ? this._parent.formDirective : null;
    }
    _checkParentType() {
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
        if (!(this._parent instanceof FormGroupName) && this._parent instanceof AbstractFormGroupDirective) {
          throw ngModelGroupException();
        } else if (!(this._parent instanceof FormGroupName) && !(this._parent instanceof FormGroupDirective) && !(this._parent instanceof FormArrayName)) {
          throw controlParentException();
        }
      }
    }
    _setUpControl() {
      this._checkParentType();
      this.control = this.formDirective.addControl(this);
      if (this.control.disabled && this.valueAccessor.setDisabledState) {
        this.valueAccessor.setDisabledState(true);
      }
      this._added = true;
    }
  }
  FormControlName.ɵfac = function FormControlName_Factory(t) {
    return new (t || FormControlName)(core_js_["ɵɵdirectiveInject"](ControlContainer, 13), core_js_["ɵɵdirectiveInject"](NG_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_ASYNC_VALIDATORS, 10), core_js_["ɵɵdirectiveInject"](NG_VALUE_ACCESSOR, 10), core_js_["ɵɵdirectiveInject"](NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));
  };
  FormControlName.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: FormControlName,
    selectors: [["", "formControlName", ""]],
    inputs: {
      isDisabled: ["disabled", "isDisabled"],
      name: ["formControlName", "name"],
      model: ["ngModel", "model"]
    },
    outputs: {
      update: "ngModelChange"
    },
    features: [core_js_["ɵɵProvidersFeature"]([controlNameBinding]), core_js_["ɵɵInheritDefinitionFeature"], core_js_["ɵɵNgOnChangesFeature"]]
  });
  /**
   * @description
   * Static property used to track whether any ngModel warnings have been sent across
   * all instances of FormControlName. Used to support warning config of "once".
   *
   * @internal
   */
  FormControlName._ngModelWarningSentOnce = false;
  return FormControlName;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const SELECT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => SelectControlValueAccessor),
  multi: true
};
function _buildValueString(id, value) {
  if (id == null) return `${value}`;
  if (value && typeof value === 'object') value = 'Object';
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId(valueString) {
  return valueString.split(':')[0];
}
/**
 * @description
 * The `ControlValueAccessor` for writing select control values and listening to select control
 * changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and
 * `NgModel` directives.
 *
 * @usageNotes
 *
 * ### Using select controls in a reactive form
 *
 * The following examples show how to use a select control in a reactive form.
 *
 * {@example forms/ts/reactiveSelectControl/reactive_select_control_example.ts region='Component'}
 *
 * ### Using select controls in a template-driven form
 *
 * To use a select in a template-driven form, simply add an `ngModel` and a `name`
 * attribute to the main `<select>` tag.
 *
 * {@example forms/ts/selectControl/select_control_example.ts region='Component'}
 *
 * ### Customizing option selection
 *
 * Angular uses object identity to select option. It's possible for the identities of items
 * to change while the data does not. This can happen, for example, if the items are produced
 * from an RPC to the server, and that RPC is re-run. Even if the data hasn't changed, the
 * second response will produce objects with different identities.
 *
 * To customize the default option comparison algorithm, `<select>` supports `compareWith` input.
 * `compareWith` takes a **function** which has two arguments: `option1` and `option2`.
 * If `compareWith` is given, Angular selects option by the return value of the function.
 *
 * ```ts
 * const selectedCountriesControl = new FormControl();
 * ```
 *
 * ```
 * <select [compareWith]="compareFn"  [formControl]="selectedCountriesControl">
 *     <option *ngFor="let country of countries" [ngValue]="country">
 *         {{country.name}}
 *     </option>
 * </select>
 *
 * compareFn(c1: Country, c2: Country): boolean {
 *     return c1 && c2 ? c1.id === c2.id : c1 === c2;
 * }
 * ```
 *
 * **Note:** We listen to the 'change' event because 'input' events aren't fired
 * for selects in IE, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event#browser_compatibility
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let SelectControlValueAccessor = /*#__PURE__*/(() => {
  class SelectControlValueAccessor extends BuiltInControlValueAccessor {
    constructor() {
      super(...arguments);
      /** @internal */
      this._optionMap = new Map();
      /** @internal */
      this._idCounter = 0;
      this._compareWith = Object.is;
    }
    /**
     * @description
     * Tracks the option comparison algorithm for tracking identities when
     * checking for changes.
     */
    set compareWith(fn) {
      if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {
        throw new Error(`compareWith must be a function, but received ${JSON.stringify(fn)}`);
      }
      this._compareWith = fn;
    }
    /**
     * Sets the "value" property on the input element. The "selectedIndex"
     * property is also set if an ID is provided on the option element.
     * @nodoc
     */
    writeValue(value) {
      this.value = value;
      const id = this._getOptionId(value);
      if (id == null) {
        this.setProperty('selectedIndex', -1);
      }
      const valueString = _buildValueString(id, value);
      this.setProperty('value', valueString);
    }
    /**
     * Registers a function called when the control value changes.
     * @nodoc
     */
    registerOnChange(fn) {
      this.onChange = valueString => {
        this.value = this._getOptionValue(valueString);
        fn(this.value);
      };
    }
    /** @internal */
    _registerOption() {
      return (this._idCounter++).toString();
    }
    /** @internal */
    _getOptionId(value) {
      for (const id of Array.from(this._optionMap.keys())) {
        if (this._compareWith(this._optionMap.get(id), value)) return id;
      }
      return null;
    }
    /** @internal */
    _getOptionValue(valueString) {
      const id = _extractId(valueString);
      return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
    }
  }
  SelectControlValueAccessor.ɵfac = /*@__PURE__*/function () {
    let ɵSelectControlValueAccessor_BaseFactory;
    return function SelectControlValueAccessor_Factory(t) {
      return (ɵSelectControlValueAccessor_BaseFactory || (ɵSelectControlValueAccessor_BaseFactory = core_js_["ɵɵgetInheritedFactory"](SelectControlValueAccessor)))(t || SelectControlValueAccessor);
    };
  }();
  SelectControlValueAccessor.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: SelectControlValueAccessor,
    selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]],
    hostBindings: function SelectControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("change", function SelectControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function SelectControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      compareWith: "compareWith"
    },
    features: [core_js_["ɵɵProvidersFeature"]([SELECT_VALUE_ACCESSOR]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return SelectControlValueAccessor;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Marks `<option>` as dynamic, so Angular can be notified when options change.
 *
 * @see `SelectControlValueAccessor`
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let NgSelectOption = /*#__PURE__*/(() => {
  class NgSelectOption {
    constructor(_element, _renderer, _select) {
      this._element = _element;
      this._renderer = _renderer;
      this._select = _select;
      if (this._select) this.id = this._select._registerOption();
    }
    /**
     * @description
     * Tracks the value bound to the option element. Unlike the value binding,
     * ngValue supports binding to objects.
     */
    set ngValue(value) {
      if (this._select == null) return;
      this._select._optionMap.set(this.id, value);
      this._setElementValue(_buildValueString(this.id, value));
      this._select.writeValue(this._select.value);
    }
    /**
     * @description
     * Tracks simple string values bound to the option element.
     * For objects, use the `ngValue` input binding.
     */
    set value(value) {
      this._setElementValue(value);
      if (this._select) this._select.writeValue(this._select.value);
    }
    /** @internal */
    _setElementValue(value) {
      this._renderer.setProperty(this._element.nativeElement, 'value', value);
    }
    /** @nodoc */
    ngOnDestroy() {
      if (this._select) {
        this._select._optionMap.delete(this.id);
        this._select.writeValue(this._select.value);
      }
    }
  }
  NgSelectOption.ɵfac = function NgSelectOption_Factory(t) {
    return new (t || NgSelectOption)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.Renderer2), core_js_["ɵɵdirectiveInject"](SelectControlValueAccessor, 9));
  };
  NgSelectOption.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: NgSelectOption,
    selectors: [["option"]],
    inputs: {
      ngValue: "ngValue",
      value: "value"
    }
  });
  return NgSelectOption;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const SELECT_MULTIPLE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => SelectMultipleControlValueAccessor),
  multi: true
};
function _buildValueString$1(id, value) {
  if (id == null) return `${value}`;
  if (typeof value === 'string') value = `'${value}'`;
  if (value && typeof value === 'object') value = 'Object';
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId$1(valueString) {
  return valueString.split(':')[0];
}
/** Mock interface for HTMLCollection */
class HTMLCollection {}
/**
 * @description
 * The `ControlValueAccessor` for writing multi-select control values and listening to multi-select
 * control changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and
 * `NgModel` directives.
 *
 * @see `SelectControlValueAccessor`
 *
 * @usageNotes
 *
 * ### Using a multi-select control
 *
 * The follow example shows you how to use a multi-select control with a reactive form.
 *
 * ```ts
 * const countryControl = new FormControl();
 * ```
 *
 * ```
 * <select multiple name="countries" [formControl]="countryControl">
 *   <option *ngFor="let country of countries" [ngValue]="country">
 *     {{ country.name }}
 *   </option>
 * </select>
 * ```
 *
 * ### Customizing option selection
 *
 * To customize the default option comparison algorithm, `<select>` supports `compareWith` input.
 * See the `SelectControlValueAccessor` for usage.
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let SelectMultipleControlValueAccessor = /*#__PURE__*/(() => {
  class SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor {
    constructor() {
      super(...arguments);
      /** @internal */
      this._optionMap = new Map();
      /** @internal */
      this._idCounter = 0;
      this._compareWith = Object.is;
    }
    /**
     * @description
     * Tracks the option comparison algorithm for tracking identities when
     * checking for changes.
     */
    set compareWith(fn) {
      if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {
        throw new Error(`compareWith must be a function, but received ${JSON.stringify(fn)}`);
      }
      this._compareWith = fn;
    }
    /**
     * Sets the "value" property on one or of more of the select's options.
     * @nodoc
     */
    writeValue(value) {
      this.value = value;
      let optionSelectedStateSetter;
      if (Array.isArray(value)) {
        // convert values to ids
        const ids = value.map(v => this._getOptionId(v));
        optionSelectedStateSetter = (opt, o) => {
          opt._setSelected(ids.indexOf(o.toString()) > -1);
        };
      } else {
        optionSelectedStateSetter = (opt, o) => {
          opt._setSelected(false);
        };
      }
      this._optionMap.forEach(optionSelectedStateSetter);
    }
    /**
     * Registers a function called when the control value changes
     * and writes an array of the selected options.
     * @nodoc
     */
    registerOnChange(fn) {
      this.onChange = _ => {
        const selected = [];
        if (_.selectedOptions !== undefined) {
          const options = _.selectedOptions;
          for (let i = 0; i < options.length; i++) {
            const opt = options.item(i);
            const val = this._getOptionValue(opt.value);
            selected.push(val);
          }
        }
        // Degrade on IE
        else {
          const options = _.options;
          for (let i = 0; i < options.length; i++) {
            const opt = options.item(i);
            if (opt.selected) {
              const val = this._getOptionValue(opt.value);
              selected.push(val);
            }
          }
        }
        this.value = selected;
        fn(selected);
      };
    }
    /** @internal */
    _registerOption(value) {
      const id = (this._idCounter++).toString();
      this._optionMap.set(id, value);
      return id;
    }
    /** @internal */
    _getOptionId(value) {
      for (const id of Array.from(this._optionMap.keys())) {
        if (this._compareWith(this._optionMap.get(id)._value, value)) return id;
      }
      return null;
    }
    /** @internal */
    _getOptionValue(valueString) {
      const id = _extractId$1(valueString);
      return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
    }
  }
  SelectMultipleControlValueAccessor.ɵfac = /*@__PURE__*/function () {
    let ɵSelectMultipleControlValueAccessor_BaseFactory;
    return function SelectMultipleControlValueAccessor_Factory(t) {
      return (ɵSelectMultipleControlValueAccessor_BaseFactory || (ɵSelectMultipleControlValueAccessor_BaseFactory = core_js_["ɵɵgetInheritedFactory"](SelectMultipleControlValueAccessor)))(t || SelectMultipleControlValueAccessor);
    };
  }();
  SelectMultipleControlValueAccessor.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: SelectMultipleControlValueAccessor,
    selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]],
    hostBindings: function SelectMultipleControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("change", function SelectMultipleControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target);
        })("blur", function SelectMultipleControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      compareWith: "compareWith"
    },
    features: [core_js_["ɵɵProvidersFeature"]([SELECT_MULTIPLE_VALUE_ACCESSOR]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return SelectMultipleControlValueAccessor;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Marks `<option>` as dynamic, so Angular can be notified when options change.
 *
 * @see `SelectMultipleControlValueAccessor`
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let ɵNgSelectMultipleOption = /*#__PURE__*/(() => {
  class ɵNgSelectMultipleOption {
    constructor(_element, _renderer, _select) {
      this._element = _element;
      this._renderer = _renderer;
      this._select = _select;
      if (this._select) {
        this.id = this._select._registerOption(this);
      }
    }
    /**
     * @description
     * Tracks the value bound to the option element. Unlike the value binding,
     * ngValue supports binding to objects.
     */
    set ngValue(value) {
      if (this._select == null) return;
      this._value = value;
      this._setElementValue(_buildValueString$1(this.id, value));
      this._select.writeValue(this._select.value);
    }
    /**
     * @description
     * Tracks simple string values bound to the option element.
     * For objects, use the `ngValue` input binding.
     */
    set value(value) {
      if (this._select) {
        this._value = value;
        this._setElementValue(_buildValueString$1(this.id, value));
        this._select.writeValue(this._select.value);
      } else {
        this._setElementValue(value);
      }
    }
    /** @internal */
    _setElementValue(value) {
      this._renderer.setProperty(this._element.nativeElement, 'value', value);
    }
    /** @internal */
    _setSelected(selected) {
      this._renderer.setProperty(this._element.nativeElement, 'selected', selected);
    }
    /** @nodoc */
    ngOnDestroy() {
      if (this._select) {
        this._select._optionMap.delete(this.id);
        this._select.writeValue(this._select.value);
      }
    }
  }
  ɵNgSelectMultipleOption.ɵfac = function ɵNgSelectMultipleOption_Factory(t) {
    return new (t || ɵNgSelectMultipleOption)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.Renderer2), core_js_["ɵɵdirectiveInject"](SelectMultipleControlValueAccessor, 9));
  };
  ɵNgSelectMultipleOption.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: ɵNgSelectMultipleOption,
    selectors: [["option"]],
    inputs: {
      ngValue: "ngValue",
      value: "value"
    }
  });
  return ɵNgSelectMultipleOption;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @description
 * Method that updates string to integer if not alread a number
 *
 * @param value The value to convert to integer
 * @returns value of parameter in number or integer.
 */
function toNumber(value) {
  return typeof value === 'number' ? value : parseInt(value, 10);
}
/**
 * A base class for Validator-based Directives. The class contains common logic shared across such
 * Directives.
 *
 * For internal use only, this class is not intended for use outside of the Forms package.
 */
let AbstractValidatorDirective = /*#__PURE__*/(() => {
  class AbstractValidatorDirective {
    constructor() {
      this._validator = nullValidator;
    }
    /**
     * Helper function invoked from child classes to process changes (from `ngOnChanges` hook).
     * @nodoc
     */
    handleChanges(changes) {
      if (this.inputName in changes) {
        const input = this.normalizeInput(changes[this.inputName].currentValue);
        this._validator = this.createValidator(input);
        if (this._onChange) {
          this._onChange();
        }
      }
    }
    /** @nodoc */
    validate(control) {
      return this._validator(control);
    }
    /** @nodoc */
    registerOnValidatorChange(fn) {
      this._onChange = fn;
    }
  }
  AbstractValidatorDirective.ɵfac = function AbstractValidatorDirective_Factory(t) {
    return new (t || AbstractValidatorDirective)();
  };
  AbstractValidatorDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: AbstractValidatorDirective
  });
  return AbstractValidatorDirective;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Provider which adds `MaxValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const MAX_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => MaxValidator),
  multi: true
};
/**
 * A directive which installs the {@link MaxValidator} for any `formControlName`,
 * `formControl`, or control with `ngModel` that also has a `max` attribute.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a max validator
 *
 * The following example shows how to add a max validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input type="number" ngModel max="4">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let MaxValidator = /*#__PURE__*/(() => {
  class MaxValidator extends AbstractValidatorDirective {
    constructor() {
      super(...arguments);
      /** @internal */
      this.inputName = 'max';
      /** @internal */
      this.normalizeInput = input => parseFloat(input);
      /** @internal */
      this.createValidator = max => maxValidator(max);
    }
    /**
     * Declare `ngOnChanges` lifecycle hook at the main directive level (vs keeping it in base class)
     * to avoid differences in handling inheritance of lifecycle hooks between Ivy and ViewEngine in
     * AOT mode. This could be refactored once ViewEngine is removed.
     * @nodoc
     */
    ngOnChanges(changes) {
      this.handleChanges(changes);
    }
  }
  MaxValidator.ɵfac = /*@__PURE__*/function () {
    let ɵMaxValidator_BaseFactory;
    return function MaxValidator_Factory(t) {
      return (ɵMaxValidator_BaseFactory || (ɵMaxValidator_BaseFactory = core_js_["ɵɵgetInheritedFactory"](MaxValidator)))(t || MaxValidator);
    };
  }();
  MaxValidator.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: MaxValidator,
    selectors: [["input", "type", "number", "max", "", "formControlName", ""], ["input", "type", "number", "max", "", "formControl", ""], ["input", "type", "number", "max", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MaxValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        let tmp_b_0;
        core_js_["ɵɵattribute"]("max", (tmp_b_0 = ctx.max) !== null && tmp_b_0 !== undefined ? tmp_b_0 : null);
      }
    },
    inputs: {
      max: "max"
    },
    features: [core_js_["ɵɵProvidersFeature"]([MAX_VALIDATOR]), core_js_["ɵɵInheritDefinitionFeature"], core_js_["ɵɵNgOnChangesFeature"]]
  });
  return MaxValidator;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Provider which adds `MinValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const MIN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => MinValidator),
  multi: true
};
/**
 * A directive which installs the {@link MinValidator} for any `formControlName`,
 * `formControl`, or control with `ngModel` that also has a `min` attribute.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a min validator
 *
 * The following example shows how to add a min validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input type="number" ngModel min="4">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let MinValidator = /*#__PURE__*/(() => {
  class MinValidator extends AbstractValidatorDirective {
    constructor() {
      super(...arguments);
      /** @internal */
      this.inputName = 'min';
      /** @internal */
      this.normalizeInput = input => parseFloat(input);
      /** @internal */
      this.createValidator = min => minValidator(min);
    }
    /**
     * Declare `ngOnChanges` lifecycle hook at the main directive level (vs keeping it in base class)
     * to avoid differences in handling inheritance of lifecycle hooks between Ivy and ViewEngine in
     * AOT mode. This could be refactored once ViewEngine is removed.
     * @nodoc
     */
    ngOnChanges(changes) {
      this.handleChanges(changes);
    }
  }
  MinValidator.ɵfac = /*@__PURE__*/function () {
    let ɵMinValidator_BaseFactory;
    return function MinValidator_Factory(t) {
      return (ɵMinValidator_BaseFactory || (ɵMinValidator_BaseFactory = core_js_["ɵɵgetInheritedFactory"](MinValidator)))(t || MinValidator);
    };
  }();
  MinValidator.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: MinValidator,
    selectors: [["input", "type", "number", "min", "", "formControlName", ""], ["input", "type", "number", "min", "", "formControl", ""], ["input", "type", "number", "min", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MinValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        let tmp_b_0;
        core_js_["ɵɵattribute"]("min", (tmp_b_0 = ctx.min) !== null && tmp_b_0 !== undefined ? tmp_b_0 : null);
      }
    },
    inputs: {
      min: "min"
    },
    features: [core_js_["ɵɵProvidersFeature"]([MIN_VALIDATOR]), core_js_["ɵɵInheritDefinitionFeature"], core_js_["ɵɵNgOnChangesFeature"]]
  });
  return MinValidator;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Provider which adds `RequiredValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => RequiredValidator),
  multi: true
};
/**
 * @description
 * Provider which adds `CheckboxRequiredValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const CHECKBOX_REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => CheckboxRequiredValidator),
  multi: true
};
/**
 * @description
 * A directive that adds the `required` validator to any controls marked with the
 * `required` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a required validator using template-driven forms
 *
 * ```
 * <input name="fullName" ngModel required>
 * ```
 *
 * @ngModule FormsModule
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
let RequiredValidator = /*#__PURE__*/(() => {
  class RequiredValidator {
    constructor() {
      this._required = false;
    }
    /**
     * @description
     * Tracks changes to the required attribute bound to this directive.
     */
    get required() {
      return this._required;
    }
    set required(value) {
      this._required = value != null && value !== false && `${value}` !== 'false';
      if (this._onChange) this._onChange();
    }
    /**
     * Method that validates whether the control is empty.
     * Returns the validation result if enabled, otherwise null.
     * @nodoc
     */
    validate(control) {
      return this.required ? requiredValidator(control) : null;
    }
    /**
     * Registers a callback function to call when the validator inputs change.
     * @nodoc
     */
    registerOnValidatorChange(fn) {
      this._onChange = fn;
    }
  }
  RequiredValidator.ɵfac = function RequiredValidator_Factory(t) {
    return new (t || RequiredValidator)();
  };
  RequiredValidator.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: RequiredValidator,
    selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]],
    hostVars: 1,
    hostBindings: function RequiredValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("required", ctx.required ? "" : null);
      }
    },
    inputs: {
      required: "required"
    },
    features: [core_js_["ɵɵProvidersFeature"]([REQUIRED_VALIDATOR])]
  });
  return RequiredValidator;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * A Directive that adds the `required` validator to checkbox controls marked with the
 * `required` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a required checkbox validator using template-driven forms
 *
 * The following example shows how to add a checkbox required validator to an input attached to an
 * ngModel binding.
 *
 * ```
 * <input type="checkbox" name="active" ngModel required>
 * ```
 *
 * @publicApi
 * @ngModule FormsModule
 * @ngModule ReactiveFormsModule
 */
let CheckboxRequiredValidator = /*#__PURE__*/(() => {
  class CheckboxRequiredValidator extends RequiredValidator {
    /**
     * Method that validates whether or not the checkbox has been checked.
     * Returns the validation result if enabled, otherwise null.
     * @nodoc
     */
    validate(control) {
      return this.required ? requiredTrueValidator(control) : null;
    }
  }
  CheckboxRequiredValidator.ɵfac = /*@__PURE__*/function () {
    let ɵCheckboxRequiredValidator_BaseFactory;
    return function CheckboxRequiredValidator_Factory(t) {
      return (ɵCheckboxRequiredValidator_BaseFactory || (ɵCheckboxRequiredValidator_BaseFactory = core_js_["ɵɵgetInheritedFactory"](CheckboxRequiredValidator)))(t || CheckboxRequiredValidator);
    };
  }();
  CheckboxRequiredValidator.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: CheckboxRequiredValidator,
    selectors: [["input", "type", "checkbox", "required", "", "formControlName", ""], ["input", "type", "checkbox", "required", "", "formControl", ""], ["input", "type", "checkbox", "required", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function CheckboxRequiredValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("required", ctx.required ? "" : null);
      }
    },
    features: [core_js_["ɵɵProvidersFeature"]([CHECKBOX_REQUIRED_VALIDATOR]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return CheckboxRequiredValidator;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Provider which adds `EmailValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const EMAIL_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => EmailValidator),
  multi: true
};
/**
 * A directive that adds the `email` validator to controls marked with the
 * `email` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding an email validator
 *
 * The following example shows how to add an email validator to an input attached to an ngModel
 * binding.
 *
 * ```
 * <input type="email" name="email" ngModel email>
 * <input type="email" name="email" ngModel email="true">
 * <input type="email" name="email" ngModel [email]="true">
 * ```
 *
 * @publicApi
 * @ngModule FormsModule
 * @ngModule ReactiveFormsModule
 */
let EmailValidator = /*#__PURE__*/(() => {
  class EmailValidator {
    constructor() {
      this._enabled = false;
    }
    /**
     * @description
     * Tracks changes to the email attribute bound to this directive.
     */
    set email(value) {
      this._enabled = value === '' || value === true || value === 'true';
      if (this._onChange) this._onChange();
    }
    /**
     * Method that validates whether an email address is valid.
     * Returns the validation result if enabled, otherwise null.
     * @nodoc
     */
    validate(control) {
      return this._enabled ? emailValidator(control) : null;
    }
    /**
     * Registers a callback function to call when the validator inputs change.
     * @nodoc
     */
    registerOnValidatorChange(fn) {
      this._onChange = fn;
    }
  }
  EmailValidator.ɵfac = function EmailValidator_Factory(t) {
    return new (t || EmailValidator)();
  };
  EmailValidator.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: EmailValidator,
    selectors: [["", "email", "", "formControlName", ""], ["", "email", "", "formControl", ""], ["", "email", "", "ngModel", ""]],
    inputs: {
      email: "email"
    },
    features: [core_js_["ɵɵProvidersFeature"]([EMAIL_VALIDATOR])]
  });
  return EmailValidator;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Provider which adds `MinLengthValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const MIN_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => MinLengthValidator),
  multi: true
};
/**
 * A directive that adds minimum length validation to controls marked with the
 * `minlength` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a minimum length validator
 *
 * The following example shows how to add a minimum length validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input name="firstName" ngModel minlength="4">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let MinLengthValidator = /*#__PURE__*/(() => {
  class MinLengthValidator {
    constructor() {
      this._validator = nullValidator;
    }
    /** @nodoc */
    ngOnChanges(changes) {
      if ('minlength' in changes) {
        this._createValidator();
        if (this._onChange) this._onChange();
      }
    }
    /**
     * Method that validates whether the value meets a minimum length requirement.
     * Returns the validation result if enabled, otherwise null.
     * @nodoc
     */
    validate(control) {
      return this.enabled() ? this._validator(control) : null;
    }
    /**
     * Registers a callback function to call when the validator inputs change.
     * @nodoc
     */
    registerOnValidatorChange(fn) {
      this._onChange = fn;
    }
    _createValidator() {
      this._validator = this.enabled() ? minLengthValidator(toNumber(this.minlength)) : nullValidator;
    }
    /** @nodoc */
    enabled() {
      return this.minlength != null /* both `null` and `undefined` */;
    }
  }

  MinLengthValidator.ɵfac = function MinLengthValidator_Factory(t) {
    return new (t || MinLengthValidator)();
  };
  MinLengthValidator.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: MinLengthValidator,
    selectors: [["", "minlength", "", "formControlName", ""], ["", "minlength", "", "formControl", ""], ["", "minlength", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MinLengthValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("minlength", ctx.enabled() ? ctx.minlength : null);
      }
    },
    inputs: {
      minlength: "minlength"
    },
    features: [core_js_["ɵɵProvidersFeature"]([MIN_LENGTH_VALIDATOR]), core_js_["ɵɵNgOnChangesFeature"]]
  });
  return MinLengthValidator;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Provider which adds `MaxLengthValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const MAX_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => MaxLengthValidator),
  multi: true
};
/**
 * A directive that adds max length validation to controls marked with the
 * `maxlength` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a maximum length validator
 *
 * The following example shows how to add a maximum length validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input name="firstName" ngModel maxlength="25">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let MaxLengthValidator = /*#__PURE__*/(() => {
  class MaxLengthValidator {
    constructor() {
      this._validator = nullValidator;
    }
    /** @nodoc */
    ngOnChanges(changes) {
      if ('maxlength' in changes) {
        this._createValidator();
        if (this._onChange) this._onChange();
      }
    }
    /**
     * Method that validates whether the value exceeds the maximum length requirement.
     * @nodoc
     */
    validate(control) {
      return this.enabled() ? this._validator(control) : null;
    }
    /**
     * Registers a callback function to call when the validator inputs change.
     * @nodoc
     */
    registerOnValidatorChange(fn) {
      this._onChange = fn;
    }
    _createValidator() {
      this._validator = this.enabled() ? maxLengthValidator(toNumber(this.maxlength)) : nullValidator;
    }
    /** @nodoc */
    enabled() {
      return this.maxlength != null /* both `null` and `undefined` */;
    }
  }

  MaxLengthValidator.ɵfac = function MaxLengthValidator_Factory(t) {
    return new (t || MaxLengthValidator)();
  };
  MaxLengthValidator.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: MaxLengthValidator,
    selectors: [["", "maxlength", "", "formControlName", ""], ["", "maxlength", "", "formControl", ""], ["", "maxlength", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MaxLengthValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("maxlength", ctx.enabled() ? ctx.maxlength : null);
      }
    },
    inputs: {
      maxlength: "maxlength"
    },
    features: [core_js_["ɵɵProvidersFeature"]([MAX_LENGTH_VALIDATOR]), core_js_["ɵɵNgOnChangesFeature"]]
  });
  return MaxLengthValidator;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * @description
 * Provider which adds `PatternValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const PATTERN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: /*#__PURE__*/(0,core_js_.forwardRef)(() => PatternValidator),
  multi: true
};
/**
 * @description
 * A directive that adds regex pattern validation to controls marked with the
 * `pattern` attribute. The regex must match the entire control value.
 * The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a pattern validator
 *
 * The following example shows how to add a pattern validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input name="firstName" ngModel pattern="[a-zA-Z ]*">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
let PatternValidator = /*#__PURE__*/(() => {
  class PatternValidator {
    constructor() {
      this._validator = nullValidator;
    }
    /** @nodoc */
    ngOnChanges(changes) {
      if ('pattern' in changes) {
        this._createValidator();
        if (this._onChange) this._onChange();
      }
    }
    /**
     * Method that validates whether the value matches the pattern requirement.
     * @nodoc
     */
    validate(control) {
      return this._validator(control);
    }
    /**
     * Registers a callback function to call when the validator inputs change.
     * @nodoc
     */
    registerOnValidatorChange(fn) {
      this._onChange = fn;
    }
    _createValidator() {
      this._validator = patternValidator(this.pattern);
    }
  }
  PatternValidator.ɵfac = function PatternValidator_Factory(t) {
    return new (t || PatternValidator)();
  };
  PatternValidator.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: PatternValidator,
    selectors: [["", "pattern", "", "formControlName", ""], ["", "pattern", "", "formControl", ""], ["", "pattern", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function PatternValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("pattern", ctx.pattern ? ctx.pattern : null);
      }
    },
    inputs: {
      pattern: "pattern"
    },
    features: [core_js_["ɵɵProvidersFeature"]([PATTERN_VALIDATOR]), core_js_["ɵɵNgOnChangesFeature"]]
  });
  return PatternValidator;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const SHARED_FORM_DIRECTIVES = [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator];
const TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
const REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
/**
 * Internal module used for sharing directives between FormsModule and ReactiveFormsModule
 */
let ɵInternalFormsSharedModule = /*#__PURE__*/(() => {
  class ɵInternalFormsSharedModule {}
  ɵInternalFormsSharedModule.ɵfac = function ɵInternalFormsSharedModule_Factory(t) {
    return new (t || ɵInternalFormsSharedModule)();
  };
  ɵInternalFormsSharedModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: ɵInternalFormsSharedModule
  });
  ɵInternalFormsSharedModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[RadioControlRegistryModule]]
  });
  return ɵInternalFormsSharedModule;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/*#__PURE__*/(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](ɵInternalFormsSharedModule, {
    declarations: [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator],
    imports: [RadioControlRegistryModule],
    exports: [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator]
  });
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Exports the required providers and directives for template-driven forms,
 * making them available for import by NgModules that import this module.
 *
 * Providers associated with this module:
 * * `RadioControlRegistry`
 *
 * @see [Forms Overview](/guide/forms-overview)
 * @see [Template-driven Forms Guide](/guide/forms)
 *
 * @publicApi
 */
let FormsModule = /*#__PURE__*/(() => {
  class FormsModule {}
  FormsModule.ɵfac = function FormsModule_Factory(t) {
    return new (t || FormsModule)();
  };
  FormsModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: FormsModule
  });
  FormsModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [ɵInternalFormsSharedModule]
  });
  return FormsModule;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/*#__PURE__*/(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](FormsModule, {
    declarations: [NgModel, NgModelGroup, NgForm],
    exports: [ɵInternalFormsSharedModule, NgModel, NgModelGroup, NgForm]
  });
})();
/**
 * Exports the required infrastructure and directives for reactive forms,
 * making them available for import by NgModules that import this module.
 *
 * Providers associated with this module:
 * * `FormBuilder`
 * * `RadioControlRegistry`
 *
 * @see [Forms Overview](guide/forms-overview)
 * @see [Reactive Forms Guide](guide/reactive-forms)
 *
 * @publicApi
 */
let ReactiveFormsModule = /*#__PURE__*/(() => {
  class ReactiveFormsModule {
    /**
     * @description
     * Provides options for configuring the reactive forms module.
     *
     * @param opts An object of configuration options
     * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`
     * binding is used with reactive form directives.
     */
    static withConfig(opts) {
      return {
        ngModule: ReactiveFormsModule,
        providers: [{
          provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,
          useValue: opts.warnOnNgModelWithFormControl
        }]
      };
    }
  }
  ReactiveFormsModule.ɵfac = function ReactiveFormsModule_Factory(t) {
    return new (t || ReactiveFormsModule)();
  };
  ReactiveFormsModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: ReactiveFormsModule
  });
  ReactiveFormsModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [ɵInternalFormsSharedModule]
  });
  return ReactiveFormsModule;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/*#__PURE__*/(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](ReactiveFormsModule, {
    declarations: [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName],
    exports: [ɵInternalFormsSharedModule, FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName]
  });
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function isAbstractControlOptions(options) {
  return options.asyncValidators !== undefined || options.validators !== undefined || options.updateOn !== undefined;
}
/**
 * @description
 * Creates an `AbstractControl` from a user-specified configuration.
 *
 * The `FormBuilder` provides syntactic sugar that shortens creating instances of a `FormControl`,
 * `FormGroup`, or `FormArray`. It reduces the amount of boilerplate needed to build complex
 * forms.
 *
 * @see [Reactive Forms Guide](/guide/reactive-forms)
 *
 * @publicApi
 */
let FormBuilder = /*#__PURE__*/(() => {
  class FormBuilder {
    group(controlsConfig, options = null) {
      const controls = this._reduceControls(controlsConfig);
      let validators = null;
      let asyncValidators = null;
      let updateOn = undefined;
      if (options != null) {
        if (isAbstractControlOptions(options)) {
          // `options` are `AbstractControlOptions`
          validators = options.validators != null ? options.validators : null;
          asyncValidators = options.asyncValidators != null ? options.asyncValidators : null;
          updateOn = options.updateOn != null ? options.updateOn : undefined;
        } else {
          // `options` are legacy form group options
          validators = options['validator'] != null ? options['validator'] : null;
          asyncValidators = options['asyncValidator'] != null ? options['asyncValidator'] : null;
        }
      }
      return new FormGroup(controls, {
        asyncValidators,
        updateOn,
        validators
      });
    }
    /**
     * @description
     * Construct a new `FormControl` with the given state, validators and options.
     *
     * @param formState Initializes the control with an initial state value, or
     * with an object that contains both a value and a disabled status.
     *
     * @param validatorOrOpts A synchronous validator function, or an array of
     * such functions, or an `AbstractControlOptions` object that contains
     * validation functions and a validation trigger.
     *
     * @param asyncValidator A single async validator or array of async validator
     * functions.
     *
     * @usageNotes
     *
     * ### Initialize a control as disabled
     *
     * The following example returns a control with an initial value in a disabled state.
     *
     * <code-example path="forms/ts/formBuilder/form_builder_example.ts" region="disabled-control">
     * </code-example>
     */
    control(formState, validatorOrOpts, asyncValidator) {
      return new FormControl(formState, validatorOrOpts, asyncValidator);
    }
    /**
     * Constructs a new `FormArray` from the given array of configurations,
     * validators and options.
     *
     * @param controlsConfig An array of child controls or control configs. Each
     * child control is given an index when it is registered.
     *
     * @param validatorOrOpts A synchronous validator function, or an array of
     * such functions, or an `AbstractControlOptions` object that contains
     * validation functions and a validation trigger.
     *
     * @param asyncValidator A single async validator or array of async validator
     * functions.
     */
    array(controlsConfig, validatorOrOpts, asyncValidator) {
      const controls = controlsConfig.map(c => this._createControl(c));
      return new FormArray(controls, validatorOrOpts, asyncValidator);
    }
    /** @internal */
    _reduceControls(controlsConfig) {
      const controls = {};
      Object.keys(controlsConfig).forEach(controlName => {
        controls[controlName] = this._createControl(controlsConfig[controlName]);
      });
      return controls;
    }
    /** @internal */
    _createControl(controlConfig) {
      if (controlConfig instanceof FormControl || controlConfig instanceof FormGroup || controlConfig instanceof FormArray) {
        return controlConfig;
      } else if (Array.isArray(controlConfig)) {
        const value = controlConfig[0];
        const validator = controlConfig.length > 1 ? controlConfig[1] : null;
        const asyncValidator = controlConfig.length > 2 ? controlConfig[2] : null;
        return this.control(value, validator, asyncValidator);
      } else {
        return this.control(controlConfig);
      }
    }
  }
  FormBuilder.ɵfac = function FormBuilder_Factory(t) {
    return new (t || FormBuilder)();
  };
  FormBuilder.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function FormBuilder_Factory() {
      return new FormBuilder();
    },
    token: FormBuilder,
    providedIn: ReactiveFormsModule
  });
  return FormBuilder;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @publicApi
 */
const VERSION = /*#__PURE__*/new core_js_.Version('12.2.17');

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// This file only reexports content of the `src` folder. Keep it that way.

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=forms.js.map

/***/ }),

/***/ 1211:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BrowserModule: () => (/* binding */ BrowserModule),
/* harmony export */   BrowserTransferStateModule: () => (/* binding */ BrowserTransferStateModule),
/* harmony export */   By: () => (/* binding */ By),
/* harmony export */   DomSanitizer: () => (/* binding */ DomSanitizer),
/* harmony export */   EVENT_MANAGER_PLUGINS: () => (/* binding */ EVENT_MANAGER_PLUGINS),
/* harmony export */   EventManager: () => (/* binding */ EventManager),
/* harmony export */   HAMMER_GESTURE_CONFIG: () => (/* binding */ HAMMER_GESTURE_CONFIG),
/* harmony export */   HAMMER_LOADER: () => (/* binding */ HAMMER_LOADER),
/* harmony export */   HammerGestureConfig: () => (/* binding */ HammerGestureConfig),
/* harmony export */   HammerModule: () => (/* binding */ HammerModule),
/* harmony export */   Meta: () => (/* binding */ Meta),
/* harmony export */   Title: () => (/* binding */ Title),
/* harmony export */   TransferState: () => (/* binding */ TransferState),
/* harmony export */   VERSION: () => (/* binding */ VERSION),
/* harmony export */   disableDebugTools: () => (/* binding */ disableDebugTools),
/* harmony export */   enableDebugTools: () => (/* binding */ enableDebugTools),
/* harmony export */   makeStateKey: () => (/* binding */ makeStateKey),
/* harmony export */   platformBrowser: () => (/* binding */ platformBrowser),
/* harmony export */   "ɵBROWSER_SANITIZATION_PROVIDERS": () => (/* binding */ BROWSER_SANITIZATION_PROVIDERS),
/* harmony export */   "ɵBROWSER_SANITIZATION_PROVIDERS__POST_R3__": () => (/* binding */ BROWSER_SANITIZATION_PROVIDERS__POST_R3__),
/* harmony export */   "ɵBrowserDomAdapter": () => (/* binding */ BrowserDomAdapter),
/* harmony export */   "ɵBrowserGetTestability": () => (/* binding */ BrowserGetTestability),
/* harmony export */   "ɵDomEventsPlugin": () => (/* binding */ DomEventsPlugin),
/* harmony export */   "ɵDomRendererFactory2": () => (/* binding */ DomRendererFactory2),
/* harmony export */   "ɵDomSanitizerImpl": () => (/* binding */ DomSanitizerImpl),
/* harmony export */   "ɵDomSharedStylesHost": () => (/* binding */ DomSharedStylesHost),
/* harmony export */   "ɵELEMENT_PROBE_PROVIDERS": () => (/* binding */ ELEMENT_PROBE_PROVIDERS),
/* harmony export */   "ɵELEMENT_PROBE_PROVIDERS__POST_R3__": () => (/* binding */ ELEMENT_PROBE_PROVIDERS__POST_R3__),
/* harmony export */   "ɵHAMMER_PROVIDERS__POST_R3__": () => (/* binding */ HAMMER_PROVIDERS__POST_R3__),
/* harmony export */   "ɵHammerGesturesPlugin": () => (/* binding */ HammerGesturesPlugin),
/* harmony export */   "ɵINTERNAL_BROWSER_PLATFORM_PROVIDERS": () => (/* binding */ INTERNAL_BROWSER_PLATFORM_PROVIDERS),
/* harmony export */   "ɵKeyEventsPlugin": () => (/* binding */ KeyEventsPlugin),
/* harmony export */   "ɵNAMESPACE_URIS": () => (/* binding */ NAMESPACE_URIS),
/* harmony export */   "ɵSharedStylesHost": () => (/* binding */ SharedStylesHost),
/* harmony export */   "ɵTRANSITION_ID": () => (/* binding */ TRANSITION_ID),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_a": () => (/* binding */ errorHandler),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_b": () => (/* binding */ _document),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_c": () => (/* binding */ BROWSER_MODULE_PROVIDERS),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_d": () => (/* binding */ createMeta),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_e": () => (/* binding */ createTitle),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_f": () => (/* binding */ initTransferState),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_g": () => (/* binding */ EventManagerPlugin),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_h": () => (/* binding */ HAMMER_PROVIDERS__PRE_R3__),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_i": () => (/* binding */ HAMMER_PROVIDERS),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_j": () => (/* binding */ domSanitizerImplFactory),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_k": () => (/* binding */ appInitializerFactory),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_l": () => (/* binding */ SERVER_TRANSITION_PROVIDERS),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_m": () => (/* binding */ _createNgProbeR2),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_n": () => (/* binding */ ELEMENT_PROBE_PROVIDERS__PRE_R3__),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_o": () => (/* binding */ BrowserXhr),
/* harmony export */   "ɵangular_packages_platform_browser_platform_browser_p": () => (/* binding */ GenericBrowserDomAdapter),
/* harmony export */   "ɵescapeHtml": () => (/* binding */ escapeHtml),
/* harmony export */   "ɵflattenStyles": () => (/* binding */ flattenStyles),
/* harmony export */   "ɵgetDOM": () => (/* reexport safe */ _angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵgetDOM"]),
/* harmony export */   "ɵinitDomAdapter": () => (/* binding */ initDomAdapter),
/* harmony export */   "ɵshimContentAttribute": () => (/* binding */ shimContentAttribute),
/* harmony export */   "ɵshimHostAttribute": () => (/* binding */ shimHostAttribute)
/* harmony export */ });
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3008);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_1__);
/**
 * @license Angular v12.2.17
 * (c) 2010-2021 Google LLC. https://angular.io/
 * License: MIT
 */






/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Provides DOM operations in any browser environment.
 *
 * @security Tread carefully! Interacting with the DOM directly is dangerous and
 * can introduce XSS risks.
 */
class GenericBrowserDomAdapter extends _angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵDomAdapter"] {
  constructor() {
    super(...arguments);
    this.supportsDOMEvents = true;
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A `DomAdapter` powered by full browser DOM APIs.
 *
 * @security Tread carefully! Interacting with the DOM directly is dangerous and
 * can introduce XSS risks.
 */
/* tslint:disable:requireParameterType no-console */
class BrowserDomAdapter extends GenericBrowserDomAdapter {
  static makeCurrent() {
    (0,_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵsetRootDomAdapter"])(new BrowserDomAdapter());
  }
  onAndCancel(el, evt, listener) {
    el.addEventListener(evt, listener, false);
    // Needed to follow Dart's subscription semantic, until fix of
    // https://code.google.com/p/dart/issues/detail?id=17406
    return () => {
      el.removeEventListener(evt, listener, false);
    };
  }
  dispatchEvent(el, evt) {
    el.dispatchEvent(evt);
  }
  remove(node) {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
  createElement(tagName, doc) {
    doc = doc || this.getDefaultDocument();
    return doc.createElement(tagName);
  }
  createHtmlDocument() {
    return document.implementation.createHTMLDocument('fakeTitle');
  }
  getDefaultDocument() {
    return document;
  }
  isElementNode(node) {
    return node.nodeType === Node.ELEMENT_NODE;
  }
  isShadowRoot(node) {
    return node instanceof DocumentFragment;
  }
  /** @deprecated No longer being used in Ivy code. To be removed in version 14. */
  getGlobalEventTarget(doc, target) {
    if (target === 'window') {
      return window;
    }
    if (target === 'document') {
      return doc;
    }
    if (target === 'body') {
      return doc.body;
    }
    return null;
  }
  getBaseHref(doc) {
    const href = getBaseElementHref();
    return href == null ? null : relativePath(href);
  }
  resetBaseElement() {
    baseElement = null;
  }
  getUserAgent() {
    return window.navigator.userAgent;
  }
  getCookie(name) {
    return (0,_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵparseCookieValue"])(document.cookie, name);
  }
}
let baseElement = null;
function getBaseElementHref() {
  baseElement = baseElement || document.querySelector('base');
  return baseElement ? baseElement.getAttribute('href') : null;
}
// based on urlUtils.js in AngularJS 1
let urlParsingNode;
function relativePath(url) {
  urlParsingNode = urlParsingNode || document.createElement('a');
  urlParsingNode.setAttribute('href', url);
  const pathName = urlParsingNode.pathname;
  return pathName.charAt(0) === '/' ? pathName : `/${pathName}`;
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * An id that identifies a particular application being bootstrapped, that should
 * match across the client/server boundary.
 */
const TRANSITION_ID = /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('TRANSITION_ID');
function appInitializerFactory(transitionId, document, injector) {
  return () => {
    // Wait for all application initializers to be completed before removing the styles set by
    // the server.
    injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_1__.ApplicationInitStatus).donePromise.then(() => {
      const dom = (0,_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵgetDOM"])();
      const styles = document.querySelectorAll(`style[ng-transition="${transitionId}"]`);
      for (let i = 0; i < styles.length; i++) {
        dom.remove(styles[i]);
      }
    });
  };
}
const SERVER_TRANSITION_PROVIDERS = [{
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_INITIALIZER,
  useFactory: appInitializerFactory,
  deps: [TRANSITION_ID, _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT, _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injector],
  multi: true
}];

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class BrowserGetTestability {
  static init() {
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.setTestabilityGetter)(new BrowserGetTestability());
  }
  addToWindow(registry) {
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵglobal"]['getAngularTestability'] = (elem, findInAncestors = true) => {
      const testability = registry.findTestabilityInTree(elem, findInAncestors);
      if (testability == null) {
        throw new Error('Could not find testability for element.');
      }
      return testability;
    };
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵglobal"]['getAllAngularTestabilities'] = () => registry.getAllTestabilities();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵglobal"]['getAllAngularRootElements'] = () => registry.getAllRootElements();
    const whenAllStable = (callback /** TODO #9100 */) => {
      const testabilities = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵglobal"]['getAllAngularTestabilities']();
      let count = testabilities.length;
      let didWork = false;
      const decrement = function (didWork_ /** TODO #9100 */) {
        didWork = didWork || didWork_;
        count--;
        if (count == 0) {
          callback(didWork);
        }
      };
      testabilities.forEach(function (testability /** TODO #9100 */) {
        testability.whenStable(decrement);
      });
    };
    if (!_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵglobal"]['frameworkStabilizers']) {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵglobal"]['frameworkStabilizers'] = [];
    }
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵglobal"]['frameworkStabilizers'].push(whenAllStable);
  }
  findTestabilityInTree(registry, elem, findInAncestors) {
    if (elem == null) {
      return null;
    }
    const t = registry.getTestability(elem);
    if (t != null) {
      return t;
    } else if (!findInAncestors) {
      return null;
    }
    if ((0,_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵgetDOM"])().isShadowRoot(elem)) {
      return this.findTestabilityInTree(registry, elem.host, true);
    }
    return this.findTestabilityInTree(registry, elem.parentElement, true);
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A factory for `HttpXhrBackend` that uses the `XMLHttpRequest` browser API.
 */
let BrowserXhr = /*#__PURE__*/(() => {
  class BrowserXhr {
    build() {
      return new XMLHttpRequest();
    }
  }
  BrowserXhr.ɵfac = function BrowserXhr_Factory(t) {
    return new (t || BrowserXhr)();
  };
  BrowserXhr.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: BrowserXhr,
    factory: BrowserXhr.ɵfac
  });
  return BrowserXhr;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const CAMEL_CASE_REGEXP = /([A-Z])/g;
const DASH_CASE_REGEXP = /-([a-z])/g;
function camelCaseToDashCase(input) {
  return input.replace(CAMEL_CASE_REGEXP, (...m) => '-' + m[1].toLowerCase());
}
function dashCaseToCamelCase(input) {
  return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());
}
/**
 * Exports the value under a given `name` in the global property `ng`. For example `ng.probe` if
 * `name` is `'probe'`.
 * @param name Name under which it will be exported. Keep in mind this will be a property of the
 * global `ng` object.
 * @param value The value to export.
 */
function exportNgVar(name, value) {
  if (typeof COMPILED === 'undefined' || !COMPILED) {
    // Note: we can't export `ng` when using closure enhanced optimization as:
    // - closure declares globals itself for minified names, which sometimes clobber our `ng` global
    // - we can't declare a closure extern as the namespace `ng` is already used within Google
    //   for typings for angularJS (via `goog.provide('ng....')`).
    const ng = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵglobal"]['ng'] = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵglobal"]['ng'] || {};
    ng[name] = value;
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const ɵ0 = () => ({
  'ApplicationRef': _angular_core__WEBPACK_IMPORTED_MODULE_1__.ApplicationRef,
  'NgZone': _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone
});
const CORE_TOKENS = /*#__PURE__*/ɵ0();
const INSPECT_GLOBAL_NAME = 'probe';
const CORE_TOKENS_GLOBAL_NAME = 'coreTokens';
/**
 * Returns a {@link DebugElement} for the given native DOM element, or
 * null if the given native element does not have an Angular view associated
 * with it.
 */
function inspectNativeElementR2(element) {
  return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵgetDebugNodeR2"])(element);
}
function _createNgProbeR2(coreTokens) {
  exportNgVar(INSPECT_GLOBAL_NAME, inspectNativeElementR2);
  exportNgVar(CORE_TOKENS_GLOBAL_NAME, Object.assign(Object.assign({}, CORE_TOKENS), _ngProbeTokensToMap(coreTokens || [])));
  return () => inspectNativeElementR2;
}
function _ngProbeTokensToMap(tokens) {
  return tokens.reduce((prev, t) => (prev[t.name] = t.token, prev), {});
}
/**
 * In Ivy, we don't support NgProbe because we have our own set of testing utilities
 * with more robust functionality.
 *
 * We shouldn't bring in NgProbe because it prevents DebugNode and friends from
 * tree-shaking properly.
 */
const ELEMENT_PROBE_PROVIDERS__POST_R3__ = [];
/**
 * Providers which support debugging Angular applications (e.g. via `ng.probe`).
 */
const ELEMENT_PROBE_PROVIDERS__PRE_R3__ = [{
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_INITIALIZER,
  useFactory: _createNgProbeR2,
  deps: [[_angular_core__WEBPACK_IMPORTED_MODULE_1__.NgProbeToken, /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional()]],
  multi: true
}];
const ELEMENT_PROBE_PROVIDERS = ELEMENT_PROBE_PROVIDERS__POST_R3__;

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * The injection token for the event-manager plug-in service.
 *
 * @publicApi
 */
const EVENT_MANAGER_PLUGINS = /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('EventManagerPlugins');
/**
 * An injectable service that provides event management for Angular
 * through a browser plug-in.
 *
 * @publicApi
 */
let EventManager = /*#__PURE__*/(() => {
  class EventManager {
    /**
     * Initializes an instance of the event-manager service.
     */
    constructor(plugins, _zone) {
      this._zone = _zone;
      this._eventNameToPlugin = new Map();
      plugins.forEach(p => p.manager = this);
      this._plugins = plugins.slice().reverse();
    }
    /**
     * Registers a handler for a specific element and event.
     *
     * @param element The HTML element to receive event notifications.
     * @param eventName The name of the event to listen for.
     * @param handler A function to call when the notification occurs. Receives the
     * event object as an argument.
     * @returns  A callback function that can be used to remove the handler.
     */
    addEventListener(element, eventName, handler) {
      const plugin = this._findPluginFor(eventName);
      return plugin.addEventListener(element, eventName, handler);
    }
    /**
     * Registers a global handler for an event in a target view.
     *
     * @param target A target for global event notifications. One of "window", "document", or "body".
     * @param eventName The name of the event to listen for.
     * @param handler A function to call when the notification occurs. Receives the
     * event object as an argument.
     * @returns A callback function that can be used to remove the handler.
     * @deprecated No longer being used in Ivy code. To be removed in version 14.
     */
    addGlobalEventListener(target, eventName, handler) {
      const plugin = this._findPluginFor(eventName);
      return plugin.addGlobalEventListener(target, eventName, handler);
    }
    /**
     * Retrieves the compilation zone in which event listeners are registered.
     */
    getZone() {
      return this._zone;
    }
    /** @internal */
    _findPluginFor(eventName) {
      const plugin = this._eventNameToPlugin.get(eventName);
      if (plugin) {
        return plugin;
      }
      const plugins = this._plugins;
      for (let i = 0; i < plugins.length; i++) {
        const plugin = plugins[i];
        if (plugin.supports(eventName)) {
          this._eventNameToPlugin.set(eventName, plugin);
          return plugin;
        }
      }
      throw new Error(`No event manager plugin found for event ${eventName}`);
    }
  }
  EventManager.ɵfac = function EventManager_Factory(t) {
    return new (t || EventManager)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](EVENT_MANAGER_PLUGINS), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone));
  };
  EventManager.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: EventManager,
    factory: EventManager.ɵfac
  });
  return EventManager;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
class EventManagerPlugin {
  constructor(_doc) {
    this._doc = _doc;
  }
  addGlobalEventListener(element, eventName, handler) {
    const target = (0,_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵgetDOM"])().getGlobalEventTarget(this._doc, element);
    if (!target) {
      throw new Error(`Unsupported event target ${target} for event ${eventName}`);
    }
    return this.addEventListener(target, eventName, handler);
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
let SharedStylesHost = /*#__PURE__*/(() => {
  class SharedStylesHost {
    constructor() {
      /** @internal */
      this._stylesSet = new Set();
    }
    addStyles(styles) {
      const additions = new Set();
      styles.forEach(style => {
        if (!this._stylesSet.has(style)) {
          this._stylesSet.add(style);
          additions.add(style);
        }
      });
      this.onStylesAdded(additions);
    }
    onStylesAdded(additions) {}
    getAllStyles() {
      return Array.from(this._stylesSet);
    }
  }
  SharedStylesHost.ɵfac = function SharedStylesHost_Factory(t) {
    return new (t || SharedStylesHost)();
  };
  SharedStylesHost.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: SharedStylesHost,
    factory: SharedStylesHost.ɵfac
  });
  return SharedStylesHost;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
let DomSharedStylesHost = /*#__PURE__*/(() => {
  class DomSharedStylesHost extends SharedStylesHost {
    constructor(_doc) {
      super();
      this._doc = _doc;
      // Maps all registered host nodes to a list of style nodes that have been added to the host node.
      this._hostNodes = new Map();
      this._hostNodes.set(_doc.head, []);
    }
    _addStylesToHost(styles, host, styleNodes) {
      styles.forEach(style => {
        const styleEl = this._doc.createElement('style');
        styleEl.textContent = style;
        styleNodes.push(host.appendChild(styleEl));
      });
    }
    addHost(hostNode) {
      const styleNodes = [];
      this._addStylesToHost(this._stylesSet, hostNode, styleNodes);
      this._hostNodes.set(hostNode, styleNodes);
    }
    removeHost(hostNode) {
      const styleNodes = this._hostNodes.get(hostNode);
      if (styleNodes) {
        styleNodes.forEach(removeStyle);
      }
      this._hostNodes.delete(hostNode);
    }
    onStylesAdded(additions) {
      this._hostNodes.forEach((styleNodes, hostNode) => {
        this._addStylesToHost(additions, hostNode, styleNodes);
      });
    }
    ngOnDestroy() {
      this._hostNodes.forEach(styleNodes => styleNodes.forEach(removeStyle));
    }
  }
  DomSharedStylesHost.ɵfac = function DomSharedStylesHost_Factory(t) {
    return new (t || DomSharedStylesHost)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));
  };
  DomSharedStylesHost.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: DomSharedStylesHost,
    factory: DomSharedStylesHost.ɵfac
  });
  return DomSharedStylesHost;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
function removeStyle(styleNode) {
  (0,_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵgetDOM"])().remove(styleNode);
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const NAMESPACE_URIS = {
  'svg': 'http://www.w3.org/2000/svg',
  'xhtml': 'http://www.w3.org/1999/xhtml',
  'xlink': 'http://www.w3.org/1999/xlink',
  'xml': 'http://www.w3.org/XML/1998/namespace',
  'xmlns': 'http://www.w3.org/2000/xmlns/'
};
const COMPONENT_REGEX = /%COMP%/g;
const NG_DEV_MODE = typeof ngDevMode === 'undefined' || !!ngDevMode;
const COMPONENT_VARIABLE = '%COMP%';
const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
function shimContentAttribute(componentShortId) {
  return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function shimHostAttribute(componentShortId) {
  return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function flattenStyles(compId, styles, target) {
  for (let i = 0; i < styles.length; i++) {
    let style = styles[i];
    if (Array.isArray(style)) {
      flattenStyles(compId, style, target);
    } else {
      style = style.replace(COMPONENT_REGEX, compId);
      target.push(style);
    }
  }
  return target;
}
function decoratePreventDefault(eventHandler) {
  // `DebugNode.triggerEventHandler` needs to know if the listener was created with
  // decoratePreventDefault or is a listener added outside the Angular context so it can handle the
  // two differently. In the first case, the special '__ngUnwrap__' token is passed to the unwrap
  // the listener (see below).
  return event => {
    // Ivy uses '__ngUnwrap__' as a special token that allows us to unwrap the function
    // so that it can be invoked programmatically by `DebugNode.triggerEventHandler`. The debug_node
    // can inspect the listener toString contents for the existence of this special token. Because
    // the token is a string literal, it is ensured to not be modified by compiled code.
    if (event === '__ngUnwrap__') {
      return eventHandler;
    }
    const allowDefaultBehavior = eventHandler(event);
    if (allowDefaultBehavior === false) {
      // TODO(tbosch): move preventDefault into event plugins...
      event.preventDefault();
      event.returnValue = false;
    }
    return undefined;
  };
}
let hasLoggedNativeEncapsulationWarning = false;
let DomRendererFactory2 = /*#__PURE__*/(() => {
  class DomRendererFactory2 {
    constructor(eventManager, sharedStylesHost, appId) {
      this.eventManager = eventManager;
      this.sharedStylesHost = sharedStylesHost;
      this.appId = appId;
      this.rendererByCompId = new Map();
      this.defaultRenderer = new DefaultDomRenderer2(eventManager);
    }
    createRenderer(element, type) {
      if (!element || !type) {
        return this.defaultRenderer;
      }
      switch (type.encapsulation) {
        case _angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewEncapsulation.Emulated:
          {
            let renderer = this.rendererByCompId.get(type.id);
            if (!renderer) {
              renderer = new EmulatedEncapsulationDomRenderer2(this.eventManager, this.sharedStylesHost, type, this.appId);
              this.rendererByCompId.set(type.id, renderer);
            }
            renderer.applyToHost(element);
            return renderer;
          }
        // @ts-ignore TODO: Remove as part of FW-2290. TS complains about us dealing with an enum
        // value that is not known (but previously was the value for ViewEncapsulation.Native)
        case 1:
        case _angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewEncapsulation.ShadowDom:
          // TODO(FW-2290): remove the `case 1:` fallback logic and the warning in v12.
          if ((typeof ngDevMode === 'undefined' || ngDevMode) &&
          // @ts-ignore TODO: Remove as part of FW-2290. TS complains about us dealing with an
          // enum value that is not known (but previously was the value for
          // ViewEncapsulation.Native)
          !hasLoggedNativeEncapsulationWarning && type.encapsulation === 1) {
            hasLoggedNativeEncapsulationWarning = true;
            console.warn('ViewEncapsulation.Native is no longer supported. Falling back to ViewEncapsulation.ShadowDom. The fallback will be removed in v12.');
          }
          return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);
        default:
          {
            if (!this.rendererByCompId.has(type.id)) {
              const styles = flattenStyles(type.id, type.styles, []);
              this.sharedStylesHost.addStyles(styles);
              this.rendererByCompId.set(type.id, this.defaultRenderer);
            }
            return this.defaultRenderer;
          }
      }
    }
    begin() {}
    end() {}
  }
  DomRendererFactory2.ɵfac = function DomRendererFactory2_Factory(t) {
    return new (t || DomRendererFactory2)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](EventManager), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](DomSharedStylesHost), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_ID));
  };
  DomRendererFactory2.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: DomRendererFactory2,
    factory: DomRendererFactory2.ɵfac
  });
  return DomRendererFactory2;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
class DefaultDomRenderer2 {
  constructor(eventManager) {
    this.eventManager = eventManager;
    this.data = Object.create(null);
  }
  destroy() {}
  createElement(name, namespace) {
    if (namespace) {
      // In cases where Ivy (not ViewEngine) is giving us the actual namespace, the look up by key
      // will result in undefined, so we just return the namespace here.
      return document.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);
    }
    return document.createElement(name);
  }
  createComment(value) {
    return document.createComment(value);
  }
  createText(value) {
    return document.createTextNode(value);
  }
  appendChild(parent, newChild) {
    parent.appendChild(newChild);
  }
  insertBefore(parent, newChild, refChild) {
    if (parent) {
      parent.insertBefore(newChild, refChild);
    }
  }
  removeChild(parent, oldChild) {
    if (parent) {
      parent.removeChild(oldChild);
    }
  }
  selectRootElement(selectorOrNode, preserveContent) {
    let el = typeof selectorOrNode === 'string' ? document.querySelector(selectorOrNode) : selectorOrNode;
    if (!el) {
      throw new Error(`The selector "${selectorOrNode}" did not match any elements`);
    }
    if (!preserveContent) {
      el.textContent = '';
    }
    return el;
  }
  parentNode(node) {
    return node.parentNode;
  }
  nextSibling(node) {
    return node.nextSibling;
  }
  setAttribute(el, name, value, namespace) {
    if (namespace) {
      name = namespace + ':' + name;
      // TODO(FW-811): Ivy may cause issues here because it's passing around
      // full URIs for namespaces, therefore this lookup will fail.
      const namespaceUri = NAMESPACE_URIS[namespace];
      if (namespaceUri) {
        el.setAttributeNS(namespaceUri, name, value);
      } else {
        el.setAttribute(name, value);
      }
    } else {
      el.setAttribute(name, value);
    }
  }
  removeAttribute(el, name, namespace) {
    if (namespace) {
      // TODO(FW-811): Ivy may cause issues here because it's passing around
      // full URIs for namespaces, therefore this lookup will fail.
      const namespaceUri = NAMESPACE_URIS[namespace];
      if (namespaceUri) {
        el.removeAttributeNS(namespaceUri, name);
      } else {
        // TODO(FW-811): Since ivy is passing around full URIs for namespaces
        // this could result in properties like `http://www.w3.org/2000/svg:cx="123"`,
        // which is wrong.
        el.removeAttribute(`${namespace}:${name}`);
      }
    } else {
      el.removeAttribute(name);
    }
  }
  addClass(el, name) {
    el.classList.add(name);
  }
  removeClass(el, name) {
    el.classList.remove(name);
  }
  setStyle(el, style, value, flags) {
    if (flags & (_angular_core__WEBPACK_IMPORTED_MODULE_1__.RendererStyleFlags2.DashCase | _angular_core__WEBPACK_IMPORTED_MODULE_1__.RendererStyleFlags2.Important)) {
      el.style.setProperty(style, value, flags & _angular_core__WEBPACK_IMPORTED_MODULE_1__.RendererStyleFlags2.Important ? 'important' : '');
    } else {
      el.style[style] = value;
    }
  }
  removeStyle(el, style, flags) {
    if (flags & _angular_core__WEBPACK_IMPORTED_MODULE_1__.RendererStyleFlags2.DashCase) {
      el.style.removeProperty(style);
    } else {
      // IE requires '' instead of null
      // see https://github.com/angular/angular/issues/7916
      el.style[style] = '';
    }
  }
  setProperty(el, name, value) {
    NG_DEV_MODE && checkNoSyntheticProp(name, 'property');
    el[name] = value;
  }
  setValue(node, value) {
    node.nodeValue = value;
  }
  listen(target, event, callback) {
    NG_DEV_MODE && checkNoSyntheticProp(event, 'listener');
    if (typeof target === 'string') {
      return this.eventManager.addGlobalEventListener(target, event, decoratePreventDefault(callback));
    }
    return this.eventManager.addEventListener(target, event, decoratePreventDefault(callback));
  }
}
const ɵ0$1 = () => '@'.charCodeAt(0);
const AT_CHARCODE = /*#__PURE__*/ɵ0$1();
function checkNoSyntheticProp(name, nameKind) {
  if (name.charCodeAt(0) === AT_CHARCODE) {
    throw new Error(`Unexpected synthetic ${nameKind} ${name} found. Please make sure that:
  - Either \`BrowserAnimationsModule\` or \`NoopAnimationsModule\` are imported in your application.
  - There is corresponding configuration for the animation named \`${name}\` defined in the \`animations\` field of the \`@Component\` decorator (see https://angular.io/api/core/Component#animations).`);
  }
}
class EmulatedEncapsulationDomRenderer2 extends DefaultDomRenderer2 {
  constructor(eventManager, sharedStylesHost, component, appId) {
    super(eventManager);
    this.component = component;
    const styles = flattenStyles(appId + '-' + component.id, component.styles, []);
    sharedStylesHost.addStyles(styles);
    this.contentAttr = shimContentAttribute(appId + '-' + component.id);
    this.hostAttr = shimHostAttribute(appId + '-' + component.id);
  }
  applyToHost(element) {
    super.setAttribute(element, this.hostAttr, '');
  }
  createElement(parent, name) {
    const el = super.createElement(parent, name);
    super.setAttribute(el, this.contentAttr, '');
    return el;
  }
}
class ShadowDomRenderer extends DefaultDomRenderer2 {
  constructor(eventManager, sharedStylesHost, hostEl, component) {
    super(eventManager);
    this.sharedStylesHost = sharedStylesHost;
    this.hostEl = hostEl;
    this.shadowRoot = hostEl.attachShadow({
      mode: 'open'
    });
    this.sharedStylesHost.addHost(this.shadowRoot);
    const styles = flattenStyles(component.id, component.styles, []);
    for (let i = 0; i < styles.length; i++) {
      const styleEl = document.createElement('style');
      styleEl.textContent = styles[i];
      this.shadowRoot.appendChild(styleEl);
    }
  }
  nodeOrShadowRoot(node) {
    return node === this.hostEl ? this.shadowRoot : node;
  }
  destroy() {
    this.sharedStylesHost.removeHost(this.shadowRoot);
  }
  appendChild(parent, newChild) {
    return super.appendChild(this.nodeOrShadowRoot(parent), newChild);
  }
  insertBefore(parent, newChild, refChild) {
    return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);
  }
  removeChild(parent, oldChild) {
    return super.removeChild(this.nodeOrShadowRoot(parent), oldChild);
  }
  parentNode(node) {
    return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
let DomEventsPlugin = /*#__PURE__*/(() => {
  class DomEventsPlugin extends EventManagerPlugin {
    constructor(doc) {
      super(doc);
    }
    // This plugin should come last in the list of plugins, because it accepts all
    // events.
    supports(eventName) {
      return true;
    }
    addEventListener(element, eventName, handler) {
      element.addEventListener(eventName, handler, false);
      return () => this.removeEventListener(element, eventName, handler);
    }
    removeEventListener(target, eventName, callback) {
      return target.removeEventListener(eventName, callback);
    }
  }
  DomEventsPlugin.ɵfac = function DomEventsPlugin_Factory(t) {
    return new (t || DomEventsPlugin)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));
  };
  DomEventsPlugin.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: DomEventsPlugin,
    factory: DomEventsPlugin.ɵfac
  });
  return DomEventsPlugin;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Supported HammerJS recognizer event names.
 */
const EVENT_NAMES = {
  // pan
  'pan': true,
  'panstart': true,
  'panmove': true,
  'panend': true,
  'pancancel': true,
  'panleft': true,
  'panright': true,
  'panup': true,
  'pandown': true,
  // pinch
  'pinch': true,
  'pinchstart': true,
  'pinchmove': true,
  'pinchend': true,
  'pinchcancel': true,
  'pinchin': true,
  'pinchout': true,
  // press
  'press': true,
  'pressup': true,
  // rotate
  'rotate': true,
  'rotatestart': true,
  'rotatemove': true,
  'rotateend': true,
  'rotatecancel': true,
  // swipe
  'swipe': true,
  'swipeleft': true,
  'swiperight': true,
  'swipeup': true,
  'swipedown': true,
  // tap
  'tap': true,
  'doubletap': true
};
/**
 * DI token for providing [HammerJS](https://hammerjs.github.io/) support to Angular.
 * @see `HammerGestureConfig`
 *
 * @ngModule HammerModule
 * @publicApi
 */
const HAMMER_GESTURE_CONFIG = /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('HammerGestureConfig');
/**
 * Injection token used to provide a {@link HammerLoader} to Angular.
 *
 * @publicApi
 */
const HAMMER_LOADER = /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('HammerLoader');
/**
 * An injectable [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)
 * for gesture recognition. Configures specific event recognition.
 * @publicApi
 */
let HammerGestureConfig = /*#__PURE__*/(() => {
  class HammerGestureConfig {
    constructor() {
      /**
       * A set of supported event names for gestures to be used in Angular.
       * Angular supports all built-in recognizers, as listed in
       * [HammerJS documentation](https://hammerjs.github.io/).
       */
      this.events = [];
      /**
       * Maps gesture event names to a set of configuration options
       * that specify overrides to the default values for specific properties.
       *
       * The key is a supported event name to be configured,
       * and the options object contains a set of properties, with override values
       * to be applied to the named recognizer event.
       * For example, to disable recognition of the rotate event, specify
       *  `{"rotate": {"enable": false}}`.
       *
       * Properties that are not present take the HammerJS default values.
       * For information about which properties are supported for which events,
       * and their allowed and default values, see
       * [HammerJS documentation](https://hammerjs.github.io/).
       *
       */
      this.overrides = {};
    }
    /**
     * Creates a [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)
     * and attaches it to a given HTML element.
     * @param element The element that will recognize gestures.
     * @returns A HammerJS event-manager object.
     */
    buildHammer(element) {
      const mc = new Hammer(element, this.options);
      mc.get('pinch').set({
        enable: true
      });
      mc.get('rotate').set({
        enable: true
      });
      for (const eventName in this.overrides) {
        mc.get(eventName).set(this.overrides[eventName]);
      }
      return mc;
    }
  }
  HammerGestureConfig.ɵfac = function HammerGestureConfig_Factory(t) {
    return new (t || HammerGestureConfig)();
  };
  HammerGestureConfig.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: HammerGestureConfig,
    factory: HammerGestureConfig.ɵfac
  });
  return HammerGestureConfig;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * Event plugin that adds Hammer support to an application.
 *
 * @ngModule HammerModule
 */
let HammerGesturesPlugin = /*#__PURE__*/(() => {
  class HammerGesturesPlugin extends EventManagerPlugin {
    constructor(doc, _config, console, loader) {
      super(doc);
      this._config = _config;
      this.console = console;
      this.loader = loader;
      this._loaderPromise = null;
    }
    supports(eventName) {
      if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
        return false;
      }
      if (!window.Hammer && !this.loader) {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
          this.console.warn(`The "${eventName}" event cannot be bound because Hammer.JS is not ` + `loaded and no custom loader has been specified.`);
        }
        return false;
      }
      return true;
    }
    addEventListener(element, eventName, handler) {
      const zone = this.manager.getZone();
      eventName = eventName.toLowerCase();
      // If Hammer is not present but a loader is specified, we defer adding the event listener
      // until Hammer is loaded.
      if (!window.Hammer && this.loader) {
        this._loaderPromise = this._loaderPromise || this.loader();
        // This `addEventListener` method returns a function to remove the added listener.
        // Until Hammer is loaded, the returned function needs to *cancel* the registration rather
        // than remove anything.
        let cancelRegistration = false;
        let deregister = () => {
          cancelRegistration = true;
        };
        this._loaderPromise.then(() => {
          // If Hammer isn't actually loaded when the custom loader resolves, give up.
          if (!window.Hammer) {
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
              this.console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);
            }
            deregister = () => {};
            return;
          }
          if (!cancelRegistration) {
            // Now that Hammer is loaded and the listener is being loaded for real,
            // the deregistration function changes from canceling registration to removal.
            deregister = this.addEventListener(element, eventName, handler);
          }
        }).catch(() => {
          if (typeof ngDevMode === 'undefined' || ngDevMode) {
            this.console.warn(`The "${eventName}" event cannot be bound because the custom ` + `Hammer.JS loader failed.`);
          }
          deregister = () => {};
        });
        // Return a function that *executes* `deregister` (and not `deregister` itself) so that we
        // can change the behavior of `deregister` once the listener is added. Using a closure in
        // this way allows us to avoid any additional data structures to track listener removal.
        return () => {
          deregister();
        };
      }
      return zone.runOutsideAngular(() => {
        // Creating the manager bind events, must be done outside of angular
        const mc = this._config.buildHammer(element);
        const callback = function (eventObj) {
          zone.runGuarded(function () {
            handler(eventObj);
          });
        };
        mc.on(eventName, callback);
        return () => {
          mc.off(eventName, callback);
          // destroy mc to prevent memory leak
          if (typeof mc.destroy === 'function') {
            mc.destroy();
          }
        };
      });
    }
    isCustomEvent(eventName) {
      return this._config.events.indexOf(eventName) > -1;
    }
  }
  HammerGesturesPlugin.ɵfac = function HammerGesturesPlugin_Factory(t) {
    return new (t || HammerGesturesPlugin)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](HAMMER_GESTURE_CONFIG), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵConsole"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](HAMMER_LOADER, 8));
  };
  HammerGesturesPlugin.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: HammerGesturesPlugin,
    factory: HammerGesturesPlugin.ɵfac
  });
  return HammerGesturesPlugin;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * In Ivy, support for Hammer gestures is optional, so applications must
 * import the `HammerModule` at root to turn on support. This means that
 * Hammer-specific code can be tree-shaken away if not needed.
 */
const HAMMER_PROVIDERS__POST_R3__ = [];
/**
 * In View Engine, support for Hammer gestures is built-in by default.
 */
const HAMMER_PROVIDERS__PRE_R3__ = [{
  provide: EVENT_MANAGER_PLUGINS,
  useClass: HammerGesturesPlugin,
  multi: true,
  deps: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT, HAMMER_GESTURE_CONFIG, _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵConsole"], [/*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional(), HAMMER_LOADER]]
}, {
  provide: HAMMER_GESTURE_CONFIG,
  useClass: HammerGestureConfig,
  deps: []
}];
const HAMMER_PROVIDERS = HAMMER_PROVIDERS__POST_R3__;
/**
 * Adds support for HammerJS.
 *
 * Import this module at the root of your application so that Angular can work with
 * HammerJS to detect gesture events.
 *
 * Note that applications still need to include the HammerJS script itself. This module
 * simply sets up the coordination layer between HammerJS and Angular's EventManager.
 *
 * @publicApi
 */
let HammerModule = /*#__PURE__*/(() => {
  class HammerModule {}
  HammerModule.ɵfac = function HammerModule_Factory(t) {
    return new (t || HammerModule)();
  };
  HammerModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
    type: HammerModule
  });
  HammerModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
    providers: HAMMER_PROVIDERS__PRE_R3__
  });
  return HammerModule;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Defines supported modifiers for key events.
 */
const MODIFIER_KEYS = ['alt', 'control', 'meta', 'shift'];
const DOM_KEY_LOCATION_NUMPAD = 3;
// Map to convert some key or keyIdentifier values to what will be returned by getEventKey
const _keyMap = {
  // The following values are here for cross-browser compatibility and to match the W3C standard
  // cf https://www.w3.org/TR/DOM-Level-3-Events-key/
  '\b': 'Backspace',
  '\t': 'Tab',
  '\x7F': 'Delete',
  '\x1B': 'Escape',
  'Del': 'Delete',
  'Esc': 'Escape',
  'Left': 'ArrowLeft',
  'Right': 'ArrowRight',
  'Up': 'ArrowUp',
  'Down': 'ArrowDown',
  'Menu': 'ContextMenu',
  'Scroll': 'ScrollLock',
  'Win': 'OS'
};
// There is a bug in Chrome for numeric keypad keys:
// https://code.google.com/p/chromium/issues/detail?id=155654
// 1, 2, 3 ... are reported as A, B, C ...
const _chromeNumKeyPadMap = {
  'A': '1',
  'B': '2',
  'C': '3',
  'D': '4',
  'E': '5',
  'F': '6',
  'G': '7',
  'H': '8',
  'I': '9',
  'J': '*',
  'K': '+',
  'M': '-',
  'N': '.',
  'O': '/',
  '\x60': '0',
  '\x90': 'NumLock'
};
const ɵ0$2 = event => event.altKey,
  ɵ1 = event => event.ctrlKey,
  ɵ2 = event => event.metaKey,
  ɵ3 = event => event.shiftKey;
/**
 * Retrieves modifiers from key-event objects.
 */
const MODIFIER_KEY_GETTERS = {
  'alt': ɵ0$2,
  'control': ɵ1,
  'meta': ɵ2,
  'shift': ɵ3
};
/**
 * @publicApi
 * A browser plug-in that provides support for handling of key events in Angular.
 */
let KeyEventsPlugin = /*#__PURE__*/(() => {
  class KeyEventsPlugin extends EventManagerPlugin {
    /**
     * Initializes an instance of the browser plug-in.
     * @param doc The document in which key events will be detected.
     */
    constructor(doc) {
      super(doc);
    }
    /**
     * Reports whether a named key event is supported.
     * @param eventName The event name to query.
     * @return True if the named key event is supported.
     */
    supports(eventName) {
      return KeyEventsPlugin.parseEventName(eventName) != null;
    }
    /**
     * Registers a handler for a specific element and key event.
     * @param element The HTML element to receive event notifications.
     * @param eventName The name of the key event to listen for.
     * @param handler A function to call when the notification occurs. Receives the
     * event object as an argument.
     * @returns The key event that was registered.
     */
    addEventListener(element, eventName, handler) {
      const parsedEvent = KeyEventsPlugin.parseEventName(eventName);
      const outsideHandler = KeyEventsPlugin.eventCallback(parsedEvent['fullKey'], handler, this.manager.getZone());
      return this.manager.getZone().runOutsideAngular(() => {
        return (0,_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵgetDOM"])().onAndCancel(element, parsedEvent['domEventName'], outsideHandler);
      });
    }
    static parseEventName(eventName) {
      const parts = eventName.toLowerCase().split('.');
      const domEventName = parts.shift();
      if (parts.length === 0 || !(domEventName === 'keydown' || domEventName === 'keyup')) {
        return null;
      }
      const key = KeyEventsPlugin._normalizeKey(parts.pop());
      let fullKey = '';
      MODIFIER_KEYS.forEach(modifierName => {
        const index = parts.indexOf(modifierName);
        if (index > -1) {
          parts.splice(index, 1);
          fullKey += modifierName + '.';
        }
      });
      fullKey += key;
      if (parts.length != 0 || key.length === 0) {
        // returning null instead of throwing to let another plugin process the event
        return null;
      }
      // NOTE: Please don't rewrite this as so, as it will break JSCompiler property renaming.
      //       The code must remain in the `result['domEventName']` form.
      // return {domEventName, fullKey};
      const result = {};
      result['domEventName'] = domEventName;
      result['fullKey'] = fullKey;
      return result;
    }
    static getEventFullKey(event) {
      let fullKey = '';
      let key = getEventKey(event);
      key = key.toLowerCase();
      if (key === ' ') {
        key = 'space'; // for readability
      } else if (key === '.') {
        key = 'dot'; // because '.' is used as a separator in event names
      }

      MODIFIER_KEYS.forEach(modifierName => {
        if (modifierName != key) {
          const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
          if (modifierGetter(event)) {
            fullKey += modifierName + '.';
          }
        }
      });
      fullKey += key;
      return fullKey;
    }
    /**
     * Configures a handler callback for a key event.
     * @param fullKey The event name that combines all simultaneous keystrokes.
     * @param handler The function that responds to the key event.
     * @param zone The zone in which the event occurred.
     * @returns A callback function.
     */
    static eventCallback(fullKey, handler, zone) {
      return (event /** TODO #9100 */) => {
        if (KeyEventsPlugin.getEventFullKey(event) === fullKey) {
          zone.runGuarded(() => handler(event));
        }
      };
    }
    /** @internal */
    static _normalizeKey(keyName) {
      // TODO: switch to a Map if the mapping grows too much
      switch (keyName) {
        case 'esc':
          return 'escape';
        default:
          return keyName;
      }
    }
  }
  KeyEventsPlugin.ɵfac = function KeyEventsPlugin_Factory(t) {
    return new (t || KeyEventsPlugin)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));
  };
  KeyEventsPlugin.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: KeyEventsPlugin,
    factory: KeyEventsPlugin.ɵfac
  });
  return KeyEventsPlugin;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
function getEventKey(event) {
  let key = event.key;
  if (key == null) {
    key = event.keyIdentifier;
    // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and
    // Safari cf
    // https://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces
    if (key == null) {
      return 'Unidentified';
    }
    if (key.startsWith('U+')) {
      key = String.fromCharCode(parseInt(key.substring(2), 16));
      if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
        // There is a bug in Chrome for numeric keypad keys:
        // https://code.google.com/p/chromium/issues/detail?id=155654
        // 1, 2, 3 ... are reported as A, B, C ...
        key = _chromeNumKeyPadMap[key];
      }
    }
  }
  return _keyMap[key] || key;
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing
 * values to be safe to use in the different DOM contexts.
 *
 * For example, when binding a URL in an `<a [href]="someValue">` hyperlink, `someValue` will be
 * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on
 * the website.
 *
 * In specific situations, it might be necessary to disable sanitization, for example if the
 * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.
 * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`
 * methods, and then binding to that value from the template.
 *
 * These situations should be very rare, and extraordinary care must be taken to avoid creating a
 * Cross Site Scripting (XSS) security bug!
 *
 * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as
 * close as possible to the source of the value, to make it easy to verify no security bug is
 * created by its use.
 *
 * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that
 * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous
 * code. The sanitizer leaves safe values intact.
 *
 * @security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in
 * sanitization for the value passed in. Carefully check and audit all values and code paths going
 * into this call. Make sure any user data is appropriately escaped for this security context.
 * For more detail, see the [Security Guide](https://g.co/ng/security).
 *
 * @publicApi
 */
let DomSanitizer = /*#__PURE__*/(() => {
  class DomSanitizer {}
  DomSanitizer.ɵfac = function DomSanitizer_Factory(t) {
    return new (t || DomSanitizer)();
  };
  DomSanitizer.ɵprov = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    factory: function DomSanitizer_Factory() {
      return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(DomSanitizerImpl);
    },
    token: DomSanitizer,
    providedIn: "root"
  });
  return DomSanitizer;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
function domSanitizerImplFactory(injector) {
  return new DomSanitizerImpl(injector.get(_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));
}
let DomSanitizerImpl = /*#__PURE__*/(() => {
  class DomSanitizerImpl extends DomSanitizer {
    constructor(_doc) {
      super();
      this._doc = _doc;
    }
    sanitize(ctx, value) {
      if (value == null) return null;
      switch (ctx) {
        case _angular_core__WEBPACK_IMPORTED_MODULE_1__.SecurityContext.NONE:
          return value;
        case _angular_core__WEBPACK_IMPORTED_MODULE_1__.SecurityContext.HTML:
          if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵallowSanitizationBypassAndThrow"])(value, "HTML" /* Html */)) {
            return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵunwrapSafeValue"])(value);
          }
          return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵ_sanitizeHtml"])(this._doc, String(value)).toString();
        case _angular_core__WEBPACK_IMPORTED_MODULE_1__.SecurityContext.STYLE:
          if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵallowSanitizationBypassAndThrow"])(value, "Style" /* Style */)) {
            return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵunwrapSafeValue"])(value);
          }
          return value;
        case _angular_core__WEBPACK_IMPORTED_MODULE_1__.SecurityContext.SCRIPT:
          if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵallowSanitizationBypassAndThrow"])(value, "Script" /* Script */)) {
            return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵunwrapSafeValue"])(value);
          }
          throw new Error('unsafe value used in a script context');
        case _angular_core__WEBPACK_IMPORTED_MODULE_1__.SecurityContext.URL:
          const type = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵgetSanitizationBypassType"])(value);
          if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵallowSanitizationBypassAndThrow"])(value, "URL" /* Url */)) {
            return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵunwrapSafeValue"])(value);
          }
          return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵ_sanitizeUrl"])(String(value));
        case _angular_core__WEBPACK_IMPORTED_MODULE_1__.SecurityContext.RESOURCE_URL:
          if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵallowSanitizationBypassAndThrow"])(value, "ResourceURL" /* ResourceUrl */)) {
            return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵunwrapSafeValue"])(value);
          }
          throw new Error('unsafe value used in a resource URL context (see https://g.co/ng/security#xss)');
        default:
          throw new Error(`Unexpected SecurityContext ${ctx} (see https://g.co/ng/security#xss)`);
      }
    }
    bypassSecurityTrustHtml(value) {
      return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵbypassSanitizationTrustHtml"])(value);
    }
    bypassSecurityTrustStyle(value) {
      return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵbypassSanitizationTrustStyle"])(value);
    }
    bypassSecurityTrustScript(value) {
      return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵbypassSanitizationTrustScript"])(value);
    }
    bypassSecurityTrustUrl(value) {
      return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵbypassSanitizationTrustUrl"])(value);
    }
    bypassSecurityTrustResourceUrl(value) {
      return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵbypassSanitizationTrustResourceUrl"])(value);
    }
  }
  DomSanitizerImpl.ɵfac = function DomSanitizerImpl_Factory(t) {
    return new (t || DomSanitizerImpl)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));
  };
  DomSanitizerImpl.ɵprov = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    factory: function DomSanitizerImpl_Factory() {
      return domSanitizerImplFactory((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__.INJECTOR));
    },
    token: DomSanitizerImpl,
    providedIn: "root"
  });
  return DomSanitizerImpl;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function initDomAdapter() {
  BrowserDomAdapter.makeCurrent();
  BrowserGetTestability.init();
}
function errorHandler() {
  return new _angular_core__WEBPACK_IMPORTED_MODULE_1__.ErrorHandler();
}
function _document() {
  // Tell ivy about the global document
  (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetDocument"])(document);
  return document;
}
const ɵ0$3 = _angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵPLATFORM_BROWSER_ID"];
const INTERNAL_BROWSER_PLATFORM_PROVIDERS = [{
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_ID,
  useValue: ɵ0$3
}, {
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_INITIALIZER,
  useValue: initDomAdapter,
  multi: true
}, {
  provide: _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT,
  useFactory: _document,
  deps: []
}];
const BROWSER_SANITIZATION_PROVIDERS__PRE_R3__ = [{
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Sanitizer,
  useExisting: DomSanitizer
}, {
  provide: DomSanitizer,
  useClass: DomSanitizerImpl,
  deps: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]
}];
const BROWSER_SANITIZATION_PROVIDERS__POST_R3__ = [];
/**
 * @security Replacing built-in sanitization providers exposes the application to XSS risks.
 * Attacker-controlled data introduced by an unsanitized provider could expose your
 * application to XSS risks. For more detail, see the [Security Guide](https://g.co/ng/security).
 * @publicApi
 */
const BROWSER_SANITIZATION_PROVIDERS = BROWSER_SANITIZATION_PROVIDERS__POST_R3__;
/**
 * A factory function that returns a `PlatformRef` instance associated with browser service
 * providers.
 *
 * @publicApi
 */
const platformBrowser = /*#__PURE__*/(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.createPlatformFactory)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.platformCore, 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);
const BROWSER_MODULE_PROVIDERS = [BROWSER_SANITIZATION_PROVIDERS, {
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵINJECTOR_SCOPE"],
  useValue: 'root'
}, {
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ErrorHandler,
  useFactory: errorHandler,
  deps: []
}, {
  provide: EVENT_MANAGER_PLUGINS,
  useClass: DomEventsPlugin,
  multi: true,
  deps: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT, _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone, _angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_ID]
}, {
  provide: EVENT_MANAGER_PLUGINS,
  useClass: KeyEventsPlugin,
  multi: true,
  deps: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]
}, HAMMER_PROVIDERS, {
  provide: DomRendererFactory2,
  useClass: DomRendererFactory2,
  deps: [EventManager, DomSharedStylesHost, _angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_ID]
}, {
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.RendererFactory2,
  useExisting: DomRendererFactory2
}, {
  provide: SharedStylesHost,
  useExisting: DomSharedStylesHost
}, {
  provide: DomSharedStylesHost,
  useClass: DomSharedStylesHost,
  deps: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]
}, {
  provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Testability,
  useClass: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Testability,
  deps: [_angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone]
}, {
  provide: EventManager,
  useClass: EventManager,
  deps: [EVENT_MANAGER_PLUGINS, _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone]
}, {
  provide: _angular_common__WEBPACK_IMPORTED_MODULE_0__.XhrFactory,
  useClass: BrowserXhr,
  deps: []
}, ELEMENT_PROBE_PROVIDERS];
/**
 * Exports required infrastructure for all Angular apps.
 * Included by default in all Angular apps created with the CLI
 * `new` command.
 * Re-exports `CommonModule` and `ApplicationModule`, making their
 * exports and providers available to all apps.
 *
 * @publicApi
 */
let BrowserModule = /*#__PURE__*/(() => {
  class BrowserModule {
    constructor(parentModule) {
      if (parentModule) {
        throw new Error(`BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.`);
      }
    }
    /**
     * Configures a browser-based app to transition from a server-rendered app, if
     * one is present on the page.
     *
     * @param params An object containing an identifier for the app to transition.
     * The ID must match between the client and server versions of the app.
     * @returns The reconfigured `BrowserModule` to import into the app's root `AppModule`.
     */
    static withServerTransition(params) {
      return {
        ngModule: BrowserModule,
        providers: [{
          provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_ID,
          useValue: params.appId
        }, {
          provide: TRANSITION_ID,
          useExisting: _angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_ID
        }, SERVER_TRANSITION_PROVIDERS]
      };
    }
  }
  BrowserModule.ɵfac = function BrowserModule_Factory(t) {
    return new (t || BrowserModule)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](BrowserModule, 12));
  };
  BrowserModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
    type: BrowserModule
  });
  BrowserModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
    providers: BROWSER_MODULE_PROVIDERS,
    imports: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.CommonModule, _angular_core__WEBPACK_IMPORTED_MODULE_1__.ApplicationModule]
  });
  return BrowserModule;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/*#__PURE__*/(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵsetNgModuleScope"](BrowserModule, {
    exports: function () {
      return [_angular_common__WEBPACK_IMPORTED_MODULE_0__.CommonModule, _angular_core__WEBPACK_IMPORTED_MODULE_1__.ApplicationModule];
    }
  });
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Factory to create a `Meta` service instance for the current DOM document.
 */
function createMeta() {
  return new Meta((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));
}
/**
 * A service for managing HTML `<meta>` tags.
 *
 * Properties of the `MetaDefinition` object match the attributes of the
 * HTML `<meta>` tag. These tags define document metadata that is important for
 * things like configuring a Content Security Policy, defining browser compatibility
 * and security settings, setting HTTP Headers, defining rich content for social sharing,
 * and Search Engine Optimization (SEO).
 *
 * To identify specific `<meta>` tags in a document, use an attribute selection
 * string in the format `"tag_attribute='value string'"`.
 * For example, an `attrSelector` value of `"name='description'"` matches a tag
 * whose `name` attribute has the value `"description"`.
 * Selectors are used with the `querySelector()` Document method,
 * in the format `meta[{attrSelector}]`.
 *
 * @see [HTML meta tag](https://developer.mozilla.org/docs/Web/HTML/Element/meta)
 * @see [Document.querySelector()](https://developer.mozilla.org/docs/Web/API/Document/querySelector)
 *
 *
 * @publicApi
 */
let Meta = /*#__PURE__*/(() => {
  class Meta {
    constructor(_doc) {
      this._doc = _doc;
      this._dom = (0,_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵgetDOM"])();
    }
    /**
     * Retrieves or creates a specific `<meta>` tag element in the current HTML document.
     * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute
     * values in the provided tag definition, and verifies that all other attribute values are equal.
     * If an existing element is found, it is returned and is not modified in any way.
     * @param tag The definition of a `<meta>` element to match or create.
     * @param forceCreation True to create a new element without checking whether one already exists.
     * @returns The existing element with the same attributes and values if found,
     * the new element if no match is found, or `null` if the tag parameter is not defined.
     */
    addTag(tag, forceCreation = false) {
      if (!tag) return null;
      return this._getOrCreateElement(tag, forceCreation);
    }
    /**
     * Retrieves or creates a set of `<meta>` tag elements in the current HTML document.
     * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute
     * values in the provided tag definition, and verifies that all other attribute values are equal.
     * @param tags An array of tag definitions to match or create.
     * @param forceCreation True to create new elements without checking whether they already exist.
     * @returns The matching elements if found, or the new elements.
     */
    addTags(tags, forceCreation = false) {
      if (!tags) return [];
      return tags.reduce((result, tag) => {
        if (tag) {
          result.push(this._getOrCreateElement(tag, forceCreation));
        }
        return result;
      }, []);
    }
    /**
     * Retrieves a `<meta>` tag element in the current HTML document.
     * @param attrSelector The tag attribute and value to match against, in the format
     * `"tag_attribute='value string'"`.
     * @returns The matching element, if any.
     */
    getTag(attrSelector) {
      if (!attrSelector) return null;
      return this._doc.querySelector(`meta[${attrSelector}]`) || null;
    }
    /**
     * Retrieves a set of `<meta>` tag elements in the current HTML document.
     * @param attrSelector The tag attribute and value to match against, in the format
     * `"tag_attribute='value string'"`.
     * @returns The matching elements, if any.
     */
    getTags(attrSelector) {
      if (!attrSelector) return [];
      const list /*NodeList*/ = this._doc.querySelectorAll(`meta[${attrSelector}]`);
      return list ? [].slice.call(list) : [];
    }
    /**
     * Modifies an existing `<meta>` tag element in the current HTML document.
     * @param tag The tag description with which to replace the existing tag content.
     * @param selector A tag attribute and value to match against, to identify
     * an existing tag. A string in the format `"tag_attribute=`value string`"`.
     * If not supplied, matches a tag with the same `name` or `property` attribute value as the
     * replacement tag.
     * @return The modified element.
     */
    updateTag(tag, selector) {
      if (!tag) return null;
      selector = selector || this._parseSelector(tag);
      const meta = this.getTag(selector);
      if (meta) {
        return this._setMetaElementAttributes(tag, meta);
      }
      return this._getOrCreateElement(tag, true);
    }
    /**
     * Removes an existing `<meta>` tag element from the current HTML document.
     * @param attrSelector A tag attribute and value to match against, to identify
     * an existing tag. A string in the format `"tag_attribute=`value string`"`.
     */
    removeTag(attrSelector) {
      this.removeTagElement(this.getTag(attrSelector));
    }
    /**
     * Removes an existing `<meta>` tag element from the current HTML document.
     * @param meta The tag definition to match against to identify an existing tag.
     */
    removeTagElement(meta) {
      if (meta) {
        this._dom.remove(meta);
      }
    }
    _getOrCreateElement(meta, forceCreation = false) {
      if (!forceCreation) {
        const selector = this._parseSelector(meta);
        // It's allowed to have multiple elements with the same name so it's not enough to
        // just check that element with the same name already present on the page. We also need to
        // check if element has tag attributes
        const elem = this.getTags(selector).filter(elem => this._containsAttributes(meta, elem))[0];
        if (elem !== undefined) return elem;
      }
      const element = this._dom.createElement('meta');
      this._setMetaElementAttributes(meta, element);
      const head = this._doc.getElementsByTagName('head')[0];
      head.appendChild(element);
      return element;
    }
    _setMetaElementAttributes(tag, el) {
      Object.keys(tag).forEach(prop => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]));
      return el;
    }
    _parseSelector(tag) {
      const attr = tag.name ? 'name' : 'property';
      return `${attr}="${tag[attr]}"`;
    }
    _containsAttributes(tag, elem) {
      return Object.keys(tag).every(key => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]);
    }
    _getMetaKeyMap(prop) {
      return META_KEYS_MAP[prop] || prop;
    }
  }
  Meta.ɵfac = function Meta_Factory(t) {
    return new (t || Meta)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));
  };
  Meta.ɵprov = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    factory: createMeta,
    token: Meta,
    providedIn: "root"
  });
  return Meta;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * Mapping for MetaDefinition properties with their correct meta attribute names
 */
const META_KEYS_MAP = {
  httpEquiv: 'http-equiv'
};

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Factory to create Title service.
 */
function createTitle() {
  return new Title((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));
}
/**
 * A service that can be used to get and set the title of a current HTML document.
 *
 * Since an Angular application can't be bootstrapped on the entire HTML document (`<html>` tag)
 * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements
 * (representing the `<title>` tag). Instead, this service can be used to set and get the current
 * title value.
 *
 * @publicApi
 */
let Title = /*#__PURE__*/(() => {
  class Title {
    constructor(_doc) {
      this._doc = _doc;
    }
    /**
     * Get the title of the current HTML document.
     */
    getTitle() {
      return this._doc.title;
    }
    /**
     * Set the title of the current HTML document.
     * @param newTitle
     */
    setTitle(newTitle) {
      this._doc.title = newTitle || '';
    }
  }
  Title.ɵfac = function Title_Factory(t) {
    return new (t || Title)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));
  };
  Title.ɵprov = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
    factory: createTitle,
    token: Title,
    providedIn: "root"
  });
  return Title;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const win = typeof window !== 'undefined' && window || {};

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class ChangeDetectionPerfRecord {
  constructor(msPerTick, numTicks) {
    this.msPerTick = msPerTick;
    this.numTicks = numTicks;
  }
}
/**
 * Entry point for all Angular profiling-related debug tools. This object
 * corresponds to the `ng.profiler` in the dev console.
 */
class AngularProfiler {
  constructor(ref) {
    this.appRef = ref.injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_1__.ApplicationRef);
  }
  // tslint:disable:no-console
  /**
   * Exercises change detection in a loop and then prints the average amount of
   * time in milliseconds how long a single round of change detection takes for
   * the current state of the UI. It runs a minimum of 5 rounds for a minimum
   * of 500 milliseconds.
   *
   * Optionally, a user may pass a `config` parameter containing a map of
   * options. Supported options are:
   *
   * `record` (boolean) - causes the profiler to record a CPU profile while
   * it exercises the change detector. Example:
   *
   * ```
   * ng.profiler.timeChangeDetection({record: true})
   * ```
   */
  timeChangeDetection(config) {
    const record = config && config['record'];
    const profileName = 'Change Detection';
    // Profiler is not available in Android browsers without dev tools opened
    const isProfilerAvailable = win.console.profile != null;
    if (record && isProfilerAvailable) {
      win.console.profile(profileName);
    }
    const start = performanceNow();
    let numTicks = 0;
    while (numTicks < 5 || performanceNow() - start < 500) {
      this.appRef.tick();
      numTicks++;
    }
    const end = performanceNow();
    if (record && isProfilerAvailable) {
      win.console.profileEnd(profileName);
    }
    const msPerTick = (end - start) / numTicks;
    win.console.log(`ran ${numTicks} change detection cycles`);
    win.console.log(`${msPerTick.toFixed(2)} ms per check`);
    return new ChangeDetectionPerfRecord(msPerTick, numTicks);
  }
}
function performanceNow() {
  return win.performance && win.performance.now ? win.performance.now() : new Date().getTime();
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const PROFILER_GLOBAL_NAME = 'profiler';
/**
 * Enabled Angular debug tools that are accessible via your browser's
 * developer console.
 *
 * Usage:
 *
 * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)
 * 1. Type `ng.` (usually the console will show auto-complete suggestion)
 * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`
 *    then hit Enter.
 *
 * @publicApi
 */
function enableDebugTools(ref) {
  exportNgVar(PROFILER_GLOBAL_NAME, new AngularProfiler(ref));
  return ref;
}
/**
 * Disables Angular tools.
 *
 * @publicApi
 */
function disableDebugTools() {
  exportNgVar(PROFILER_GLOBAL_NAME, null);
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function escapeHtml(text) {
  const escapedText = {
    '&': '&a;',
    '"': '&q;',
    '\'': '&s;',
    '<': '&l;',
    '>': '&g;'
  };
  return text.replace(/[&"'<>]/g, s => escapedText[s]);
}
function unescapeHtml(text) {
  const unescapedText = {
    '&a;': '&',
    '&q;': '"',
    '&s;': '\'',
    '&l;': '<',
    '&g;': '>'
  };
  return text.replace(/&[^;]+;/g, s => unescapedText[s]);
}
/**
 * Create a `StateKey<T>` that can be used to store value of type T with `TransferState`.
 *
 * Example:
 *
 * ```
 * const COUNTER_KEY = makeStateKey<number>('counter');
 * let value = 10;
 *
 * transferState.set(COUNTER_KEY, value);
 * ```
 *
 * @publicApi
 */
function makeStateKey(key) {
  return key;
}
/**
 * A key value store that is transferred from the application on the server side to the application
 * on the client side.
 *
 * `TransferState` will be available as an injectable token. To use it import
 * `ServerTransferStateModule` on the server and `BrowserTransferStateModule` on the client.
 *
 * The values in the store are serialized/deserialized using JSON.stringify/JSON.parse. So only
 * boolean, number, string, null and non-class objects will be serialized and deserialized in a
 * non-lossy manner.
 *
 * @publicApi
 */
let TransferState = /*#__PURE__*/(() => {
  class TransferState {
    constructor() {
      this.store = {};
      this.onSerializeCallbacks = {};
    }
    /** @internal */
    static init(initState) {
      const transferState = new TransferState();
      transferState.store = initState;
      return transferState;
    }
    /**
     * Get the value corresponding to a key. Return `defaultValue` if key is not found.
     */
    get(key, defaultValue) {
      return this.store[key] !== undefined ? this.store[key] : defaultValue;
    }
    /**
     * Set the value corresponding to a key.
     */
    set(key, value) {
      this.store[key] = value;
    }
    /**
     * Remove a key from the store.
     */
    remove(key) {
      delete this.store[key];
    }
    /**
     * Test whether a key exists in the store.
     */
    hasKey(key) {
      return this.store.hasOwnProperty(key);
    }
    /**
     * Register a callback to provide the value for a key when `toJson` is called.
     */
    onSerialize(key, callback) {
      this.onSerializeCallbacks[key] = callback;
    }
    /**
     * Serialize the current state of the store to JSON.
     */
    toJson() {
      // Call the onSerialize callbacks and put those values into the store.
      for (const key in this.onSerializeCallbacks) {
        if (this.onSerializeCallbacks.hasOwnProperty(key)) {
          try {
            this.store[key] = this.onSerializeCallbacks[key]();
          } catch (e) {
            console.warn('Exception in onSerialize callback: ', e);
          }
        }
      }
      return JSON.stringify(this.store);
    }
  }
  TransferState.ɵfac = function TransferState_Factory(t) {
    return new (t || TransferState)();
  };
  TransferState.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: TransferState,
    factory: TransferState.ɵfac
  });
  return TransferState;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
function initTransferState(doc, appId) {
  // Locate the script tag with the JSON data transferred from the server.
  // The id of the script tag is set to the Angular appId + 'state'.
  const script = doc.getElementById(appId + '-state');
  let initialState = {};
  if (script && script.textContent) {
    try {
      // Avoid using any here as it triggers lint errors in google3 (any is not allowed).
      initialState = JSON.parse(unescapeHtml(script.textContent));
    } catch (e) {
      console.warn('Exception while restoring TransferState for app ' + appId, e);
    }
  }
  return TransferState.init(initialState);
}
/**
 * NgModule to install on the client side while using the `TransferState` to transfer state from
 * server to client.
 *
 * @publicApi
 */
let BrowserTransferStateModule = /*#__PURE__*/(() => {
  class BrowserTransferStateModule {}
  BrowserTransferStateModule.ɵfac = function BrowserTransferStateModule_Factory(t) {
    return new (t || BrowserTransferStateModule)();
  };
  BrowserTransferStateModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
    type: BrowserTransferStateModule
  });
  BrowserTransferStateModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
    providers: [{
      provide: TransferState,
      useFactory: initTransferState,
      deps: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT, _angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_ID]
    }]
  });
  return BrowserTransferStateModule;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Predicates for use with {@link DebugElement}'s query functions.
 *
 * @publicApi
 */
class By {
  /**
   * Match all nodes.
   *
   * @usageNotes
   * ### Example
   *
   * {@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}
   */
  static all() {
    return () => true;
  }
  /**
   * Match elements by the given CSS selector.
   *
   * @usageNotes
   * ### Example
   *
   * {@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}
   */
  static css(selector) {
    return debugElement => {
      return debugElement.nativeElement != null ? elementMatches(debugElement.nativeElement, selector) : false;
    };
  }
  /**
   * Match nodes that have the given directive present.
   *
   * @usageNotes
   * ### Example
   *
   * {@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}
   */
  static directive(type) {
    return debugNode => debugNode.providerTokens.indexOf(type) !== -1;
  }
}
function elementMatches(n, selector) {
  if ((0,_angular_common__WEBPACK_IMPORTED_MODULE_0__["ɵgetDOM"])().isElementNode(n)) {
    return n.matches && n.matches(selector) || n.msMatchesSelector && n.msMatchesSelector(selector) || n.webkitMatchesSelector && n.webkitMatchesSelector(selector);
  }
  return false;
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @publicApi
 */
const VERSION = /*#__PURE__*/new _angular_core__WEBPACK_IMPORTED_MODULE_1__.Version('12.2.17');

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// This file only reexports content of the `src` folder. Keep it that way.

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=platform-browser.js.map

/***/ }),

/***/ 2579:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ct: () => (/* binding */ LOCATION),
/* harmony export */   H3: () => (/* binding */ LOCAL_STORAGE),
/* harmony export */   L1: () => (/* binding */ ANIMATION_FRAME),
/* harmony export */   UA: () => (/* binding */ HISTORY),
/* harmony export */   m9: () => (/* binding */ WINDOW),
/* harmony export */   s5: () => (/* binding */ NAVIGATOR),
/* harmony export */   ux: () => (/* binding */ CSS),
/* harmony export */   yZ: () => (/* binding */ USER_AGENT)
/* harmony export */ });
/* unused harmony exports CACHES, CRYPTO, MEDIA_DEVICES, NETWORK_INFORMATION, PAGE_VISIBILITY, PERFORMANCE, SESSION_STORAGE, SPEECH_RECOGNITION, SPEECH_SYNTHESIS */
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3008);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8891);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2759);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8819);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9761);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8002);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7519);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_1__);





/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const WINDOW = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over global window object', {
  factory: () => {
    const {
      defaultView
    } = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT);
    if (!defaultView) {
      throw new Error('Window is not available');
    }
    return defaultView;
  }
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ANIMATION_FRAME = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('Shared Observable based on `window.requestAnimationFrame`', {
  factory: () => {
    const {
      requestAnimationFrame,
      cancelAnimationFrame
    } = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(WINDOW);
    /** @type {?} */
    const animationFrame$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__/* .Observable */ .y(subscriber => {
      /** @type {?} */
      let id = NaN;
      /** @type {?} */
      const callback = timestamp => {
        subscriber.next(timestamp);
        id = requestAnimationFrame(callback);
      };
      id = requestAnimationFrame(callback);
      return () => {
        cancelAnimationFrame(id);
      };
    });
    return animationFrame$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__/* .share */ .B)());
  }
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CACHES = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.caches object', {
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(WINDOW).caches
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CRYPTO = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.crypto object', {
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(WINDOW).crypto
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CSS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.CSS object', {
  factory: () => /** @type {?} */(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(WINDOW).CSS || {
    escape: v => v,
    supports: () => false
  }
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const HISTORY = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.history object', {
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(WINDOW).history
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOCAL_STORAGE = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.localStorage object', {
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(WINDOW).localStorage
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOCATION = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.location object', {
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(WINDOW).location
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NAVIGATOR = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.navigator object', {
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(WINDOW).navigator
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MEDIA_DEVICES = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.navigator.mediaDevices object', {
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(NAVIGATOR).mediaDevices
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NETWORK_INFORMATION = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.navigator.connection object', {
  // @ts-ignore
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(NAVIGATOR).connection || null
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PAGE_VISIBILITY = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('Shared Observable based on `document visibility changed`', {
  factory: () => {
    /** @type {?} */
    const documentRef = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT);
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_4__/* .fromEvent */ .R)(documentRef, 'visibilitychange').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__/* .startWith */ .O)(0), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__/* .map */ .U)(() => documentRef.visibilityState !== 'hidden'), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__/* .distinctUntilChanged */ .x)(), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__/* .share */ .B)());
  }
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PERFORMANCE = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.performance object', {
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(WINDOW).performance
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SESSION_STORAGE = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.sessionStorage object', {
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(WINDOW).sessionStorage
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SPEECH_RECOGNITION = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over SpeechRecognition class', {
  factory: () => {
    /** @type {?} */
    const windowRef = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(WINDOW);
    return windowRef.speechRecognition || windowRef.webkitSpeechRecognition || null;
  }
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SPEECH_SYNTHESIS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.speechSynthesis object', {
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(WINDOW).speechSynthesis
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const USER_AGENT = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('An abstraction over window.navigator.userAgent object', {
  factory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(NAVIGATOR).userAgent
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */



//# sourceMappingURL=ng-web-apis-common.js.map

/***/ }),

/***/ 6154:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Or: () => (/* binding */ TUI_DOC_LOGO),
  V5: () => (/* binding */ TUI_DOC_PAGES),
  fV: () => (/* binding */ TuiAddonDocModule),
  c0: () => (/* binding */ TuiDocCodeComponent),
  JF: () => (/* binding */ TuiDocCodeModule),
  zb: () => (/* binding */ TuiDocDocumentationComponent),
  B7: () => (/* binding */ TuiDocDocumentationPropertyConnectorDirective),
  $5: () => (/* binding */ TuiDocMainComponent),
  qn: () => (/* binding */ TuiDocMainModule),
  qo: () => (/* binding */ TuiDocPageComponent),
  Lq: () => (/* binding */ TuiDocPageModule),
  nj: () => (/* binding */ TuiDocPageTabConnectorDirective),
  iY: () => (/* binding */ generateRoutes)
});

// UNUSED EXPORTS: DEMO_TEXTS, DOC_TEXTS, EXAMPLE_TEXTS, ScrollIntoViewDirective, ScrollIntoViewModule, TUI_DOC_CODE_ACTIONS, TUI_DOC_CODE_EDITOR, TUI_DOC_DEFAULT_TABS, TUI_DOC_DEMO_TEXTS, TUI_DOC_DOCUMENTATION_TEXTS, TUI_DOC_EXAMPLE_CONTENT_PROCESSOR, TUI_DOC_EXAMPLE_TEXTS, TUI_DOC_MENU_TEXT, TUI_DOC_PAGE_LOADED, TUI_DOC_RUSSIAN, TUI_DOC_SCROLL_BEHAVIOR, TUI_DOC_SEARCH_TEXT, TUI_DOC_SEE_ALSO, TUI_DOC_SEE_ALSO_TEXT, TUI_DOC_SOURCE_CODE, TUI_DOC_SOURCE_CODE_TEXT, TUI_DOC_TITLE, TUI_EXAMPLE_PRIMARY_FILE_NAME, TuiDocCopyComponent, TuiDocCopyModule, TuiDocDemoComponent, TuiDocDemoModule, TuiDocDocumentationModule, TuiDocExampleComponent, TuiDocExampleModule, TuiDocNavigationComponent, TuiDocNavigationModule, TuiLanguageSwitcherComponent, TuiLanguageSwitcherModule, TuiScrollIntoViewLinkDirective, TuiScrollIntoViewLinkModule, coerceValue, rawLoad, rawLoadRecord, tryParseMarkdownCodeBlock, tuiCoerceValue, tuiGenerateRoutes, tuiRawLoad, tuiRawLoadRecord, tuiTryParseMarkdownCodeBlock, ɵa, ɵb, ɵc, ɵd, ɵe, ɵf, ɵg, ɵh, ɵi, ɵj, ɵk, ɵl, ɵm, ɵn, ɵo, ɵp, ɵq, ɵr, ɵs, ɵt

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.mjs
var tslib_es6 = __webpack_require__(7582);
// EXTERNAL MODULE: consume shared module (default) @angular/core@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/core/fesm2015/core.js)
var core_js_ = __webpack_require__(8312);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/isFunction.js
function isFunction(x) {
  return typeof x === 'function';
}
//# sourceMappingURL=isFunction.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/config.js
let _enable_super_gross_mode_that_will_cause_bad_things = false;
const config = {
  Promise: undefined,
  set useDeprecatedSynchronousErrorHandling(value) {
    if (value) {
      const error = new Error();
      console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
    } else if (_enable_super_gross_mode_that_will_cause_bad_things) {
      console.log('RxJS: Back to a better error behavior. Thank you. <3');
    }
    _enable_super_gross_mode_that_will_cause_bad_things = value;
  },
  get useDeprecatedSynchronousErrorHandling() {
    return _enable_super_gross_mode_that_will_cause_bad_things;
  }
};
//# sourceMappingURL=config.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/hostReportError.js
function hostReportError(err) {
  setTimeout(() => {
    throw err;
  }, 0);
}
//# sourceMappingURL=hostReportError.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/Observer.js


const empty = {
  closed: true,
  next(value) {},
  error(err) {
    if (config.useDeprecatedSynchronousErrorHandling) {
      throw err;
    } else {
      hostReportError(err);
    }
  },
  complete() {}
};
//# sourceMappingURL=Observer.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/isArray.js
const isArray = (() => Array.isArray || (x => x && typeof x.length === 'number'))();
//# sourceMappingURL=isArray.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/isObject.js
function isObject(x) {
  return x !== null && typeof x === 'object';
}
//# sourceMappingURL=isObject.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/UnsubscriptionError.js
const UnsubscriptionErrorImpl = (() => {
  function UnsubscriptionErrorImpl(errors) {
    Error.call(this);
    this.message = errors ? `${errors.length} errors occurred during unsubscription:
${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\n  ')}` : '';
    this.name = 'UnsubscriptionError';
    this.errors = errors;
    return this;
  }
  UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);
  return UnsubscriptionErrorImpl;
})();
const UnsubscriptionError = UnsubscriptionErrorImpl;
//# sourceMappingURL=UnsubscriptionError.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/Subscription.js




class Subscription {
  constructor(unsubscribe) {
    this.closed = false;
    this._parentOrParents = null;
    this._subscriptions = null;
    if (unsubscribe) {
      this._unsubscribe = unsubscribe;
    }
  }
  unsubscribe() {
    let errors;
    if (this.closed) {
      return;
    }
    let {
      _parentOrParents,
      _unsubscribe,
      _subscriptions
    } = this;
    this.closed = true;
    this._parentOrParents = null;
    this._subscriptions = null;
    if (_parentOrParents instanceof Subscription) {
      _parentOrParents.remove(this);
    } else if (_parentOrParents !== null) {
      for (let index = 0; index < _parentOrParents.length; ++index) {
        const parent = _parentOrParents[index];
        parent.remove(this);
      }
    }
    if (isFunction(_unsubscribe)) {
      try {
        _unsubscribe.call(this);
      } catch (e) {
        errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
      }
    }
    if (isArray(_subscriptions)) {
      let index = -1;
      let len = _subscriptions.length;
      while (++index < len) {
        const sub = _subscriptions[index];
        if (isObject(sub)) {
          try {
            sub.unsubscribe();
          } catch (e) {
            errors = errors || [];
            if (e instanceof UnsubscriptionError) {
              errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
            } else {
              errors.push(e);
            }
          }
        }
      }
    }
    if (errors) {
      throw new UnsubscriptionError(errors);
    }
  }
  add(teardown) {
    let subscription = teardown;
    if (!teardown) {
      return Subscription.EMPTY;
    }
    switch (typeof teardown) {
      case 'function':
        subscription = new Subscription(teardown);
      case 'object':
        if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
          return subscription;
        } else if (this.closed) {
          subscription.unsubscribe();
          return subscription;
        } else if (!(subscription instanceof Subscription)) {
          const tmp = subscription;
          subscription = new Subscription();
          subscription._subscriptions = [tmp];
        }
        break;
      default:
        {
          throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
    }
    let {
      _parentOrParents
    } = subscription;
    if (_parentOrParents === null) {
      subscription._parentOrParents = this;
    } else if (_parentOrParents instanceof Subscription) {
      if (_parentOrParents === this) {
        return subscription;
      }
      subscription._parentOrParents = [_parentOrParents, this];
    } else if (_parentOrParents.indexOf(this) === -1) {
      _parentOrParents.push(this);
    } else {
      return subscription;
    }
    const subscriptions = this._subscriptions;
    if (subscriptions === null) {
      this._subscriptions = [subscription];
    } else {
      subscriptions.push(subscription);
    }
    return subscription;
  }
  remove(subscription) {
    const subscriptions = this._subscriptions;
    if (subscriptions) {
      const subscriptionIndex = subscriptions.indexOf(subscription);
      if (subscriptionIndex !== -1) {
        subscriptions.splice(subscriptionIndex, 1);
      }
    }
  }
}
Subscription.EMPTY = function (empty) {
  empty.closed = true;
  return empty;
}(new Subscription());
function flattenUnsubscriptionErrors(errors) {
  return errors.reduce((errs, err) => errs.concat(err instanceof UnsubscriptionError ? err.errors : err), []);
}
//# sourceMappingURL=Subscription.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/symbol/rxSubscriber.js
const rxSubscriber = (() => typeof Symbol === 'function' ? Symbol('rxSubscriber') : '@@rxSubscriber_' + Math.random())();
const $$rxSubscriber = (/* unused pure expression or super */ null && (rxSubscriber));
//# sourceMappingURL=rxSubscriber.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/Subscriber.js






class Subscriber extends Subscription {
  constructor(destinationOrNext, error, complete) {
    super();
    this.syncErrorValue = null;
    this.syncErrorThrown = false;
    this.syncErrorThrowable = false;
    this.isStopped = false;
    switch (arguments.length) {
      case 0:
        this.destination = empty;
        break;
      case 1:
        if (!destinationOrNext) {
          this.destination = empty;
          break;
        }
        if (typeof destinationOrNext === 'object') {
          if (destinationOrNext instanceof Subscriber) {
            this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
            this.destination = destinationOrNext;
            destinationOrNext.add(this);
          } else {
            this.syncErrorThrowable = true;
            this.destination = new SafeSubscriber(this, destinationOrNext);
          }
          break;
        }
      default:
        this.syncErrorThrowable = true;
        this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
        break;
    }
  }
  [rxSubscriber]() {
    return this;
  }
  static create(next, error, complete) {
    const subscriber = new Subscriber(next, error, complete);
    subscriber.syncErrorThrowable = false;
    return subscriber;
  }
  next(value) {
    if (!this.isStopped) {
      this._next(value);
    }
  }
  error(err) {
    if (!this.isStopped) {
      this.isStopped = true;
      this._error(err);
    }
  }
  complete() {
    if (!this.isStopped) {
      this.isStopped = true;
      this._complete();
    }
  }
  unsubscribe() {
    if (this.closed) {
      return;
    }
    this.isStopped = true;
    super.unsubscribe();
  }
  _next(value) {
    this.destination.next(value);
  }
  _error(err) {
    this.destination.error(err);
    this.unsubscribe();
  }
  _complete() {
    this.destination.complete();
    this.unsubscribe();
  }
  _unsubscribeAndRecycle() {
    const {
      _parentOrParents
    } = this;
    this._parentOrParents = null;
    this.unsubscribe();
    this.closed = false;
    this.isStopped = false;
    this._parentOrParents = _parentOrParents;
    return this;
  }
}
class SafeSubscriber extends Subscriber {
  constructor(_parentSubscriber, observerOrNext, error, complete) {
    super();
    this._parentSubscriber = _parentSubscriber;
    let next;
    let context = this;
    if (isFunction(observerOrNext)) {
      next = observerOrNext;
    } else if (observerOrNext) {
      next = observerOrNext.next;
      error = observerOrNext.error;
      complete = observerOrNext.complete;
      if (observerOrNext !== empty) {
        context = Object.create(observerOrNext);
        if (isFunction(context.unsubscribe)) {
          this.add(context.unsubscribe.bind(context));
        }
        context.unsubscribe = this.unsubscribe.bind(this);
      }
    }
    this._context = context;
    this._next = next;
    this._error = error;
    this._complete = complete;
  }
  next(value) {
    if (!this.isStopped && this._next) {
      const {
        _parentSubscriber
      } = this;
      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
        this.__tryOrUnsub(this._next, value);
      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
        this.unsubscribe();
      }
    }
  }
  error(err) {
    if (!this.isStopped) {
      const {
        _parentSubscriber
      } = this;
      const {
        useDeprecatedSynchronousErrorHandling
      } = config;
      if (this._error) {
        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(this._error, err);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, this._error, err);
          this.unsubscribe();
        }
      } else if (!_parentSubscriber.syncErrorThrowable) {
        this.unsubscribe();
        if (useDeprecatedSynchronousErrorHandling) {
          throw err;
        }
        hostReportError(err);
      } else {
        if (useDeprecatedSynchronousErrorHandling) {
          _parentSubscriber.syncErrorValue = err;
          _parentSubscriber.syncErrorThrown = true;
        } else {
          hostReportError(err);
        }
        this.unsubscribe();
      }
    }
  }
  complete() {
    if (!this.isStopped) {
      const {
        _parentSubscriber
      } = this;
      if (this._complete) {
        const wrappedComplete = () => this._complete.call(this._context);
        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(wrappedComplete);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, wrappedComplete);
          this.unsubscribe();
        }
      } else {
        this.unsubscribe();
      }
    }
  }
  __tryOrUnsub(fn, value) {
    try {
      fn.call(this._context, value);
    } catch (err) {
      this.unsubscribe();
      if (config.useDeprecatedSynchronousErrorHandling) {
        throw err;
      } else {
        hostReportError(err);
      }
    }
  }
  __tryOrSetError(parent, fn, value) {
    if (!config.useDeprecatedSynchronousErrorHandling) {
      throw new Error('bad call');
    }
    try {
      fn.call(this._context, value);
    } catch (err) {
      if (config.useDeprecatedSynchronousErrorHandling) {
        parent.syncErrorValue = err;
        parent.syncErrorThrown = true;
        return true;
      } else {
        hostReportError(err);
        return true;
      }
    }
    return false;
  }
  _unsubscribe() {
    const {
      _parentSubscriber
    } = this;
    this._context = null;
    this._parentSubscriber = null;
    _parentSubscriber.unsubscribe();
  }
}
//# sourceMappingURL=Subscriber.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/canReportError.js

function canReportError(observer) {
  while (observer) {
    const {
      closed,
      destination,
      isStopped
    } = observer;
    if (closed || isStopped) {
      return false;
    } else if (destination && destination instanceof Subscriber) {
      observer = destination;
    } else {
      observer = null;
    }
  }
  return true;
}
//# sourceMappingURL=canReportError.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/toSubscriber.js



function toSubscriber(nextOrObserver, error, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof Subscriber) {
      return nextOrObserver;
    }
    if (nextOrObserver[rxSubscriber]) {
      return nextOrObserver[rxSubscriber]();
    }
  }
  if (!nextOrObserver && !error && !complete) {
    return new Subscriber(empty);
  }
  return new Subscriber(nextOrObserver, error, complete);
}
//# sourceMappingURL=toSubscriber.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/symbol/observable.js
const observable_observable = (() => typeof Symbol === 'function' && Symbol.observable || '@@observable')();
//# sourceMappingURL=observable.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/noop.js
function noop() {}
//# sourceMappingURL=noop.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/pipe.js

function pipe(...fns) {
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (!fns) {
    return noop;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce((prev, fn) => fn(prev), input);
  };
}
//# sourceMappingURL=pipe.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/Observable.js





let Observable = /*#__PURE__*/(() => {
  class Observable {
    constructor(subscribe) {
      this._isScalar = false;
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    lift(operator) {
      const observable = new Observable();
      observable.source = this;
      observable.operator = operator;
      return observable;
    }
    subscribe(observerOrNext, error, complete) {
      const {
        operator
      } = this;
      const sink = toSubscriber(observerOrNext, error, complete);
      if (operator) {
        sink.add(operator.call(sink, this.source));
      } else {
        sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
      }
      if (config.useDeprecatedSynchronousErrorHandling) {
        if (sink.syncErrorThrowable) {
          sink.syncErrorThrowable = false;
          if (sink.syncErrorThrown) {
            throw sink.syncErrorValue;
          }
        }
      }
      return sink;
    }
    _trySubscribe(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        if (config.useDeprecatedSynchronousErrorHandling) {
          sink.syncErrorThrown = true;
          sink.syncErrorValue = err;
        }
        if (canReportError(sink)) {
          sink.error(err);
        } else {
          console.warn(err);
        }
      }
    }
    forEach(next, promiseCtor) {
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor((resolve, reject) => {
        let subscription;
        subscription = this.subscribe(value => {
          try {
            next(value);
          } catch (err) {
            reject(err);
            if (subscription) {
              subscription.unsubscribe();
            }
          }
        }, reject, resolve);
      });
    }
    _subscribe(subscriber) {
      const {
        source
      } = this;
      return source && source.subscribe(subscriber);
    }
    [observable_observable]() {
      return this;
    }
    pipe(...operations) {
      if (operations.length === 0) {
        return this;
      }
      return pipeFromArray(operations)(this);
    }
    toPromise(promiseCtor) {
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor((resolve, reject) => {
        let value;
        this.subscribe(x => value = x, err => reject(err), () => resolve(value));
      });
    }
  }
  Observable.create = subscribe => {
    return new Observable(subscribe);
  };
  return Observable;
})();
function getPromiseCtor(promiseCtor) {
  if (!promiseCtor) {
    promiseCtor = config.Promise || Promise;
  }
  if (!promiseCtor) {
    throw new Error('no Promise impl found');
  }
  return promiseCtor;
}
//# sourceMappingURL=Observable.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/ObjectUnsubscribedError.js
const ObjectUnsubscribedErrorImpl = (() => {
  function ObjectUnsubscribedErrorImpl() {
    Error.call(this);
    this.message = 'object unsubscribed';
    this.name = 'ObjectUnsubscribedError';
    return this;
  }
  ObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);
  return ObjectUnsubscribedErrorImpl;
})();
const ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
//# sourceMappingURL=ObjectUnsubscribedError.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/SubjectSubscription.js

class SubjectSubscription extends Subscription {
  constructor(subject, subscriber) {
    super();
    this.subject = subject;
    this.subscriber = subscriber;
    this.closed = false;
  }
  unsubscribe() {
    if (this.closed) {
      return;
    }
    this.closed = true;
    const subject = this.subject;
    const observers = subject.observers;
    this.subject = null;
    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
      return;
    }
    const subscriberIndex = observers.indexOf(this.subscriber);
    if (subscriberIndex !== -1) {
      observers.splice(subscriberIndex, 1);
    }
  }
}
//# sourceMappingURL=SubjectSubscription.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/Subject.js






class SubjectSubscriber extends Subscriber {
  constructor(destination) {
    super(destination);
    this.destination = destination;
  }
}
let Subject = /*#__PURE__*/(() => {
  class Subject extends Observable {
    constructor() {
      super();
      this.observers = [];
      this.closed = false;
      this.isStopped = false;
      this.hasError = false;
      this.thrownError = null;
    }
    [rxSubscriber]() {
      return new SubjectSubscriber(this);
    }
    lift(operator) {
      const subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    }
    next(value) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
      if (!this.isStopped) {
        const {
          observers
        } = this;
        const len = observers.length;
        const copy = observers.slice();
        for (let i = 0; i < len; i++) {
          copy[i].next(value);
        }
      }
    }
    error(err) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
      this.hasError = true;
      this.thrownError = err;
      this.isStopped = true;
      const {
        observers
      } = this;
      const len = observers.length;
      const copy = observers.slice();
      for (let i = 0; i < len; i++) {
        copy[i].error(err);
      }
      this.observers.length = 0;
    }
    complete() {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
      this.isStopped = true;
      const {
        observers
      } = this;
      const len = observers.length;
      const copy = observers.slice();
      for (let i = 0; i < len; i++) {
        copy[i].complete();
      }
      this.observers.length = 0;
    }
    unsubscribe() {
      this.isStopped = true;
      this.closed = true;
      this.observers = null;
    }
    _trySubscribe(subscriber) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      } else {
        return super._trySubscribe(subscriber);
      }
    }
    _subscribe(subscriber) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      } else if (this.hasError) {
        subscriber.error(this.thrownError);
        return Subscription.EMPTY;
      } else if (this.isStopped) {
        subscriber.complete();
        return Subscription.EMPTY;
      } else {
        this.observers.push(subscriber);
        return new SubjectSubscription(this, subscriber);
      }
    }
    asObservable() {
      const observable = new Observable();
      observable.source = this;
      return observable;
    }
  }
  Subject.create = (destination, source) => {
    return new AnonymousSubject(destination, source);
  };
  return Subject;
})();
class AnonymousSubject extends Subject {
  constructor(destination, source) {
    super();
    this.destination = destination;
    this.source = source;
  }
  next(value) {
    const {
      destination
    } = this;
    if (destination && destination.next) {
      destination.next(value);
    }
  }
  error(err) {
    const {
      destination
    } = this;
    if (destination && destination.error) {
      this.destination.error(err);
    }
  }
  complete() {
    const {
      destination
    } = this;
    if (destination && destination.complete) {
      this.destination.complete();
    }
  }
  _subscribe(subscriber) {
    const {
      source
    } = this;
    if (source) {
      return this.source.subscribe(subscriber);
    } else {
      return Subscription.EMPTY;
    }
  }
}
//# sourceMappingURL=Subject.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/BehaviorSubject.js


class BehaviorSubject extends Subject {
  constructor(_value) {
    super();
    this._value = _value;
  }
  get value() {
    return this.getValue();
  }
  _subscribe(subscriber) {
    const subscription = super._subscribe(subscriber);
    if (subscription && !subscription.closed) {
      subscriber.next(this._value);
    }
    return subscription;
  }
  getValue() {
    if (this.hasError) {
      throw this.thrownError;
    } else if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else {
      return this._value;
    }
  }
  next(value) {
    super.next(this._value = value);
  }
}
//# sourceMappingURL=BehaviorSubject.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/scheduler/Action.js

class Action extends Subscription {
  constructor(scheduler, work) {
    super();
  }
  schedule(state, delay = 0) {
    return this;
  }
}
//# sourceMappingURL=Action.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js

class AsyncAction extends Action {
  constructor(scheduler, work) {
    super(scheduler, work);
    this.scheduler = scheduler;
    this.work = work;
    this.pending = false;
  }
  schedule(state, delay = 0) {
    if (this.closed) {
      return this;
    }
    this.state = state;
    const id = this.id;
    const scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay);
    }
    this.pending = true;
    this.delay = delay;
    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
    return this;
  }
  requestAsyncId(scheduler, id, delay = 0) {
    return setInterval(scheduler.flush.bind(scheduler, this), delay);
  }
  recycleAsyncId(scheduler, id, delay = 0) {
    if (delay !== null && this.delay === delay && this.pending === false) {
      return id;
    }
    clearInterval(id);
    return undefined;
  }
  execute(state, delay) {
    if (this.closed) {
      return new Error('executing a cancelled action');
    }
    this.pending = false;
    const error = this._execute(state, delay);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  }
  _execute(state, delay) {
    let errored = false;
    let errorValue = undefined;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = !!e && e || new Error(e);
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  }
  _unsubscribe() {
    const id = this.id;
    const scheduler = this.scheduler;
    const actions = scheduler.actions;
    const index = actions.indexOf(this);
    this.work = null;
    this.state = null;
    this.pending = false;
    this.scheduler = null;
    if (index !== -1) {
      actions.splice(index, 1);
    }
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, null);
    }
    this.delay = null;
  }
}
//# sourceMappingURL=AsyncAction.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/Scheduler.js
let Scheduler = /*#__PURE__*/(() => {
  class Scheduler {
    constructor(SchedulerAction, now = Scheduler.now) {
      this.SchedulerAction = SchedulerAction;
      this.now = now;
    }
    schedule(work, delay = 0, state) {
      return new this.SchedulerAction(this, work).schedule(state, delay);
    }
  }
  Scheduler.now = () => Date.now();
  //# sourceMappingURL=Scheduler.js.map
  return Scheduler;
})();
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js

class AsyncScheduler extends Scheduler {
  constructor(SchedulerAction, now = Scheduler.now) {
    super(SchedulerAction, () => {
      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
        return AsyncScheduler.delegate.now();
      } else {
        return now();
      }
    });
    this.actions = [];
    this.active = false;
    this.scheduled = undefined;
  }
  schedule(work, delay = 0, state) {
    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
      return AsyncScheduler.delegate.schedule(work, delay, state);
    } else {
      return super.schedule(work, delay, state);
    }
  }
  flush(action) {
    const {
      actions
    } = this;
    if (this.active) {
      actions.push(action);
      return;
    }
    let error;
    this.active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this.active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  }
}
//# sourceMappingURL=AsyncScheduler.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/scheduler/async.js


const async_async = new AsyncScheduler(AsyncAction);
//# sourceMappingURL=async.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/isNumeric.js

function isNumeric(val) {
  return !isArray(val) && val - parseFloat(val) + 1 >= 0;
}
//# sourceMappingURL=isNumeric.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/isScheduler.js
function isScheduler(value) {
  return value && typeof value.schedule === 'function';
}
//# sourceMappingURL=isScheduler.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/observable/timer.js




function timer(dueTime = 0, periodOrScheduler, scheduler) {
  let period = -1;
  if (isNumeric(periodOrScheduler)) {
    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
  } else if (isScheduler(periodOrScheduler)) {
    scheduler = periodOrScheduler;
  }
  if (!isScheduler(scheduler)) {
    scheduler = async_async;
  }
  return new Observable(subscriber => {
    const due = isNumeric(dueTime) ? dueTime : +dueTime - scheduler.now();
    return scheduler.schedule(dispatch, due, {
      index: 0,
      period,
      subscriber
    });
  });
}
function dispatch(state) {
  const {
    index,
    period,
    subscriber
  } = state;
  subscriber.next(index);
  if (subscriber.closed) {
    return;
  } else if (period === -1) {
    return subscriber.complete();
  }
  state.index = index + 1;
  this.schedule(state, period);
}
//# sourceMappingURL=timer.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/InnerSubscriber.js

class InnerSubscriber extends Subscriber {
  constructor(parent, outerValue, outerIndex) {
    super();
    this.parent = parent;
    this.outerValue = outerValue;
    this.outerIndex = outerIndex;
    this.index = 0;
  }
  _next(value) {
    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
  }
  _error(error) {
    this.parent.notifyError(error, this);
    this.unsubscribe();
  }
  _complete() {
    this.parent.notifyComplete(this);
    this.unsubscribe();
  }
}
//# sourceMappingURL=InnerSubscriber.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/subscribeToArray.js
const subscribeToArray = array => subscriber => {
  for (let i = 0, len = array.length; i < len && !subscriber.closed; i++) {
    subscriber.next(array[i]);
  }
  subscriber.complete();
};
//# sourceMappingURL=subscribeToArray.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/subscribeToPromise.js

const subscribeToPromise = promise => subscriber => {
  promise.then(value => {
    if (!subscriber.closed) {
      subscriber.next(value);
      subscriber.complete();
    }
  }, err => subscriber.error(err)).then(null, hostReportError);
  return subscriber;
};
//# sourceMappingURL=subscribeToPromise.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== 'function' || !Symbol.iterator) {
    return '@@iterator';
  }
  return Symbol.iterator;
}
const iterator_iterator = getSymbolIterator();
const $$iterator = (/* unused pure expression or super */ null && (iterator_iterator));
//# sourceMappingURL=iterator.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/subscribeToIterable.js

const subscribeToIterable = iterable => subscriber => {
  const iterator = iterable[iterator_iterator]();
  do {
    const item = iterator.next();
    if (item.done) {
      subscriber.complete();
      break;
    }
    subscriber.next(item.value);
    if (subscriber.closed) {
      break;
    }
  } while (true);
  if (typeof iterator.return === 'function') {
    subscriber.add(() => {
      if (iterator.return) {
        iterator.return();
      }
    });
  }
  return subscriber;
};
//# sourceMappingURL=subscribeToIterable.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/subscribeToObservable.js

const subscribeToObservable = obj => subscriber => {
  const obs = obj[observable_observable]();
  if (typeof obs.subscribe !== 'function') {
    throw new TypeError('Provided object does not correctly implement Symbol.observable');
  } else {
    return obs.subscribe(subscriber);
  }
};
//# sourceMappingURL=subscribeToObservable.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/isArrayLike.js
const isArrayLike = x => x && typeof x.length === 'number' && typeof x !== 'function';
//# sourceMappingURL=isArrayLike.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/isPromise.js
function isPromise(value) {
  return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
//# sourceMappingURL=isPromise.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/subscribeTo.js









const subscribeTo = result => {
  if (!!result && typeof result[observable_observable] === 'function') {
    return subscribeToObservable(result);
  } else if (isArrayLike(result)) {
    return subscribeToArray(result);
  } else if (isPromise(result)) {
    return subscribeToPromise(result);
  } else if (!!result && typeof result[iterator_iterator] === 'function') {
    return subscribeToIterable(result);
  } else {
    const value = isObject(result) ? 'an invalid object' : `'${result}'`;
    const msg = `You provided ${value} where a stream was expected.` + ' You can provide an Observable, Promise, Array, or Iterable.';
    throw new TypeError(msg);
  }
};
//# sourceMappingURL=subscribeTo.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js



function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber = new InnerSubscriber(outerSubscriber, outerValue, outerIndex)) {
  if (innerSubscriber.closed) {
    return undefined;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  return subscribeTo(result)(innerSubscriber);
}
//# sourceMappingURL=subscribeToResult.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/OuterSubscriber.js

class OuterSubscriber extends Subscriber {
  notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  }
  notifyError(error, innerSub) {
    this.destination.error(error);
  }
  notifyComplete(innerSub) {
    this.destination.complete();
  }
}
//# sourceMappingURL=OuterSubscriber.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/operators/map.js

function map(project, thisArg) {
  return function mapOperation(source) {
    if (typeof project !== 'function') {
      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
    }
    return source.lift(new MapOperator(project, thisArg));
  };
}
class MapOperator {
  constructor(project, thisArg) {
    this.project = project;
    this.thisArg = thisArg;
  }
  call(subscriber, source) {
    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
  }
}
class MapSubscriber extends Subscriber {
  constructor(destination, project, thisArg) {
    super(destination);
    this.project = project;
    this.count = 0;
    this.thisArg = thisArg || this;
  }
  _next(value) {
    let result;
    try {
      result = this.project.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  }
}
//# sourceMappingURL=map.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/scheduled/scheduleObservable.js



function scheduleObservable(input, scheduler) {
  return new Observable(subscriber => {
    const sub = new Subscription();
    sub.add(scheduler.schedule(() => {
      const observable = input[observable_observable]();
      sub.add(observable.subscribe({
        next(value) {
          sub.add(scheduler.schedule(() => subscriber.next(value)));
        },
        error(err) {
          sub.add(scheduler.schedule(() => subscriber.error(err)));
        },
        complete() {
          sub.add(scheduler.schedule(() => subscriber.complete()));
        }
      }));
    }));
    return sub;
  });
}
//# sourceMappingURL=scheduleObservable.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/scheduled/schedulePromise.js


function schedulePromise(input, scheduler) {
  return new Observable(subscriber => {
    const sub = new Subscription();
    sub.add(scheduler.schedule(() => input.then(value => {
      sub.add(scheduler.schedule(() => {
        subscriber.next(value);
        sub.add(scheduler.schedule(() => subscriber.complete()));
      }));
    }, err => {
      sub.add(scheduler.schedule(() => subscriber.error(err)));
    })));
    return sub;
  });
}
//# sourceMappingURL=schedulePromise.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/scheduled/scheduleArray.js


function scheduleArray(input, scheduler) {
  return new Observable(subscriber => {
    const sub = new Subscription();
    let i = 0;
    sub.add(scheduler.schedule(function () {
      if (i === input.length) {
        subscriber.complete();
        return;
      }
      subscriber.next(input[i++]);
      if (!subscriber.closed) {
        sub.add(this.schedule());
      }
    }));
    return sub;
  });
}
//# sourceMappingURL=scheduleArray.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/scheduled/scheduleIterable.js



function scheduleIterable(input, scheduler) {
  if (!input) {
    throw new Error('Iterable cannot be null');
  }
  return new Observable(subscriber => {
    const sub = new Subscription();
    let iterator;
    sub.add(() => {
      if (iterator && typeof iterator.return === 'function') {
        iterator.return();
      }
    });
    sub.add(scheduler.schedule(() => {
      iterator = input[iterator_iterator]();
      sub.add(scheduler.schedule(function () {
        if (subscriber.closed) {
          return;
        }
        let value;
        let done;
        try {
          const result = iterator.next();
          value = result.value;
          done = result.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
          this.schedule();
        }
      }));
    }));
    return sub;
  });
}
//# sourceMappingURL=scheduleIterable.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/isInteropObservable.js

function isInteropObservable(input) {
  return input && typeof input[observable_observable] === 'function';
}
//# sourceMappingURL=isInteropObservable.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/isIterable.js

function isIterable(input) {
  return input && typeof input[iterator_iterator] === 'function';
}
//# sourceMappingURL=isIterable.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/scheduled/scheduled.js








function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    } else if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    } else if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    } else if (isIterable(input) || typeof input === 'string') {
      return scheduleIterable(input, scheduler);
    }
  }
  throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}
//# sourceMappingURL=scheduled.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/observable/from.js



function from(input, scheduler) {
  if (!scheduler) {
    if (input instanceof Observable) {
      return input;
    }
    return new Observable(subscribeTo(input));
  } else {
    return scheduled(input, scheduler);
  }
}
//# sourceMappingURL=from.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/operators/mergeMap.js





function mergeMap(project, resultSelector, concurrent = Number.POSITIVE_INFINITY) {
  if (typeof resultSelector === 'function') {
    return source => source.pipe(mergeMap((a, i) => from(project(a, i)).pipe(map((b, ii) => resultSelector(a, b, i, ii))), concurrent));
  } else if (typeof resultSelector === 'number') {
    concurrent = resultSelector;
  }
  return source => source.lift(new MergeMapOperator(project, concurrent));
}
class MergeMapOperator {
  constructor(project, concurrent = Number.POSITIVE_INFINITY) {
    this.project = project;
    this.concurrent = concurrent;
  }
  call(observer, source) {
    return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
  }
}
class MergeMapSubscriber extends OuterSubscriber {
  constructor(destination, project, concurrent = Number.POSITIVE_INFINITY) {
    super(destination);
    this.project = project;
    this.concurrent = concurrent;
    this.hasCompleted = false;
    this.buffer = [];
    this.active = 0;
    this.index = 0;
  }
  _next(value) {
    if (this.active < this.concurrent) {
      this._tryNext(value);
    } else {
      this.buffer.push(value);
    }
  }
  _tryNext(value) {
    let result;
    const index = this.index++;
    try {
      result = this.project(value, index);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.active++;
    this._innerSub(result, value, index);
  }
  _innerSub(ish, value, index) {
    const innerSubscriber = new InnerSubscriber(this, value, index);
    const destination = this.destination;
    destination.add(innerSubscriber);
    const innerSubscription = subscribeToResult(this, ish, undefined, undefined, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  }
  _complete() {
    this.hasCompleted = true;
    if (this.active === 0 && this.buffer.length === 0) {
      this.destination.complete();
    }
    this.unsubscribe();
  }
  notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  }
  notifyComplete(innerSub) {
    const buffer = this.buffer;
    this.remove(innerSub);
    this.active--;
    if (buffer.length > 0) {
      this._next(buffer.shift());
    } else if (this.active === 0 && this.hasCompleted) {
      this.destination.complete();
    }
  }
}
//# sourceMappingURL=mergeMap.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/identity.js
function identity(x) {
  return x;
}
//# sourceMappingURL=identity.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/operators/mergeAll.js


function mergeAll(concurrent = Number.POSITIVE_INFINITY) {
  return mergeMap(identity, concurrent);
}
//# sourceMappingURL=mergeAll.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/observable/fromArray.js



function fromArray(input, scheduler) {
  if (!scheduler) {
    return new Observable(subscribeToArray(input));
  } else {
    return scheduleArray(input, scheduler);
  }
}
//# sourceMappingURL=fromArray.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/observable/merge.js




function merge(...observables) {
  let concurrent = Number.POSITIVE_INFINITY;
  let scheduler = null;
  let last = observables[observables.length - 1];
  if (isScheduler(last)) {
    scheduler = observables.pop();
    if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
      concurrent = observables.pop();
    }
  } else if (typeof last === 'number') {
    concurrent = observables.pop();
  }
  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
    return observables[0];
  }
  return mergeAll(concurrent)(fromArray(observables, scheduler));
}
//# sourceMappingURL=merge.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/observable/empty.js

const EMPTY = new Observable(subscriber => subscriber.complete());
function empty_empty(scheduler) {
  return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
  return new Observable(subscriber => scheduler.schedule(() => subscriber.complete()));
}
//# sourceMappingURL=empty.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/observable/defer.js



function defer(observableFactory) {
  return new Observable(subscriber => {
    let input;
    try {
      input = observableFactory();
    } catch (err) {
      subscriber.error(err);
      return undefined;
    }
    const source = input ? from(input) : empty_empty();
    return source.subscribe(subscriber);
  });
}
//# sourceMappingURL=defer.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/observable/of.js



function of(...args) {
  let scheduler = args[args.length - 1];
  if (isScheduler(scheduler)) {
    args.pop();
    return scheduleArray(args, scheduler);
  } else {
    return fromArray(args);
  }
}
//# sourceMappingURL=of.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/scheduler/QueueAction.js

class QueueAction extends AsyncAction {
  constructor(scheduler, work) {
    super(scheduler, work);
    this.scheduler = scheduler;
    this.work = work;
  }
  schedule(state, delay = 0) {
    if (delay > 0) {
      return super.schedule(state, delay);
    }
    this.delay = delay;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  }
  execute(state, delay) {
    return delay > 0 || this.closed ? super.execute(state, delay) : this._execute(state, delay);
  }
  requestAsyncId(scheduler, id, delay = 0) {
    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
      return super.requestAsyncId(scheduler, id, delay);
    }
    return scheduler.flush(this);
  }
}
//# sourceMappingURL=QueueAction.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/scheduler/QueueScheduler.js

class QueueScheduler extends AsyncScheduler {}
//# sourceMappingURL=QueueScheduler.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/scheduler/queue.js


const queue = new QueueScheduler(QueueAction);
//# sourceMappingURL=queue.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/observable/throwError.js

function throwError(error, scheduler) {
  if (!scheduler) {
    return new Observable(subscriber => subscriber.error(error));
  } else {
    return new Observable(subscriber => scheduler.schedule(throwError_dispatch, 0, {
      error,
      subscriber
    }));
  }
}
function throwError_dispatch({
  error,
  subscriber
}) {
  subscriber.error(error);
}
//# sourceMappingURL=throwError.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/Notification.js



var NotificationKind = /*#__PURE__*/(/* unused pure expression or super */ null && ((() => {
  (function (NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
  })(NotificationKind || (NotificationKind = {}));
  return NotificationKind;
})()));
class Notification {
  constructor(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === 'N';
  }
  observe(observer) {
    switch (this.kind) {
      case 'N':
        return observer.next && observer.next(this.value);
      case 'E':
        return observer.error && observer.error(this.error);
      case 'C':
        return observer.complete && observer.complete();
    }
  }
  do(next, error, complete) {
    const kind = this.kind;
    switch (kind) {
      case 'N':
        return next && next(this.value);
      case 'E':
        return error && error(this.error);
      case 'C':
        return complete && complete();
    }
  }
  accept(nextOrObserver, error, complete) {
    if (nextOrObserver && typeof nextOrObserver.next === 'function') {
      return this.observe(nextOrObserver);
    } else {
      return this.do(nextOrObserver, error, complete);
    }
  }
  toObservable() {
    const kind = this.kind;
    switch (kind) {
      case 'N':
        return of(this.value);
      case 'E':
        return throwError(this.error);
      case 'C':
        return empty_empty();
    }
    throw new Error('unexpected notification kind value');
  }
  static createNext(value) {
    if (typeof value !== 'undefined') {
      return new Notification('N', value);
    }
    return Notification.undefinedValueNotification;
  }
  static createError(err) {
    return new Notification('E', undefined, err);
  }
  static createComplete() {
    return Notification.completeNotification;
  }
}
Notification.completeNotification = new Notification('C');
Notification.undefinedValueNotification = new Notification('N', undefined);
//# sourceMappingURL=Notification.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/operators/observeOn.js


function observeOn(scheduler, delay = 0) {
  return function observeOnOperatorFunction(source) {
    return source.lift(new ObserveOnOperator(scheduler, delay));
  };
}
class ObserveOnOperator {
  constructor(scheduler, delay = 0) {
    this.scheduler = scheduler;
    this.delay = delay;
  }
  call(subscriber, source) {
    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
  }
}
class ObserveOnSubscriber extends Subscriber {
  constructor(destination, scheduler, delay = 0) {
    super(destination);
    this.scheduler = scheduler;
    this.delay = delay;
  }
  static dispatch(arg) {
    const {
      notification,
      destination
    } = arg;
    notification.observe(destination);
    this.unsubscribe();
  }
  scheduleMessage(notification) {
    const destination = this.destination;
    destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
  }
  _next(value) {
    this.scheduleMessage(Notification.createNext(value));
  }
  _error(err) {
    this.scheduleMessage(Notification.createError(err));
    this.unsubscribe();
  }
  _complete() {
    this.scheduleMessage(Notification.createComplete());
    this.unsubscribe();
  }
}
class ObserveOnMessage {
  constructor(notification, destination) {
    this.notification = notification;
    this.destination = destination;
  }
}
//# sourceMappingURL=observeOn.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/ReplaySubject.js






class ReplaySubject extends Subject {
  constructor(bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY, scheduler) {
    super();
    this.scheduler = scheduler;
    this._events = [];
    this._infiniteTimeWindow = false;
    this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
    this._windowTime = windowTime < 1 ? 1 : windowTime;
    if (windowTime === Number.POSITIVE_INFINITY) {
      this._infiniteTimeWindow = true;
      this.next = this.nextInfiniteTimeWindow;
    } else {
      this.next = this.nextTimeWindow;
    }
  }
  nextInfiniteTimeWindow(value) {
    const _events = this._events;
    _events.push(value);
    if (_events.length > this._bufferSize) {
      _events.shift();
    }
    super.next(value);
  }
  nextTimeWindow(value) {
    this._events.push(new ReplayEvent(this._getNow(), value));
    this._trimBufferThenGetEvents();
    super.next(value);
  }
  _subscribe(subscriber) {
    const _infiniteTimeWindow = this._infiniteTimeWindow;
    const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
    const scheduler = this.scheduler;
    const len = _events.length;
    let subscription;
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else if (this.isStopped || this.hasError) {
      subscription = Subscription.EMPTY;
    } else {
      this.observers.push(subscriber);
      subscription = new SubjectSubscription(this, subscriber);
    }
    if (scheduler) {
      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
    }
    if (_infiniteTimeWindow) {
      for (let i = 0; i < len && !subscriber.closed; i++) {
        subscriber.next(_events[i]);
      }
    } else {
      for (let i = 0; i < len && !subscriber.closed; i++) {
        subscriber.next(_events[i].value);
      }
    }
    if (this.hasError) {
      subscriber.error(this.thrownError);
    } else if (this.isStopped) {
      subscriber.complete();
    }
    return subscription;
  }
  _getNow() {
    return (this.scheduler || queue).now();
  }
  _trimBufferThenGetEvents() {
    const now = this._getNow();
    const _bufferSize = this._bufferSize;
    const _windowTime = this._windowTime;
    const _events = this._events;
    const eventsCount = _events.length;
    let spliceCount = 0;
    while (spliceCount < eventsCount) {
      if (now - _events[spliceCount].time < _windowTime) {
        break;
      }
      spliceCount++;
    }
    if (eventsCount > _bufferSize) {
      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
    }
    if (spliceCount > 0) {
      _events.splice(0, spliceCount);
    }
    return _events;
  }
}
class ReplayEvent {
  constructor(time, value) {
    this.time = time;
    this.value = value;
  }
}
//# sourceMappingURL=ReplaySubject.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/operators/switchMap.js





function switchMap(project, resultSelector) {
  if (typeof resultSelector === 'function') {
    return source => source.pipe(switchMap((a, i) => from(project(a, i)).pipe(map((b, ii) => resultSelector(a, b, i, ii)))));
  }
  return source => source.lift(new SwitchMapOperator(project));
}
class SwitchMapOperator {
  constructor(project) {
    this.project = project;
  }
  call(subscriber, source) {
    return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
  }
}
class SwitchMapSubscriber extends OuterSubscriber {
  constructor(destination, project) {
    super(destination);
    this.project = project;
    this.index = 0;
  }
  _next(value) {
    let result;
    const index = this.index++;
    try {
      result = this.project(value, index);
    } catch (error) {
      this.destination.error(error);
      return;
    }
    this._innerSub(result, value, index);
  }
  _innerSub(result, value, index) {
    const innerSubscription = this.innerSubscription;
    if (innerSubscription) {
      innerSubscription.unsubscribe();
    }
    const innerSubscriber = new InnerSubscriber(this, value, index);
    const destination = this.destination;
    destination.add(innerSubscriber);
    this.innerSubscription = subscribeToResult(this, result, undefined, undefined, innerSubscriber);
    if (this.innerSubscription !== innerSubscriber) {
      destination.add(this.innerSubscription);
    }
  }
  _complete() {
    const {
      innerSubscription
    } = this;
    if (!innerSubscription || innerSubscription.closed) {
      super._complete();
    }
    this.unsubscribe();
  }
  _unsubscribe() {
    this.innerSubscription = null;
  }
  notifyComplete(innerSub) {
    const destination = this.destination;
    destination.remove(innerSub);
    this.innerSubscription = null;
    if (this.isStopped) {
      super._complete();
    }
  }
  notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  }
}
//# sourceMappingURL=switchMap.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/operators/switchMapTo.js

function switchMapTo(innerObservable, resultSelector) {
  return resultSelector ? switchMap(() => innerObservable, resultSelector) : switchMap(() => innerObservable);
}
//# sourceMappingURL=switchMapTo.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/operators/mapTo.js

function mapTo(value) {
  return source => source.lift(new MapToOperator(value));
}
class MapToOperator {
  constructor(value) {
    this.value = value;
  }
  call(subscriber, source) {
    return source.subscribe(new MapToSubscriber(subscriber, this.value));
  }
}
class MapToSubscriber extends Subscriber {
  constructor(destination, value) {
    super(destination);
    this.value = value;
  }
  _next(x) {
    this.destination.next(this.value);
  }
}
//# sourceMappingURL=mapTo.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/operators/concatAll.js

function concatAll() {
  return mergeAll(1);
}
//# sourceMappingURL=concatAll.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/observable/concat.js


function concat(...observables) {
  return concatAll()(of(...observables));
}
//# sourceMappingURL=concat.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/operators/startWith.js


function startWith(...array) {
  const scheduler = array[array.length - 1];
  if (isScheduler(scheduler)) {
    array.pop();
    return source => concat(array, source, scheduler);
  } else {
    return source => concat(array, source);
  }
}
//# sourceMappingURL=startWith.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/operators/takeUntil.js


function takeUntil(notifier) {
  return source => source.lift(new TakeUntilOperator(notifier));
}
class TakeUntilOperator {
  constructor(notifier) {
    this.notifier = notifier;
  }
  call(subscriber, source) {
    const takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
    const notifierSubscription = subscribeToResult(takeUntilSubscriber, this.notifier);
    if (notifierSubscription && !takeUntilSubscriber.seenValue) {
      takeUntilSubscriber.add(notifierSubscription);
      return source.subscribe(takeUntilSubscriber);
    }
    return takeUntilSubscriber;
  }
}
class TakeUntilSubscriber extends OuterSubscriber {
  constructor(destination) {
    super(destination);
    this.seenValue = false;
  }
  notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.seenValue = true;
    this.complete();
  }
  notifyComplete() {}
}
//# sourceMappingURL=takeUntil.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/operators/filter.js

function filter(predicate, thisArg) {
  return function filterOperatorFunction(source) {
    return source.lift(new FilterOperator(predicate, thisArg));
  };
}
class FilterOperator {
  constructor(predicate, thisArg) {
    this.predicate = predicate;
    this.thisArg = thisArg;
  }
  call(subscriber, source) {
    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
  }
}
class FilterSubscriber extends Subscriber {
  constructor(destination, predicate, thisArg) {
    super(destination);
    this.predicate = predicate;
    this.thisArg = thisArg;
    this.count = 0;
  }
  _next(value) {
    let result;
    try {
      result = this.predicate.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    if (result) {
      this.destination.next(value);
    }
  }
}
//# sourceMappingURL=filter.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/operators/debounceTime.js


function debounceTime(dueTime, scheduler = async_async) {
  return source => source.lift(new DebounceTimeOperator(dueTime, scheduler));
}
class DebounceTimeOperator {
  constructor(dueTime, scheduler) {
    this.dueTime = dueTime;
    this.scheduler = scheduler;
  }
  call(subscriber, source) {
    return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
  }
}
class DebounceTimeSubscriber extends Subscriber {
  constructor(destination, dueTime, scheduler) {
    super(destination);
    this.dueTime = dueTime;
    this.scheduler = scheduler;
    this.debouncedSubscription = null;
    this.lastValue = null;
    this.hasValue = false;
  }
  _next(value) {
    this.clearDebounce();
    this.lastValue = value;
    this.hasValue = true;
    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
  }
  _complete() {
    this.debouncedNext();
    this.destination.complete();
  }
  debouncedNext() {
    this.clearDebounce();
    if (this.hasValue) {
      const {
        lastValue
      } = this;
      this.lastValue = null;
      this.hasValue = false;
      this.destination.next(lastValue);
    }
  }
  clearDebounce() {
    const debouncedSubscription = this.debouncedSubscription;
    if (debouncedSubscription !== null) {
      this.remove(debouncedSubscription);
      debouncedSubscription.unsubscribe();
      this.debouncedSubscription = null;
    }
  }
}
function dispatchNext(subscriber) {
  subscriber.debouncedNext();
}
//# sourceMappingURL=debounceTime.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/util/ArgumentOutOfRangeError.js
const ArgumentOutOfRangeErrorImpl = (() => {
  function ArgumentOutOfRangeErrorImpl() {
    Error.call(this);
    this.message = 'argument out of range';
    this.name = 'ArgumentOutOfRangeError';
    return this;
  }
  ArgumentOutOfRangeErrorImpl.prototype = Object.create(Error.prototype);
  return ArgumentOutOfRangeErrorImpl;
})();
const ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
//# sourceMappingURL=ArgumentOutOfRangeError.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/operators/take.js



function take(count) {
  return source => {
    if (count === 0) {
      return empty_empty();
    } else {
      return source.lift(new TakeOperator(count));
    }
  };
}
class TakeOperator {
  constructor(total) {
    this.total = total;
    if (this.total < 0) {
      throw new ArgumentOutOfRangeError();
    }
  }
  call(subscriber, source) {
    return source.subscribe(new TakeSubscriber(subscriber, this.total));
  }
}
class TakeSubscriber extends Subscriber {
  constructor(destination, total) {
    super(destination);
    this.total = total;
    this.count = 0;
  }
  _next(value) {
    const total = this.total;
    const count = ++this.count;
    if (count <= total) {
      this.destination.next(value);
      if (count === total) {
        this.destination.complete();
        this.unsubscribe();
      }
    }
  }
}
//# sourceMappingURL=take.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js

function distinctUntilChanged(compare, keySelector) {
  return source => source.lift(new DistinctUntilChangedOperator(compare, keySelector));
}
class DistinctUntilChangedOperator {
  constructor(compare, keySelector) {
    this.compare = compare;
    this.keySelector = keySelector;
  }
  call(subscriber, source) {
    return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
  }
}
class DistinctUntilChangedSubscriber extends Subscriber {
  constructor(destination, compare, keySelector) {
    super(destination);
    this.keySelector = keySelector;
    this.hasKey = false;
    if (typeof compare === 'function') {
      this.compare = compare;
    }
  }
  compare(x, y) {
    return x === y;
  }
  _next(value) {
    let key;
    try {
      const {
        keySelector
      } = this;
      key = keySelector ? keySelector(value) : value;
    } catch (err) {
      return this.destination.error(err);
    }
    let result = false;
    if (this.hasKey) {
      try {
        const {
          compare
        } = this;
        result = compare(this.key, key);
      } catch (err) {
        return this.destination.error(err);
      }
    } else {
      this.hasKey = true;
    }
    if (!result) {
      this.key = key;
      this.destination.next(value);
    }
  }
}
//# sourceMappingURL=distinctUntilChanged.js.map
// EXTERNAL MODULE: ./node_modules/markdown-it/index.js
var markdown_it = __webpack_require__(4841);
var markdown_it_default = /*#__PURE__*/__webpack_require__.n(markdown_it);
// EXTERNAL MODULE: consume shared module (default) @angular/common@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/common/fesm2015/common.js)
var common_js_ = __webpack_require__(3008);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/observable/zip.js






function zip(...observables) {
  const resultSelector = observables[observables.length - 1];
  if (typeof resultSelector === 'function') {
    observables.pop();
  }
  return fromArray(observables, undefined).lift(new ZipOperator(resultSelector));
}
class ZipOperator {
  constructor(resultSelector) {
    this.resultSelector = resultSelector;
  }
  call(subscriber, source) {
    return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
  }
}
class ZipSubscriber extends Subscriber {
  constructor(destination, resultSelector, values = Object.create(null)) {
    super(destination);
    this.iterators = [];
    this.active = 0;
    this.resultSelector = typeof resultSelector === 'function' ? resultSelector : null;
    this.values = values;
  }
  _next(value) {
    const iterators = this.iterators;
    if (isArray(value)) {
      iterators.push(new StaticArrayIterator(value));
    } else if (typeof value[iterator_iterator] === 'function') {
      iterators.push(new StaticIterator(value[iterator_iterator]()));
    } else {
      iterators.push(new ZipBufferIterator(this.destination, this, value));
    }
  }
  _complete() {
    const iterators = this.iterators;
    const len = iterators.length;
    this.unsubscribe();
    if (len === 0) {
      this.destination.complete();
      return;
    }
    this.active = len;
    for (let i = 0; i < len; i++) {
      let iterator = iterators[i];
      if (iterator.stillUnsubscribed) {
        const destination = this.destination;
        destination.add(iterator.subscribe(iterator, i));
      } else {
        this.active--;
      }
    }
  }
  notifyInactive() {
    this.active--;
    if (this.active === 0) {
      this.destination.complete();
    }
  }
  checkIterators() {
    const iterators = this.iterators;
    const len = iterators.length;
    const destination = this.destination;
    for (let i = 0; i < len; i++) {
      let iterator = iterators[i];
      if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
        return;
      }
    }
    let shouldComplete = false;
    const args = [];
    for (let i = 0; i < len; i++) {
      let iterator = iterators[i];
      let result = iterator.next();
      if (iterator.hasCompleted()) {
        shouldComplete = true;
      }
      if (result.done) {
        destination.complete();
        return;
      }
      args.push(result.value);
    }
    if (this.resultSelector) {
      this._tryresultSelector(args);
    } else {
      destination.next(args);
    }
    if (shouldComplete) {
      destination.complete();
    }
  }
  _tryresultSelector(args) {
    let result;
    try {
      result = this.resultSelector.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  }
}
class StaticIterator {
  constructor(iterator) {
    this.iterator = iterator;
    this.nextResult = iterator.next();
  }
  hasValue() {
    return true;
  }
  next() {
    const result = this.nextResult;
    this.nextResult = this.iterator.next();
    return result;
  }
  hasCompleted() {
    const nextResult = this.nextResult;
    return nextResult && nextResult.done;
  }
}
class StaticArrayIterator {
  constructor(array) {
    this.array = array;
    this.index = 0;
    this.length = 0;
    this.length = array.length;
  }
  [iterator_iterator]() {
    return this;
  }
  next(value) {
    const i = this.index++;
    const array = this.array;
    return i < this.length ? {
      value: array[i],
      done: false
    } : {
      value: null,
      done: true
    };
  }
  hasValue() {
    return this.array.length > this.index;
  }
  hasCompleted() {
    return this.array.length === this.index;
  }
}
class ZipBufferIterator extends OuterSubscriber {
  constructor(destination, parent, observable) {
    super(destination);
    this.parent = parent;
    this.observable = observable;
    this.stillUnsubscribed = true;
    this.buffer = [];
    this.isComplete = false;
  }
  [iterator_iterator]() {
    return this;
  }
  next() {
    const buffer = this.buffer;
    if (buffer.length === 0 && this.isComplete) {
      return {
        value: null,
        done: true
      };
    } else {
      return {
        value: buffer.shift(),
        done: false
      };
    }
  }
  hasValue() {
    return this.buffer.length > 0;
  }
  hasCompleted() {
    return this.buffer.length === 0 && this.isComplete;
  }
  notifyComplete() {
    if (this.buffer.length > 0) {
      this.isComplete = true;
      this.parent.notifyInactive();
    } else {
      this.destination.complete();
    }
  }
  notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.buffer.push(innerValue);
    this.parent.checkIterators();
  }
  subscribe(value, index) {
    return subscribeToResult(this, this.observable, this, index);
  }
}
//# sourceMappingURL=zip.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameAction.js

class AnimationFrameAction extends AsyncAction {
  constructor(scheduler, work) {
    super(scheduler, work);
    this.scheduler = scheduler;
    this.work = work;
  }
  requestAsyncId(scheduler, id, delay = 0) {
    if (delay !== null && delay > 0) {
      return super.requestAsyncId(scheduler, id, delay);
    }
    scheduler.actions.push(this);
    return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(() => scheduler.flush(null)));
  }
  recycleAsyncId(scheduler, id, delay = 0) {
    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
      return super.recycleAsyncId(scheduler, id, delay);
    }
    if (scheduler.actions.length === 0) {
      cancelAnimationFrame(id);
      scheduler.scheduled = undefined;
    }
    return undefined;
  }
}
//# sourceMappingURL=AnimationFrameAction.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameScheduler.js

class AnimationFrameScheduler extends AsyncScheduler {
  flush(action) {
    this.active = true;
    this.scheduled = undefined;
    const {
      actions
    } = this;
    let error;
    let index = -1;
    let count = actions.length;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (++index < count && (action = actions.shift()));
    this.active = false;
    if (error) {
      while (++index < count && (action = actions.shift())) {
        action.unsubscribe();
      }
      throw error;
    }
  }
}
//# sourceMappingURL=AnimationFrameScheduler.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/scheduler/animationFrame.js


const animationFrame = new AnimationFrameScheduler(AnimationFrameAction);
//# sourceMappingURL=animationFrame.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/operators/tap.js



function tap(nextOrObserver, error, complete) {
  return function tapOperatorFunction(source) {
    return source.lift(new DoOperator(nextOrObserver, error, complete));
  };
}
class DoOperator {
  constructor(nextOrObserver, error, complete) {
    this.nextOrObserver = nextOrObserver;
    this.error = error;
    this.complete = complete;
  }
  call(subscriber, source) {
    return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
  }
}
class TapSubscriber extends Subscriber {
  constructor(destination, observerOrNext, error, complete) {
    super(destination);
    this._tapNext = noop;
    this._tapError = noop;
    this._tapComplete = noop;
    this._tapError = error || noop;
    this._tapComplete = complete || noop;
    if (isFunction(observerOrNext)) {
      this._context = this;
      this._tapNext = observerOrNext;
    } else if (observerOrNext) {
      this._context = observerOrNext;
      this._tapNext = observerOrNext.next || noop;
      this._tapError = observerOrNext.error || noop;
      this._tapComplete = observerOrNext.complete || noop;
    }
  }
  _next(value) {
    try {
      this._tapNext.call(this._context, value);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(value);
  }
  _error(err) {
    try {
      this._tapError.call(this._context, err);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.error(err);
  }
  _complete() {
    try {
      this._tapComplete.call(this._context);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    return this.destination.complete();
  }
}
//# sourceMappingURL=tap.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/rxjs/_esm2015/internal/operators/catchError.js



function catchError(selector) {
  return function catchErrorOperatorFunction(source) {
    const operator = new CatchOperator(selector);
    const caught = source.lift(operator);
    return operator.caught = caught;
  };
}
class CatchOperator {
  constructor(selector) {
    this.selector = selector;
  }
  call(subscriber, source) {
    return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
  }
}
class CatchSubscriber extends OuterSubscriber {
  constructor(destination, selector, caught) {
    super(destination);
    this.selector = selector;
    this.caught = caught;
  }
  error(err) {
    if (!this.isStopped) {
      let result;
      try {
        result = this.selector(err, this.caught);
      } catch (err2) {
        super.error(err2);
        return;
      }
      this._unsubscribeAndRecycle();
      const innerSubscriber = new InnerSubscriber(this, undefined, undefined);
      this.add(innerSubscriber);
      const innerSubscription = subscribeToResult(this, result, undefined, undefined, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        this.add(innerSubscription);
      }
    }
  }
}
//# sourceMappingURL=catchError.js.map
// EXTERNAL MODULE: ./node_modules/@angular/platform-browser/fesm2015/platform-browser.js
var platform_browser = __webpack_require__(1211);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/node_modules/ngx-highlightjs/fesm2015/ngx-highlightjs.js









const HIGHLIGHT_OPTIONS = new core_js_.InjectionToken('HIGHLIGHT_OPTIONS');

// @dynamic
let HighlightLoader = /*#__PURE__*/(() => {
  class HighlightLoader {
    constructor(doc, platformId, _options) {
      this._options = _options;
      // Stream that emits when hljs library is loaded and ready to use
      this._ready = new BehaviorSubject(null);
      this.ready = this._ready.asObservable().pipe(filter(hljs => !!hljs), map(hljs => hljs), take(1));
      // Check if hljs is already available
      if ((0,common_js_.isPlatformBrowser)(platformId) && doc.defaultView.hljs) {
        this._ready.next(doc.defaultView.hljs);
      } else {
        // Load hljs library
        this._loadLibrary().pipe(switchMap(hljs => {
          if (this._options && this._options.lineNumbersLoader) {
            // Make hljs available on window object (required for the line numbers library)
            doc.defaultView.hljs = hljs;
            // Load line numbers library
            return this.loadLineNumbers().pipe(tap(() => this._ready.next(hljs)));
          } else {
            this._ready.next(hljs);
            return EMPTY;
          }
        }), catchError(e => {
          console.error('[HLJS] ', e);
          return EMPTY;
        })).subscribe();
      }
    }
    /**
     * Lazy-Load highlight.js library
     */
    _loadLibrary() {
      if (this._options) {
        if (this._options.fullLibraryLoader && this._options.coreLibraryLoader) {
          return throwError('The full library and the core library were imported, only one of them should be imported!');
        }
        if (this._options.fullLibraryLoader && this._options.languages) {
          return throwError('The highlighting languages were imported they are not needed!');
        }
        if (this._options.coreLibraryLoader && !this._options.languages) {
          return throwError('The highlighting languages were not imported!');
        }
        if (!this._options.coreLibraryLoader && this._options.languages) {
          return throwError('The core library was not imported!');
        }
        if (this._options.fullLibraryLoader) {
          return this.loadFullLibrary();
        }
        if (this._options.coreLibraryLoader && this._options.languages && Object.keys(this._options.languages).length) {
          return this.loadCoreLibrary().pipe(switchMap(hljs => this._loadLanguages(hljs)));
        }
      }
      return throwError('Highlight.js library was not imported!');
    }
    /**
     * Lazy-load highlight.js languages
     */
    _loadLanguages(hljs) {
      const languages = Object.entries(this._options.languages).map(([langName, langLoader]) => importModule(langLoader()).pipe(tap(langFunc => hljs.registerLanguage(langName, langFunc))));
      return zip(...languages).pipe(map(() => hljs));
    }
    /**
     * Import highlight.js core library
     */
    loadCoreLibrary() {
      return importModule(this._options.coreLibraryLoader());
    }
    /**
     * Import highlight.js library with all languages
     */
    loadFullLibrary() {
      return importModule(this._options.fullLibraryLoader());
    }
    /**
     * Import line numbers library
     */
    loadLineNumbers() {
      return importModule(this._options.lineNumbersLoader());
    }
  }
  HighlightLoader.ɵfac = function HighlightLoader_Factory(t) {
    return new (t || HighlightLoader)(core_js_["ɵɵinject"](common_js_.DOCUMENT), core_js_["ɵɵinject"](core_js_.PLATFORM_ID), core_js_["ɵɵinject"](HIGHLIGHT_OPTIONS, 8));
  };
  HighlightLoader.ɵprov = core_js_["ɵɵdefineInjectable"]({
    factory: function HighlightLoader_Factory() {
      return new HighlightLoader(core_js_["ɵɵinject"](common_js_.DOCUMENT), core_js_["ɵɵinject"](core_js_.PLATFORM_ID), core_js_["ɵɵinject"](HIGHLIGHT_OPTIONS, 8));
    },
    token: HighlightLoader,
    providedIn: "root"
  });
  return HighlightLoader;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/**
 * Map loader response to module object
 */
const importModule = moduleLoader => {
  return from(moduleLoader).pipe(filter(module => !!module && !!module.default), map(module => module.default));
};
const ɵ0 = (/* unused pure expression or super */ null && (importModule));
let HighlightJS = /*#__PURE__*/(() => {
  class HighlightJS {
    constructor(_loader, options) {
      this._loader = _loader;
      this._hljs = null;
      // Load highlight.js library on init
      _loader.ready.pipe().subscribe(hljs => {
        this._hljs = hljs;
        if (options && options.config) {
          // Set global config if present
          hljs.configure(options.config);
          if (hljs.listLanguages().length < 1) {
            console.error('[HighlightJS]: No languages were registered!');
          }
        }
      });
    }
    // A reference for hljs library
    get hljs() {
      return this._hljs;
    }
    /**
     * Core highlighting function.
     * @param name Accepts a language name, or an alias
     * @param value A string with the code to highlight.
     * @param ignore_illegals When present and evaluates to a true value, forces highlighting to finish
     * even in case of detecting illegal syntax for the language instead of throwing an exception.
     * @param continuation An optional mode stack representing unfinished parsing.
     * When present, the function will restart parsing from this state instead of initializing a new one
     */
    highlight(name, value, ignore_illegals, continuation) {
      return this._loader.ready.pipe(map(hljs => hljs.highlight(name, value, ignore_illegals, continuation)));
    }
    /**
     * Highlighting with language detection.
     * @param value Accepts a string with the code to highlight
     * @param languageSubset An optional array of language names and aliases restricting detection to only those languages.
     * The subset can also be set with configure, but the local parameter overrides the option if set.
     */
    highlightAuto(value, languageSubset) {
      return this._loader.ready.pipe(map(hljs => hljs.highlightAuto(value, languageSubset)));
    }
    /**
     * Post-processing of the highlighted markup.
     * Currently consists of replacing indentation TAB characters and using <br> tags instead of new-line characters.
     * Options are set globally with configure.
     * @param value Accepts a string with the highlighted markup
     */
    fixMarkup(value) {
      return this._loader.ready.pipe(map(hljs => hljs.fixMarkup(value)));
    }
    /**
     * Applies highlighting to a DOM node containing code.
     * The function uses language detection by default but you can specify the language in the class attribute of the DOM node.
     * See the class reference for all available language names and aliases.
     * @param block The element to apply highlight on.
     */
    highlightBlock(block) {
      return this._loader.ready.pipe(map(hljs => hljs.highlightBlock(block)));
    }
    /**
     * Configures global options:
     * @param config HighlightJs configuration argument
     */
    configure(config) {
      return this._loader.ready.pipe(map(hljs => hljs.configure(config)));
    }
    /**
     * Applies highlighting to all <pre><code>..</code></pre> blocks on a page.
     */
    initHighlighting() {
      return this._loader.ready.pipe(map(hljs => hljs.initHighlighting()));
    }
    /**
     * Adds new language to the library under the specified name. Used mostly internally.
     * @param name A string with the name of the language being registered
     * @param language A function that returns an object which represents the language definition.
     * The function is passed the hljs object to be able to use common regular expressions defined within it.
     */
    registerLanguage(name, language) {
      return this._loader.ready.pipe(tap(hljs => hljs.registerLanguage(name, language)));
    }
    /**
     * @return The languages names list.
     */
    listLanguages() {
      return this._loader.ready.pipe(map(hljs => hljs.listLanguages()));
    }
    /**
     * Looks up a language by name or alias.
     * @param name Language name
     * @return The language object if found, undefined otherwise.
     */
    getLanguage(name) {
      return this._loader.ready.pipe(map(hljs => hljs.getLanguage(name)));
    }
    /**
     * Display line numbers
     * @param el Code element
     */
    lineNumbersBlock(el) {
      return this._loader.ready.pipe(filter(hljs => !!hljs.lineNumbersBlock), tap(hljs => hljs.lineNumbersBlock(el)));
    }
  }
  HighlightJS.ɵfac = function HighlightJS_Factory(t) {
    return new (t || HighlightJS)(core_js_["ɵɵinject"](HighlightLoader), core_js_["ɵɵinject"](HIGHLIGHT_OPTIONS, 8));
  };
  HighlightJS.ɵprov = core_js_["ɵɵdefineInjectable"]({
    factory: function HighlightJS_Factory() {
      return new HighlightJS(core_js_["ɵɵinject"](HighlightLoader), core_js_["ɵɵinject"](HIGHLIGHT_OPTIONS, 8));
    },
    token: HighlightJS,
    providedIn: "root"
  });
  return HighlightJS;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
let Highlight = /*#__PURE__*/(() => {
  class Highlight {
    constructor(el, _hljs, _sanitizer, _options) {
      this._hljs = _hljs;
      this._sanitizer = _sanitizer;
      this._options = _options;
      // Stream that emits when code string is highlighted
      this.highlighted = new core_js_.EventEmitter();
      this._nativeElement = el.nativeElement;
    }
    ngOnChanges(changes) {
      if (this.code && changes.code && typeof changes.code.currentValue !== 'undefined' && changes.code.currentValue !== changes.code.previousValue) {
        this.highlightElement(this.code, this.languages);
      }
    }
    /**
     * Highlighting with language detection and fix markup.
     * @param code Accepts a string with the code to highlight
     * @param languages An optional array of language names and aliases restricting detection to only those languages.
     * The subset can also be set with configure, but the local parameter overrides the option if set.
     */
    highlightElement(code, languages) {
      // Set code text before highlighting
      this.setTextContent(code);
      this._hljs.highlightAuto(code, languages).subscribe(res => {
        // Set highlighted code
        this.setInnerHTML(res.value);
        // Check if user want to show line numbers
        if (this.lineNumbers && this._options && this._options.lineNumbersLoader) {
          this.addLineNumbers();
        }
        // Forward highlight response to the highlighted output
        this.highlighted.emit(res);
      });
    }
    addLineNumbers() {
      // Clean up line numbers observer
      this.destroyLineNumbersObserver();
      animationFrame.schedule(() => {
        // Add line numbers
        this._hljs.lineNumbersBlock(this._nativeElement).subscribe();
        // If lines count is 1, the line numbers library will not add numbers
        // Observe changes to add 'hljs-line-numbers' class only when line numbers is added to the code element
        this._lineNumbersObs = new MutationObserver(() => {
          if (this._nativeElement.firstElementChild && this._nativeElement.firstElementChild.tagName.toUpperCase() === 'TABLE') {
            this._nativeElement.classList.add('hljs-line-numbers');
          }
          this.destroyLineNumbersObserver();
        });
        this._lineNumbersObs.observe(this._nativeElement, {
          childList: true
        });
      });
    }
    destroyLineNumbersObserver() {
      if (this._lineNumbersObs) {
        this._lineNumbersObs.disconnect();
        this._lineNumbersObs = null;
      }
    }
    setTextContent(content) {
      animationFrame.schedule(() => this._nativeElement.textContent = content);
    }
    setInnerHTML(content) {
      animationFrame.schedule(() => this._nativeElement.innerHTML = this._sanitizer.sanitize(core_js_.SecurityContext.HTML, content) || '');
    }
  }
  Highlight.ɵfac = function Highlight_Factory(t) {
    return new (t || Highlight)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](HighlightJS), core_js_["ɵɵdirectiveInject"](platform_browser.DomSanitizer), core_js_["ɵɵdirectiveInject"](HIGHLIGHT_OPTIONS, 8));
  };
  Highlight.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: Highlight,
    selectors: [["", "highlight", ""]],
    hostVars: 2,
    hostBindings: function Highlight_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("hljs", true);
      }
    },
    inputs: {
      code: ["highlight", "code"],
      languages: "languages",
      lineNumbers: "lineNumbers"
    },
    outputs: {
      highlighted: "highlighted"
    },
    features: [core_js_["ɵɵNgOnChangesFeature"]]
  });
  return Highlight;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
let HighlightModule = /*#__PURE__*/(() => {
  class HighlightModule {}
  HighlightModule.ɵfac = function HighlightModule_Factory(t) {
    return new (t || HighlightModule)();
  };
  HighlightModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: HighlightModule
  });
  HighlightModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return HighlightModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](HighlightModule, {
    declarations: [Highlight],
    exports: [Highlight]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=ngx-highlightjs.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-services.js + 1 modules
var taiga_ui_cdk_services = __webpack_require__(3503);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-decorators.js
var taiga_ui_cdk_decorators = __webpack_require__(4358);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-classes.js
var taiga_ui_cdk_classes = __webpack_require__(8939);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-format.js


/**
 * @deprecated use String.prototype.padStart in 3.0 (after Chrome 49 support is dropped)
 * Pads a string with symbols in the beginning
 *
 * @param sourceString
 * @param minResultLength
 * @param padString string to pad with
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function padStart(sourceString, minResultLength, padString = ` `) {
  const padSize = minResultLength - sourceString.length;
  if (padSize <= 0) {
    return sourceString;
  }
  return padString.repeat(padSize / padString.length).slice(0, padSize) + sourceString;
}

/**
 * @deprecated: use {@link tuiPx} instead
 * Adds 'px' to the number and turns it into a string
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function px(value) {
  taiga_ui_cdk_classes/* tuiAssert */.zU.assert(Number.isFinite(value), `Value must be finite number`);
  return `${value}px`;
}
const tuiPx = px;

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-utils-format.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-tokens.js + 1 modules
var taiga_ui_cdk_tokens = __webpack_require__(3034);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-observables.js + 1 modules
var taiga_ui_cdk_observables = __webpack_require__(4197);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/filter.js
var operators_filter = __webpack_require__(5435);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js
var operators_map = __webpack_require__(8002);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-drag.js





let TuiDragDirective = /*#__PURE__*/(() => {
  let TuiDragDirective = class TuiDragDirective {
    constructor(elementRef) {
      this.elementRef = elementRef;
      this.dragAndDropFrom$ = (0,taiga_ui_cdk_observables/* dragAndDropFrom */.AA)(this.elementRef.nativeElement);
      this.start = this.dragAndDropFrom$.pipe((0,operators_filter/* filter */.h)(({
        stage
      }) => stage === 0 /* Start */), (0,operators_map/* map */.U)(({
        event
      }) => event));
      this.continues = this.dragAndDropFrom$.pipe((0,operators_filter/* filter */.h)(({
        stage
      }) => stage === 1 /* Continues */), (0,operators_map/* map */.U)(({
        event
      }) => event));
      this.end = this.dragAndDropFrom$.pipe((0,operators_filter/* filter */.h)(({
        stage
      }) => stage === 2 /* End */), (0,operators_map/* map */.U)(({
        event
      }) => event));
    }
  };
  TuiDragDirective.ɵfac = function TuiDragDirective_Factory(t) {
    return new (t || TuiDragDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef));
  };
  TuiDragDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiDragDirective,
    selectors: [["", "tuiDragStart", ""], ["", "tuiDragContinues", ""], ["", "tuiDragEnd", ""]],
    outputs: {
      start: "tuiDragStart",
      continues: "tuiDragContinues",
      end: "tuiDragEnd"
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)('tuiDragStart')], TuiDragDirective.prototype, "start", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)('tuiDragContinues')], TuiDragDirective.prototype, "continues", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)('tuiDragEnd')], TuiDragDirective.prototype, "end", void 0);
  TuiDragDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef))], TuiDragDirective);
  return TuiDragDirective;
})();
let TuiDragModule = /*#__PURE__*/(() => {
  let TuiDragModule = class TuiDragModule {};
  TuiDragModule.ɵfac = function TuiDragModule_Factory(t) {
    return new (t || TuiDragModule)();
  };
  TuiDragModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDragModule
  });
  TuiDragModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiDragModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDragModule, {
    declarations: [TuiDragDirective],
    exports: [TuiDragDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-drag.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-constants.js
var taiga_ui_cdk_constants = __webpack_require__(3770);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-dom.js
var taiga_ui_cdk_utils_dom = __webpack_require__(5242);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-miscellaneous.js
var taiga_ui_cdk_utils_miscellaneous = __webpack_require__(1927);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Observable.js + 2 modules
var internal_Observable = __webpack_require__(8891);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/startWith.js
var operators_startWith = __webpack_require__(9761);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js
var operators_distinctUntilChanged = __webpack_require__(7519);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscriber.js
var internal_Subscriber = __webpack_require__(7393);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/skip.js

function skip(count) {
  return source => source.lift(new SkipOperator(count));
}
class SkipOperator {
  constructor(total) {
    this.total = total;
  }
  call(subscriber, source) {
    return source.subscribe(new SkipSubscriber(subscriber, this.total));
  }
}
class SkipSubscriber extends internal_Subscriber/* Subscriber */.L {
  constructor(destination, total) {
    super(destination);
    this.total = total;
    this.count = 0;
  }
  _next(x) {
    if (++this.count > this.total) {
      this.destination.next(x);
    }
  }
}
//# sourceMappingURL=skip.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-active-zone.js









var TuiActiveZoneDirective_1;
let TuiActiveZoneDirective = TuiActiveZoneDirective_1 = class TuiActiveZoneDirective {
  constructor(active$, ngZone, elementRef, directParentActiveZone) {
    this.active$ = active$;
    this.ngZone = ngZone;
    this.elementRef = elementRef;
    this.directParentActiveZone = directParentActiveZone;
    this.subActiveZones = [];
    this.tuiActiveZoneParent = null;
    this.tuiActiveZoneChange = this.active$.pipe((0,operators_map/* map */.U)(element => !!element && this.contains(element)), (0,operators_startWith/* startWith */.O)(false), (0,operators_distinctUntilChanged/* distinctUntilChanged */.x)(), skip(1), (0,taiga_ui_cdk_observables/* tuiZoneOptimized */.Yr)(this.ngZone));
    if (this.directParentActiveZone) {
      this.directParentActiveZone.addSubActiveZone(this);
    }
  }
  set tuiActiveZoneParentSetter(zone) {
    this.setZone(zone);
  }
  ngOnDestroy() {
    if (this.directParentActiveZone) {
      this.directParentActiveZone.removeSubActiveZone(this);
    }
    if (this.tuiActiveZoneParent) {
      this.tuiActiveZoneParent.removeSubActiveZone(this);
    }
  }
  contains(node) {
    return this.elementRef.nativeElement.contains(node) || this.subActiveZones.some((item, index, array) => array.indexOf(item) === index && item.contains(node));
  }
  setZone(zone) {
    if (this.tuiActiveZoneParent) {
      this.tuiActiveZoneParent.removeSubActiveZone(this);
    }
    if (zone) {
      zone.addSubActiveZone(this);
    }
    this.tuiActiveZoneParent = zone;
  }
  addSubActiveZone(activeZone) {
    this.subActiveZones = [...this.subActiveZones, activeZone];
  }
  removeSubActiveZone(activeZone) {
    const index = this.subActiveZones.findIndex(item => item === activeZone);
    this.subActiveZones = [...this.subActiveZones.slice(0, index), ...this.subActiveZones.slice(index + 1)];
  }
};
TuiActiveZoneDirective.ɵfac = function TuiActiveZoneDirective_Factory(t) {
  return new (t || TuiActiveZoneDirective)(core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_ACTIVE_ELEMENT */.wk), core_js_["ɵɵdirectiveInject"](core_js_.NgZone), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](TuiActiveZoneDirective_1, 12));
};
TuiActiveZoneDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiActiveZoneDirective,
  selectors: [["", "tuiActiveZone", "", 5, "ng-container"], ["", "tuiActiveZoneChange", "", 5, "ng-container"], ["", "tuiActiveZoneParent", "", 5, "ng-container"]],
  inputs: {
    tuiActiveZoneParentSetter: ["tuiActiveZoneParent", "tuiActiveZoneParentSetter"]
  },
  outputs: {
    tuiActiveZoneChange: "tuiActiveZoneChange"
  },
  exportAs: ["tuiActiveZone"]
});
TuiActiveZoneDirective.ctorParameters = () => [{
  type: internal_Observable/* Observable */.y,
  decorators: [{
    type: core_js_.Inject,
    args: [taiga_ui_cdk_tokens/* TUI_ACTIVE_ELEMENT */.wk]
  }]
}, {
  type: core_js_.NgZone,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.NgZone]
  }]
}, {
  type: core_js_.ElementRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ElementRef]
  }]
}, {
  type: TuiActiveZoneDirective,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.SkipSelf
  }, {
    type: core_js_.Inject,
    args: [TuiActiveZoneDirective_1]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiActiveZoneParent'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiActiveZoneDirective.prototype, "tuiActiveZoneParentSetter", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiActiveZoneDirective.prototype, "tuiActiveZoneChange", void 0);
(0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiActiveZoneDirective.prototype, "setZone", null);
TuiActiveZoneDirective = TuiActiveZoneDirective_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_ACTIVE_ELEMENT */.wk)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.NgZone)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.SkipSelf)()), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TuiActiveZoneDirective_1))], TuiActiveZoneDirective);
let TuiActiveZoneModule = /*#__PURE__*/(() => {
  let TuiActiveZoneModule = class TuiActiveZoneModule {};
  TuiActiveZoneModule.ɵfac = function TuiActiveZoneModule_Factory(t) {
    return new (t || TuiActiveZoneModule)();
  };
  TuiActiveZoneModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiActiveZoneModule
  });
  TuiActiveZoneModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiActiveZoneModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiActiveZoneModule, {
    declarations: [TuiActiveZoneDirective],
    exports: [TuiActiveZoneDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-active-zone.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-let.js
var taiga_ui_cdk_directives_let = __webpack_require__(2668);
// EXTERNAL MODULE: ./node_modules/@ng-web-apis/common/fesm2015/ng-web-apis-common.js
var ng_web_apis_common = __webpack_require__(2579);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isArray.js
var util_isArray = __webpack_require__(9796);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/fromArray.js
var observable_fromArray = __webpack_require__(6693);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js
var internal_OuterSubscriber = __webpack_require__(5197);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js + 1 modules
var util_subscribeToResult = __webpack_require__(509);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/observable/race.js




function race(...observables) {
  if (observables.length === 1) {
    if ((0,util_isArray/* isArray */.k)(observables[0])) {
      observables = observables[0];
    } else {
      return observables[0];
    }
  }
  return (0,observable_fromArray/* fromArray */.n)(observables, undefined).lift(new RaceOperator());
}
class RaceOperator {
  call(subscriber, source) {
    return source.subscribe(new RaceSubscriber(subscriber));
  }
}
class RaceSubscriber extends internal_OuterSubscriber/* OuterSubscriber */.L {
  constructor(destination) {
    super(destination);
    this.hasFirst = false;
    this.observables = [];
    this.subscriptions = [];
  }
  _next(observable) {
    this.observables.push(observable);
  }
  _complete() {
    const observables = this.observables;
    const len = observables.length;
    if (len === 0) {
      this.destination.complete();
    } else {
      for (let i = 0; i < len && !this.hasFirst; i++) {
        const observable = observables[i];
        const subscription = (0,util_subscribeToResult/* subscribeToResult */.D)(this, observable, undefined, i);
        if (this.subscriptions) {
          this.subscriptions.push(subscription);
        }
        this.add(subscription);
      }
      this.observables = null;
    }
  }
  notifyNext(_outerValue, innerValue, outerIndex) {
    if (!this.hasFirst) {
      this.hasFirst = true;
      for (let i = 0; i < this.subscriptions.length; i++) {
        if (i !== outerIndex) {
          let subscription = this.subscriptions[i];
          subscription.unsubscribe();
          this.remove(subscription);
        }
      }
      this.subscriptions = null;
    }
    this.destination.next(innerValue);
  }
}
//# sourceMappingURL=race.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/timer.js + 1 modules
var observable_timer = __webpack_require__(8634);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/throttleTime.js + 1 modules
var throttleTime = __webpack_require__(9426);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/skipWhile.js

function skipWhile(predicate) {
  return source => source.lift(new SkipWhileOperator(predicate));
}
class SkipWhileOperator {
  constructor(predicate) {
    this.predicate = predicate;
  }
  call(subscriber, source) {
    return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
  }
}
class SkipWhileSubscriber extends internal_Subscriber/* Subscriber */.L {
  constructor(destination, predicate) {
    super(destination);
    this.predicate = predicate;
    this.skipping = true;
    this.index = 0;
  }
  _next(value) {
    const destination = this.destination;
    if (this.skipping) {
      this.tryCallPredicate(value);
    }
    if (!this.skipping) {
      destination.next(value);
    }
  }
  tryCallPredicate(value) {
    try {
      const result = this.predicate(value, this.index++);
      this.skipping = Boolean(result);
    } catch (err) {
      this.destination.error(err);
    }
  }
}
//# sourceMappingURL=skipWhile.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/take.js
var operators_take = __webpack_require__(5257);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-auto-focus.js










let AbstractTuiAutofocusHandler = /*#__PURE__*/(() => {
  let AbstractTuiAutofocusHandler = class AbstractTuiAutofocusHandler {
    constructor(tuiFocusableComponent, elementRef) {
      this.tuiFocusableComponent = tuiFocusableComponent;
      this.elementRef = elementRef;
    }
    get element() {
      var _a;
      return ((_a = this.tuiFocusableComponent) === null || _a === void 0 ? void 0 : _a.nativeFocusableElement) || this.elementRef.nativeElement;
    }
    get isTextFieldElement() {
      return this.element.matches(`input, textarea`);
    }
  };
  AbstractTuiAutofocusHandler.ɵfac = function AbstractTuiAutofocusHandler_Factory(t) {
    return new (t || AbstractTuiAutofocusHandler)(core_js_["ɵɵdirectiveInject"](undefined), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef));
  };
  AbstractTuiAutofocusHandler.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: AbstractTuiAutofocusHandler
  });
  return AbstractTuiAutofocusHandler;
})();
const TIMEOUT = 1000;
const NG_ANIMATION_SELECTOR = `.ng-animating`;
let TuiDefaultAutofocusHandler = /*#__PURE__*/(() => {
  let TuiDefaultAutofocusHandler = class TuiDefaultAutofocusHandler extends AbstractTuiAutofocusHandler {
    constructor(tuiFocusableComponent, elementRef, animationFrame$) {
      super(tuiFocusableComponent, elementRef);
      this.animationFrame$ = animationFrame$;
    }
    setFocus() {
      if (this.isTextFieldElement) {
        race((0,observable_timer/* timer */.H)(TIMEOUT), this.animationFrame$.pipe((0,throttleTime/* throttleTime */.p)(taiga_ui_cdk_constants/* POLLING_TIME */.Yg), (0,operators_map/* map */.U)(() => this.element.closest(NG_ANIMATION_SELECTOR)), skipWhile(Boolean), (0,operators_take/* take */.q)(1))).subscribe(() => this.element.focus());
      } else {
        this.element.focus();
      }
    }
  };
  TuiDefaultAutofocusHandler.ɵfac = function TuiDefaultAutofocusHandler_Factory(t) {
    return new (t || TuiDefaultAutofocusHandler)(core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ, 10), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* ANIMATION_FRAME */.L1));
  };
  TuiDefaultAutofocusHandler.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiDefaultAutofocusHandler,
    features: [core_js_["ɵɵInheritDefinitionFeature"]]
  });
  TuiDefaultAutofocusHandler = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(ng_web_apis_common/* ANIMATION_FRAME */.L1))], TuiDefaultAutofocusHandler);

  // @dynamic
  return TuiDefaultAutofocusHandler;
})();
let TuiIosAutofocusHandler = /*#__PURE__*/(() => {
  let TuiIosAutofocusHandler = class TuiIosAutofocusHandler extends AbstractTuiAutofocusHandler {
    constructor(tuiFocusableComponent, elementRef, renderer, ngZone, windowRef) {
      super(tuiFocusableComponent, elementRef);
      this.renderer = renderer;
      this.ngZone = ngZone;
      this.windowRef = windowRef;
      this.patchCssStyles();
    }
    setFocus() {
      if (this.isTextFieldElement) {
        this.ngZone.runOutsideAngular(() => this.iosWebkitAutofocus());
      } else {
        this.element.focus();
      }
    }
    iosWebkitAutofocus() {
      var _a;
      const fakeInput = this.makeFakeInput();
      const duration = this.getDurationTimeBeforeFocus();
      let fakeFocusTimeoutId = 0;
      let elementFocusTimeoutId = 0;
      const blurHandler = () => fakeInput.focus({
        preventScroll: true
      });
      const focusHandler = () => {
        clearTimeout(fakeFocusTimeoutId);
        fakeFocusTimeoutId = this.windowRef.setTimeout(() => {
          clearTimeout(elementFocusTimeoutId);
          fakeInput.removeEventListener(`blur`, blurHandler);
          fakeInput.removeEventListener(`focus`, focusHandler);
          elementFocusTimeoutId = this.windowRef.setTimeout(() => {
            this.element.focus({
              preventScroll: false
            });
            fakeInput.remove();
          }, duration);
        });
      };
      fakeInput.addEventListener(`blur`, blurHandler, {
        once: true
      });
      fakeInput.addEventListener(`focus`, focusHandler);
      if (this.insideDialog()) {
        this.windowRef.document.body.appendChild(fakeInput);
      } else {
        (_a = this.element.parentElement) === null || _a === void 0 ? void 0 : _a.appendChild(fakeInput);
      }
      fakeInput.focus({
        preventScroll: true
      });
    }
    /**
     * @note:
     * emulate textfield position in layout with cursor
     * before focus to real textfield element
     */
    makeFakeInput() {
      const fakeInput = this.renderer.createElement(`input`);
      const rect = this.element.getBoundingClientRect();
      fakeInput.setAttribute(`maxlength`, `0`);
      // @note: don't use opacity: 0,
      // sometimes it's doesn't work for emulate real input
      fakeInput.style.height = tuiPx(rect.height);
      fakeInput.style.width = tuiPx(rect.width / 2);
      fakeInput.style.position = `fixed`;
      fakeInput.style.zIndex = `-99999999`;
      fakeInput.style.caretColor = `transparent`;
      fakeInput.style.color = `transparent`;
      fakeInput.style.cursor = `none`;
      fakeInput.style.fontSize = tuiPx(16); // disable possible auto zoom
      fakeInput.readOnly = true; // prevent keyboard for fake input
      // @note: emulate position cursor before focus to real textfield element
      fakeInput.style.top = tuiPx(rect.top);
      fakeInput.style.left = tuiPx(rect.left);
      return fakeInput;
    }
    getDurationTimeBeforeFocus() {
      return parseFloat(this.windowRef.getComputedStyle(this.element).getPropertyValue(`--tui-duration`)) || 0;
    }
    /**
     * @note:
     * unfortunately, in older versions of iOS
     * there is a bug that the fake input cursor
     * will move along with the dialog animation
     * and then that dialog will be shaking
     */
    insideDialog() {
      return !!this.element.closest(`tui-dialog`);
    }
    /**
     * @note:
     * This is necessary so that the viewport isn't recalculated
     * and then the dialogs don't shake.
     *
     * Also, we need to fixed height viewport,
     * so that when focusing the dialogs don't shake
     */
    patchCssStyles() {
      const documentRef = this.windowRef.document;
      for (const element of [documentRef.documentElement, documentRef.body]) {
        element.style.setProperty(`overflow`, `auto`);
        element.style.setProperty(`height`, `100%`);
      }
    }
  };
  TuiIosAutofocusHandler.ɵfac = function TuiIosAutofocusHandler_Factory(t) {
    return new (t || TuiIosAutofocusHandler)(core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ, 10), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.Renderer2), core_js_["ɵɵdirectiveInject"](core_js_.NgZone), core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* WINDOW */.m9));
  };
  TuiIosAutofocusHandler.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiIosAutofocusHandler,
    features: [core_js_["ɵɵInheritDefinitionFeature"]]
  });
  TuiIosAutofocusHandler = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.Renderer2)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(core_js_.NgZone)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(ng_web_apis_common/* WINDOW */.m9))], TuiIosAutofocusHandler);
  return TuiIosAutofocusHandler;
})();
const TUI_AUTOFOCUS_HANDLER = new core_js_.InjectionToken(`Autofocusing handler`);
// TODO: 3.0 remove in ivy compilation
function tuiAutofocusHandlerFactory(tuiFocusableComponent, elementRef, animationFrame$, renderer, ngZone, windowRef, isIos) {
  return isIos ? new TuiIosAutofocusHandler(tuiFocusableComponent, elementRef, renderer, ngZone, windowRef) : new TuiDefaultAutofocusHandler(tuiFocusableComponent, elementRef, animationFrame$);
}
const TUI_AUTOFOCUS_PROVIDERS = [{
  provide: TUI_AUTOFOCUS_HANDLER,
  // TODO: replace to useClass in v3.0
  useFactory: tuiAutofocusHandlerFactory,
  deps: [[new core_js_.Optional(), new core_js_.Self(), taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ], core_js_.ElementRef, ng_web_apis_common/* ANIMATION_FRAME */.L1, core_js_.Renderer2, core_js_.NgZone, ng_web_apis_common/* WINDOW */.m9, taiga_ui_cdk_tokens/* TUI_IS_IOS */.FA]
}];

// TODO: 3.0 change input name to tuiAutoFocus and handle empty string
let TuiAutoFocusDirective = /*#__PURE__*/(() => {
  let TuiAutoFocusDirective = class TuiAutoFocusDirective {
    constructor(handler) {
      this.handler = handler;
      this.autoFocus = true;
    }
    ngAfterViewInit() {
      if (this.autoFocus) {
        this.focus();
      }
    }
    focus() {
      void Promise.resolve().then(() => this.handler.setFocus());
    }
  };
  TuiAutoFocusDirective.ɵfac = function TuiAutoFocusDirective_Factory(t) {
    return new (t || TuiAutoFocusDirective)(core_js_["ɵɵdirectiveInject"](TUI_AUTOFOCUS_HANDLER));
  };
  TuiAutoFocusDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiAutoFocusDirective,
    selectors: [["", "tuiAutoFocus", ""]],
    inputs: {
      autoFocus: "autoFocus"
    },
    features: [core_js_["ɵɵProvidersFeature"](TUI_AUTOFOCUS_PROVIDERS)]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiAutoFocusDirective.prototype, "autoFocus", void 0);
  TuiAutoFocusDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TUI_AUTOFOCUS_HANDLER))], TuiAutoFocusDirective);
  return TuiAutoFocusDirective;
})();
let TuiAutoFocusModule = /*#__PURE__*/(() => {
  let TuiAutoFocusModule = class TuiAutoFocusModule {};
  TuiAutoFocusModule.ɵfac = function TuiAutoFocusModule_Factory(t) {
    return new (t || TuiAutoFocusModule)();
  };
  TuiAutoFocusModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiAutoFocusModule
  });
  TuiAutoFocusModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiAutoFocusModule;
})();
let TuiSynchronousAutofocusHandler = /*#__PURE__*/(/* unused pure expression or super */ null && ((() => {
  let TuiSynchronousAutofocusHandler = class TuiSynchronousAutofocusHandler extends AbstractTuiAutofocusHandler {
    constructor(tuiFocusableComponent, elementRef) {
      super(tuiFocusableComponent, elementRef);
    }
    setFocus() {
      this.element.focus();
    }
  };
  TuiSynchronousAutofocusHandler.ɵfac = function TuiSynchronousAutofocusHandler_Factory(t) {
    return new (t || TuiSynchronousAutofocusHandler)(ɵngcc0.ɵɵdirectiveInject(TUI_FOCUSABLE_ITEM_ACCESSOR, 10), ɵngcc0.ɵɵdirectiveInject(ElementRef));
  };
  TuiSynchronousAutofocusHandler.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({
    type: TuiSynchronousAutofocusHandler,
    features: [ɵngcc0.ɵɵInheritDefinitionFeature]
  });
  TuiSynchronousAutofocusHandler = __decorate([__param(0, Optional()), __param(0, Self()), __param(0, Inject(TUI_FOCUSABLE_ITEM_ACCESSOR)), __param(1, Inject(ElementRef))], TuiSynchronousAutofocusHandler);
  return TuiSynchronousAutofocusHandler;
})()));
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiAutoFocusModule, {
    declarations: [TuiAutoFocusDirective],
    exports: [TuiAutoFocusDirective]
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-auto-focus.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/i18n/fesm2015/taiga-ui-i18n-enums.js
var taiga_ui_i18n_enums = __webpack_require__(1081);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-constants.js
var taiga_ui_core_constants = __webpack_require__(8269);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-constants.js




/**
 * @deprecated Dont use it (will be deleted soon).
 * - Use token `TUI_COUNTRIES_MASKS` to get phone mask by country iso code
 * - Use token `TUI_COUNTRIES` to get localized country name by its iso code
 * @example
 * import {TUI_COUNTRIES, TUI_COUNTRIES_MASKS} from '@taiga-ui/kit';
 *
 * @todo TODO: remove it in 3.0
 */
const COUNTRIES = {
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AD]: {
    mask: `+376###-###`,
    name: `Андорра`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AE]: {
    mask: `+971-##-###-####`,
    name: `Объединенные Арабские Эмираты`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AF]: {
    mask: `+93##-###-####`,
    name: `Афганистан`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AG]: {
    mask: `+1(268) ###-####`,
    name: `Антигуа и Барбуда`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AI]: {
    mask: `+1(264) ###-####`,
    name: `Ангилья`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AL]: {
    mask: `+355(###) ###-###`,
    name: `Албания`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AM]: {
    mask: `+374##-###-###`,
    name: `Армения`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AO]: {
    mask: `+244(###) ###-###`,
    name: `Ангола`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AR]: {
    mask: `+54(###) ###-####`,
    name: `Аргентина`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AT]: {
    mask: `+43(###) ###-####`,
    name: `Австрия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AU]: {
    mask: `+61#-####-####`,
    name: `Австралия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AW]: {
    mask: `+297###-####`,
    name: `Аруба`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AZ]: {
    mask: `+994##-###-##-##`,
    name: `Азербайджан`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BA]: {
    mask: `+387 ###-####-#`,
    name: `Босния и Герцеговина`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BB]: {
    mask: `+1(246) ###-####`,
    name: `Барбадос`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BD]: {
    mask: `+880##-###-###`,
    name: `Бангладеш`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BE]: {
    mask: `+32(###) ###-###`,
    name: `Бельгия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BF]: {
    mask: `+226##-##-####`,
    name: `Буркина Фасо`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BG]: {
    mask: `+359(###) ###-###`,
    name: `Болгария`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BH]: {
    mask: `+973####-####`,
    name: `Бахрейн`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BI]: {
    mask: `+257##-##-####`,
    name: `Бурунди`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BJ]: {
    mask: `+229##-##-####`,
    name: `Бенин`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BL]: {
    mask: `+590 ## ## ## ## ##`,
    name: `Сен-Бартельми`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BM]: {
    mask: `+1(441) ###-####`,
    name: `Бермудские острова`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BN]: {
    mask: `+673###-####`,
    name: `Бруней-Даруссалам`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BO]: {
    mask: `+591#-###-####`,
    name: `Боливия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BQ]: {
    mask: `+599-###-####`,
    name: `Бонайре, Синт-Эстатиус и Саба`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BR]: {
    mask: `+55(##) ####-####`,
    name: `Бразилия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BS]: {
    mask: `+1(242) ###-####`,
    name: `Багамские Острова`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BT]: {
    mask: `+975#-###-###`,
    name: `Бутан`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BW]: {
    mask: `+267##-###-###`,
    name: `Ботсвана`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BY]: {
    mask: `+375(##) ###-##-##`,
    name: `Беларусь (Белоруссия)`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BZ]: {
    mask: `+501###-####`,
    name: `Белиз`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CA]: {
    mask: `+1(###) ###-####`,
    name: `Канада`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CD]: {
    mask: `+243(###) ###-###`,
    name: `Дем. Респ. Конго (Киншаса)`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CF]: {
    mask: `+236-##-##-####`,
    name: `Центральноафриканская Республика`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CG]: {
    mask: `+242##-###-####`,
    name: `Конго (Браззавиль)`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CH]: {
    mask: `+41##-###-####`,
    name: `Швейцария`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CI]: {
    mask: `+225##-###-###`,
    name: `Кот-д’Ивуар`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CL]: {
    mask: `+56#-####-####`,
    name: `Чили`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CM]: {
    mask: `+237####-####`,
    name: `Камерун`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CN]: {
    mask: `+86(###) ####-####`,
    name: `Китайская Н.Р.`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CO]: {
    mask: `+57(###) ###-####`,
    name: `Колумбия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CR]: {
    mask: `+506####-####`,
    name: `Коста-Рика`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CU]: {
    mask: `+53#-###-####`,
    name: `Куба`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CV]: {
    mask: `+238(###) ##-##`,
    name: `Кабо-Верде`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CW]: {
    mask: `+5999-###-####`,
    name: `Кюрасао`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CY]: {
    mask: `+357##-###-###`,
    name: `Кипр`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CZ]: {
    mask: `+420(###) ###-###`,
    name: `Чехия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.DE]: {
    mask: `+49(###) ###-###-##`,
    name: `Германия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.DJ]: {
    mask: `+253##-##-##-##`,
    name: `Джибути`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.DK]: {
    mask: `+45##-##-##-##`,
    name: `Дания`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.DM]: {
    mask: `+1(767) ###-####`,
    name: `Доминика`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.DO]: {
    mask: `+1(###) ###-####`,
    name: `Доминиканская Республика`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.DZ]: {
    mask: `+213##-###-####`,
    name: `Алжир`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.EC]: {
    mask: `+593##-###-####`,
    name: `Эквадор `
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.EE]: {
    mask: `+372####-####`,
    name: `Эстония `
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.EG]: {
    mask: `+20(###) ###-####`,
    name: `Египет`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.ER]: {
    mask: `+291#-###-###`,
    name: `Эритрея`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.ES]: {
    mask: `+34(###) ###-###`,
    name: `Испания`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.ET]: {
    mask: `+251##-###-####`,
    name: `Эфиопия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.FI]: {
    mask: `+358(###) ###-##-##`,
    name: `Финляндия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.FJ]: {
    mask: `+679##-#####`,
    name: `Фиджи`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.FK]: {
    mask: `+500#####`,
    name: `Фолклендские острова`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.FM]: {
    mask: `+691###-####`,
    name: `Ф.Ш. Микронезии`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.FR]: {
    mask: `+33 ## ## ## ## ##`,
    name: `Франция`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GA]: {
    mask: `+241#-##-##-##`,
    name: `Габон`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GB]: {
    mask: `+44##-####-####`,
    name: `Великобритания`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GD]: {
    mask: `+1(473) ###-####`,
    name: `Гренада`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GE]: {
    mask: `+995(###) ###-###`,
    name: `Грузия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GF]: {
    mask: `+594 ## ## ## ## ##`,
    name: `Гайана`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GH]: {
    mask: `+233(###) ###-###`,
    name: `Гана`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GI]: {
    mask: `+350###-#####`,
    name: `Гибралтар`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GL]: {
    mask: `+299##-##-##`,
    name: `Гренландия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GM]: {
    mask: `+220(###) ##-##`,
    name: `Гамбия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GN]: {
    mask: `+224##-###-###`,
    name: `Гвинея`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GP]: {
    mask: `+590 ## ## ## ## ##`,
    name: `Гваделупа`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GQ]: {
    mask: `+240##-###-####`,
    name: `Экваториальная Гвинея`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GR]: {
    mask: `+30(###) ###-####`,
    name: `Греция`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GT]: {
    mask: `+502#-###-####`,
    name: `Гватемала`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GW]: {
    mask: `+245#-######`,
    name: `Гвинея-Бисау`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GY]: {
    mask: `+592###-####`,
    name: `Гайана`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.HK]: {
    mask: `+852####-####`,
    name: `Гонконг`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.HN]: {
    mask: `+504####-####`,
    name: `Гондурас`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.HR]: {
    mask: `+385##-###-###`,
    name: `Хорватия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.HT]: {
    mask: `+509##-##-####`,
    name: `Гаити`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.HU]: {
    mask: `+36(###) ###-###`,
    name: `Венгрия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.ID]: {
    mask: `+62(###) ###-##-###`,
    name: `Индонезия `
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.IE]: {
    mask: `+353(###) ###-###`,
    name: `Ирландия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.IL]: {
    mask: `+972##-###-####`,
    name: `Израиль`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.IN]: {
    mask: `+91(####) ###-###`,
    name: `Индия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.IQ]: {
    mask: `+964(###) ###-####`,
    name: `Ирак`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.IR]: {
    mask: `+98(###) ###-####`,
    name: `Иран`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.IS]: {
    mask: `+354###-####`,
    name: `Исландия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.IT]: {
    mask: `+39(###) ####-###`,
    name: `Италия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.JM]: {
    mask: `+1(876) ###-####`,
    name: `Ямайка`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.JO]: {
    mask: `+962#-####-####`,
    name: `Иордания`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.JP]: {
    mask: `+81-##-####-####`,
    name: `Япония `
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.KE]: {
    mask: `+254###-######`,
    name: `Кения`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.KG]: {
    mask: `+996(###) ###-###`,
    name: `Киргизия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.KH]: {
    mask: `+855##-###-###`,
    name: `Камбоджа`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.KM]: {
    mask: `+269##-#####`,
    name: `Коморы`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.KN]: {
    mask: `+1(869) ###-####`,
    name: `Сент-Китс и Невис`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.KP]: {
    mask: `+850####-#############`,
    name: `Корейская НДР`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.KR]: {
    mask: `+82##-###-####`,
    name: `Респ. Корея`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.KW]: {
    mask: `+965####-####`,
    name: `Кувейт`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.KY]: {
    mask: `+1(345) ###-####`,
    name: `Каймановы острова`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.KZ]: {
    mask: `+7(###) ###-##-##`,
    name: `Казахстан`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LA]: {
    mask: `+856##-##-###-###`,
    name: `Лаос`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LB]: {
    mask: `+961##-###-###`,
    name: `Ливан `
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LC]: {
    mask: `+1(758) ###-####`,
    name: `Сент-Люсия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LI]: {
    mask: `+423(###) ###-####`,
    name: `Лихтенштейн`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LK]: {
    mask: `+94##-###-####`,
    name: `Шри-Ланка`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LR]: {
    mask: `+231##-###-###`,
    name: `Либерия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LS]: {
    mask: `+266#-###-####`,
    name: `Лесото`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LT]: {
    mask: `+370(###) ##-###`,
    name: `Литва`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LU]: {
    mask: `+352(###) ###-###`,
    name: `Люксембург`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LV]: {
    mask: `+371##-###-###`,
    name: `Латвия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LY]: {
    mask: `+218##-###-####`,
    name: `Ливия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MA]: {
    mask: `+212##-####-###`,
    name: `Марокко`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MC]: {
    mask: `+377###-###-###`,
    name: `Монако`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MD]: {
    mask: `+373####-####`,
    name: `Молдова`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.ME]: {
    mask: `+382##-###-###`,
    name: `Черногория`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MF]: {
    mask: `+590 ## ## ## ## ##`,
    name: `Сен-Мартен`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MG]: {
    mask: `+261##-##-#####`,
    name: `Мадагаскар`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MK]: {
    mask: `+389##-###-###`,
    name: `Респ. Македония`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.ML]: {
    mask: `+223##-##-####`,
    name: `Мали`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MM]: {
    mask: `+95##-###-###`,
    name: `Бирма (Мьянма)`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MN]: {
    mask: `+976##-##-####`,
    name: `Монголия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MO]: {
    mask: `+853####-####`,
    name: `Макао`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MQ]: {
    mask: `+596 ## ## ## ## ##`,
    name: `Мартиника`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MR]: {
    mask: `+222##-##-####`,
    name: `Мавритания`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MS]: {
    mask: `+1(664) ###-####`,
    name: `Монтсеррат`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MT]: {
    mask: `+356####-####`,
    name: `Мальта`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MU]: {
    mask: `+230###-####`,
    name: `Маврикий`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MV]: {
    mask: `+960###-####`,
    name: `Мальдивские острова`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MW]: {
    mask: `+265#-####-####`,
    name: `Малави`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MX]: {
    mask: `+52(###) ###-####`,
    name: `Мексика`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MY]: {
    mask: `+60(###) ###-###`,
    name: `Малайзия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MZ]: {
    mask: `+258##-###-###`,
    name: `Мозамбик`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.NA]: {
    mask: `+264##-###-####`,
    name: `Намибия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.NC]: {
    mask: `+687 ### ###`,
    name: `Каледония`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.NE]: {
    mask: `+227##-##-####`,
    name: `Нигер`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.NG]: {
    mask: `+234(###) ###-####`,
    name: `Нигерия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.NI]: {
    mask: `+505####-####`,
    name: `Никарагуа`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.NL]: {
    mask: `+31##-###-####`,
    name: `Нидерланды`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.NO]: {
    mask: `+47(###) ##-###`,
    name: `Норвегия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.NP]: {
    mask: `+977##-###-###`,
    name: `Непал`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.NZ]: {
    mask: `+64(###) ###-####`,
    name: `Новая Зеландия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.OM]: {
    mask: `+968##-###-###`,
    name: `Оман`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PA]: {
    mask: `+507###-####`,
    name: `Панама`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PE]: {
    mask: `+51(###) ###-###`,
    name: `Перу`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PF]: {
    mask: `+689##-##-##`,
    name: `Французская Полинезия (Таити)`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PG]: {
    mask: `+675(###) ##-###`,
    name: `Папуа-Новая Гвинея`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PH]: {
    mask: `+63(###) ###-####`,
    name: `Филиппины`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PK]: {
    mask: `+92(###) ###-####`,
    name: `Пакистан`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PL]: {
    mask: `+48(###) ###-###`,
    name: `Польша`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PT]: {
    mask: `+351##-###-####`,
    name: `Португалия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PW]: {
    mask: `+680###-####`,
    name: `Палау`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PY]: {
    mask: `+595(###) ###-###`,
    name: `Парагвай`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.QA]: {
    mask: `+974####-####`,
    name: `Катар`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.RE]: {
    mask: `+262 ## ## ## ## ##`,
    name: `Реюньон`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.RO]: {
    mask: `+40##-###-####`,
    name: `Румыния`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.RS]: {
    mask: `+381##-###-####`,
    name: `Сербия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.RU]: {
    mask: `+7### ###-##-##`,
    name: `Россия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.RW]: {
    mask: `+250(###) ###-###`,
    name: `Руанда`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SA]: {
    mask: `+966#-####-####`,
    name: `Саудовская Аравия `
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SB]: {
    mask: `+677###-####`,
    name: `Соломоновы Острова `
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SC]: {
    mask: `+248#-###-###`,
    name: `Сейшелы`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SD]: {
    mask: `+249##-###-####`,
    name: `Судан`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SE]: {
    mask: `+46##-###-####`,
    name: `Швеция`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SG]: {
    mask: `+65####-####`,
    name: `Сингапур`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SH]: {
    mask: `+290####`,
    name: `Остров Святой Елены`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SI]: {
    mask: `+386##-###-###`,
    name: `Словения`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SK]: {
    mask: `+421(###) ###-###`,
    name: `Словакия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SL]: {
    mask: `+232##-######`,
    name: `Сьерра-Леоне`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SM]: {
    mask: `+378####-######`,
    name: `Сан-Марино`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SN]: {
    mask: `+221##-###-####`,
    name: `Сенегал`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SO]: {
    mask: `+252##-###-###`,
    name: `Сомали`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SR]: {
    mask: `+597###-####`,
    name: `Суринам `
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.ST]: {
    mask: `+239##-#####`,
    name: `Сан-Томе и Принсипи`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SV]: {
    mask: `+503##-##-####`,
    name: `Сальвадор`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SX]: {
    mask: `+1(721) ###-####`,
    name: `Синт-Мартен`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SY]: {
    mask: `+963##-####-###`,
    name: `Сирийская арабская республика`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SZ]: {
    mask: `+268##-##-####`,
    name: `Свазиленд`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TC]: {
    mask: `+1(649) ###-####`,
    name: `Тёркс и Кайкос`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TD]: {
    mask: `+235##-##-##-##`,
    name: `Чад`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TG]: {
    mask: `+228##-###-###`,
    name: `Того`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TH]: {
    mask: `+66##-###-####`,
    name: `Таиланд `
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TJ]: {
    mask: `+992##-###-####`,
    name: `Таджикистан`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TL]: {
    mask: `+670###-#####`,
    name: `Восточный Тимор`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TM]: {
    mask: `+993#-###-####`,
    name: `Туркменистан`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TN]: {
    mask: `+216##-###-###`,
    name: `Тунис`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TO]: {
    mask: `+676#####`,
    name: `Тонга`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TR]: {
    mask: `+90(###) ###-####`,
    name: `Турция`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TT]: {
    mask: `+1(868) ###-####`,
    name: `Тринидад и Тобаго`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TW]: {
    mask: `+886#-####-####`,
    name: `Тайвань`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TZ]: {
    mask: `+255##-###-####`,
    name: `Танзания`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.UA]: {
    mask: `+380(##) ###-##-##`,
    name: `Украина`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.UG]: {
    mask: `+256(###) ###-###`,
    name: `Уганда`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.US]: {
    mask: `+1(###) ###-####`,
    name: `США`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.UY]: {
    mask: `+598#-###-##-##`,
    name: `Уругвай`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.UZ]: {
    mask: `+998##-###-####`,
    name: `Узбекистан`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.VC]: {
    mask: `+1(784) ###-####`,
    name: `Сент-Винсент и Гренадины`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.VE]: {
    mask: `+58(###) ###-####`,
    name: `Венесуэла`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.VG]: {
    mask: `+1(284)###-####`,
    name: `Британские Виргинские острова`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.VN]: {
    mask: `+84(###) ####-###`,
    name: `Вьетнам`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.VU]: {
    mask: `+678##-#####`,
    name: `Вануату `
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.WS]: {
    mask: `+685##-####`,
    name: `Самоа`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.XK]: {
    mask: `+383##-###-###`,
    name: `Косово`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.YE]: {
    mask: `+967###-###-###`,
    name: `Йемен `
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.YT]: {
    mask: `+262 ## ## ## ## ##`,
    name: `Майотта`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.ZA]: {
    mask: `+27##-###-####`,
    name: `Южно-Африканская Респ.`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.ZM]: {
    mask: `+260##-###-####`,
    name: `Замбия`
  },
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.ZW]: {
    mask: `+263#-######`,
    name: `Зимбабве`
  }
};
/**
 * @deprecated will be deleted soon
 * TODO: remove in 3.0 (in ivy compilation)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function countriesMasksReducer(acc, [countryIsoCode, {
  mask
}]) {
  acc[countryIsoCode] = mask;
  return acc;
}
/**
 * @deprecated will be deleted soon
 * Use token `TUI_COUNTRIES_MASKS`
 * TODO: remove in 3.0
 */
const COUNTRIES_MASKS = Object.entries(COUNTRIES).reduce(countriesMasksReducer, {});
const DATE_TIME_SEPARATOR = (/* unused pure expression or super */ null && (`, `));
const EMPTY_MASK = {
  mask() {
    return false;
  }
};
const GROUP_CLASS_NAMES = (/* unused pure expression or super */ null && ([`_active`, `_disabled`, `_focused`, `_focus-visible`, `_hosted_dropdown_focused`, `ng-invalid`, `ng-touched`, `_pressed`, `_readonly`]));
const iconBlank = (/* unused pure expression or super */ null && (`<svg></svg>`));
const MASK_AFTER_CODE_REGEXP = /\([#]+\)|[#\- ]/g;
const TUI_PHONE_MASK = [taiga_ui_cdk_constants/* CHAR_PLUS */.kU, `7`, ` `, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW, ` `, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW, taiga_ui_cdk_constants/* CHAR_HYPHEN */.fv, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW, taiga_ui_cdk_constants/* CHAR_HYPHEN */.fv, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW];
const TUI_TIME_MASK = [taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW, `:`, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW];
/**
 * @deprecated use {@link tuiCreateDateMask} (from '@taiga-ui/kit') instead
 */
const TUI_DATE_MASK = [taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW, `.`, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW, `.`, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW];
/**
 * @deprecated use {@link tuiCreateDateRangeMask} (from '@taiga-ui/kit') instead
 */
const TUI_DATE_RANGE_MASK = [...TUI_DATE_MASK, taiga_ui_cdk_constants/* CHAR_NO_BREAK_SPACE */.f$, taiga_ui_cdk_constants/* CHAR_EN_DASH */.F, taiga_ui_cdk_constants/* CHAR_NO_BREAK_SPACE */.f$, ...TUI_DATE_MASK];

/**
 * Used as a limit for eliminating JS issues with floating point math
 */
const TUI_FLOATING_PRECISION = 7;
const MAX_DAY_RANGE_LENGTH_MAPPER = (min, value, maxLength, backwards) => {
  if (!(value === null || value === void 0 ? void 0 : value.isSingleDay) || !maxLength) {
    return min;
  }
  const dateShift = value.from.append(maxLength, backwards).append({
    day: 1
  }, !backwards);
  if (backwards) {
    return dateShift.dayBefore(min) ? min : dateShift;
  }
  if (!min) {
    return dateShift;
  }
  return dateShift.dayAfter(min) ? min : dateShift;
};
const MAX_TIME_VALUES = {
  HH: 23,
  MM: 59,
  SS: 59,
  MS: 999
};
const DEFAULT_ROUTER_LINK_OPTIONS = {
  fragment: ``,
  preserveFragment: true,
  replaceUrl: false,
  skipLocationChange: false,
  queryParams: null,
  useHref: false,
  target: null
};

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-constants.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/i18n/fesm2015/taiga-ui-i18n-tools.js + 2 modules
var taiga_ui_i18n_tools = __webpack_require__(8345);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-tokens.js




const TUI_CALENDAR_DATA_STREAM = new core_js_.InjectionToken(`Stream that emits calendar data change`);
const TUI_COUNTRIES_MASKS = new core_js_.InjectionToken(`Countries masks`, {
  factory: () => COUNTRIES_MASKS
});
const TUI_DATE_VALUE_TRANSFORMER = new core_js_.InjectionToken(`Control value transformer of TuiDay to custom value format for InputDate* components`);
const TUI_DATE_RANGE_VALUE_TRANSFORMER = new core_js_.InjectionToken(`Control value transformer for InputDateRange component`);
const TUI_DATE_TIME_VALUE_TRANSFORMER = new core_js_.InjectionToken(`Control value transformer for InputDateTime component`);
const TUI_CANCEL_WORD = new core_js_.InjectionToken(`i18n 'cancel' word`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`cancel`)
});
const TUI_DONE_WORD = new core_js_.InjectionToken(`i18n 'done' word`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`done`)
});
const TUI_MORE_WORD = new core_js_.InjectionToken(`i18n 'more' word`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`more`)
});
const TUI_HIDE_TEXT = new core_js_.InjectionToken(`i18n 'hide' word`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`hide`)
});
const TUI_SHOW_ALL_TEXT = new core_js_.InjectionToken(`i18n 'show all' word`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`showAll`)
});
const TUI_OTHER_DATE_TEXT = new core_js_.InjectionToken(`i18n 'Other date' text`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`otherDate`)
});
const TUI_CHOOSE_DAY_OR_RANGE_TEXTS = new core_js_.InjectionToken(`choose day or range i18n texts`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`mobileCalendarTexts`)
});
const TUI_FROM_TO_TEXTS = new core_js_.InjectionToken(`from and to i18n texts`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`range`)
});
const TUI_PLUS_MINUS_TEXTS = new core_js_.InjectionToken(`plus and minus i18n texts`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`countTexts`)
});
const TUI_TIME_TEXTS = new core_js_.InjectionToken(`time i18n texts`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`time`)
});
const TUI_DATE_TEXTS = new core_js_.InjectionToken(`date format i18n texts`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`dateTexts`)
});
const TUI_DIGITAL_INFORMATION_UNITS = new core_js_.InjectionToken(`short bytes, kilobytes and megabytes i18n texts`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`digitalInformationUnits`)
});
const TUI_COPY_TEXTS = new core_js_.InjectionToken(`copy i18n texts`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`copyTexts`)
});
const TUI_PASSWORD_TEXTS = new core_js_.InjectionToken(`password i18n texts`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`passwordTexts`)
});
const TUI_CALENDAR_MONTHS = new core_js_.InjectionToken(`short calendar months i18n`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`shortCalendarMonths`)
});
const TUI_FILE_TEXTS = new core_js_.InjectionToken(`file i18n texts`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`fileTexts`)
});
const TUI_PAGINATION_TEXTS = new core_js_.InjectionToken(`pagination i18n texts`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`pagination`)
});
const TUI_INPUT_FILE_TEXTS = new core_js_.InjectionToken(`tui-input-file i18n texts`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`inputFileTexts`)
});
const TUI_COUNTRIES = new core_js_.InjectionToken(`Localized countries names`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`countries`)
});
const TUI_DEFAULT_ITEMS_HANDLERS = {
  stringify: taiga_ui_cdk_constants/* TUI_DEFAULT_STRINGIFY */.yZ,
  identityMatcher: taiga_ui_cdk_constants/* TUI_DEFAULT_IDENTITY_MATCHER */.bg,
  disabledItemHandler: taiga_ui_cdk_constants/* ALWAYS_FALSE_HANDLER */.Iy
};
const TUI_ITEMS_HANDLERS = new core_js_.InjectionToken(`Default items handlers for components`, {
  factory: () => TUI_DEFAULT_ITEMS_HANDLERS
});
const tuiItemsHandlersProvider = options => ({
  provide: TUI_ITEMS_HANDLERS,
  useValue: Object.assign(Object.assign({}, TUI_DEFAULT_ITEMS_HANDLERS), options)
});

/** @deprecated use {@link TuiMobileTabsDirective} from @taiga-ui/addon-mobile */
const TUI_MOBILE_AWARE = new core_js_.InjectionToken(`A flag enabling mobile-specific behavior for supporting components`, {
  factory: () => false
});
const TUI_MOBILE_CALENDAR = new core_js_.InjectionToken(`A component for mobile data picker`);
const TUI_MONTH_FORMATTER = new core_js_.InjectionToken(`A function to get localized formatted month`);
const TUI_TAB_MARGIN = new core_js_.InjectionToken(`Margin between tabs`, {
  factory: () => 24
});

// TODO: 3.0 use TUI_TAG_OPTIONS instead of it
const TUI_TAG_STATUS = new core_js_.InjectionToken(`Status for tags inside InputTag component`, {
  factory: () => "primary" /* Primary */
});

const TUI_VALIDATION_ERRORS = new core_js_.InjectionToken(`Validation errors`, {
  factory: () => ({})
});

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-tokens.js.map
// EXTERNAL MODULE: ./node_modules/@angular/forms/fesm2015/forms.js + 1 modules
var fesm2015_forms = __webpack_require__(3738);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-abstract.js
var taiga_ui_cdk_abstract = __webpack_require__(6480);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-focus.js
var taiga_ui_cdk_utils_focus = __webpack_require__(7179);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-tokens.js + 1 modules
var taiga_ui_core_tokens = __webpack_require__(865);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/merge.js
var observable_merge = __webpack_require__(6682);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/noop.js
var util_noop = __webpack_require__(8640);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/observable/never.js


const NEVER = new internal_Observable/* Observable */.y(util_noop/* noop */.Z);
function never() {
  return NEVER;
}
//# sourceMappingURL=never.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/takeUntil.js
var operators_takeUntil = __webpack_require__(6782);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-directives-textfield-controller.js






class TuiTextfieldController {
  constructor(change$, autocompleteDirective, cleanerDirective, customContentDirective, exampleTextDirective, inputModeDirective, labelOutsideDirective, maxLengthDirective, sizeDirective, typeDirective) {
    this.change$ = change$;
    this.autocompleteDirective = autocompleteDirective;
    this.cleanerDirective = cleanerDirective;
    this.customContentDirective = customContentDirective;
    this.exampleTextDirective = exampleTextDirective;
    this.inputModeDirective = inputModeDirective;
    this.labelOutsideDirective = labelOutsideDirective;
    this.maxLengthDirective = maxLengthDirective;
    this.sizeDirective = sizeDirective;
    this.typeDirective = typeDirective;
  }
  get autocomplete() {
    return this.autocompleteDirective.autocomplete;
  }
  get cleaner() {
    return this.cleanerDirective.cleaner;
  }
  get customContent() {
    return this.customContentDirective.customContent || ``;
  }
  get exampleText() {
    return this.exampleTextDirective.exampleText;
  }
  get inputMode() {
    return this.inputModeDirective.inputMode;
  }
  get labelOutside() {
    return this.labelOutsideDirective.labelOutside;
  }
  get maxLength() {
    return this.maxLengthDirective.maxLength;
  }
  get size() {
    return this.sizeDirective.size;
  }
  get type() {
    return this.typeDirective.type;
  }
}
var TuiTextfieldAutocompleteDirective_1;
const TUI_TEXTFIELD_AUTOCOMPLETE = new core_js_.InjectionToken('tuiTextfieldAutocomplete', {
  factory: autocompleteDirectiveFactory
});
let TuiTextfieldAutocompleteDirective = TuiTextfieldAutocompleteDirective_1 = class TuiTextfieldAutocompleteDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor() {
    super(...arguments);
    this.autocomplete = '';
  }
};
TuiTextfieldAutocompleteDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiTextfieldAutocompleteDirective_BaseFactory;
  return function TuiTextfieldAutocompleteDirective_Factory(t) {
    return (ɵTuiTextfieldAutocompleteDirective_BaseFactory || (ɵTuiTextfieldAutocompleteDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiTextfieldAutocompleteDirective)))(t || TuiTextfieldAutocompleteDirective);
  };
}();
TuiTextfieldAutocompleteDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiTextfieldAutocompleteDirective,
  selectors: [["", "tuiTextfieldAutocomplete", ""]],
  inputs: {
    autocomplete: ["tuiTextfieldAutocomplete", "autocomplete"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_TEXTFIELD_AUTOCOMPLETE,
    useExisting: (0,core_js_.forwardRef)(() => TuiTextfieldAutocompleteDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiTextfieldAutocomplete')], TuiTextfieldAutocompleteDirective.prototype, "autocomplete", void 0);
// eslint-disable-next-line @typescript-eslint/naming-convention
function autocompleteDirectiveFactory() {
  return new TuiTextfieldAutocompleteDirective();
}
var TuiTextfieldCleanerDirective_1;
const TUI_TEXTFIELD_CLEANER = new core_js_.InjectionToken('tuiTextfieldCleaner', {
  factory: cleanerDirectiveFactory
});
let TuiTextfieldCleanerDirective = TuiTextfieldCleanerDirective_1 = class TuiTextfieldCleanerDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor() {
    super(...arguments);
    this.cleaner = false;
  }
};
TuiTextfieldCleanerDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiTextfieldCleanerDirective_BaseFactory;
  return function TuiTextfieldCleanerDirective_Factory(t) {
    return (ɵTuiTextfieldCleanerDirective_BaseFactory || (ɵTuiTextfieldCleanerDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiTextfieldCleanerDirective)))(t || TuiTextfieldCleanerDirective);
  };
}();
TuiTextfieldCleanerDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiTextfieldCleanerDirective,
  selectors: [["", "tuiTextfieldCleaner", ""]],
  inputs: {
    cleaner: ["tuiTextfieldCleaner", "cleaner"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_TEXTFIELD_CLEANER,
    useExisting: (0,core_js_.forwardRef)(() => TuiTextfieldCleanerDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiTextfieldCleaner')], TuiTextfieldCleanerDirective.prototype, "cleaner", void 0);
// eslint-disable-next-line @typescript-eslint/naming-convention
function cleanerDirectiveFactory() {
  return new TuiTextfieldCleanerDirective();
}
var TuiTextfieldCustomContentDirective_1;
const TUI_TEXTFIELD_CUSTOM_CONTENT = new core_js_.InjectionToken('tuiTextfieldCustomContent', {
  factory: customContentDirectiveFactory
});
let TuiTextfieldCustomContentDirective = TuiTextfieldCustomContentDirective_1 = class TuiTextfieldCustomContentDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor() {
    super(...arguments);
    // TODO: 3.0 Remove null
    this.customContent = '';
  }
};
TuiTextfieldCustomContentDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiTextfieldCustomContentDirective_BaseFactory;
  return function TuiTextfieldCustomContentDirective_Factory(t) {
    return (ɵTuiTextfieldCustomContentDirective_BaseFactory || (ɵTuiTextfieldCustomContentDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiTextfieldCustomContentDirective)))(t || TuiTextfieldCustomContentDirective);
  };
}();
TuiTextfieldCustomContentDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiTextfieldCustomContentDirective,
  selectors: [["", "tuiTextfieldCustomContent", ""]],
  inputs: {
    customContent: ["tuiTextfieldCustomContent", "customContent"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_TEXTFIELD_CUSTOM_CONTENT,
    useExisting: (0,core_js_.forwardRef)(() => TuiTextfieldCustomContentDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiTextfieldCustomContent')], TuiTextfieldCustomContentDirective.prototype, "customContent", void 0);
// eslint-disable-next-line @typescript-eslint/naming-convention
function customContentDirectiveFactory() {
  return new TuiTextfieldCustomContentDirective();
}
var TuiTextfieldExampleTextDirective_1;
const TUI_TEXTFIELD_EXAMPLE_TEXT = new core_js_.InjectionToken('tuiTextfieldExampleText', {
  factory: exampleTextDirectiveFactory
});
let TuiTextfieldExampleTextDirective = TuiTextfieldExampleTextDirective_1 = class TuiTextfieldExampleTextDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor() {
    super(...arguments);
    this.exampleText = '';
  }
};
TuiTextfieldExampleTextDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiTextfieldExampleTextDirective_BaseFactory;
  return function TuiTextfieldExampleTextDirective_Factory(t) {
    return (ɵTuiTextfieldExampleTextDirective_BaseFactory || (ɵTuiTextfieldExampleTextDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiTextfieldExampleTextDirective)))(t || TuiTextfieldExampleTextDirective);
  };
}();
TuiTextfieldExampleTextDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiTextfieldExampleTextDirective,
  selectors: [["", "tuiTextfieldExampleText", ""]],
  inputs: {
    exampleText: ["tuiTextfieldExampleText", "exampleText"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_TEXTFIELD_EXAMPLE_TEXT,
    useExisting: (0,core_js_.forwardRef)(() => TuiTextfieldExampleTextDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiTextfieldExampleText')], TuiTextfieldExampleTextDirective.prototype, "exampleText", void 0);
// eslint-disable-next-line @typescript-eslint/naming-convention
function exampleTextDirectiveFactory() {
  return new TuiTextfieldExampleTextDirective();
}
var TuiTextfieldInputModeDirective_1;
const TUI_TEXTFIELD_INPUT_MODE = new core_js_.InjectionToken('tuiTextfieldInputMode', {
  factory: inputModeDirectiveFactory
});
let TuiTextfieldInputModeDirective = TuiTextfieldInputModeDirective_1 = class TuiTextfieldInputModeDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor() {
    super(...arguments);
    this.inputMode = 'text';
  }
};
TuiTextfieldInputModeDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiTextfieldInputModeDirective_BaseFactory;
  return function TuiTextfieldInputModeDirective_Factory(t) {
    return (ɵTuiTextfieldInputModeDirective_BaseFactory || (ɵTuiTextfieldInputModeDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiTextfieldInputModeDirective)))(t || TuiTextfieldInputModeDirective);
  };
}();
TuiTextfieldInputModeDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiTextfieldInputModeDirective,
  selectors: [["", "tuiTextfieldInputMode", ""]],
  inputs: {
    inputMode: ["tuiTextfieldInputMode", "inputMode"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_TEXTFIELD_INPUT_MODE,
    useExisting: (0,core_js_.forwardRef)(() => TuiTextfieldInputModeDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiTextfieldInputMode')], TuiTextfieldInputModeDirective.prototype, "inputMode", void 0);
// eslint-disable-next-line @typescript-eslint/naming-convention
function inputModeDirectiveFactory() {
  return new TuiTextfieldInputModeDirective();
}
var TuiTextfieldLabelOutsideDirective_1;
const TUI_TEXTFIELD_LABEL_OUTSIDE = new core_js_.InjectionToken('tuiTextfieldLabelOutside', {
  factory: labelOutsideDirectiveFactory
});
let TuiTextfieldLabelOutsideDirective = TuiTextfieldLabelOutsideDirective_1 = class TuiTextfieldLabelOutsideDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor() {
    super(...arguments);
    this.labelOutside = false;
  }
};
TuiTextfieldLabelOutsideDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiTextfieldLabelOutsideDirective_BaseFactory;
  return function TuiTextfieldLabelOutsideDirective_Factory(t) {
    return (ɵTuiTextfieldLabelOutsideDirective_BaseFactory || (ɵTuiTextfieldLabelOutsideDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiTextfieldLabelOutsideDirective)))(t || TuiTextfieldLabelOutsideDirective);
  };
}();
TuiTextfieldLabelOutsideDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiTextfieldLabelOutsideDirective,
  selectors: [["", "tuiTextfieldLabelOutside", ""]],
  inputs: {
    labelOutside: ["tuiTextfieldLabelOutside", "labelOutside"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_TEXTFIELD_LABEL_OUTSIDE,
    useExisting: (0,core_js_.forwardRef)(() => TuiTextfieldLabelOutsideDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiTextfieldLabelOutside')], TuiTextfieldLabelOutsideDirective.prototype, "labelOutside", void 0);
// eslint-disable-next-line @typescript-eslint/naming-convention
function labelOutsideDirectiveFactory() {
  return new TuiTextfieldLabelOutsideDirective();
}
var TuiTextfieldMaxLengthDirective_1;
const TUI_TEXTFIELD_MAX_LENGTH = new core_js_.InjectionToken('tuiTextfieldMaxLength', {
  factory: maxLengthDirectiveFactory
});
let TuiTextfieldMaxLengthDirective = TuiTextfieldMaxLengthDirective_1 = class TuiTextfieldMaxLengthDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor() {
    super(...arguments);
    this.maxLength = null;
  }
};
TuiTextfieldMaxLengthDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiTextfieldMaxLengthDirective_BaseFactory;
  return function TuiTextfieldMaxLengthDirective_Factory(t) {
    return (ɵTuiTextfieldMaxLengthDirective_BaseFactory || (ɵTuiTextfieldMaxLengthDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiTextfieldMaxLengthDirective)))(t || TuiTextfieldMaxLengthDirective);
  };
}();
TuiTextfieldMaxLengthDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiTextfieldMaxLengthDirective,
  selectors: [["", "tuiTextfieldMaxLength", ""]],
  inputs: {
    maxLength: ["tuiTextfieldMaxLength", "maxLength"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_TEXTFIELD_MAX_LENGTH,
    useExisting: (0,core_js_.forwardRef)(() => TuiTextfieldMaxLengthDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiTextfieldMaxLength')], TuiTextfieldMaxLengthDirective.prototype, "maxLength", void 0);
// eslint-disable-next-line @typescript-eslint/naming-convention
function maxLengthDirectiveFactory() {
  return new TuiTextfieldMaxLengthDirective();
}
var TuiTextfieldSizeDirective_1;
const TUI_TEXTFIELD_SIZE = new core_js_.InjectionToken('tuiTextfieldSize', {
  factory: sizeDirectiveFactory
});
let TuiTextfieldSizeDirective = TuiTextfieldSizeDirective_1 = class TuiTextfieldSizeDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor() {
    super(...arguments);
    this.size = 'l';
  }
};
TuiTextfieldSizeDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiTextfieldSizeDirective_BaseFactory;
  return function TuiTextfieldSizeDirective_Factory(t) {
    return (ɵTuiTextfieldSizeDirective_BaseFactory || (ɵTuiTextfieldSizeDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiTextfieldSizeDirective)))(t || TuiTextfieldSizeDirective);
  };
}();
TuiTextfieldSizeDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiTextfieldSizeDirective,
  selectors: [["", "tuiTextfieldSize", ""]],
  inputs: {
    size: ["tuiTextfieldSize", "size"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_TEXTFIELD_SIZE,
    useExisting: (0,core_js_.forwardRef)(() => TuiTextfieldSizeDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiTextfieldSize')], TuiTextfieldSizeDirective.prototype, "size", void 0);
// eslint-disable-next-line @typescript-eslint/naming-convention
function sizeDirectiveFactory() {
  return new TuiTextfieldSizeDirective();
}
var TuiTextfieldTypeDirective_1;
const TUI_TEXTFIELD_TYPE = new core_js_.InjectionToken('tuiTextfieldType', {
  factory: typeDirectiveFactory
});
let TuiTextfieldTypeDirective = TuiTextfieldTypeDirective_1 = class TuiTextfieldTypeDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor() {
    super(...arguments);
    this.type = 'text';
  }
};
TuiTextfieldTypeDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiTextfieldTypeDirective_BaseFactory;
  return function TuiTextfieldTypeDirective_Factory(t) {
    return (ɵTuiTextfieldTypeDirective_BaseFactory || (ɵTuiTextfieldTypeDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiTextfieldTypeDirective)))(t || TuiTextfieldTypeDirective);
  };
}();
TuiTextfieldTypeDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiTextfieldTypeDirective,
  selectors: [["", "tuiTextfieldType", ""]],
  inputs: {
    type: ["tuiTextfieldType", "type"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_TEXTFIELD_TYPE,
    useExisting: (0,core_js_.forwardRef)(() => TuiTextfieldTypeDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiTextfieldType')], TuiTextfieldTypeDirective.prototype, "type", void 0);
// eslint-disable-next-line @typescript-eslint/naming-convention
function typeDirectiveFactory() {
  return new TuiTextfieldTypeDirective();
}
let TuiTextfieldControllerModule = /*#__PURE__*/(() => {
  let TuiTextfieldControllerModule = class TuiTextfieldControllerModule {};
  TuiTextfieldControllerModule.ɵfac = function TuiTextfieldControllerModule_Factory(t) {
    return new (t || TuiTextfieldControllerModule)();
  };
  TuiTextfieldControllerModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiTextfieldControllerModule
  });
  TuiTextfieldControllerModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiTextfieldControllerModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiTextfieldControllerModule, {
    declarations: [TuiTextfieldAutocompleteDirective, TuiTextfieldCleanerDirective, TuiTextfieldCustomContentDirective, TuiTextfieldExampleTextDirective, TuiTextfieldInputModeDirective, TuiTextfieldLabelOutsideDirective, TuiTextfieldMaxLengthDirective, TuiTextfieldSizeDirective, TuiTextfieldTypeDirective],
    exports: [TuiTextfieldAutocompleteDirective, TuiTextfieldCleanerDirective, TuiTextfieldCustomContentDirective, TuiTextfieldExampleTextDirective, TuiTextfieldInputModeDirective, TuiTextfieldLabelOutsideDirective, TuiTextfieldMaxLengthDirective, TuiTextfieldSizeDirective, TuiTextfieldTypeDirective]
  });
})();
const TUI_TEXTFIELD_WATCHED_CONTROLLER = new core_js_.InjectionToken(`watched textfield controller`);
/**
 * @deprecated: use {@link tuiTextfieldWatchedControllerFactory} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function textfieldWatchedControllerFactory(changeDetectorRef, destroy$, ...controllers) {
  const change$ = (0,observable_merge/* merge */.T)(...controllers.map(({
    change$
  }) => change$ || NEVER)).pipe((0,taiga_ui_cdk_observables/* watch */.YP)(changeDetectorRef), (0,operators_takeUntil/* takeUntil */.R)(destroy$));
  change$.subscribe();
  return new TuiTextfieldController(change$, ...controllers);
}
const TEXTFIELD_CONTROLLER_PROVIDER = [taiga_ui_cdk_services/* TuiDestroyService */.a3, {
  provide: TUI_TEXTFIELD_WATCHED_CONTROLLER,
  deps: [core_js_.ChangeDetectorRef, taiga_ui_cdk_services/* TuiDestroyService */.a3, TUI_TEXTFIELD_AUTOCOMPLETE, TUI_TEXTFIELD_CLEANER, TUI_TEXTFIELD_CUSTOM_CONTENT, TUI_TEXTFIELD_EXAMPLE_TEXT, TUI_TEXTFIELD_INPUT_MODE, TUI_TEXTFIELD_LABEL_OUTSIDE, TUI_TEXTFIELD_MAX_LENGTH, TUI_TEXTFIELD_SIZE, TUI_TEXTFIELD_TYPE],
  useFactory: textfieldWatchedControllerFactory
}];
const tuiTextfieldWatchedControllerFactory = (/* unused pure expression or super */ null && (textfieldWatchedControllerFactory));

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-directives-textfield-controller.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/empty.js
var observable_empty = __webpack_require__(9193);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/switchMap.js
var operators_switchMap = __webpack_require__(3190);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/tap.js
var operators_tap = __webpack_require__(8307);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/shareReplay.js
var shareReplay = __webpack_require__(7349);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/mapTo.js
var operators_mapTo = __webpack_require__(6736);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/debounceTime.js
var operators_debounceTime = __webpack_require__(4395);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-components-portal-host.js




/**
 * @deprecated create your own portal (see {@link https://taiga-ui.dev/portals Portals})
 * TODO: 3.0 replace with {@link TuiDropdownPortalService}
 */

let TuiPortalService = /*#__PURE__*/(() => {
  let TuiPortalService = class TuiPortalService extends taiga_ui_cdk_abstract/* AbstractTuiPortalService */.N9 {};
  TuiPortalService.ɵfac = /*@__PURE__*/function () {
    let ɵTuiPortalService_BaseFactory;
    return function TuiPortalService_Factory(t) {
      return (ɵTuiPortalService_BaseFactory || (ɵTuiPortalService_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiPortalService)))(t || TuiPortalService);
    };
  }();
  TuiPortalService.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function TuiPortalService_Factory() {
      return new TuiPortalService();
    },
    token: TuiPortalService,
    providedIn: "root"
  });
  return TuiPortalService;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-components-portal-host.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-math.js
var taiga_ui_cdk_utils_math = __webpack_require__(5648);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-overscroll.js








/**
 * Directive to isolate scrolling, i.e. prevent body scroll behind modal dialog
 * @dynamic
 */


let TuiOverscrollDirective = /*#__PURE__*/(() => {
  let TuiOverscrollDirective = class TuiOverscrollDirective {
    constructor({
      nativeElement
    }, ngZone, destroy$) {
      this.mode = 'scroll';
      (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, 'wheel', {
        passive: false
      }).pipe((0,operators_filter/* filter */.h)(() => this.enabled), (0,taiga_ui_cdk_observables/* tuiZonefree */.fL)(ngZone), (0,operators_takeUntil/* takeUntil */.R)(destroy$)).subscribe(event => {
        this.processEvent(event, !!event.deltaY, event.deltaY ? event.deltaY < 0 : event.deltaX < 0);
      });
      (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, 'touchstart', {
        passive: true
      }).pipe((0,operators_switchMap/* switchMap */.w)(({
        touches
      }) => {
        let {
          clientX,
          clientY
        } = touches[0];
        let deltaX = 0;
        let deltaY = 0;
        let vertical;
        return (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, 'touchmove', {
          passive: false
        }).pipe((0,operators_filter/* filter */.h)(() => this.enabled), (0,operators_tap/* tap */.b)(event => {
          // We have to have it in tap instead of subscribe due to variables in closure
          const changedTouch = event.changedTouches[0];
          deltaX = clientX - changedTouch.clientX;
          deltaY = clientY - changedTouch.clientY;
          clientX = changedTouch.clientX;
          clientY = changedTouch.clientY;
          if (vertical === undefined) {
            vertical = Math.abs(deltaY) > Math.abs(deltaX);
          }
          this.processEvent(event, vertical, vertical ? deltaY < 0 : deltaX < 0);
        }));
      }), (0,taiga_ui_cdk_observables/* tuiZonefree */.fL)(ngZone), (0,operators_takeUntil/* takeUntil */.R)(destroy$)).subscribe();
    }
    get enabled() {
      return this.mode !== 'none';
    }
    get overscrollBehavior() {
      return this.enabled ? 'contain' : null;
    }
    processEvent(event, vertical, negative) {
      var _a;
      const {
        target,
        currentTarget,
        cancelable
      } = event;
      // TODO: iframe warning
      if (!cancelable || !(target instanceof Element) || ((_a = target) === null || _a === void 0 ? void 0 : _a.type) === 'range') {
        return;
      }
      // This is all what's needed in Chrome/Firefox thanks to CSS overscroll-behavior
      if (this.mode === 'all' && (vertical && !currentTarget.contains((0,taiga_ui_cdk_utils_dom/* getScrollParent */.rP)(target)) || !vertical && !currentTarget.contains((0,taiga_ui_cdk_utils_dom/* getScrollParent */.rP)(target, false)))) {
        event.preventDefault();
        return;
      }
      // This is Safari/IE/Edge fallback
      if (vertical && (negative && !(0,taiga_ui_cdk_utils_dom/* canScroll */.eE)(target, currentTarget, true, false) || !negative && !(0,taiga_ui_cdk_utils_dom/* canScroll */.eE)(target, currentTarget, true, true))) {
        event.preventDefault();
        return;
      }
      if (!vertical && (negative && !(0,taiga_ui_cdk_utils_dom/* canScroll */.eE)(target, currentTarget, false, false) || !negative && !(0,taiga_ui_cdk_utils_dom/* canScroll */.eE)(target, currentTarget, false, true))) {
        event.preventDefault();
      }
    }
  };
  TuiOverscrollDirective.ɵfac = function TuiOverscrollDirective_Factory(t) {
    return new (t || TuiOverscrollDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.NgZone), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3));
  };
  TuiOverscrollDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiOverscrollDirective,
    selectors: [["", "tuiOverscroll", ""]],
    hostVars: 2,
    hostBindings: function TuiOverscrollDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵstyleProp"]("overscroll-behavior", ctx.overscrollBehavior);
      }
    },
    inputs: {
      mode: ["tuiOverscroll", "mode"]
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiOverscroll')], TuiOverscrollDirective.prototype, "mode", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('style.overscrollBehavior')], TuiOverscrollDirective.prototype, "overscrollBehavior", null);
  TuiOverscrollDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.NgZone)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3))], TuiOverscrollDirective);
  return TuiOverscrollDirective;
})();
let TuiOverscrollModule = /*#__PURE__*/(() => {
  let TuiOverscrollModule = class TuiOverscrollModule {};
  TuiOverscrollModule.ɵfac = function TuiOverscrollModule_Factory(t) {
    return new (t || TuiOverscrollModule)();
  };
  TuiOverscrollModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiOverscrollModule
  });
  TuiOverscrollModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiOverscrollModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiOverscrollModule, {
    declarations: [TuiOverscrollDirective],
    exports: [TuiOverscrollDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-overscroll.js.map
// EXTERNAL MODULE: ./node_modules/@angular/animations/fesm2015/animations.js
var animations = __webpack_require__(6083);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-animations.js

const TRANSITION = `{{duration}}ms ease-in-out`;
const DURATION = {
  params: {
    duration: 300
  }
};
const STAGGER = 300;
const tuiHeightCollapse = (0,animations/* trigger */.X$)(`tuiHeightCollapse`, [(0,animations/* transition */.eR)(`:enter`, [(0,animations/* style */.oB)({
  height: 0
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  height: `*`
}))], DURATION), (0,animations/* transition */.eR)(`:leave`, [(0,animations/* style */.oB)({
  height: `*`
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  height: 0
}))], DURATION)]);
const tuiHeightCollapseList = (0,animations/* trigger */.X$)(`tuiHeightCollapseList`, [(0,animations/* transition */.eR)(`* => *`, [(0,animations/* query */.IO)(`:enter`, [(0,animations/* style */.oB)({
  height: 0
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  height: `*`
}))])], {
  optional: true
}), (0,animations/* query */.IO)(`:leave`, [(0,animations/* style */.oB)({
  height: `*`
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  height: 0
}))])], {
  optional: true
})], DURATION)]);
const tuiWidthCollapse = (0,animations/* trigger */.X$)(`tuiWidthCollapse`, [(0,animations/* transition */.eR)(`:enter`, [(0,animations/* style */.oB)({
  width: 0
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  width: `*`
}))], DURATION), (0,animations/* transition */.eR)(`:leave`, [(0,animations/* style */.oB)({
  width: `*`
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  width: 0
}))], DURATION)]);
const tuiWidthCollapseList = (0,animations/* trigger */.X$)(`tuiWidthCollapseList`, [(0,animations/* transition */.eR)(`* => *`, [(0,animations/* query */.IO)(`:enter`, [(0,animations/* style */.oB)({
  width: 0
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  width: `*`
}))])], {
  optional: true
}), (0,animations/* query */.IO)(`:leave`, [(0,animations/* style */.oB)({
  width: `*`
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  width: 0
}))])], {
  optional: true
})], DURATION)]);
const tuiFadeIn = (0,animations/* trigger */.X$)(`tuiFadeIn`, [(0,animations/* transition */.eR)(`:enter`, [(0,animations/* style */.oB)({
  opacity: 0
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  opacity: 1
}))], DURATION), (0,animations/* transition */.eR)(`:leave`, [(0,animations/* style */.oB)({
  opacity: 1
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  opacity: 0
}))], DURATION)]);
const tuiFadeInList = (0,animations/* trigger */.X$)(`tuiFadeInList`, [(0,animations/* transition */.eR)(`* => *`, [(0,animations/* query */.IO)(`:enter`, [(0,animations/* style */.oB)({
  opacity: 0
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  opacity: 1
}))])], {
  optional: true
}), (0,animations/* query */.IO)(`:leave`, [(0,animations/* style */.oB)({
  opacity: 1
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  opacity: 0
}))])], {
  optional: true
})], DURATION)]);
const tuiFadeInTop = (0,animations/* trigger */.X$)(`tuiFadeInTop`, [(0,animations/* transition */.eR)(`:enter`, [(0,animations/* style */.oB)({
  transform: `translateY(-10px)`,
  opacity: 0
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateY(0)`,
  opacity: 1
}))], DURATION), (0,animations/* transition */.eR)(`:leave`, [(0,animations/* style */.oB)({
  transform: `translateY(0)`,
  opacity: 1
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateY(-10px)`,
  opacity: 0
}))], DURATION)]);
const tuiFadeInBottom = (0,animations/* trigger */.X$)(`tuiFadeInBottom`, [(0,animations/* transition */.eR)(`:enter`, [(0,animations/* style */.oB)({
  transform: `translateY(10px)`,
  opacity: 0
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateY(0)`,
  opacity: 1
}))], DURATION), (0,animations/* transition */.eR)(`:leave`, [(0,animations/* style */.oB)({
  transform: `translateY(0)`,
  opacity: 1
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateY(10px)`,
  opacity: 0
}))], DURATION)]);
const tuiDropdownAnimation = (0,animations/* trigger */.X$)(`tuiDropdownAnimation`, [(0,animations/* transition */.eR)(`* => ${"fadeInTop" /* FadeInTop */}`, [(0,animations/* style */.oB)({
  transform: `translateY(-10px)`,
  opacity: 0
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateY(0)`,
  opacity: 1
}))], DURATION), (0,animations/* transition */.eR)(`* => ${"fadeInBottom" /* FadeInBottom */}`, [(0,animations/* style */.oB)({
  transform: `translateY(10px)`,
  opacity: 0
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateY(0)`,
  opacity: 1
}))], DURATION), (0,animations/* transition */.eR)(`${"fadeInBottom" /* FadeInBottom */} => *`, [(0,animations/* style */.oB)({
  transform: `translateY(0)`,
  opacity: 1
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateY(10px)`,
  opacity: 0
}))], DURATION), (0,animations/* transition */.eR)(`${"fadeInTop" /* FadeInTop */} => *`, [(0,animations/* style */.oB)({
  transform: `translateY(0)`,
  opacity: 1
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateY(-10px)`,
  opacity: 0
}))], DURATION)]);
const tuiScaleIn = (0,animations/* trigger */.X$)(`tuiScaleIn`, [(0,animations/* transition */.eR)(`:enter`, [(0,animations/* style */.oB)({
  transform: `scale(0)`
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `scale(1)`
}))], DURATION), (0,animations/* transition */.eR)(`:leave`, [(0,animations/* style */.oB)({
  transform: `scale(1)`
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `scale(0)`
}))], DURATION)]);
const tuiScaleInList = (0,animations/* trigger */.X$)(`tuiScaleInList`, [(0,animations/* transition */.eR)(`* => *`, [(0,animations/* query */.IO)(`:enter`, [(0,animations/* style */.oB)({
  transform: `scale(0)`
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `scale(1)`
}))])], {
  optional: true
}), (0,animations/* query */.IO)(`:leave`, [(0,animations/* style */.oB)({
  transform: `scale(1)`
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `scale(0)`
}))])], {
  optional: true
})], DURATION)]);
const tuiSlideIn = (0,animations/* trigger */.X$)(`tuiSlideIn`, [(0,animations/* transition */.eR)(`* => left`, [(0,animations/* style */.oB)({
  transform: `translateX(-100%)`
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateX(0)`
}))], DURATION), (0,animations/* transition */.eR)(`left => *`, [(0,animations/* style */.oB)({
  transform: `translateX(0)`
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateX(-100%)`
}))], DURATION), (0,animations/* transition */.eR)(`* => right`, [(0,animations/* style */.oB)({
  transform: `translateX(100%)`
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateX(0)`
}))], DURATION), (0,animations/* transition */.eR)(`right => *`, [(0,animations/* style */.oB)({
  transform: `translateX(0)`
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateX(100%)`
}))], DURATION)]);
const tuiSlideInLeft = (0,animations/* trigger */.X$)(`tuiSlideInLeft`, [(0,animations/* transition */.eR)(`:enter`, [(0,animations/* style */.oB)({
  transform: `translateX(-100%)`
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateX(0)`
}))], DURATION), (0,animations/* transition */.eR)(`:leave`, [(0,animations/* style */.oB)({
  transform: `translateX(0)`
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateX(-100%)`
}))], DURATION)]);
const tuiSlideInLeftList = (0,animations/* trigger */.X$)(`tuiSlideInLeftList`, [(0,animations/* transition */.eR)(`* => *`, [(0,animations/* query */.IO)(`:enter`, [(0,animations/* style */.oB)({
  transform: `translateX(-100%)`
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateX(0)`
}))])], {
  optional: true
}), (0,animations/* query */.IO)(`:leave`, [(0,animations/* style */.oB)({
  transform: `translateX(0)`
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateX(-100%)`
}))])], {
  optional: true
})], DURATION)]);
const tuiSlideInRight = (0,animations/* trigger */.X$)(`tuiSlideInRight`, [(0,animations/* transition */.eR)(`:enter`, [(0,animations/* style */.oB)({
  transform: `translateX(100%)`
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateX(0)`
}))], DURATION), (0,animations/* transition */.eR)(`:leave`, [(0,animations/* style */.oB)({
  transform: `translateX(0)`
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateX(100%)`
}))], DURATION)]);
const tuiSlideInRightList = (0,animations/* trigger */.X$)(`tuiSlideInRightList`, [(0,animations/* transition */.eR)(`* => *`, [(0,animations/* query */.IO)(`:enter`, [(0,animations/* style */.oB)({
  transform: `translateX(100%)`
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateX(0)`
}))])], {
  optional: true
}), (0,animations/* query */.IO)(`:leave`, [(0,animations/* style */.oB)({
  transform: `translateX(0)`
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateX(100%)`
}))])], {
  optional: true
})], DURATION)]);
const tuiSlideInTop = (0,animations/* trigger */.X$)(`tuiSlideInTop`, [(0,animations/* transition */.eR)(`:enter`, [(0,animations/* style */.oB)({
  transform: `translate3d(0,{{start}},0)`
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translate3d(0,{{end}},0)`
}))], {
  params: {
    end: 0,
    start: `100%`,
    duration: 300
  }
}), (0,animations/* transition */.eR)(`:leave`, [(0,animations/* style */.oB)({
  transform: `translate3d(0,{{end}},0)`
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translate3d(0,{{start}},0)`
}))], {
  params: {
    end: 0,
    start: `100%`,
    duration: 300
  }
})]);
const tuiSlideInTopList = (0,animations/* trigger */.X$)(`tuiSlideInTopList`, [(0,animations/* transition */.eR)(`* => *`, [(0,animations/* query */.IO)(`:enter`, [(0,animations/* style */.oB)({
  transform: `translateY(100%)`
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateY(0)`
}))])], {
  optional: true
}), (0,animations/* query */.IO)(`:leave`, [(0,animations/* style */.oB)({
  transform: `translateY(0)`
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateY(100%)`
}))])], {
  optional: true
})], DURATION)]);
const tuiSlideInBottom = (0,animations/* trigger */.X$)(`tuiSlideInBottom`, [(0,animations/* transition */.eR)(`:enter`, [(0,animations/* style */.oB)({
  transform: `translateY(-100%)`
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateY(0)`
}))], DURATION), (0,animations/* transition */.eR)(`:leave`, [(0,animations/* style */.oB)({
  transform: `translateY(0)`
}), (0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateY(-100%)`
}))], DURATION)]);
const tuiSlideInBottomList = (0,animations/* trigger */.X$)(`tuiSlideInBottomList`, [(0,animations/* transition */.eR)(`* => *`, [(0,animations/* query */.IO)(`:enter`, [(0,animations/* style */.oB)({
  transform: `translateY(-100%)`
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateY(0)`
}))])], {
  optional: true
}), (0,animations/* query */.IO)(`:leave`, [(0,animations/* style */.oB)({
  transform: `translateY(0)`
}), (0,animations/* stagger */.EY)(STAGGER, [(0,animations/* animate */.jt)(TRANSITION, (0,animations/* style */.oB)({
  transform: `translateY(-100%)`
}))])], {
  optional: true
})], DURATION)]);

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-animations.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-utils-dom.js
var taiga_ui_core_utils_dom = __webpack_require__(7766);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/fromEvent.js
var fromEvent = __webpack_require__(2759);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-browser.js
var taiga_ui_cdk_utils_browser = __webpack_require__(1213);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-providers.js
var taiga_ui_core_providers = __webpack_require__(2130);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-scroll-controls.js











// @dynamic




function TuiScrollControlsComponent_ng_container_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 3);
    core_js_["ɵɵelement"](1, "div", 4);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const bars_r1 = core_js_["ɵɵnextContext"]().tuiLet;
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵclassProp"]("t-bar_has-horizontal", bars_r1[1]);
    core_js_["ɵɵproperty"]("@tuiFadeIn", ctx_r2.animation);
  }
}
function TuiScrollControlsComponent_ng_container_0_div_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 5);
    core_js_["ɵɵelement"](1, "div", 6);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const bars_r1 = core_js_["ɵɵnextContext"]().tuiLet;
    const ctx_r3 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵclassProp"]("t-bar_has-vertical", bars_r1[0]);
    core_js_["ɵɵproperty"]("@tuiFadeIn", ctx_r3.animation);
  }
}
function TuiScrollControlsComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiScrollControlsComponent_ng_container_0_div_1_Template, 2, 3, "div", 1);
    core_js_["ɵɵtemplate"](2, TuiScrollControlsComponent_ng_container_0_div_2_Template, 2, 3, "div", 2);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const bars_r1 = ctx.tuiLet;
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", bars_r1[0]);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", bars_r1[1]);
  }
}
let TuiScrollControlsComponent = /*#__PURE__*/(() => {
  let TuiScrollControlsComponent = class TuiScrollControlsComponent {
    constructor(options, ngZone, scrollRef, animationFrame$, mode$) {
      this.options = options;
      this.ngZone = ngZone;
      this.scrollRef = scrollRef;
      this.animationFrame$ = animationFrame$;
      this.mode$ = mode$;
      this.refresh$ = this.animationFrame$.pipe((0,throttleTime/* throttleTime */.p)(300), (0,operators_map/* map */.U)(() => this.scrollbars), (0,operators_startWith/* startWith */.O)([false, false]), (0,operators_distinctUntilChanged/* distinctUntilChanged */.x)((a, b) => a[0] === b[0] && a[1] === b[1]), (0,taiga_ui_cdk_observables/* tuiZoneOptimized */.Yr)(this.ngZone));
      this.animation = Object.assign({
        value: ''
      }, this.options);
    }
    get scrollbars() {
      const {
        clientHeight,
        scrollHeight,
        clientWidth,
        scrollWidth
      } = this.scrollRef.nativeElement;
      return [Math.ceil(clientHeight / scrollHeight * 100) < 100, Math.ceil(clientWidth / scrollWidth * 100) < 100];
    }
  };
  TuiScrollControlsComponent.ɵfac = function TuiScrollControlsComponent_Factory(t) {
    return new (t || TuiScrollControlsComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw), core_js_["ɵɵdirectiveInject"](core_js_.NgZone), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_SCROLL_REF */.$_), core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* ANIMATION_FRAME */.L1), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_MODE */.Au));
  };
  TuiScrollControlsComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiScrollControlsComponent,
    selectors: [["tui-scroll-controls"]],
    hostBindings: function TuiScrollControlsComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("$.data-mode.attr", function TuiScrollControlsComponent___data_mode_attr_HostBindingHandler() {
          return ctx.mode$;
        });
      }
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_core_providers/* MODE_PROVIDER */.CV])],
    decls: 2,
    vars: 3,
    consts: [[4, "tuiLet"], ["tuiScrollbarWrapper", "", "class", "t-bar t-bar_vertical", 3, "t-bar_has-horizontal", 4, "ngIf"], ["tuiScrollbarWrapper", "", "class", "t-bar t-bar_horizontal", 3, "t-bar_has-vertical", 4, "ngIf"], ["tuiScrollbarWrapper", "", 1, "t-bar", "t-bar_vertical"], ["tuiScrollbar", "vertical", 1, "t-thumb"], ["tuiScrollbarWrapper", "", 1, "t-bar", "t-bar_horizontal"], ["tuiScrollbar", "horizontal", 1, "t-thumb"]],
    template: function TuiScrollControlsComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵtemplate"](0, TuiScrollControlsComponent_ng_container_0_Template, 3, 2, "ng-container", 0);
        core_js_["ɵɵpipe"](1, "async");
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("tuiLet", core_js_["ɵɵpipeBind1"](1, 1, ctx.refresh$));
      }
    },
    directives: function () {
      return [taiga_ui_cdk_directives_let/* TuiLetDirective */.Ls, common_js_.NgIf, TuiScrollbarWrapperDirective, TuiScrollbarDirective];
    },
    pipes: function () {
      return [common_js_.AsyncPipe];
    },
    styles: ["[_nghost-%COMP%]{position:-webkit-sticky;position:sticky;top:0;left:0;z-index:1;min-width:calc(100% - 1px);min-height:calc(100% - 1px);max-width:calc(100% - 1px);max-height:calc(100% - 1px);float:left;margin-right:calc(-100% + 1px);-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:calc(-100% + 1px);margin-inline-end:calc(-100% + 1px);pointer-events:none}.t-bar[_ngcontent-%COMP%]{position:absolute;right:0;bottom:0;pointer-events:auto}.t-bar_vertical[_ngcontent-%COMP%]{top:0;width:.875rem}.t-bar_horizontal[_ngcontent-%COMP%]{left:0;height:.875rem}.t-bar_has-horizontal[_ngcontent-%COMP%]{bottom:.5rem}.t-bar_has-vertical[_ngcontent-%COMP%]{right:.5rem}.t-thumb[_ngcontent-%COMP%]{transition-duration:.15s;transition-timing-function:ease-in-out;position:absolute;border-radius:6.25rem;border:.25rem solid transparent;cursor:pointer;pointer-events:auto;background:var(--tui-text-01);background-clip:content-box;box-sizing:border-box;transition-property:width,height;opacity:.2}.t-thumb[_ngcontent-%COMP%]:hover{opacity:.24}.t-thumb[_ngcontent-%COMP%]:active{opacity:.48}[data-mode=onDark][_nghost-%COMP%]   .t-thumb[_ngcontent-%COMP%]{background-color:var(--tui-text-01-night)}.t-bar_vertical[_ngcontent-%COMP%]   .t-thumb[_ngcontent-%COMP%]{right:0;width:.75rem;min-height:1.25rem}.t-bar_vertical[_ngcontent-%COMP%]   .t-thumb[_ngcontent-%COMP%]:active, .t-bar_vertical[_ngcontent-%COMP%]:hover   .t-thumb[_ngcontent-%COMP%]{width:.875rem}.t-bar_horizontal[_ngcontent-%COMP%]   .t-thumb[_ngcontent-%COMP%]{bottom:0;height:.75rem;min-width:1.25rem}.t-bar_horizontal[_ngcontent-%COMP%]   .t-thumb[_ngcontent-%COMP%]:active, .t-bar_horizontal[_ngcontent-%COMP%]:hover   .t-thumb[_ngcontent-%COMP%]{height:.875rem}"],
    data: {
      animation: [tuiFadeIn]
    },
    changeDetection: 0
  });
  TuiScrollControlsComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.NgZone)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_SCROLL_REF */.$_)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(ng_web_apis_common/* ANIMATION_FRAME */.L1)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_MODE */.Au))], TuiScrollControlsComponent);
  return TuiScrollControlsComponent;
})();
const MIN_WIDTH = 24;
// @dynamic
let TuiScrollbarDirective = /*#__PURE__*/(() => {
  let TuiScrollbarDirective = class TuiScrollbarDirective {
    constructor(ngZone, renderer, destroy$, animationFrame$, wrapper, container, doc, el) {
      this.wrapper = wrapper;
      this.container = container;
      this.doc = doc;
      this.el = el;
      this.tuiScrollbar = 'vertical';
      const {
        nativeElement
      } = this.el;
      const mousedown$ = (0,taiga_ui_cdk_observables/* tuiTypedFromEvent */.mL)(nativeElement, 'mousedown');
      const mousemove$ = (0,taiga_ui_cdk_observables/* tuiTypedFromEvent */.mL)(this.doc, 'mousemove');
      const mouseup$ = (0,taiga_ui_cdk_observables/* tuiTypedFromEvent */.mL)(this.doc, 'mouseup');
      const mousedownWrapper$ = (0,taiga_ui_cdk_observables/* tuiTypedFromEvent */.mL)(this.wrapper.nativeElement, 'mousedown');
      (0,observable_merge/* merge */.T)(mousedownWrapper$.pipe((0,taiga_ui_cdk_observables/* tuiPreventDefault */.mp)(), (0,operators_map/* map */.U)(event => this.getScrolled(event, 0.5, 0.5))), mousedown$.pipe((0,taiga_ui_cdk_observables/* tuiPreventDefault */.mp)(), (0,taiga_ui_cdk_observables/* tuiStopPropagation */.vm)(), (0,operators_switchMap/* switchMap */.w)(event => {
        const rect = nativeElement.getBoundingClientRect();
        const vertical = getOffsetVertical(event, rect);
        const horizontal = getOffsetHorizontal(event, rect);
        return mousemove$.pipe((0,operators_map/* map */.U)(event => this.getScrolled(event, vertical, horizontal)), (0,operators_takeUntil/* takeUntil */.R)(mouseup$));
      }))).pipe((0,taiga_ui_cdk_observables/* tuiZonefree */.fL)(ngZone), (0,operators_takeUntil/* takeUntil */.R)(destroy$)).subscribe(([scrollTop, scrollLeft]) => {
        if (this.tuiScrollbar === 'vertical') {
          renderer.setProperty(this.element, 'scrollTop', scrollTop);
        } else {
          renderer.setProperty(this.element, 'scrollLeft', scrollLeft);
        }
      });
      (0,observable_merge/* merge */.T)(animationFrame$.pipe((0,throttleTime/* throttleTime */.p)(taiga_ui_cdk_constants/* POLLING_TIME */.Yg)), (0,taiga_ui_cdk_observables/* tuiScrollFrom */.pt)(this.element)).pipe((0,taiga_ui_cdk_observables/* tuiZonefree */.fL)(ngZone), (0,operators_takeUntil/* takeUntil */.R)(destroy$)).subscribe(() => {
        if (this.tuiScrollbar === 'vertical') {
          renderer.setStyle(nativeElement, 'top', `${this.thumb * 100}%`);
          renderer.setStyle(nativeElement, 'height', `${this.view * 100}%`);
        } else {
          renderer.setStyle(nativeElement, 'left', `${this.thumb * 100}%`);
          renderer.setStyle(nativeElement, 'width', `${this.view * 100}%`);
        }
      });
    }
    get scrolled() {
      const {
        scrollTop,
        scrollHeight,
        clientHeight,
        scrollLeft,
        scrollWidth,
        clientWidth
      } = this.element;
      return this.tuiScrollbar === 'vertical' ? scrollTop / (scrollHeight - clientHeight) : scrollLeft / (scrollWidth - clientWidth);
    }
    get compensation() {
      const {
        clientHeight,
        scrollHeight,
        clientWidth,
        scrollWidth
      } = this.element;
      if (clientHeight * clientHeight / scrollHeight > MIN_WIDTH && this.tuiScrollbar === 'vertical' || clientWidth * clientWidth / scrollWidth > MIN_WIDTH && this.tuiScrollbar === 'horizontal') {
        return 0;
      }
      return this.tuiScrollbar === 'vertical' ? MIN_WIDTH / clientHeight : MIN_WIDTH / clientWidth;
    }
    get thumb() {
      const compensation = this.compensation || this.view;
      return this.scrolled * (1 - compensation);
    }
    get view() {
      const {
        clientHeight,
        scrollHeight,
        clientWidth,
        scrollWidth
      } = this.element;
      return this.tuiScrollbar === 'vertical' ? Math.ceil(clientHeight / scrollHeight * 100) / 100 : Math.ceil(clientWidth / scrollWidth * 100) / 100;
    }
    get element() {
      return this.container.nativeElement;
    }
    getScrolled({
      clientY,
      clientX
    }, offsetVertical, offsetHorizontal) {
      const {
        offsetHeight,
        offsetWidth
      } = this.el.nativeElement;
      const {
        top,
        left,
        width,
        height
      } = this.wrapper.nativeElement.getBoundingClientRect();
      const maxTop = this.element.scrollHeight - height;
      const maxLeft = this.element.scrollWidth - width;
      const scrolledTop = (clientY - top - offsetHeight * offsetVertical) / (height - offsetHeight);
      const scrolledLeft = (clientX - left - offsetWidth * offsetHorizontal) / (width - offsetWidth);
      return [maxTop * scrolledTop, maxLeft * scrolledLeft];
    }
  };
  TuiScrollbarDirective.ɵfac = function TuiScrollbarDirective_Factory(t) {
    return new (t || TuiScrollbarDirective)(core_js_["ɵɵdirectiveInject"](core_js_.NgZone), core_js_["ɵɵdirectiveInject"](core_js_.Renderer2), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3, 2), core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* ANIMATION_FRAME */.L1), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_ELEMENT_REF */.zP), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_SCROLL_REF */.$_), core_js_["ɵɵdirectiveInject"](common_js_.DOCUMENT), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef));
  };
  TuiScrollbarDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiScrollbarDirective,
    selectors: [["", "tuiScrollbar", ""]],
    inputs: {
      tuiScrollbar: "tuiScrollbar"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiScrollbarDirective.prototype, "tuiScrollbar", void 0);
  TuiScrollbarDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.NgZone)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.Renderer2)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(ng_web_apis_common/* ANIMATION_FRAME */.L1)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_ELEMENT_REF */.zP)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_SCROLL_REF */.$_)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(common_js_.DOCUMENT)), (0,tslib_es6/* __param */.fM)(7, (0,core_js_.Inject)(core_js_.ElementRef))], TuiScrollbarDirective);
  return TuiScrollbarDirective;
})();
function getOffsetVertical({
  clientY
}, {
  top,
  height
}) {
  return (clientY - top) / height;
}
function getOffsetHorizontal({
  clientX
}, {
  left,
  width
}) {
  return (clientX - left) / width;
}
let TuiScrollbarWrapperDirective = /*#__PURE__*/(() => {
  let TuiScrollbarWrapperDirective = class TuiScrollbarWrapperDirective {};
  TuiScrollbarWrapperDirective.ɵfac = function TuiScrollbarWrapperDirective_Factory(t) {
    return new (t || TuiScrollbarWrapperDirective)();
  };
  TuiScrollbarWrapperDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiScrollbarWrapperDirective,
    selectors: [["", "tuiScrollbarWrapper", ""]],
    features: [core_js_["ɵɵProvidersFeature"]([{
      provide: taiga_ui_core_tokens/* TUI_ELEMENT_REF */.zP,
      useExisting: core_js_.ElementRef
    }])]
  });
  return TuiScrollbarWrapperDirective;
})();
let TuiScrollControlsModule = /*#__PURE__*/(() => {
  let TuiScrollControlsModule = class TuiScrollControlsModule {};
  TuiScrollControlsModule.ɵfac = function TuiScrollControlsModule_Factory(t) {
    return new (t || TuiScrollControlsModule)();
  };
  TuiScrollControlsModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiScrollControlsModule
  });
  TuiScrollControlsModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, taiga_ui_cdk_directives_let/* TuiLetModule */.WD]]
  });
  return TuiScrollControlsModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiScrollControlsModule, {
    declarations: function () {
      return [TuiScrollbarDirective, TuiScrollbarWrapperDirective, TuiScrollControlsComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, taiga_ui_cdk_directives_let/* TuiLetModule */.WD];
    },
    exports: function () {
      return [TuiScrollControlsComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-scroll-controls.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-scrollbar.js











function TuiScrollbarComponent_tui_scroll_controls_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-scroll-controls");
  }
}
const _c0 = ["*"];
const SCROLL_REF_SELECTOR = '[tuiScrollRef]';
let TuiScrollRefDirective = /*#__PURE__*/(() => {
  let TuiScrollRefDirective = class TuiScrollRefDirective {};
  TuiScrollRefDirective.ɵfac = function TuiScrollRefDirective_Factory(t) {
    return new (t || TuiScrollRefDirective)();
  };
  TuiScrollRefDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiScrollRefDirective,
    selectors: [["", "tuiScrollRef", ""]],
    features: [core_js_["ɵɵProvidersFeature"]([{
      provide: taiga_ui_core_tokens/* TUI_SCROLL_REF */.$_,
      useExisting: core_js_.ElementRef
    }])]
  });
  return TuiScrollRefDirective;
})();
let TuiScrollableDirective = /*#__PURE__*/(() => {
  let TuiScrollableDirective = class TuiScrollableDirective {
    constructor(elementRef) {
      this.elementRef = elementRef;
    }
    ngOnInit() {
      this.elementRef.nativeElement.dispatchEvent(new CustomEvent(taiga_ui_core_constants/* TUI_SCROLLABLE */.UZ, {
        bubbles: true,
        detail: this.elementRef.nativeElement
      }));
    }
  };
  TuiScrollableDirective.ɵfac = function TuiScrollableDirective_Factory(t) {
    return new (t || TuiScrollableDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef));
  };
  TuiScrollableDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiScrollableDirective,
    selectors: [["", "tuiScrollable", ""]]
  });
  TuiScrollableDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef))], TuiScrollableDirective);
  return TuiScrollableDirective;
})();
var TuiScrollbarComponent_1;
// eslint-disable-next-line @typescript-eslint/naming-convention
function scrollRefFactory({
  browserScrollRef
}) {
  return browserScrollRef;
}
// @dynamic
let TuiScrollbarComponent = TuiScrollbarComponent_1 = class TuiScrollbarComponent {
  constructor(cssRef, elementRef, userAgent, isIos) {
    this.cssRef = cssRef;
    this.elementRef = elementRef;
    this.userAgent = userAgent;
    this.isIos = isIos;
    this.delegated = false;
    this.isLegacy = !this.cssRef.supports('position', 'sticky') || (0,taiga_ui_cdk_utils_browser/* isFirefox */.vU)(this.userAgent) && !this.cssRef.supports('scrollbar-width', 'none');
    this.hidden = false;
    this.browserScrollRef = new core_js_.ElementRef(this.elementRef.nativeElement);
  }
  get showScrollbars() {
    return !this.hidden && !this.isIos && (!this.isLegacy || this.delegated);
  }
  get showNative() {
    return this.isLegacy && !this.hidden && !this.delegated;
  }
  onScrollable(element) {
    this.delegated = true;
    this.browserScrollRef.nativeElement = element;
  }
  scrollIntoView(detail) {
    if (this.delegated) {
      return;
    }
    const {
      nativeElement
    } = this.browserScrollRef;
    const {
      offsetTop,
      offsetLeft
    } = (0,taiga_ui_cdk_utils_dom/* getElementOffset */.pW)(nativeElement, detail);
    nativeElement.scrollTop = offsetTop + detail.offsetHeight / 2 - nativeElement.clientHeight / 2;
    nativeElement.scrollLeft = offsetLeft + detail.offsetWidth / 2 - nativeElement.clientWidth / 2;
  }
};
TuiScrollbarComponent.ɵfac = function TuiScrollbarComponent_Factory(t) {
  return new (t || TuiScrollbarComponent)(core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* CSS */.ux), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* USER_AGENT */.yZ), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_IOS */.FA));
};
TuiScrollbarComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiScrollbarComponent,
  selectors: [["tui-scrollbar"]],
  hostVars: 2,
  hostBindings: function TuiScrollbarComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵlistener"]("tui-scrollable.stop", function TuiScrollbarComponent_tui_scrollable_stop_HostBindingHandler($event) {
        return ctx.onScrollable($event.detail);
      })("tui-scroll-into-view.stop", function TuiScrollbarComponent_tui_scroll_into_view_stop_HostBindingHandler($event) {
        return ctx.scrollIntoView($event.detail);
      });
    }
    if (rf & 2) {
      core_js_["ɵɵclassProp"]("_legacy", ctx.showNative);
    }
  },
  inputs: {
    hidden: "hidden"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_core_tokens/* TUI_SCROLL_REF */.$_,
    deps: [TuiScrollbarComponent_1],
    useFactory: scrollRefFactory
  }])],
  ngContentSelectors: _c0,
  decls: 3,
  vars: 1,
  consts: [[4, "ngIf"], [1, "t-content"]],
  template: function TuiScrollbarComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"]();
      core_js_["ɵɵtemplate"](0, TuiScrollbarComponent_tui_scroll_controls_0_Template, 1, 0, "tui-scroll-controls", 0);
      core_js_["ɵɵelementStart"](1, "div", 1);
      core_js_["ɵɵprojection"](2);
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      core_js_["ɵɵproperty"]("ngIf", ctx.showScrollbars);
    }
  },
  directives: [common_js_.NgIf, TuiScrollControlsComponent],
  styles: ["[_nghost-%COMP%]{z-index:0;position:relative;display:flex;overflow:auto}[_nghost-%COMP%]:not(._legacy){scrollbar-width:none;-ms-overflow-style:none}[_nghost-%COMP%]:not(._legacy)::-webkit-scrollbar, [_nghost-%COMP%]:not(._legacy)::-webkit-scrollbar-thumb{background:0 0;width:0;height:0}._legacy[_nghost-%COMP%]{overflow:overlay}@media all and (-webkit-min-device-pixel-ratio:0) and (min-resolution:0.001dpcm){._legacy[_nghost-%COMP%]::-webkit-scrollbar, ._legacy[_nghost-%COMP%]::-webkit-scrollbar-thumb{width:1rem;height:1rem;border-radius:6.25rem;background-clip:padding-box;border:2.667rem solid transparent}._legacy[_nghost-%COMP%]::-webkit-scrollbar{background-color:transparent}._legacy[_nghost-%COMP%]::-webkit-scrollbar-thumb{background-color:var(--tui-clear-hover)}._legacy[_nghost-%COMP%]::-webkit-scrollbar-thumb:hover{background-color:var(--tui-clear-active)}._legacy[_nghost-%COMP%]::-webkit-scrollbar-thumb:active{background-color:var(--tui-text-03)}}.t-content[_ngcontent-%COMP%]{position:relative;z-index:0;flex:1;flex-basis:auto;width:100%;height:-webkit-max-content;height:-moz-max-content;height:max-content}"],
  changeDetection: 0
});
TuiScrollbarComponent.ctorParameters = () => [{
  type: undefined,
  decorators: [{
    type: core_js_.Inject,
    args: [ng_web_apis_common/* CSS */.ux]
  }]
}, {
  type: core_js_.ElementRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ElementRef]
  }]
}, {
  type: String,
  decorators: [{
    type: core_js_.Inject,
    args: [ng_web_apis_common/* USER_AGENT */.yZ]
  }]
}, {
  type: Boolean,
  decorators: [{
    type: core_js_.Inject,
    args: [taiga_ui_cdk_tokens/* TUI_IS_IOS */.FA]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiScrollbarComponent.prototype, "hidden", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._legacy')], TuiScrollbarComponent.prototype, "showNative", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)(`${taiga_ui_core_constants/* TUI_SCROLLABLE */.UZ}.stop`, ['$event.detail'])], TuiScrollbarComponent.prototype, "onScrollable", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)(`${taiga_ui_core_constants/* TUI_SCROLL_INTO_VIEW */.fe}.stop`, ['$event.detail'])], TuiScrollbarComponent.prototype, "scrollIntoView", null);
TuiScrollbarComponent = TuiScrollbarComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(ng_web_apis_common/* CSS */.ux)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(ng_web_apis_common/* USER_AGENT */.yZ)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_IOS */.FA))], TuiScrollbarComponent);
let TuiScrollbarModule = /*#__PURE__*/(() => {
  let TuiScrollbarModule = class TuiScrollbarModule {};
  TuiScrollbarModule.ɵfac = function TuiScrollbarModule_Factory(t) {
    return new (t || TuiScrollbarModule)();
  };
  TuiScrollbarModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiScrollbarModule
  });
  TuiScrollbarModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, TuiScrollControlsModule]]
  });
  return TuiScrollbarModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiScrollbarModule, {
    declarations: function () {
      return [TuiScrollbarComponent, TuiScrollRefDirective, TuiScrollableDirective];
    },
    imports: function () {
      return [common_js_.CommonModule, TuiScrollControlsModule];
    },
    exports: function () {
      return [TuiScrollbarComponent, TuiScrollRefDirective, TuiScrollableDirective];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-scrollbar.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-directives-mode.js
var taiga_ui_core_directives_mode = __webpack_require__(5452);
// EXTERNAL MODULE: ./node_modules/@tinkoff/ng-polymorpheus/fesm2015/tinkoff-ng-polymorpheus.js
var tinkoff_ng_polymorpheus = __webpack_require__(9570);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-dropdown-box.js














/**
 *  This component is used to show template in a portal using default style of white rounded box with a shadow
 */
// @bad TODO: OnPush
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic






const taiga_ui_core_components_dropdown_box_c0 = ["content"];
let TuiDropdownBoxComponent = /*#__PURE__*/(() => {
  let TuiDropdownBoxComponent = class TuiDropdownBoxComponent {
    constructor(destroy$, ngZone, directive, windowRef, elementRef, portalHost, options, animationFrame$) {
      this.directive = directive;
      this.windowRef = windowRef;
      this.elementRef = elementRef;
      this.portalHost = portalHost;
      this.options = options;
      this.animationTop = Object.assign({
        value: "fadeInTop" /* FadeInTop */
      }, this.options);
      this.animationBottom = Object.assign({
        value: "fadeInBottom" /* FadeInBottom */
      }, this.options);
      /**
       * Is previous position on top (to prevent jumping up and down on scroll)
       */
      this.prevDirectionIsTop = false;
      (0,observable_merge/* merge */.T)(animationFrame$.pipe((0,throttleTime/* throttleTime */.p)(taiga_ui_cdk_constants/* POLLING_TIME */.Yg)), this.directive.refresh$, (0,fromEvent/* fromEvent */.R)(this.windowRef, 'resize')).pipe((0,taiga_ui_cdk_observables/* tuiZonefree */.fL)(ngZone), (0,operators_takeUntil/* takeUntil */.R)(destroy$)).subscribe(() => {
        this.calculatePositionAndSize();
      });
    }
    get overscroll() {
      return this.inModal ? 'all' : 'scroll';
    }
    getContext(context, activeZone) {
      return Object.assign(Object.assign({}, context), {
        activeZone
      });
    }
    ngAfterViewChecked() {
      this.calculatePositionAndSize();
    }
    onTopFocus() {
      this.moveFocusOutside(true);
    }
    onBottomFocus() {
      this.moveFocusOutside(false);
    }
    get inModal() {
      // @awful TODO: get rid of component tag name dependency
      return !!this.directive.host.closest('tui-dialog-host');
    }
    get inOption() {
      // @awful TODO: get rid of component tag name dependency
      return !!this.directive.host.closest('[tuiOption]');
    }
    calculatePositionAndSize() {
      const {
        clientRect
      } = this.directive;
      const {
        style
      } = this.elementRef.nativeElement;
      const hostRect = this.directive.fixed ? this.portalHost.fixedPositionOffset() : this.portalHost.clientRect;
      style.position = this.directive.fixed ? 'fixed' : 'absolute';
      this.calculateVerticalPosition(style, clientRect, hostRect);
      this.calculateHorizontalPosition(style, clientRect, hostRect);
      this.calculateWidth(style, clientRect);
    }
    getFinalAlign(style, directiveRect) {
      const dropdownRect = this.elementRef.nativeElement.getBoundingClientRect();
      const dropdownWidth = this.elementRef.nativeElement.offsetWidth;
      const screenWidth = (0,taiga_ui_core_utils_dom/* getScreenWidth */.zP)(this.windowRef.document);
      const isDropdownSizeHypotheticallyFitsViewport = directiveRect.left + dropdownWidth < screenWidth || directiveRect.right - dropdownWidth > 0;
      const isDropdownSizeActuallyFitsViewport = dropdownRect.right <= screenWidth && dropdownRect.left >= 0;
      let finalAlign = this.directive.align;
      switch (this.directive.align) {
        case 'left':
          if (isDropdownSizeHypotheticallyFitsViewport && dropdownRect.right > screenWidth) {
            finalAlign = 'right';
          }
          break;
        case 'right':
          if (isDropdownSizeHypotheticallyFitsViewport && dropdownRect.left < 0) {
            finalAlign = 'left';
          }
          break;
      }
      if (style.right === 'auto' && isDropdownSizeActuallyFitsViewport) {
        finalAlign = 'left';
      }
      if (style.left === 'auto' && isDropdownSizeActuallyFitsViewport) {
        finalAlign = 'right';
      }
      return finalAlign;
    }
    /**
     * Calculates horizontal position
     *
     * @param style dropdownBox elementRef styles object
     * @param directiveRect ClientRect of hosting directive
     * @param hostRect ClientRect of  portal host
     */
    calculateHorizontalPosition(style, directiveRect, hostRect) {
      const offset = this.directive.sided ? this.elementRef.nativeElement.getBoundingClientRect().width + taiga_ui_core_constants/* DEFAULT_MARGIN */.jK : 0;
      const left = Math.ceil(directiveRect.left - hostRect.left - offset);
      const right = Math.floor(hostRect.right - directiveRect.right - offset);
      const viewportWidth = (0,taiga_ui_core_utils_dom/* tuiGetViewportWidth */.ic)(this.windowRef);
      switch (this.getFinalAlign(style, directiveRect)) {
        case 'left':
          if (right + taiga_ui_core_constants/* DEFAULT_MARGIN */.jK > viewportWidth || (0,taiga_ui_cdk_utils_math/* inRange */.Z2)(left + taiga_ui_core_constants/* DEFAULT_MARGIN */.jK, 0, viewportWidth)) {
            style.left = px(left);
            style.right = 'auto';
          } else {
            style.left = 'auto';
            style.right = px(right);
          }
          break;
        case 'right':
          if ((0,taiga_ui_cdk_utils_math/* inRange */.Z2)(right + taiga_ui_core_constants/* DEFAULT_MARGIN */.jK, 0, viewportWidth) || left + taiga_ui_core_constants/* DEFAULT_MARGIN */.jK > viewportWidth) {
            style.left = 'auto';
            style.right = px(right);
          } else {
            style.left = px(left);
            style.right = 'auto';
          }
          break;
      }
    }
    /**
     * Calculates vertical position and height
     *
     * @param style dropdownBox elementRef styles object
     * @param directiveRect ClientRect of hosting directive
     * @param hostRect ClientRect of  portal host
     */
    calculateVerticalPosition(style, directiveRect, hostRect) {
      const windowHeight = this.windowRef.innerHeight;
      // Maximum height of the box
      const boxHeightLimit = Math.min(this.directive.maxHeight, windowHeight - taiga_ui_core_constants/* DEFAULT_MARGIN */.jK * 2);
      const offset = this.directive.sided ? taiga_ui_core_constants/* DEFAULT_MARGIN */.jK - directiveRect.height : taiga_ui_core_constants/* DEFAULT_MARGIN */.jK * 2;
      const topAvailableHeight = directiveRect.top - offset;
      const bottomAvailableHeight = windowHeight - directiveRect.bottom - offset;
      const finalDirection = this.getFinalDirection(directiveRect);
      const optionOffset = this.inOption ? taiga_ui_core_constants/* DEFAULT_MARGIN */.jK * 2 : 0;
      this.prevDirectionIsTop = finalDirection === 'top';
      if (finalDirection === 'top') {
        this.dropdownAnimation = this.animationBottom;
        style.maxHeight = px(Math.min(boxHeightLimit, topAvailableHeight));
        style.top = 'auto';
        style.bottom = px(hostRect.bottom - directiveRect.top - taiga_ui_core_constants/* DEFAULT_MARGIN */.jK + offset - optionOffset);
      } else {
        this.dropdownAnimation = this.animationTop;
        style.maxHeight = px(Math.min(boxHeightLimit, bottomAvailableHeight));
        style.top = px(directiveRect.bottom - hostRect.top - taiga_ui_core_constants/* DEFAULT_MARGIN */.jK + offset - optionOffset);
        style.bottom = 'auto';
      }
    }
    getFinalDirection(directiveRect) {
      const windowHeight = this.windowRef.innerHeight;
      const offset = this.directive.sided ? taiga_ui_core_constants/* DEFAULT_MARGIN */.jK - directiveRect.height : taiga_ui_core_constants/* DEFAULT_MARGIN */.jK * 2;
      // Maximum space available on top and on the bottom in the viewport
      const topAvailableHeight = directiveRect.top - offset;
      const bottomAvailableHeight = windowHeight - directiveRect.bottom - offset;
      let finalDirection = null;
      // Given direction is applied if we can fit the box in the limits that way
      switch (this.directive.direction) {
        case 'top':
          if (topAvailableHeight >= this.directive.minHeight) {
            finalDirection = 'top';
          }
          break;
        case 'bottom':
          if (bottomAvailableHeight >= this.directive.minHeight) {
            finalDirection = 'bottom';
          }
          break;
      }
      // Maximum height of the box
      const boxHeightLimit = Math.min(this.directive.maxHeight, windowHeight - taiga_ui_core_constants/* DEFAULT_MARGIN */.jK * 2);
      // Choose direction if given direction did not fit
      if (finalDirection === null && this.contentElementRef) {
        // Box height if it fits without scroll
        const visualHeight = Math.min(this.contentElementRef.nativeElement.getBoundingClientRect().height + (this.elementRef.nativeElement.offsetHeight - this.elementRef.nativeElement.clientHeight), boxHeightLimit);
        // If there is enough space to fit below without scroll,
        // choose 'bottom', unless it was previously on the top
        if (this.prevDirectionIsTop && topAvailableHeight >= visualHeight) {
          finalDirection = 'top';
        } else if (bottomAvailableHeight >= visualHeight) {
          finalDirection = 'bottom';
        } else {
          // Corner case — select direction with more space
          finalDirection = bottomAvailableHeight >= topAvailableHeight ? 'bottom' : 'top';
        }
      }
      return finalDirection;
    }
    /**
     * Calculates width
     *
     * @param style dropdownBox elementRef styles object
     * @param directiveRect ClientRect of hosting directive
     */
    calculateWidth(style, directiveRect) {
      style.width = this.directive.limitMinWidth === 'fixed' && !this.directive.sided ? px(directiveRect.width) : '';
      if (this.directive.limitMinWidth === 'min' && !this.directive.sided) {
        style.minWidth = px(directiveRect.width);
        style.maxWidth = px(taiga_ui_core_constants/* DEFAULT_MAX_WIDTH */.yA);
        return;
      }
      style.minWidth = '';
      style.maxWidth = '';
    }
    moveFocusOutside(previous) {
      const {
        host
      } = this.directive;
      const {
        ownerDocument
      } = host;
      const root = ownerDocument ? ownerDocument.body : host;
      (0,taiga_ui_cdk_classes/* tuiAssertIsHTMLElement */.HU)(host);
      let focusable = (0,taiga_ui_cdk_utils_focus/* getClosestFocusable */.kA)(host, previous, root);
      while (focusable !== null && host.contains(focusable)) {
        focusable = (0,taiga_ui_cdk_utils_focus/* getClosestFocusable */.kA)(focusable, previous, root);
      }
      focusable === null || focusable === void 0 ? void 0 : focusable.focus();
    }
  };
  TuiDropdownBoxComponent.ɵfac = function TuiDropdownBoxComponent_Factory(t) {
    return new (t || TuiDropdownBoxComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3), core_js_["ɵɵdirectiveInject"](core_js_.NgZone), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_DROPDOWN_DIRECTIVE */.Jd), core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* WINDOW */.m9), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_abstract/* AbstractTuiPortalHostComponent */.Er), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw), core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* ANIMATION_FRAME */.L1));
  };
  TuiDropdownBoxComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDropdownBoxComponent,
    selectors: [["tui-dropdown-box"]],
    viewQuery: function TuiDropdownBoxComponent_Query(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵviewQuery"](taiga_ui_core_components_dropdown_box_c0, 5, core_js_.ElementRef);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.contentElementRef = _t.first);
      }
    },
    hostVars: 1,
    hostBindings: function TuiDropdownBoxComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵsyntheticHostProperty"]("@tuiDropdownAnimation", ctx.dropdownAnimation);
      }
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])],
    decls: 7,
    vars: 5,
    consts: [[1, "t-wrapper", 3, "tuiOverscroll", "tuiMode", "tuiActiveZoneParent"], ["activeZone", "tuiActiveZone"], [1, "t-scroll"], ["tabindex", "0", 3, "focus"], ["polymorpheus-outlet", "", 1, "t-content", 3, "content", "context"], ["content", ""]],
    template: function TuiDropdownBoxComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵelementStart"](0, "div", 0, 1);
        core_js_["ɵɵelementStart"](2, "tui-scrollbar", 2);
        core_js_["ɵɵelementStart"](3, "div", 3);
        core_js_["ɵɵlistener"]("focus", function TuiDropdownBoxComponent_Template_div_focus_3_listener() {
          return ctx.onTopFocus();
        });
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelement"](4, "div", 4, 5);
        core_js_["ɵɵelementStart"](6, "div", 3);
        core_js_["ɵɵlistener"]("focus", function TuiDropdownBoxComponent_Template_div_focus_6_listener() {
          return ctx.onBottomFocus();
        });
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        const _r0 = core_js_["ɵɵreference"](1);
        core_js_["ɵɵproperty"]("tuiOverscroll", ctx.overscroll)("tuiMode", null)("tuiActiveZoneParent", ctx.directive.activeZone || null);
        core_js_["ɵɵadvance"](4);
        core_js_["ɵɵproperty"]("content", ctx.directive.content)("context", ctx.getContext(ctx.directive.context, _r0));
      }
    },
    directives: [TuiOverscrollDirective, taiga_ui_core_directives_mode/* TuiModeDirective */.w, TuiActiveZoneDirective, TuiScrollbarComponent, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1],
    styles: ["[_nghost-%COMP%]{z-index:0;box-shadow:0 .5rem 1rem rgba(0,0,0,.16);position:absolute;top:0;left:0;display:flex;background-color:#fff;background-color:var(--tui-elevation-01);border-radius:var(--tui-radius-m);overflow:hidden;border:1px solid var(--tui-base-03);box-sizing:border-box}.ng-animating[_nghost-%COMP%]{pointer-events:none}.t-content[_ngcontent-%COMP%]{display:flex;flex-direction:column;max-height:100%}.t-wrapper[_ngcontent-%COMP%]{flex-grow:1;max-width:100%;max-height:inherit;overflow:visible}.t-scroll[_ngcontent-%COMP%]{height:100%}"],
    data: {
      animation: [tuiDropdownAnimation]
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('@tuiDropdownAnimation')], TuiDropdownBoxComponent.prototype, "dropdownAnimation", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('content', {
    read: core_js_.ElementRef
  })], TuiDropdownBoxComponent.prototype, "contentElementRef", void 0);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDropdownBoxComponent.prototype, "getContext", null);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDropdownBoxComponent.prototype, "inModal", null);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDropdownBoxComponent.prototype, "inOption", null);
  TuiDropdownBoxComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.NgZone)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_DROPDOWN_DIRECTIVE */.Jd)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(ng_web_apis_common/* WINDOW */.m9)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(taiga_ui_cdk_abstract/* AbstractTuiPortalHostComponent */.Er)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw)), (0,tslib_es6/* __param */.fM)(7, (0,core_js_.Inject)(ng_web_apis_common/* ANIMATION_FRAME */.L1))], TuiDropdownBoxComponent);
  return TuiDropdownBoxComponent;
})();
let TuiDropdownBoxModule = /*#__PURE__*/(() => {
  let TuiDropdownBoxModule = class TuiDropdownBoxModule {};
  TuiDropdownBoxModule.ɵfac = function TuiDropdownBoxModule_Factory(t) {
    return new (t || TuiDropdownBoxModule)();
  };
  TuiDropdownBoxModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDropdownBoxModule
  });
  TuiDropdownBoxModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[TuiActiveZoneModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiOverscrollModule, TuiScrollbarModule, taiga_ui_core_directives_mode/* TuiModeModule */.z]]
  });
  return TuiDropdownBoxModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDropdownBoxModule, {
    declarations: function () {
      return [TuiDropdownBoxComponent];
    },
    imports: function () {
      return [TuiActiveZoneModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiOverscrollModule, TuiScrollbarModule, taiga_ui_core_directives_mode/* TuiModeModule */.z];
    },
    exports: function () {
      return [TuiDropdownBoxComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-dropdown-box.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-services.js
var taiga_ui_core_services = __webpack_require__(7941);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-abstract.js








// @bad TODO: Possibly refactor to make more abstract



let AbstractTuiDropdown = /*#__PURE__*/(() => {
  let AbstractTuiDropdown = class AbstractTuiDropdown {
    constructor(componentFactoryResolver, injector, portalService, elementRef, activeZone) {
      this.componentFactoryResolver = componentFactoryResolver;
      this.injector = injector;
      this.portalService = portalService;
      this.elementRef = elementRef;
      this.activeZone = activeZone;
      this.content = ``;
      this.tuiDropdownHost = null;
      this.minHeight = taiga_ui_core_constants/* DEFAULT_MIN_HEIGHT */.q_;
      this.maxHeight = taiga_ui_core_constants/* DEFAULT_MAX_HEIGHT */.ze;
      this.align = `left`;
      this.direction = null;
      this.sided = false;
      this.limitMinWidth = `min`;
      this.dropdownBoxRef = null;
    }
    ngOnDestroy() {
      this.closeDropdownBox();
    }
    ngAfterViewChecked() {
      // @awful TODO: This is probably wrong to call both but in TuiHostedDropdown some changes do not propagate otherwise
      if (this.dropdownBoxRef !== null) {
        this.dropdownBoxRef.changeDetectorRef.detectChanges();
        this.dropdownBoxRef.changeDetectorRef.markForCheck();
      }
    }
    get clientRect() {
      return this.elementRef.nativeElement.getBoundingClientRect();
    }
    get host() {
      return this.tuiDropdownHost || this.elementRef.nativeElement;
    }
    get fixed() {
      return (0,taiga_ui_core_utils_dom/* checkFixedPosition */.rn)(this.elementRef.nativeElement);
    }
    toggleDropdown(value) {
      if (value) {
        this.openDropdownBox();
      } else {
        this.closeDropdownBox();
      }
    }
    openDropdownBox() {
      if (this.dropdownBoxRef !== null) {
        return;
      }
      const componentFactory = this.componentFactoryResolver.resolveComponentFactory(TuiDropdownBoxComponent);
      this.dropdownBoxRef = this.portalService.add(componentFactory, this.injector);
      this.dropdownBoxRef.changeDetectorRef.detectChanges();
    }
    closeDropdownBox() {
      if (this.dropdownBoxRef === null) {
        return;
      }
      this.portalService.remove(this.dropdownBoxRef);
      this.dropdownBoxRef = null;
    }
  };
  AbstractTuiDropdown.ɵfac = function AbstractTuiDropdown_Factory(t) {
    return new (t || AbstractTuiDropdown)(core_js_["ɵɵdirectiveInject"](core_js_.ComponentFactoryResolver), core_js_["ɵɵdirectiveInject"](core_js_.Injector), core_js_["ɵɵdirectiveInject"](TuiPortalService), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](TuiActiveZoneDirective));
  };
  AbstractTuiDropdown.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: AbstractTuiDropdown,
    inputs: {
      content: ["tuiDropdownContent", "content"],
      tuiDropdownHost: "tuiDropdownHost",
      minHeight: ["tuiDropdownMinHeight", "minHeight"],
      maxHeight: ["tuiDropdownMaxHeight", "maxHeight"],
      align: ["tuiDropdownAlign", "align"],
      direction: ["tuiDropdownDirection", "direction"],
      sided: ["tuiDropdownSided", "sided"],
      limitMinWidth: ["tuiDropdownLimitWidth", "limitMinWidth"]
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(`tuiDropdownContent`), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiDropdown.prototype, "content", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(`tuiDropdownHost`), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiDropdown.prototype, "tuiDropdownHost", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(`tuiDropdownMinHeight`), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiDropdown.prototype, "minHeight", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(`tuiDropdownMaxHeight`), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiDropdown.prototype, "maxHeight", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(`tuiDropdownAlign`), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiDropdown.prototype, "align", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(`tuiDropdownDirection`), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiDropdown.prototype, "direction", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(`tuiDropdownSided`), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiDropdown.prototype, "sided", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(`tuiDropdownLimitWidth`), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiDropdown.prototype, "limitMinWidth", void 0);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], AbstractTuiDropdown.prototype, "fixed", null);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], AbstractTuiDropdown.prototype, "toggleDropdown", null);
  return AbstractTuiDropdown;
})();
let AbstractTuiHint = /*#__PURE__*/(() => {
  let AbstractTuiHint = class AbstractTuiHint {
    constructor(elementRef, hintService, activeZone, options) {
      this.elementRef = elementRef;
      this.hintService = hintService;
      this.activeZone = activeZone;
      this.options = options;
      this.mode = this.options.mode;
      this.direction = this.options.direction;
      this.content = ``;
    }
    ngOnDestroy() {
      this.hideTooltip();
    }
    showTooltip() {
      this.hintService.add(this);
    }
    hideTooltip() {
      this.hintService.remove(this);
    }
  };
  AbstractTuiHint.ɵfac = function AbstractTuiHint_Factory(t) {
    return new (t || AbstractTuiHint)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_services/* TuiHintService */.BN), core_js_["ɵɵdirectiveInject"](TuiActiveZoneDirective), core_js_["ɵɵdirectiveInject"](undefined));
  };
  AbstractTuiHint.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: AbstractTuiHint,
    inputs: {
      mode: ["tuiHintMode", "mode"],
      direction: ["tuiHintDirection", "direction"]
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(`tuiHintMode`), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiHint.prototype, "mode", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(`tuiHintDirection`), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiHint.prototype, "direction", void 0);

  /** Default values for abstract hint options */
  return AbstractTuiHint;
})();
const TUI_ABSTRACT_HINT_DEFAULT_OPTIONS = {
  mode: null,
  direction: `bottom-left`
};

// @dynamic
let TuiAbstractTextfieldHost =
/*#__PURE__*/
// eslint-disable-next-line @typescript-eslint/naming-convention
(() => {
  let TuiAbstractTextfieldHost = class TuiAbstractTextfieldHost {
    constructor(host) {
      this.host = host;
    }
    get readOnly() {
      return this.host.readOnly;
    }
    get disabled() {
      return this.host.computedDisabled;
    }
    get invalid() {
      return this.host.computedInvalid;
    }
    get focusable() {
      return this.host.computedFocusable;
    }
    get value() {
      return String(this.host.value);
    }
    process(_input) {}
  };
  TuiAbstractTextfieldHost.ɵfac = function TuiAbstractTextfieldHost_Factory(t) {
    return new (t || TuiAbstractTextfieldHost)(core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_abstract/* AbstractTuiControl */.M$));
  };
  TuiAbstractTextfieldHost.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiAbstractTextfieldHost
  });
  TuiAbstractTextfieldHost = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_cdk_abstract/* AbstractTuiControl */.M$))], TuiAbstractTextfieldHost);
  return TuiAbstractTextfieldHost;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-abstract.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-directives-dropdown.js








var TuiDropdownDirective_1;
let TuiDropdownDirective = TuiDropdownDirective_1 = class TuiDropdownDirective extends AbstractTuiDropdown {
  constructor(componentFactoryResolver, injector, portalService, elementRef, activeZone, refresh$) {
    super(componentFactoryResolver, injector, portalService, elementRef, activeZone);
    this.refresh$ = refresh$;
  }
  set open(value) {
    this.toggleDropdown(value);
  }
};
TuiDropdownDirective.ɵfac = function TuiDropdownDirective_Factory(t) {
  return new (t || TuiDropdownDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ComponentFactoryResolver), core_js_["ɵɵdirectiveInject"](core_js_.Injector), core_js_["ɵɵdirectiveInject"](TuiPortalService), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](TuiActiveZoneDirective, 8), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiParentsScrollService */.b0));
};
TuiDropdownDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiDropdownDirective,
  selectors: [["", "tuiDropdown", "", 5, "ng-container"]],
  inputs: {
    open: ["tuiDropdown", "open"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_core_tokens/* TUI_DROPDOWN_DIRECTIVE */.Jd,
    useExisting: (0,core_js_.forwardRef)(() => TuiDropdownDirective_1)
  }, taiga_ui_cdk_services/* TuiParentsScrollService */.b0]), core_js_["ɵɵInheritDefinitionFeature"]]
});
TuiDropdownDirective.ctorParameters = () => [{
  type: core_js_.ComponentFactoryResolver,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ComponentFactoryResolver]
  }]
}, {
  type: core_js_.Injector,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.Injector]
  }]
}, {
  type: TuiPortalService,
  decorators: [{
    type: core_js_.Inject,
    args: [TuiPortalService]
  }]
}, {
  type: core_js_.ElementRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ElementRef]
  }]
}, {
  type: TuiActiveZoneDirective,
  decorators: [{
    type: core_js_.Inject,
    args: [TuiActiveZoneDirective]
  }, {
    type: core_js_.Optional
  }]
}, {
  type: taiga_ui_cdk_services/* TuiParentsScrollService */.b0,
  decorators: [{
    type: core_js_.Inject,
    args: [taiga_ui_cdk_services/* TuiParentsScrollService */.b0]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdown')], TuiDropdownDirective.prototype, "open", null);
TuiDropdownDirective = TuiDropdownDirective_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ComponentFactoryResolver)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.Injector)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(TuiPortalService)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(TuiActiveZoneDirective)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiParentsScrollService */.b0))], TuiDropdownDirective);
let TuiDropdownModule = /*#__PURE__*/(() => {
  let TuiDropdownModule = class TuiDropdownModule {};
  TuiDropdownModule.ɵfac = function TuiDropdownModule_Factory(t) {
    return new (t || TuiDropdownModule)();
  };
  TuiDropdownModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDropdownModule
  });
  TuiDropdownModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[TuiDropdownBoxModule]]
  });
  return TuiDropdownModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDropdownModule, {
    declarations: function () {
      return [TuiDropdownDirective];
    },
    imports: function () {
      return [TuiDropdownBoxModule];
    },
    exports: function () {
      return [TuiDropdownDirective];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-directives-dropdown.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/concat.js + 1 modules
var observable_concat = __webpack_require__(8071);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/defer.js
var observable_defer = __webpack_require__(1439);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/takeWhile.js
var takeWhile = __webpack_require__(409);
;// CONCATENATED MODULE: ./node_modules/@tinkoff/ng-event-plugins/fesm2015/tinkoff-ng-event-plugins.js





/**
 * @fileoverview added by tsickle
 * Generated from: utils/dasharize.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} camel
 * @return {?}
 */

function dasharize(camel) {
  return camel.replace(/[a-z][A-Z]/g,
  /**
  * @param {?} letterLetter
  * @return {?}
  */
  letterLetter => {
    return `${letterLetter[0]}-${letterLetter[1].toLowerCase()}`;
  });
}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/abstract.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class AbstractEventPlugin {
  /**
   * @param {?} event
   * @return {?}
   */
  supports(event) {
    return event.includes(this.modifier);
  }
  /**
   * @param {?} _element
   * @param {?} _event
   * @param {?} _handler
   * @return {?}
   */
  addGlobalEventListener(_element, _event, _handler) {
    throw new Error(`Global event targets are not supported by ${this.modifier} plugin`);
  }
  /**
   * @protected
   * @param {?} event
   * @return {?}
   */
  unwrap(event) {
    return event.split('.').filter(
    /**
    * @param {?} v
    * @return {?}
    */
    v => !this.modifier.includes(v)).join('.');
  }
}
if (false) {}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/bind.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
let BindEventPlugin = /*#__PURE__*/(() => {
  class BindEventPlugin extends AbstractEventPlugin {
    constructor() {
      super(...arguments);
      this.modifier = '$';
    }
    /**
     * @param {?} element
     * @param {?} event
     * @return {?}
     */
    addEventListener(element, event) {
      element[event] = element[event] || observable_empty/* EMPTY */.E;
      /** @type {?} */
      const method = this.getMethod(element, event);
      /** @type {?} */
      const zone$ = this.manager.getZone().onStable;
      /** @type {?} */
      const sub = (0,observable_concat/* concat */.z)(zone$.pipe((0,takeWhile/* takeWhile */.o)(
      /**
      * @return {?}
      */
      () => element[event] === observable_empty/* EMPTY */.E)), (0,observable_defer/* defer */.P)(
      /**
      * @return {?}
      */
      () => element[event])).subscribe(method);
      return (
        /**
        * @return {?}
        */
        () => sub.unsubscribe()
      );
    }
    /**
     * @private
     * @param {?} element
     * @param {?} event
     * @return {?}
     */
    getMethod(element, event) {
      const [, key, value, unit = ''] = event.split('.');
      if (event.endsWith('.attr')) {
        return (
          /**
          * @param {?} v
          * @return {?}
          */
          v => v === null ? element.removeAttribute(key) : element.setAttribute(key, String(v))
        );
      }
      if (key === 'class') {
        return (
          /**
          * @param {?} v
          * @return {?}
          */
          v => element.classList.toggle(value, !!v)
        );
      }
      if (key === 'style') {
        return (
          /**
          * @param {?} v
          * @return {?}
          */
          v => element.style.setProperty(dasharize(value), `${v}${unit}`)
        );
      }
      return (
        /**
        * @param {?} v
        * @return {?}
        */
        v => element[key] = v
      );
    }
  }
  BindEventPlugin.ɵfac = /*@__PURE__*/function () {
    let ɵBindEventPlugin_BaseFactory;
    return function BindEventPlugin_Factory(t) {
      return (ɵBindEventPlugin_BaseFactory || (ɵBindEventPlugin_BaseFactory = core_js_["ɵɵgetInheritedFactory"](BindEventPlugin)))(t || BindEventPlugin);
    };
  }();
  BindEventPlugin.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: BindEventPlugin,
    factory: BindEventPlugin.ɵfac
  });
  return BindEventPlugin;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
if (false) {}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/options.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
let OptionsEventPlugin = /*#__PURE__*/(() => {
  class OptionsEventPlugin extends AbstractEventPlugin {
    constructor() {
      super(...arguments);
      this.modifier = 'capture.once.passive';
    }
    /**
     * @param {?} event
     * @return {?}
     */
    supports(event) {
      return event.includes('.') && !this.unwrap(event).includes('.');
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addEventListener(element, event, handler) {
      element.addEventListener(this.unwrap(event), handler, {
        once: event.includes('.once'),
        passive: event.includes('.passive'),
        capture: event.includes('.capture')
      });
      return (
        /**
        * @return {?}
        */
        () => element.removeEventListener(this.unwrap(event), handler)
      );
    }
  }
  OptionsEventPlugin.ɵfac = /*@__PURE__*/function () {
    let ɵOptionsEventPlugin_BaseFactory;
    return function OptionsEventPlugin_Factory(t) {
      return (ɵOptionsEventPlugin_BaseFactory || (ɵOptionsEventPlugin_BaseFactory = core_js_["ɵɵgetInheritedFactory"](OptionsEventPlugin)))(t || OptionsEventPlugin);
    };
  }();
  OptionsEventPlugin.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: OptionsEventPlugin,
    factory: OptionsEventPlugin.ɵfac
  });
  return OptionsEventPlugin;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
if (false) {}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/prevent.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
let PreventEventPlugin = /*#__PURE__*/(() => {
  class PreventEventPlugin extends AbstractEventPlugin {
    constructor() {
      super(...arguments);
      this.modifier = '.prevent';
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addEventListener(element, event, handler) {
      /** @type {?} */
      const wrapped =
      /**
      * @param {?} event
      * @return {?}
      */
      event => {
        event.preventDefault();
        handler(event);
      };
      return this.manager.addEventListener(element, this.unwrap(event), wrapped);
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addGlobalEventListener(element, event, handler) {
      /** @type {?} */
      const wrapped =
      /**
      * @param {?} event
      * @return {?}
      */
      event => {
        event.preventDefault();
        handler(event);
      };
      return this.manager.addGlobalEventListener(element, this.unwrap(event), wrapped);
    }
  }
  PreventEventPlugin.ɵfac = /*@__PURE__*/function () {
    let ɵPreventEventPlugin_BaseFactory;
    return function PreventEventPlugin_Factory(t) {
      return (ɵPreventEventPlugin_BaseFactory || (ɵPreventEventPlugin_BaseFactory = core_js_["ɵɵgetInheritedFactory"](PreventEventPlugin)))(t || PreventEventPlugin);
    };
  }();
  PreventEventPlugin.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: PreventEventPlugin,
    factory: PreventEventPlugin.ɵfac
  });
  return PreventEventPlugin;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
if (false) {}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/self.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
let SelfEventPlugin = /*#__PURE__*/(() => {
  class SelfEventPlugin extends AbstractEventPlugin {
    constructor() {
      super(...arguments);
      this.modifier = '.self';
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addEventListener(element, event, handler) {
      /** @type {?} */
      const wrapped =
      /**
      * @param {?} event
      * @return {?}
      */
      event => {
        if (event.target === event.currentTarget) {
          handler(event);
        }
      };
      return this.manager.addEventListener(element, this.unwrap(event), wrapped);
    }
  }
  SelfEventPlugin.ɵfac = /*@__PURE__*/function () {
    let ɵSelfEventPlugin_BaseFactory;
    return function SelfEventPlugin_Factory(t) {
      return (ɵSelfEventPlugin_BaseFactory || (ɵSelfEventPlugin_BaseFactory = core_js_["ɵɵgetInheritedFactory"](SelfEventPlugin)))(t || SelfEventPlugin);
    };
  }();
  SelfEventPlugin.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: SelfEventPlugin,
    factory: SelfEventPlugin.ɵfac
  });
  return SelfEventPlugin;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
if (false) {}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/silent.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
let SilentEventPlugin = /*#__PURE__*/(() => {
  class SilentEventPlugin extends AbstractEventPlugin {
    constructor() {
      super(...arguments);
      this.modifier = '.silent';
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addEventListener(element, event, handler) {
      return this.manager.getZone().runOutsideAngular(
      /**
      * @return {?}
      */
      () => this.manager.addEventListener(element, this.unwrap(event), handler));
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addGlobalEventListener(element, event, handler) {
      return this.manager.getZone().runOutsideAngular(
      /**
      * @return {?}
      */
      () => this.manager.addGlobalEventListener(element, this.unwrap(event), handler));
    }
  }
  SilentEventPlugin.ɵfac = /*@__PURE__*/function () {
    let ɵSilentEventPlugin_BaseFactory;
    return function SilentEventPlugin_Factory(t) {
      return (ɵSilentEventPlugin_BaseFactory || (ɵSilentEventPlugin_BaseFactory = core_js_["ɵɵgetInheritedFactory"](SilentEventPlugin)))(t || SilentEventPlugin);
    };
  }();
  SilentEventPlugin.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: SilentEventPlugin,
    factory: SilentEventPlugin.ɵfac
  });
  return SilentEventPlugin;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
if (false) {}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/stop.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
let StopEventPlugin = /*#__PURE__*/(() => {
  class StopEventPlugin extends AbstractEventPlugin {
    constructor() {
      super(...arguments);
      this.modifier = '.stop';
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addEventListener(element, event, handler) {
      /** @type {?} */
      const wrapped =
      /**
      * @param {?} event
      * @return {?}
      */
      event => {
        event.stopPropagation();
        handler(event);
      };
      return this.manager.addEventListener(element, this.unwrap(event), wrapped);
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addGlobalEventListener(element, event, handler) {
      /** @type {?} */
      const wrapped =
      /**
      * @param {?} event
      * @return {?}
      */
      event => {
        event.stopPropagation();
        handler(event);
      };
      return this.manager.addGlobalEventListener(element, this.unwrap(event), wrapped);
    }
  }
  StopEventPlugin.ɵfac = /*@__PURE__*/function () {
    let ɵStopEventPlugin_BaseFactory;
    return function StopEventPlugin_Factory(t) {
      return (ɵStopEventPlugin_BaseFactory || (ɵStopEventPlugin_BaseFactory = core_js_["ɵɵgetInheritedFactory"](StopEventPlugin)))(t || StopEventPlugin);
    };
  }();
  StopEventPlugin.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: StopEventPlugin,
    factory: StopEventPlugin.ɵfac
  });
  return StopEventPlugin;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
if (false) {}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/zone.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * TODO: This will not be needed in Angular 10
 * when libraries are allowed to use Ivy renderer and markDirty becomes stable API
 */
let ZoneEventPlugin = /*#__PURE__*/(() => {
  class ZoneEventPlugin extends AbstractEventPlugin {
    constructor() {
      super(...arguments);
      this.modifier = '.init';
    }
    /**
     * @param {?} _element
     * @param {?} _event
     * @param {?} handler
     * @return {?}
     */
    addEventListener(_element, _event, handler) {
      return this.handle(handler);
    }
    /**
     * @param {?} _element
     * @param {?} _event
     * @param {?} handler
     * @return {?}
     */
    addGlobalEventListener(_element, _event, handler) {
      return this.handle(handler);
    }
    /**
     * @private
     * @param {?} handler
     * @return {?}
     */
    handle(handler) {
      /** @type {?} */
      const zone = this.manager.getZone();
      /** @type {?} */
      const subscription = zone.onStable.subscribe(
      /**
      * @return {?}
      */
      () => {
        subscription.unsubscribe();
        handler(zone);
      });
      return (
        /**
        * @return {?}
        */
        () => {}
      );
    }
  }
  ZoneEventPlugin.ɵfac = /*@__PURE__*/function () {
    let ɵZoneEventPlugin_BaseFactory;
    return function ZoneEventPlugin_Factory(t) {
      return (ɵZoneEventPlugin_BaseFactory || (ɵZoneEventPlugin_BaseFactory = core_js_["ɵɵgetInheritedFactory"](ZoneEventPlugin)))(t || ZoneEventPlugin);
    };
  }();
  ZoneEventPlugin.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: ZoneEventPlugin,
    factory: ZoneEventPlugin.ɵfac
  });
  return ZoneEventPlugin;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
if (false) {}

/**
 * @fileoverview added by tsickle
 * Generated from: constants/plugins.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NG_EVENT_PLUGINS = [{
  provide: platform_browser.EVENT_MANAGER_PLUGINS,
  useClass: SilentEventPlugin,
  multi: true
}, {
  provide: platform_browser.EVENT_MANAGER_PLUGINS,
  useClass: PreventEventPlugin,
  multi: true
}, {
  provide: platform_browser.EVENT_MANAGER_PLUGINS,
  useClass: SelfEventPlugin,
  multi: true
}, {
  provide: platform_browser.EVENT_MANAGER_PLUGINS,
  useClass: StopEventPlugin,
  multi: true
}, {
  provide: platform_browser.EVENT_MANAGER_PLUGINS,
  useClass: ZoneEventPlugin,
  multi: true
}, {
  provide: platform_browser.EVENT_MANAGER_PLUGINS,
  useClass: OptionsEventPlugin,
  multi: true
}, {
  provide: platform_browser.EVENT_MANAGER_PLUGINS,
  useClass: BindEventPlugin,
  multi: true
}];

/**
 * @fileoverview added by tsickle
 * Generated from: decorators/should-call.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * TODO: This will not be needed when markDirty becomes stable API
 * @template T
 * @param {?} predicate
 * @return {?}
 */
function shouldCall(predicate) {
  return (
    /**
    * @param {?} _
    * @param {?} key
    * @param {?} desc
    * @return {?}
    */
    (_, key, desc) => {
      const {
        value
      } = desc;
      desc.value =
      /**
      * @this {?}
      * @param {...?} args
      * @return {?}
      */
      function (...args) {
        /** @type {?} */
        const zone = arguments[0];
        if (zone instanceof core_js_.NgZone) {
          Object.defineProperty(this, key, {
            /**
             * @this {?}
             * @param {...?} args
             * @return {?}
             */
            value(...args) {
              if (predicate.apply(this, args)) {
                zone.run(
                /**
                * @return {?}
                */
                () => {
                  value.apply(this, args);
                });
              }
            }
          });
        } else if (predicate.apply(this, args)) {
          value.apply(this, args);
        }
      };
    }
  );
}

/**
 * @fileoverview added by tsickle
 * Generated from: types/predicate.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: utils/as-callable.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} a
 * @return {?}
 */
function asCallable(a) {
  return (/** @type {?} */a
  );
}

/**
 * @fileoverview added by tsickle
 * Generated from: module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @dynamic
let EventPluginsModule = /*#__PURE__*/(() => {
  class EventPluginsModule {
    /**
     * @param {?} plugins
     */
    constructor(plugins) {
      console.assert(!(plugins[0] instanceof SilentEventPlugin) || EventPluginsModule.initialized, 'EventPluginsModule must come after BrowserModule in imports');
      EventPluginsModule.initialized = true;
    }
  }
  EventPluginsModule.ɵfac = function EventPluginsModule_Factory(t) {
    return new (t || EventPluginsModule)(core_js_["ɵɵinject"](platform_browser.EVENT_MANAGER_PLUGINS));
  };
  EventPluginsModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: EventPluginsModule
  });
  EventPluginsModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    providers: NG_EVENT_PLUGINS
  });
  EventPluginsModule.initialized = false;
  /** @nocollapse */
  return EventPluginsModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
if (false) {}

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: tinkoff-ng-event-plugins.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */



//# sourceMappingURL=tinkoff-ng-event-plugins.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-svg.js
var taiga_ui_core_components_svg = __webpack_require__(4789);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-data-list.js












// eslint-disable-next-line @typescript-eslint/naming-convention






const taiga_ui_core_components_data_list_c0 = ["tuiOption", ""];
const _c1 = function (a0) {
  return {
    $implicit: a0
  };
};
function TuiOptionComponent_span_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "span", 2);
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    const _r1 = core_js_["ɵɵreference"](2);
    core_js_["ɵɵproperty"]("content", ctx_r0.content)("context", core_js_["ɵɵpureFunction1"](2, _c1, _r1));
  }
}
function TuiOptionComponent_ng_template_1_tui_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 4);
  }
}
function TuiOptionComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵprojection"](0);
    core_js_["ɵɵtemplate"](1, TuiOptionComponent_ng_template_1_tui_svg_1_Template, 1, 0, "tui-svg", 3);
  }
  if (rf & 2) {
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", ctx_r2.dropdown);
  }
}
const _c2 = ["*"];
function TuiDataListComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "div", 2);
    core_js_["ɵɵpipe"](1, "async");
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("content", ctx_r0.emptyContent || core_js_["ɵɵpipeBind1"](1, 1, ctx_r0.defaultEmptyContent$));
  }
}
function shouldFocus({
  currentTarget
}) {
  return !(0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(currentTarget);
}
// TODO: Consider all use cases for aria roles
let TuiOptionComponent = /*#__PURE__*/(() => {
  let TuiOptionComponent = class TuiOptionComponent {
    // TODO: 3.0 Fix dataList type when updated to Ivy and compilation drops metadata
    constructor(content, dataList, elementRef, host, dropdown) {
      this.content = content;
      this.dataList = dataList;
      this.elementRef = elementRef;
      this.host = host;
      this.dropdown = dropdown;
      this.size = 'm';
      this.role = 'option';
      this.disabled = false;
    }
    get active() {
      return !!this.dropdown && !!this.dropdown.dropdownBoxRef;
    }
    onClick() {
      if (this.host && this.value !== undefined) {
        this.host.handleOption(this.value);
      }
    }
    // @bad TODO: Consider aria-activedescendant for proper accessibility implementation
    onMouseMove({
      currentTarget
    }) {
      (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(currentTarget, true, true);
    }
    // Preventing focus loss upon focused option removal
    ngOnDestroy() {
      this.dataList.handleFocusLossIfNecessary(this.elementRef.nativeElement);
    }
  };
  TuiOptionComponent.ɵfac = function TuiOptionComponent_Factory(t) {
    return new (t || TuiOptionComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_OPTION_CONTENT */.IQ, 8), core_js_["ɵɵdirectiveInject"]((0,core_js_.forwardRef)(() => TuiDataListComponent)), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_DATA_LIST_HOST */.N1, 8), core_js_["ɵɵdirectiveInject"](TuiDropdownDirective, 10));
  };
  TuiOptionComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiOptionComponent,
    selectors: [["button", "tuiOption", ""], ["a", "tuiOption", ""]],
    hostAttrs: ["tabIndex", "-1", "type", "button"],
    hostVars: 5,
    hostBindings: function TuiOptionComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("click", function TuiOptionComponent_click_HostBindingHandler() {
          return ctx.onClick();
        })("mousemove.init", function TuiOptionComponent_mousemove_init_HostBindingHandler($event) {
          return ctx.onMouseMove($event);
        })("mousemove.silent", function TuiOptionComponent_mousemove_silent_HostBindingHandler($event) {
          return ctx.onMouseMove($event);
        });
      }
      if (rf & 2) {
        core_js_["ɵɵattribute"]("disabled", ctx.disabled || null)("data-size", ctx.size)("role", ctx.role);
        core_js_["ɵɵclassProp"]("_with-dropdown", ctx.active);
      }
    },
    inputs: {
      size: "size",
      role: "role",
      disabled: "disabled",
      value: "value"
    },
    attrs: taiga_ui_core_components_data_list_c0,
    ngContentSelectors: _c2,
    decls: 3,
    vars: 2,
    consts: [["polymorpheus-outlet", "", "class", "t-content", 3, "content", "context", 4, "ngIf", "ngIfElse"], ["base", ""], ["polymorpheus-outlet", "", 1, "t-content", 3, "content", "context"], ["src", "tuiIconChevronRight", "class", "t-arrow", 4, "ngIf"], ["src", "tuiIconChevronRight", 1, "t-arrow"]],
    template: function TuiOptionComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵtemplate"](0, TuiOptionComponent_span_0_Template, 1, 4, "span", 0);
        core_js_["ɵɵtemplate"](1, TuiOptionComponent_ng_template_1_Template, 2, 1, "ng-template", null, 1, core_js_["ɵɵtemplateRefExtractor"]);
      }
      if (rf & 2) {
        const _r1 = core_js_["ɵɵreference"](2);
        core_js_["ɵɵproperty"]("ngIf", ctx.content)("ngIfElse", _r1);
      }
    },
    directives: [common_js_.NgIf, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, taiga_ui_core_components_svg/* TuiSvgComponent */.P],
    styles: ["[_nghost-%COMP%]{-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:0;border:0;background:padding-box;font-size:inherit;line-height:inherit;transition-property:background;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;display:flex;font:var(--tui-font-text-m);width:100%;align-items:center;justify-content:space-between;text-align:left;box-sizing:border-box;color:var(--tui-text-01);outline:0;text-decoration:none;cursor:pointer}[_nghost-%COMP%]:disabled{opacity:var(--tui-disabled-opacity);cursor:default}._with-dropdown[_nghost-%COMP%], [_nghost-%COMP%]:focus{background-color:var(--tui-base-02)}[data-size=xs][_nghost-%COMP%]{font:var(--tui-font-text-s);min-height:2rem;padding:.3125rem .75rem}[data-size='s'][_nghost-%COMP%]{min-height:2rem;padding:.3125rem .75rem}[data-size='m'][_nghost-%COMP%]{min-height:2.75rem;padding:.375rem 1rem}[data-size='l'][_nghost-%COMP%]{min-height:3.5rem;padding:.75rem 1rem}.t-content[_ngcontent-%COMP%]{display:flex;flex:1;max-width:100%}.t-arrow[_ngcontent-%COMP%]{margin:0 -.5rem 0 .75rem}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-size'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiOptionComponent.prototype, "size", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.role'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiOptionComponent.prototype, "role", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiOptionComponent.prototype, "disabled", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiOptionComponent.prototype, "value", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._with-dropdown')], TuiOptionComponent.prototype, "active", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('click')], TuiOptionComponent.prototype, "onClick", null);
  (0,tslib_es6/* __decorate */.gn)([shouldCall(shouldFocus), (0,core_js_.HostListener)('mousemove.init', ['$event']), (0,core_js_.HostListener)('mousemove.silent', ['$event'])], TuiOptionComponent.prototype, "onMouseMove", null);
  TuiOptionComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_OPTION_CONTENT */.IQ)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)((0,core_js_.forwardRef)(() => TuiDataListComponent))), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_DATA_LIST_HOST */.N1)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(TuiDropdownDirective))], TuiOptionComponent);
  return TuiOptionComponent;
})();
var TuiDataListComponent_1;
// TODO: Consider aria-activedescendant for proper accessibility implementation
// @dynamic
let TuiDataListComponent = TuiDataListComponent_1 = class TuiDataListComponent {
  constructor(elementRef, defaultEmptyContent$) {
    this.elementRef = elementRef;
    this.defaultEmptyContent$ = defaultEmptyContent$;
    this.options = taiga_ui_cdk_constants/* EMPTY_QUERY */.Mm;
    this.role = 'listbox';
    this.emptyContent = '';
  }
  get empty$() {
    return (0,taiga_ui_cdk_observables/* itemsQueryListObservable */.Fp)(this.options).pipe((0,operators_map/* map */.U)(({
      length
    }) => !length));
  }
  onFocusIn(relatedTarget, currentTarget) {
    if (!currentTarget.contains(relatedTarget) && !this.origin) {
      this.origin = relatedTarget;
    }
  }
  noop() {}
  onKeyDownArrow(current, step) {
    const {
      elements
    } = this;
    (0,taiga_ui_cdk_utils_focus/* moveFocus */.pr)(elements.indexOf(current), elements, step);
  }
  // TODO: Consider aria-activedescendant for proper accessibility implementation
  handleFocusLossIfNecessary(element = this.elementRef.nativeElement) {
    if (this.origin && (0,taiga_ui_cdk_utils_focus/* isNativeFocusedIn */.KF)(element)) {
      (0,taiga_ui_cdk_utils_focus/* setNativeMouseFocused */.Gi)(this.origin, true, true);
    }
  }
  getOptions(includeDisabled = false) {
    return this.options.toArray().filter(({
      disabled
    }) => includeDisabled || !disabled).map(({
      value
    }) => value).filter(taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN);
  }
  onFocus({
    target
  }, top) {
    (0,taiga_ui_cdk_classes/* tuiAssertIsHTMLElement */.HU)(target);
    const {
      elements
    } = this;
    (0,taiga_ui_cdk_utils_focus/* moveFocus */.pr)(top ? -1 : elements.length, elements, top ? 1 : -1);
    this.handleFocusLossIfNecessary(target);
  }
  get elements() {
    return Array.from(this.elementRef.nativeElement.querySelectorAll('[tuiOption]'));
  }
};
TuiDataListComponent.ɵfac = function TuiDataListComponent_Factory(t) {
  return new (t || TuiDataListComponent)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_NOTHING_FOUND_MESSAGE */.PH));
};
TuiDataListComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiDataListComponent,
  selectors: [["tui-data-list"]],
  contentQueries: function TuiDataListComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      core_js_["ɵɵcontentQuery"](dirIndex, TuiOptionComponent, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.options = _t);
    }
  },
  hostVars: 1,
  hostBindings: function TuiDataListComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵlistener"]("focusin", function TuiDataListComponent_focusin_HostBindingHandler($event) {
        return ctx.onFocusIn($event.relatedTarget, $event.currentTarget);
      })("mousedown.prevent", function TuiDataListComponent_mousedown_prevent_HostBindingHandler() {
        return ctx.noop();
      })("keydown.arrowDown.prevent", function TuiDataListComponent_keydown_arrowDown_prevent_HostBindingHandler($event) {
        return ctx.onKeyDownArrow($event.target, 1);
      })("keydown.arrowUp.prevent", function TuiDataListComponent_keydown_arrowUp_prevent_HostBindingHandler($event) {
        return ctx.onKeyDownArrow($event.target, -1);
      })("wheel.silent.passive", function TuiDataListComponent_wheel_silent_passive_HostBindingHandler() {
        return ctx.handleFocusLossIfNecessary();
      })("mouseleave", function TuiDataListComponent_mouseleave_HostBindingHandler($event) {
        return ctx.handleFocusLossIfNecessary($event.target);
      });
    }
    if (rf & 2) {
      core_js_["ɵɵattribute"]("role", ctx.role);
    }
  },
  inputs: {
    role: "role",
    emptyContent: "emptyContent"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_core_tokens/* TUI_DATA_LIST_ACCESSOR */.Cc,
    useExisting: (0,core_js_.forwardRef)(() => TuiDataListComponent_1)
  }])],
  ngContentSelectors: _c2,
  decls: 5,
  vars: 3,
  consts: [["tabindex", "0", 1, "t-trap", 3, "focusin"], ["polymorpheus-outlet", "", "class", "t-empty", 3, "content", 4, "ngIf"], ["polymorpheus-outlet", "", 1, "t-empty", 3, "content"]],
  template: function TuiDataListComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"]();
      core_js_["ɵɵelementStart"](0, "div", 0);
      core_js_["ɵɵlistener"]("focusin", function TuiDataListComponent_Template_div_focusin_0_listener($event) {
        return ctx.onFocus($event, true);
      });
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵprojection"](1);
      core_js_["ɵɵtemplate"](2, TuiDataListComponent_div_2_Template, 2, 3, "div", 1);
      core_js_["ɵɵpipe"](3, "async");
      core_js_["ɵɵelementStart"](4, "div", 0);
      core_js_["ɵɵlistener"]("focusin", function TuiDataListComponent_Template_div_focusin_4_listener($event) {
        return ctx.onFocus($event, false);
      });
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      core_js_["ɵɵadvance"](2);
      core_js_["ɵɵproperty"]("ngIf", core_js_["ɵɵpipeBind1"](3, 1, ctx.empty$));
    }
  },
  directives: [common_js_.NgIf, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1],
  pipes: [common_js_.AsyncPipe],
  styles: ["tui-data-list{display:flex;font:var(--tui-font-text-m);flex-direction:column;padding:.5rem 0;color:var(--tui-text-03)}tui-data-list:focus-within .t-trap{display:none}tui-data-list:focus-within [tuiOption]._with-dropdown:not(:focus){background-color:transparent}tui-data-list>.t-empty{margin:.75rem 1rem}tui-opt-group{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;position:relative;display:flex;font:var(--tui-font-text-xs);flex-direction:column;line-height:2rem}tui-opt-group:empty:after,tui-opt-group:empty:before{display:none}tui-opt-group:before{content:attr(data-label);padding:.5rem 1rem;color:var(--tui-text-02);line-height:1rem;white-space:normal}tui-opt-group:not(:empty)~tui-opt-group:before{padding:1.5rem 1rem .5rem}tui-opt-group:not(:empty)~tui-opt-group[data-label='']:before{padding:1rem 0 0}tui-opt-group:not(:empty)~tui-opt-group:after{content:'';position:absolute;left:0;right:0;top:.5rem;height:1px;background:var(--tui-base-03)}tui-opt-group[data-label='']:before{padding:0 1rem}"],
  encapsulation: 2,
  changeDetection: 0
});
TuiDataListComponent.ctorParameters = () => [{
  type: core_js_.ElementRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ElementRef]
  }]
}, {
  type: internal_Observable/* Observable */.y,
  decorators: [{
    type: core_js_.Inject,
    args: [taiga_ui_core_tokens/* TUI_NOTHING_FOUND_MESSAGE */.PH]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChildren)((0,core_js_.forwardRef)(() => TuiOptionComponent), {
  descendants: true
})], TuiDataListComponent.prototype, "options", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.role'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDataListComponent.prototype, "role", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDataListComponent.prototype, "emptyContent", void 0);
(0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDataListComponent.prototype, "empty$", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('focusin', ['$event.relatedTarget', '$event.currentTarget'])], TuiDataListComponent.prototype, "onFocusIn", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('mousedown.prevent')], TuiDataListComponent.prototype, "noop", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('keydown.arrowDown.prevent', ['$event.target', '1']), (0,core_js_.HostListener)('keydown.arrowUp.prevent', ['$event.target', '-1'])], TuiDataListComponent.prototype, "onKeyDownArrow", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('wheel.silent.passive'), (0,core_js_.HostListener)('mouseleave', ['$event.target'])], TuiDataListComponent.prototype, "handleFocusLossIfNecessary", null);
TuiDataListComponent = TuiDataListComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_NOTHING_FOUND_MESSAGE */.PH))], TuiDataListComponent);
let TuiDataListDirective = /*#__PURE__*/(() => {
  let TuiDataListDirective = class TuiDataListDirective {};
  TuiDataListDirective.ɵfac = function TuiDataListDirective_Factory(t) {
    return new (t || TuiDataListDirective)();
  };
  TuiDataListDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiDataListDirective,
    selectors: [["ng-template", "tuiDataList", ""]]
  });

  // TODO: 3.0 Move into separate module
  return TuiDataListDirective;
})();
let TuiDataListDropdownManagerDirective = /*#__PURE__*/(() => {
  let TuiDataListDropdownManagerDirective = class TuiDataListDropdownManagerDirective {
    constructor() {
      this.dropdowns = taiga_ui_cdk_constants/* EMPTY_QUERY */.Mm;
      this.elements = taiga_ui_cdk_constants/* EMPTY_QUERY */.Mm;
    }
    ngAfterViewInit() {
      this.right$.subscribe(index => {
        this.tryToFocus(index);
      });
      (0,observable_merge/* merge */.T)(this.immediate$, this.debounce$).pipe((0,operators_switchMap/* switchMap */.w)(active => {
        this.dropdowns.forEach((dropdown, index) => {
          dropdown.open = index === active;
        });
        const element = this.elements.toArray()[active];
        const dropdown = this.dropdowns.toArray()[active];
        if (!element || !dropdown || !dropdown.dropdownBoxRef) {
          return observable_empty/* EMPTY */.E;
        }
        const {
          nativeElement
        } = dropdown.dropdownBoxRef.location;
        const mouseEnter$ = (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, 'mouseenter').pipe((0,operators_take/* take */.q)(1));
        const esc$ = (0,observable_merge/* merge */.T)((0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(element.nativeElement, 'keydown'), (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, 'keydown')).pipe((0,operators_filter/* filter */.h)(({
          keyCode
        }) => keyCode === 27));
        return (0,observable_merge/* merge */.T)(mouseEnter$, esc$).pipe((0,operators_tap/* tap */.b)(event => {
          if (dropdown.dropdownBoxRef) {
            event.stopPropagation();
          }
          (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(element.nativeElement);
          // TODO: iframe warning
          dropdown.open = event instanceof MouseEvent;
        }));
      })).subscribe();
    }
    get elements$() {
      return (0,taiga_ui_cdk_observables/* itemsQueryListObservable */.Fp)(this.elements).pipe((0,operators_map/* map */.U)(array => array.map(({
        nativeElement
      }) => nativeElement)), (0,shareReplay/* shareReplay */.d)({
        bufferSize: 1,
        refCount: true
      }));
    }
    get right$() {
      return this.elements$.pipe((0,operators_switchMap/* switchMap */.w)(elements => (0,observable_merge/* merge */.T)(...elements.map((element, index) => (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(element, 'keydown').pipe((0,operators_filter/* filter */.h)(({
        keyCode
      }) => keyCode === 39), (0,taiga_ui_cdk_observables/* preventDefault */.PF)(), (0,operators_mapTo/* mapTo */.h)(index))))));
    }
    get immediate$() {
      return this.elements$.pipe((0,operators_switchMap/* switchMap */.w)(elements => (0,observable_merge/* merge */.T)(...elements.map((element, index) => (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(element, 'click').pipe((0,operators_mapTo/* mapTo */.h)(index))))));
    }
    get debounce$() {
      return this.elements$.pipe((0,operators_switchMap/* switchMap */.w)(elements => (0,observable_merge/* merge */.T)(...elements.map((element, index) => (0,observable_merge/* merge */.T)((0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(element, 'focus'), (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(element, 'blur')).pipe((0,operators_filter/* filter */.h)(({
        relatedTarget
      }) => this.notInDropdown(relatedTarget, index)), (0,operators_map/* map */.U)(({
        type
      }) => type === 'focus' ? index : NaN))))), (0,operators_debounceTime/* debounceTime */.b)(300));
    }
    notInDropdown(element, index) {
      var _a;
      const dropdown = this.dropdowns.toArray()[index];
      return !((_a = dropdown === null || dropdown === void 0 ? void 0 : dropdown.dropdownBoxRef) === null || _a === void 0 ? void 0 : _a.location.nativeElement.contains(element));
    }
    tryToFocus(index) {
      var _a;
      const dropdown = this.dropdowns.toArray()[index];
      const content = (_a = dropdown === null || dropdown === void 0 ? void 0 : dropdown.dropdownBoxRef) === null || _a === void 0 ? void 0 : _a.instance.contentElementRef;
      if (!content) {
        return;
      }
      const item = (0,taiga_ui_cdk_utils_focus/* getClosestKeyboardFocusable */.O9)(content.nativeElement, false, content.nativeElement);
      if (item) {
        (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(item);
      }
    }
  };
  TuiDataListDropdownManagerDirective.ɵfac = function TuiDataListDropdownManagerDirective_Factory(t) {
    return new (t || TuiDataListDropdownManagerDirective)();
  };
  TuiDataListDropdownManagerDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiDataListDropdownManagerDirective,
    selectors: [["tui-data-list", "tuiDataListDropdownManager", ""]],
    contentQueries: function TuiDataListDropdownManagerDirective_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        core_js_["ɵɵcontentQuery"](dirIndex, TuiDropdownDirective, 5);
        core_js_["ɵɵcontentQuery"](dirIndex, TuiDropdownDirective, 5, core_js_.ElementRef);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.dropdowns = _t);
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.elements = _t);
      }
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChildren)(TuiDropdownDirective, {
    descendants: true
  })], TuiDataListDropdownManagerDirective.prototype, "dropdowns", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChildren)(TuiDropdownDirective, {
    read: core_js_.ElementRef,
    descendants: true
  })], TuiDataListDropdownManagerDirective.prototype, "elements", void 0);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDataListDropdownManagerDirective.prototype, "elements$", null);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDataListDropdownManagerDirective.prototype, "right$", null);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDataListDropdownManagerDirective.prototype, "immediate$", null);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDataListDropdownManagerDirective.prototype, "debounce$", null);
  return TuiDataListDropdownManagerDirective;
})();
let TuiOptGroupDirective = /*#__PURE__*/(() => {
  let TuiOptGroupDirective = class TuiOptGroupDirective {
    constructor() {
      this.label = '';
    }
  };
  TuiOptGroupDirective.ɵfac = function TuiOptGroupDirective_Factory(t) {
    return new (t || TuiOptGroupDirective)();
  };
  TuiOptGroupDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiOptGroupDirective,
    selectors: [["tui-opt-group"]],
    hostAttrs: ["role", "group"],
    hostVars: 1,
    hostBindings: function TuiOptGroupDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("data-label", ctx.label);
      }
    },
    inputs: {
      label: "label"
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-label'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiOptGroupDirective.prototype, "label", void 0);
  return TuiOptGroupDirective;
})();
let TuiDataListModule = /*#__PURE__*/(() => {
  let TuiDataListModule = class TuiDataListModule {};
  TuiDataListModule.ɵfac = function TuiDataListModule_Factory(t) {
    return new (t || TuiDataListModule)();
  };
  TuiDataListModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDataListModule
  });
  TuiDataListModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq]]
  });
  return TuiDataListModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDataListModule, {
    declarations: function () {
      return [TuiDataListComponent, TuiOptionComponent, TuiOptGroupDirective, TuiDataListDirective, TuiDataListDropdownManagerDirective];
    },
    imports: function () {
      return [common_js_.CommonModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq];
    },
    exports: function () {
      return [TuiDataListComponent, TuiOptionComponent, TuiOptGroupDirective, TuiDataListDirective, TuiDataListDropdownManagerDirective];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-data-list.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-focusable.js



/**
 * Abstraction over `tabindex`
 */

let TuiFocusableDirective = /*#__PURE__*/(() => {
  let TuiFocusableDirective = class TuiFocusableDirective {
    constructor() {
      /**
       * Element can be focused with keyboard
       */
      this.focusable = true;
    }
    get tabIndex() {
      return this.focusable ? 0 : -1;
    }
  };
  TuiFocusableDirective.ɵfac = function TuiFocusableDirective_Factory(t) {
    return new (t || TuiFocusableDirective)();
  };
  TuiFocusableDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiFocusableDirective,
    selectors: [["", "tuiFocusable", ""]],
    hostVars: 1,
    hostBindings: function TuiFocusableDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵhostProperty"]("tabIndex", ctx.tabIndex);
      }
    },
    inputs: {
      focusable: ["tuiFocusable", "focusable"]
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiFocusable')], TuiFocusableDirective.prototype, "focusable", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('tabIndex')], TuiFocusableDirective.prototype, "tabIndex", null);
  return TuiFocusableDirective;
})();
let TuiFocusableModule = /*#__PURE__*/(() => {
  let TuiFocusableModule = class TuiFocusableModule {};
  TuiFocusableModule.ɵfac = function TuiFocusableModule_Factory(t) {
    return new (t || TuiFocusableModule)();
  };
  TuiFocusableModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiFocusableModule
  });
  TuiFocusableModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiFocusableModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiFocusableModule, {
    declarations: [TuiFocusableDirective],
    exports: [TuiFocusableDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-focusable.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-hovered.js





// eslint-disable-next-line @typescript-eslint/naming-convention

function movedOut({
  currentTarget,
  relatedTarget
}) {
  if (!relatedTarget) {
    return true;
  }
  (0,taiga_ui_cdk_classes/* tuiAssertIsHTMLElement */.HU)(currentTarget);
  (0,taiga_ui_cdk_classes/* tuiAssertIsHTMLElement */.HU)(relatedTarget);
  return !currentTarget.contains(relatedTarget);
}
let TuiHoveredDirective = /*#__PURE__*/(() => {
  let TuiHoveredDirective = class TuiHoveredDirective {
    constructor() {
      this.tuiHoveredChange = new core_js_.EventEmitter();
    }
    onHover() {
      this.tuiHoveredChange.emit(true);
    }
    onOut(_) {
      this.tuiHoveredChange.emit(false);
    }
  };
  TuiHoveredDirective.ɵfac = function TuiHoveredDirective_Factory(t) {
    return new (t || TuiHoveredDirective)();
  };
  TuiHoveredDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiHoveredDirective,
    selectors: [["", "tuiHoveredChange", ""]],
    hostBindings: function TuiHoveredDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("mouseenter", function TuiHoveredDirective_mouseenter_HostBindingHandler() {
          return ctx.onHover();
        })("mouseout.init", function TuiHoveredDirective_mouseout_init_HostBindingHandler($event) {
          return ctx.onOut($event);
        })("mouseout.silent", function TuiHoveredDirective_mouseout_silent_HostBindingHandler($event) {
          return ctx.onOut($event);
        });
      }
    },
    outputs: {
      tuiHoveredChange: "tuiHoveredChange"
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiHoveredDirective.prototype, "tuiHoveredChange", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('mouseenter')], TuiHoveredDirective.prototype, "onHover", null);
  (0,tslib_es6/* __decorate */.gn)([shouldCall(movedOut), (0,core_js_.HostListener)('mouseout.init', ['$event']), (0,core_js_.HostListener)('mouseout.silent', ['$event'])], TuiHoveredDirective.prototype, "onOut", null);
  return TuiHoveredDirective;
})();
let TuiHoveredModule = /*#__PURE__*/(() => {
  let TuiHoveredModule = class TuiHoveredModule {};
  TuiHoveredModule.ɵfac = function TuiHoveredModule_Factory(t) {
    return new (t || TuiHoveredModule)();
  };
  TuiHoveredModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiHoveredModule
  });
  TuiHoveredModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiHoveredModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiHoveredModule, {
    declarations: [TuiHoveredDirective],
    exports: [TuiHoveredDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-hovered.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-input-mode.js




/**
 * Abstraction over `inputMode` attribute
 */

let TuiInputModeDirective = /*#__PURE__*/(() => {
  let TuiInputModeDirective = class TuiInputModeDirective {
    constructor(pattern, isIOS) {
      this.pattern = pattern;
      this.isIOS = isIOS;
      this.mode = 'text';
    }
    get patternAttribute() {
      return this.mode === 'numeric' && this.isIOS && !this.pattern ? '[0-9]*' : this.pattern;
    }
  };
  TuiInputModeDirective.ɵfac = function TuiInputModeDirective_Factory(t) {
    return new (t || TuiInputModeDirective)(core_js_["ɵɵinjectAttribute"]('pattern'), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_IOS */.FA));
  };
  TuiInputModeDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiInputModeDirective,
    selectors: [["input", "tuiInputMode", ""]],
    hostVars: 3,
    hostBindings: function TuiInputModeDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("inputmode", ctx.mode)("x-inputmode", ctx.mode)("pattern", ctx.patternAttribute);
      }
    },
    inputs: {
      mode: ["tuiInputMode", "mode"]
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiInputMode'), (0,core_js_.HostBinding)('attr.inputmode'), (0,core_js_.HostBinding)('attr.x-inputmode')], TuiInputModeDirective.prototype, "mode", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('attr.pattern')], TuiInputModeDirective.prototype, "patternAttribute", null);
  TuiInputModeDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Attribute)('pattern')), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_IOS */.FA))], TuiInputModeDirective);
  return TuiInputModeDirective;
})();
let TuiInputModeModule = /*#__PURE__*/(() => {
  let TuiInputModeModule = class TuiInputModeModule {};
  TuiInputModeModule.ɵfac = function TuiInputModeModule_Factory(t) {
    return new (t || TuiInputModeModule)();
  };
  TuiInputModeModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiInputModeModule
  });
  TuiInputModeModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiInputModeModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiInputModeModule, {
    declarations: [TuiInputModeDirective],
    exports: [TuiInputModeDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-input-mode.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-autofilled.js





let TuiAutofilledStyleComponent = /*#__PURE__*/(() => {
  let TuiAutofilledStyleComponent = class TuiAutofilledStyleComponent {};
  TuiAutofilledStyleComponent.ɵfac = function TuiAutofilledStyleComponent_Factory(t) {
    return new (t || TuiAutofilledStyleComponent)();
  };
  TuiAutofilledStyleComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiAutofilledStyleComponent,
    selectors: [["ng-component"]],
    decls: 0,
    vars: 0,
    template: function TuiAutofilledStyleComponent_Template(rf, ctx) {},
    styles: [".tui-autofill input,input.tui-autofill{transition:box-shadow 10ms}"],
    encapsulation: 2
  });
  return TuiAutofilledStyleComponent;
})();
let TuiAutofilledDirective = /*#__PURE__*/(() => {
  let TuiAutofilledDirective = class TuiAutofilledDirective {
    constructor(directiveStyles) {
      this.autofilled = false;
      this.tuiAutofilledChange = new core_js_.EventEmitter();
      directiveStyles.addComponent(TuiAutofilledStyleComponent);
    }
    transitionStartHandler({
      propertyName,
      target
    }) {
      var _a;
      const matchedAutofill = propertyName.includes('box-shadow') && ((_a = target) === null || _a === void 0 ? void 0 : _a.matches('input'));
      if (matchedAutofill) {
        this.autofilled = !this.autofilled;
        this.tuiAutofilledChange.emit(this.autofilled);
      }
    }
  };
  TuiAutofilledDirective.ɵfac = function TuiAutofilledDirective_Factory(t) {
    return new (t || TuiAutofilledDirective)(core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDirectiveStylesService */.gH));
  };
  TuiAutofilledDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiAutofilledDirective,
    selectors: [["", "tuiAutofilledChange", ""]],
    hostAttrs: [1, "tui-autofill"],
    hostVars: 2,
    hostBindings: function TuiAutofilledDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("transitionstart", function TuiAutofilledDirective_transitionstart_HostBindingHandler($event) {
          return ctx.transitionStartHandler($event);
        });
      }
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("_autofilled", ctx.autofilled);
      }
    },
    outputs: {
      tuiAutofilledChange: "tuiAutofilledChange"
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._autofilled')], TuiAutofilledDirective.prototype, "autofilled", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiAutofilledDirective.prototype, "tuiAutofilledChange", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('transitionstart', ['$event'])], TuiAutofilledDirective.prototype, "transitionStartHandler", null);
  TuiAutofilledDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDirectiveStylesService */.gH))], TuiAutofilledDirective);
  return TuiAutofilledDirective;
})();
let TuiAutofilledModule = /*#__PURE__*/(() => {
  let TuiAutofilledModule = class TuiAutofilledModule {};
  TuiAutofilledModule.ɵfac = function TuiAutofilledModule_Factory(t) {
    return new (t || TuiAutofilledModule)();
  };
  TuiAutofilledModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiAutofilledModule
  });
  TuiAutofilledModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiAutofilledModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiAutofilledModule, {
    declarations: [TuiAutofilledDirective, TuiAutofilledStyleComponent],
    exports: [TuiAutofilledDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-autofilled.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/switchMapTo.js
var operators_switchMapTo = __webpack_require__(9499);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-directives-described-by.js









const DELAY = 1000;
const TUI_DESCRIBED_BY_SHOW = new core_js_.InjectionToken(`Accessible tooltip visibility stream`);
const TUI_DESCRIBED_BY_PROVIDERS = [taiga_ui_cdk_services/* TuiDestroyService */.a3, taiga_ui_cdk_services/* TuiFocusVisibleService */.ku, {
  provide: TUI_DESCRIBED_BY_SHOW,
  deps: [taiga_ui_cdk_services/* TuiFocusVisibleService */.ku, core_js_.ElementRef],
  useFactory: describedByFactory
}];
// eslint-disable-next-line @typescript-eslint/naming-convention
function describedByFactory(focusVisible$, {
  nativeElement
}) {
  return focusVisible$.pipe((0,operators_filter/* filter */.h)(Boolean), (0,operators_switchMapTo/* switchMapTo */.c)((0,observable_timer/* timer */.H)(DELAY).pipe((0,operators_mapTo/* mapTo */.h)(true), (0,operators_takeUntil/* takeUntil */.R)((0,observable_merge/* merge */.T)((0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, `keydown`), (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, `blur`))))), (0,operators_switchMapTo/* switchMapTo */.c)((0,observable_merge/* merge */.T)((0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, `keydown`).pipe((0,operators_filter/* filter */.h)(({
    key
  }) => key === `Escape`), (0,operators_take/* take */.q)(1), (0,taiga_ui_cdk_observables/* stopPropagation */.UW)(), (0,operators_mapTo/* mapTo */.h)(false), (0,operators_startWith/* startWith */.O)(true)), (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, `blur`).pipe((0,operators_mapTo/* mapTo */.h)(false))))).pipe((0,operators_distinctUntilChanged/* distinctUntilChanged */.x)());
}
const DESCRIBED_BY = '_described-by';
/**
 * A directive linking focusable elements and hints for accessibility
 */
let TuiDescribedByDirective = /*#__PURE__*/(() => {
  let TuiDescribedByDirective = class TuiDescribedByDirective {
    constructor(hintService, visibility$) {
      this.tuiDescribedBy = '';
      visibility$.subscribe(visible => {
        if (!this.tuiDescribedBy) {
          return;
        }
        if (visible) {
          hintService.showHintForId(this.tuiDescribedBy);
        } else {
          hintService.hideHintForId(this.tuiDescribedBy);
        }
      });
    }
    get computedDescribedBy() {
      return this.tuiDescribedBy ? this.tuiDescribedBy + DESCRIBED_BY : null;
    }
  };
  TuiDescribedByDirective.ɵfac = function TuiDescribedByDirective_Factory(t) {
    return new (t || TuiDescribedByDirective)(core_js_["ɵɵdirectiveInject"](taiga_ui_core_services/* TuiHintService */.BN), core_js_["ɵɵdirectiveInject"](TUI_DESCRIBED_BY_SHOW));
  };
  TuiDescribedByDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiDescribedByDirective,
    selectors: [["", "tuiDescribedBy", "", 5, "ng-container"]],
    hostVars: 1,
    hostBindings: function TuiDescribedByDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("aria-describedby", ctx.computedDescribedBy);
      }
    },
    inputs: {
      tuiDescribedBy: "tuiDescribedBy"
    },
    features: [core_js_["ɵɵProvidersFeature"](TUI_DESCRIBED_BY_PROVIDERS)]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDescribedByDirective.prototype, "tuiDescribedBy", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('attr.aria-describedby')], TuiDescribedByDirective.prototype, "computedDescribedBy", null);
  TuiDescribedByDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_services/* TuiHintService */.BN)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_DESCRIBED_BY_SHOW))], TuiDescribedByDirective);
  return TuiDescribedByDirective;
})();
let TuiDescribedByModule = /*#__PURE__*/(() => {
  let TuiDescribedByModule = class TuiDescribedByModule {};
  TuiDescribedByModule.ɵfac = function TuiDescribedByModule_Factory(t) {
    return new (t || TuiDescribedByModule)();
  };
  TuiDescribedByModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDescribedByModule
  });
  TuiDescribedByModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiDescribedByModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDescribedByModule, {
    declarations: [TuiDescribedByDirective],
    exports: [TuiDescribedByDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-directives-described-by.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subject.js
var internal_Subject = __webpack_require__(9765);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/combineLatest.js
var combineLatest = __webpack_require__(9112);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/of.js
var observable_of = __webpack_require__(5917);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/delay.js + 1 modules
var delay = __webpack_require__(1289);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-directives-hint.js









// TODO: 3.0 remove in ivy compilation



const TUI_TOOLTIP_ICON = `tuiIconTooltipLarge`;
/** Default values for hint options */
const TUI_HINT_DEFAULT_OPTIONS = Object.assign(Object.assign({}, TUI_ABSTRACT_HINT_DEFAULT_OPTIONS), {
  tuiHintShowDelay: 500,
  tuiHintHideDelay: 200,
  tooltipIcon: TUI_TOOLTIP_ICON
});
const TUI_HINT_OPTIONS = new core_js_.InjectionToken(`Default parameters for hint directive`, {
  factory: () => TUI_HINT_DEFAULT_OPTIONS
});
const tuiHintOptionsProvider = options => ({
  provide: TUI_HINT_OPTIONS,
  useValue: Object.assign(Object.assign({}, TUI_HINT_DEFAULT_OPTIONS), options)
});
const HINT_HOVERED_CLASS = '_hint_hovered';
let TuiHintDirective = /*#__PURE__*/(() => {
  let TuiHintDirective = class TuiHintDirective extends AbstractTuiHint {
    constructor(renderer, elementRef, hintService, destroy$, obscured$, hoveredService, activeZone, options) {
      super(elementRef, hintService, activeZone, options);
      this.renderer = renderer;
      this.options = options;
      this.tuiHintShowDelay = this.options.tuiHintShowDelay;
      this.tuiHintHideDelay = this.options.tuiHintHideDelay;
      this.tuiHintHost = null;
      this.componentHovered$ = new internal_Subject/* Subject */.xQ();
      // @bad TODO: Use private provider
      (0,combineLatest/* combineLatest */.aj)(hoveredService.createHovered$(elementRef.nativeElement), this.componentHovered$.pipe((0,operators_startWith/* startWith */.O)(false))).pipe((0,operators_map/* map */.U)(([directiveHovered, componentHovered]) => directiveHovered || componentHovered), (0,operators_switchMap/* switchMap */.w)(visible => {
        this.toggleClass(visible);
        return (0,observable_of.of)(visible).pipe((0,delay/* delay */.g)(visible ? this.tuiHintShowDelay : this.tuiHintHideDelay));
      }), (0,operators_switchMap/* switchMap */.w)(visible => visible && this.mode !== 'overflow' ? obscured$.pipe((0,operators_map/* map */.U)(obscured => !obscured), (0,operators_take/* take */.q)(2)) : (0,observable_of.of)(visible)), (0,operators_distinctUntilChanged/* distinctUntilChanged */.x)(), (0,operators_takeUntil/* takeUntil */.R)(destroy$)).subscribe(visible => {
        if (visible) {
          this.showTooltip();
        } else {
          this.hideTooltip();
        }
      });
      this.hintService.register(this);
    }
    // TODO: 3.0 Remove null
    set tuiHint(value) {
      if (!value) {
        this.hideTooltip();
        this.content = '';
        return;
      }
      this.content = value;
    }
    get id() {
      return this.tuiHintId ? this.tuiHintId + DESCRIBED_BY : null;
    }
    get host() {
      return this.tuiHintHost ? this.tuiHintHost : this.elementRef.nativeElement;
    }
    getElementClientRect() {
      return this.host.getBoundingClientRect();
    }
    ngOnDestroy() {
      this.hintService.unregister(this);
    }
    showTooltip() {
      if (this.content === '') {
        return;
      }
      this.toggleClass(true);
      this.hintService.add(this);
    }
    hideTooltip() {
      this.toggleClass(false);
      this.hintService.remove(this);
    }
    toggleClass(add) {
      if (add) {
        this.renderer.addClass(this.elementRef.nativeElement, HINT_HOVERED_CLASS);
      } else {
        this.renderer.removeClass(this.elementRef.nativeElement, HINT_HOVERED_CLASS);
      }
    }
  };
  TuiHintDirective.ɵfac = function TuiHintDirective_Factory(t) {
    return new (t || TuiHintDirective)(core_js_["ɵɵdirectiveInject"](core_js_.Renderer2), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_services/* TuiHintService */.BN), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiObscuredService */.AQ, 2), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiHoveredService */.gs), core_js_["ɵɵdirectiveInject"](TuiActiveZoneDirective, 8), core_js_["ɵɵdirectiveInject"](TUI_HINT_OPTIONS));
  };
  TuiHintDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiHintDirective,
    selectors: [["", "tuiHint", "", 5, "ng-container"]],
    inputs: {
      tuiHintShowDelay: "tuiHintShowDelay",
      tuiHintHideDelay: "tuiHintHideDelay",
      tuiHintHost: "tuiHintHost",
      tuiHint: "tuiHint",
      tuiHintId: "tuiHintId"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiObscuredService */.AQ, taiga_ui_cdk_services/* TuiParentsScrollService */.b0, taiga_ui_cdk_services/* TuiDestroyService */.a3]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiHintDirective.prototype, "tuiHintId", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHintDirective.prototype, "tuiHintShowDelay", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHintDirective.prototype, "tuiHintHideDelay", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHintDirective.prototype, "tuiHintHost", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiRequiredSetter */.NH)()], TuiHintDirective.prototype, "tuiHint", null);
  TuiHintDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.Renderer2)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_core_services/* TuiHintService */.BN)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiObscuredService */.AQ)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiHoveredService */.gs)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(TuiActiveZoneDirective)), (0,tslib_es6/* __param */.fM)(7, (0,core_js_.Inject)(TUI_HINT_OPTIONS))], TuiHintDirective);
  return TuiHintDirective;
})();
let TuiHintModule = /*#__PURE__*/(() => {
  let TuiHintModule = class TuiHintModule {};
  TuiHintModule.ɵfac = function TuiHintModule_Factory(t) {
    return new (t || TuiHintModule)();
  };
  TuiHintModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiHintModule
  });
  TuiHintModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiHintModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiHintModule, {
    declarations: [TuiHintDirective],
    exports: [TuiHintDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-directives-hint.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-directives-hint-controller.js






const TUI_HINT_CONTROLLER = new core_js_.InjectionToken(`Controls configuration of hints`, {
  factory: () => new TuiHintControllerDirective((0,core_js_.inject)(TUI_HINT_OPTIONS))
});
var TuiHintControllerDirective_1;
// TODO: v2.0 use in Charts
let TuiHintControllerDirective = TuiHintControllerDirective_1 = class TuiHintControllerDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor(options) {
    super();
    this.options = options;
    // TODO: 3.0 Remove null
    this.content = null;
    this.direction = this.options.direction;
    this.mode = this.options.mode;
    this.showDelay = this.options.tuiHintShowDelay;
    this.hideDelay = this.options.tuiHintHideDelay;
  }
};
TuiHintControllerDirective.ɵfac = function TuiHintControllerDirective_Factory(t) {
  return new (t || TuiHintControllerDirective)(core_js_["ɵɵdirectiveInject"](TUI_HINT_OPTIONS));
};
TuiHintControllerDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiHintControllerDirective,
  selectors: [["", "tuiHintContent", ""]],
  inputs: {
    content: ["tuiHintContent", "content"],
    direction: ["tuiHintDirection", "direction"],
    mode: ["tuiHintMode", "mode"],
    showDelay: ["tuiHintShowDelay", "showDelay"],
    hideDelay: ["tuiHintHideDelay", "hideDelay"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_HINT_CONTROLLER,
    useExisting: (0,core_js_.forwardRef)(() => TuiHintControllerDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
TuiHintControllerDirective.ctorParameters = () => [{
  type: undefined,
  decorators: [{
    type: core_js_.Inject,
    args: [TUI_HINT_OPTIONS]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiHintContent'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHintControllerDirective.prototype, "content", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiHintDirection'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHintControllerDirective.prototype, "direction", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiHintMode'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHintControllerDirective.prototype, "mode", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiHintShowDelay'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHintControllerDirective.prototype, "showDelay", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiHintHideDelay'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHintControllerDirective.prototype, "hideDelay", void 0);
TuiHintControllerDirective = TuiHintControllerDirective_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TUI_HINT_OPTIONS))], TuiHintControllerDirective);
let TuiHintControllerModule = /*#__PURE__*/(() => {
  let TuiHintControllerModule = class TuiHintControllerModule {};
  TuiHintControllerModule.ɵfac = function TuiHintControllerModule_Factory(t) {
    return new (t || TuiHintControllerModule)();
  };
  TuiHintControllerModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiHintControllerModule
  });
  TuiHintControllerModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiHintControllerModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiHintControllerModule, {
    declarations: [TuiHintControllerDirective],
    exports: [TuiHintControllerDirective]
  });
})();
const TUI_HINT_WATCHED_CONTROLLER = new core_js_.InjectionToken(`watched hint controller`);
// TODO: 3.0 remove in ivy compilation
const HINT_CONTROLLER_FACTORY = taiga_ui_core_providers/* watchedControllerFactory */.my;
const HINT_CONTROLLER_PROVIDER = [taiga_ui_cdk_services/* TuiDestroyService */.a3, {
  provide: TUI_HINT_WATCHED_CONTROLLER,
  deps: [TUI_HINT_CONTROLLER, core_js_.ChangeDetectorRef, taiga_ui_cdk_services/* TuiDestroyService */.a3],
  useFactory: HINT_CONTROLLER_FACTORY
}];

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-directives-hint-controller.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-utils-miscellaneous.js
var taiga_ui_core_utils_miscellaneous = __webpack_require__(6640);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/BehaviorSubject.js
var internal_BehaviorSubject = __webpack_require__(6215);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-tooltip.js

















function TuiTooltipComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 1);
  }
  if (rf & 2) {
    const icon_r1 = ctx.$implicit;
    core_js_["ɵɵproperty"]("src", icon_r1);
  }
}
let TuiTooltipComponent = /*#__PURE__*/(() => {
  let TuiTooltipComponent = class TuiTooltipComponent {
    constructor(destroy$, mode$, isMobile, options) {
      this.isMobile = isMobile;
      this.options = options;
      this.globalMode = null;
      this.content = '';
      this.mode = this.options.mode;
      this.direction = this.options.direction;
      this.showDelay = this.options.tuiHintShowDelay;
      this.hideDelay = this.options.tuiHintHideDelay;
      this.describeId = '';
      mode$.pipe((0,operators_takeUntil/* takeUntil */.R)(destroy$)).subscribe(mode => {
        this.globalMode = mode;
      });
    }
    // TODO: Simplify
    get computedMode() {
      return this.mode || (this.globalMode === 'onDark' ? 'onDark' : null);
    }
    stopOnMobile(event) {
      if (this.isMobile) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
    get icon() {
      return this.options.tooltipIcon;
    }
  };
  TuiTooltipComponent.ɵfac = function TuiTooltipComponent_Factory(t) {
    return new (t || TuiTooltipComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_MODE */.Au), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL), core_js_["ɵɵdirectiveInject"](TUI_HINT_OPTIONS));
  };
  TuiTooltipComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiTooltipComponent,
    selectors: [["tui-tooltip"]],
    hostVars: 1,
    hostBindings: function TuiTooltipComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("mousedown", function TuiTooltipComponent_mousedown_HostBindingHandler($event) {
          return ctx.stopOnMobile($event);
        })("click", function TuiTooltipComponent_click_HostBindingHandler($event) {
          return ctx.stopOnMobile($event);
        });
      }
      if (rf & 2) {
        core_js_["ɵɵattribute"]("data-mode", ctx.computedMode);
      }
    },
    inputs: {
      content: "content",
      mode: "mode",
      direction: "direction",
      showDelay: "showDelay",
      hideDelay: "hideDelay",
      describeId: "describeId"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3, taiga_ui_core_providers/* MODE_PROVIDER */.CV])],
    decls: 2,
    vars: 7,
    consts: [["polymorpheus-outlet", "", "automation-id", "tui-tooltip__icon", 1, "t-tooltip-icon", 3, "content", "tuiHintId", "tuiHint", "tuiHintDirection", "tuiHintShowDelay", "tuiHintHideDelay", "tuiHintMode"], [3, "src"]],
    template: function TuiTooltipComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵelementStart"](0, "span", 0);
        core_js_["ɵɵtemplate"](1, TuiTooltipComponent_ng_template_1_Template, 1, 1, "ng-template");
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("content", ctx.icon)("tuiHintId", ctx.describeId)("tuiHint", ctx.content)("tuiHintDirection", ctx.direction)("tuiHintShowDelay", ctx.showDelay)("tuiHintHideDelay", ctx.hideDelay)("tuiHintMode", ctx.computedMode);
      }
    },
    directives: [tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, TuiHintDirective, taiga_ui_core_components_svg/* TuiSvgComponent */.P],
    styles: ["[_nghost-%COMP%]{transition-property:color;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;position:relative;display:inline-block;width:1.5rem;height:1.5rem;vertical-align:middle;font-size:0;line-height:0;cursor:pointer;color:var(--tui-text-03)}[_nghost-%COMP%]:hover{color:var(--tui-text-02)}[data-mode=onDark][_nghost-%COMP%]{color:var(--tui-text-01-night)}[data-mode=onLight][_nghost-%COMP%]{color:var(--tui-text-01)}[data-mode=error][_nghost-%COMP%]{color:var(--tui-error-fill)}.t-tooltip-icon[_ngcontent-%COMP%]{transition-property:opacity,color;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;display:inline-block;width:100%;height:100%}[_nghost-%COMP%]:not([data-mode])   .t-tooltip-icon._hint_hovered[_ngcontent-%COMP%]{color:var(--tui-text-02)}[data-mode=onDark][_nghost-%COMP%]   .t-tooltip-icon[_ngcontent-%COMP%], [data-mode=onLight][_nghost-%COMP%]   .t-tooltip-icon[_ngcontent-%COMP%]{opacity:var(--tui-disabled-opacity)}[data-mode=onDark][_nghost-%COMP%]   .t-tooltip-icon._hint_hovered[_ngcontent-%COMP%], [data-mode=onDark][_nghost-%COMP%]   .t-tooltip-icon[_ngcontent-%COMP%]:hover, [data-mode=onLight][_nghost-%COMP%]   .t-tooltip-icon._hint_hovered[_ngcontent-%COMP%], [data-mode=onLight][_nghost-%COMP%]   .t-tooltip-icon[_ngcontent-%COMP%]:hover{opacity:1}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTooltipComponent.prototype, "content", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTooltipComponent.prototype, "mode", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTooltipComponent.prototype, "direction", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTooltipComponent.prototype, "showDelay", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTooltipComponent.prototype, "hideDelay", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTooltipComponent.prototype, "describeId", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('attr.data-mode')], TuiTooltipComponent.prototype, "computedMode", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('mousedown', ['$event']), (0,core_js_.HostListener)('click', ['$event'])], TuiTooltipComponent.prototype, "stopOnMobile", null);
  TuiTooltipComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_MODE */.Au)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TUI_HINT_OPTIONS))], TuiTooltipComponent);
  return TuiTooltipComponent;
})();
let TuiTooltipModule = /*#__PURE__*/(() => {
  let TuiTooltipModule = class TuiTooltipModule {};
  TuiTooltipModule.ɵfac = function TuiTooltipModule_Factory(t) {
    return new (t || TuiTooltipModule)();
  };
  TuiTooltipModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiTooltipModule
  });
  TuiTooltipModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiHintModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq]]
  });
  return TuiTooltipModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiTooltipModule, {
    declarations: function () {
      return [TuiTooltipComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiHintModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq];
    },
    exports: function () {
      return [TuiTooltipComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-tooltip.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-directives-mask-accessor.js





// eslint-disable-next-line @typescript-eslint/naming-convention

function fallbackAccessorFactory(accessor, fallback) {
  return accessor ? accessor[0] : fallback;
}
let TuiMaskAccessorDirective = /*#__PURE__*/(() => {
  let TuiMaskAccessorDirective = class TuiMaskAccessorDirective {};
  TuiMaskAccessorDirective.ɵfac = function TuiMaskAccessorDirective_Factory(t) {
    return new (t || TuiMaskAccessorDirective)();
  };
  TuiMaskAccessorDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiMaskAccessorDirective,
    selectors: [["input", "tuiMaskAccessor", ""]],
    features: [core_js_["ɵɵProvidersFeature"]([{
      provide: fesm2015_forms.NG_VALUE_ACCESSOR,
      deps: [[new core_js_.Optional(), taiga_ui_core_tokens/* TUI_VALUE_ACCESSOR */.sE], fesm2015_forms.DefaultValueAccessor],
      useFactory: fallbackAccessorFactory,
      multi: true
    }])]
  });

  /**
   * @internal
   */
  return TuiMaskAccessorDirective;
})();
let TuiMaskAccessorModule = /*#__PURE__*/(() => {
  let TuiMaskAccessorModule = class TuiMaskAccessorModule {};
  TuiMaskAccessorModule.ɵfac = function TuiMaskAccessorModule_Factory(t) {
    return new (t || TuiMaskAccessorModule)();
  };
  TuiMaskAccessorModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiMaskAccessorModule
  });
  TuiMaskAccessorModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiMaskAccessorModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiMaskAccessorModule, {
    declarations: [TuiMaskAccessorDirective],
    exports: [TuiMaskAccessorDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-directives-mask-accessor.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-directives-wrapper.js
var taiga_ui_core_directives_wrapper = __webpack_require__(1489);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-primitive-textfield.js


































const taiga_ui_core_components_primitive_textfield_c0 = ["focusableElement"];
function TuiPrimitiveTextfieldComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0);
  }
}
function TuiPrimitiveTextfieldComponent_div_7_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 16);
    core_js_["ɵɵprojection"](1, 1);
    core_js_["ɵɵelementEnd"]();
  }
}
function TuiPrimitiveTextfieldComponent_div_9_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 18);
  }
  if (rf & 2) {
    const iconSrc_r11 = ctx.$implicit;
    core_js_["ɵɵproperty"]("src", iconSrc_r11);
  }
}
const taiga_ui_core_components_primitive_textfield_c1 = function (a0) {
  return {
    $implicit: a0
  };
};
function TuiPrimitiveTextfieldComponent_div_9_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 17);
    core_js_["ɵɵtemplate"](1, TuiPrimitiveTextfieldComponent_div_9_ng_template_1_Template, 1, 1, "ng-template");
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r3 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("content", ctx_r3.iconContent)("context", core_js_["ɵɵpureFunction1"](2, taiga_ui_core_components_primitive_textfield_c1, ctx_r3.size));
  }
}
function TuiPrimitiveTextfieldComponent_label_11_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "label", 19);
    core_js_["ɵɵprojection"](1, 2);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r4 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵclassProp"]("t-placeholder_raised", ctx_r4.placeholderRaised);
    core_js_["ɵɵproperty"]("for", ctx_r4.computedId);
  }
}
function TuiPrimitiveTextfieldComponent_div_16_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 21);
  }
  if (rf & 2) {
    const iconSrc_r13 = ctx.$implicit;
    core_js_["ɵɵproperty"]("src", iconSrc_r13);
  }
}
function TuiPrimitiveTextfieldComponent_div_16_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 20);
    core_js_["ɵɵtemplate"](1, TuiPrimitiveTextfieldComponent_div_16_ng_template_1_Template, 1, 1, "ng-template");
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r6 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("content", ctx_r6.controller.customContent);
  }
}
function TuiPrimitiveTextfieldComponent_span_17_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 18);
  }
  if (rf & 2) {
    const icon_r15 = ctx.$implicit;
    core_js_["ɵɵproperty"]("src", icon_r15);
  }
}
function TuiPrimitiveTextfieldComponent_span_17_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "span", 22);
    core_js_["ɵɵlistener"]("click.stop", function TuiPrimitiveTextfieldComponent_span_17_Template_span_click_stop_0_listener() {
      core_js_["ɵɵrestoreView"](_r17);
      const ctx_r16 = core_js_["ɵɵnextContext"]();
      return ctx_r16.clear();
    });
    core_js_["ɵɵtemplate"](1, TuiPrimitiveTextfieldComponent_span_17_ng_template_1_Template, 1, 1, "ng-template");
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r7 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("content", ctx_r7.iconCleaner);
  }
}
function TuiPrimitiveTextfieldComponent_tui_tooltip_18_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-tooltip", 23);
  }
  if (rf & 2) {
    const ctx_r8 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("describeId", ctx_r8.computedId)("content", ctx_r8.hintController.content || "")("direction", ctx_r8.hintController.direction)("mode", ctx_r8.hintController.mode)("showDelay", ctx_r8.hintController.showDelay)("hideDelay", ctx_r8.hintController.hideDelay);
  }
}
function TuiPrimitiveTextfieldComponent_div_19_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 18);
  }
  if (rf & 2) {
    const iconSrc_r19 = ctx.$implicit;
    core_js_["ɵɵproperty"]("src", iconSrc_r19);
  }
}
function TuiPrimitiveTextfieldComponent_div_19_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 24);
    core_js_["ɵɵtemplate"](1, TuiPrimitiveTextfieldComponent_div_19_ng_template_1_Template, 1, 1, "ng-template");
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r9 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("content", ctx_r9.iconContent)("context", core_js_["ɵɵpureFunction1"](2, taiga_ui_core_components_primitive_textfield_c1, ctx_r9.size));
  }
}
const taiga_ui_core_components_primitive_textfield_c2 = [[["input"]], [["", "polymorpheus-outlet", ""]], "*"];
const _c3 = ["input", "[polymorpheus-outlet]", "*"];
const _c4 = ["tuiTextfield", ""];
const _c5 = ["pre"];
const TUI_PRIMITIVE_TEXTFIELD_PROVIDERS = [{
  provide: taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ,
  useExisting: (0,core_js_.forwardRef)(() => TuiPrimitiveTextfieldComponent)
}, TEXTFIELD_CONTROLLER_PROVIDER, HINT_CONTROLLER_PROVIDER, taiga_ui_core_providers/* MODE_PROVIDER */.CV];

// TODO: 3.0 remove in ivy compilation
const TUI_PRIMITIVE_TEXTFIELD_ICON_CLEANER = `tuiIconCloseLarge`;
/** Default values for primitive textfield options */
const TUI_PRIMITIVE_TEXTFIELD_DEFAULT_OPTIONS = {
  iconAlign: `right`,
  iconCleaner: TUI_PRIMITIVE_TEXTFIELD_ICON_CLEANER
};
const TUI_PRIMITIVE_TEXTFIELD_OPTIONS = new core_js_.InjectionToken(`Default parameters for primitive textfield component`, {
  factory: () => TUI_PRIMITIVE_TEXTFIELD_DEFAULT_OPTIONS
});
const tuiPrimitiveTextfieldOptionsProvider = options => ({
  provide: TUI_PRIMITIVE_TEXTFIELD_OPTIONS,
  useValue: Object.assign(Object.assign({}, TUI_PRIMITIVE_TEXTFIELD_DEFAULT_OPTIONS), options)
});
const ICON_PADDING = 1.75;
const ICON_PADDING_S = 1.5;
let TuiPrimitiveTextfieldComponent = /*#__PURE__*/(() => {
  let TuiPrimitiveTextfieldComponent = class TuiPrimitiveTextfieldComponent extends taiga_ui_cdk_abstract/* AbstractTuiInteractive */.Xn {
    constructor(mode$, appearance, controller, hintController, options, elementRef) {
      super();
      this.mode$ = mode$;
      this.appearance = appearance;
      this.controller = controller;
      this.hintController = hintController;
      this.options = options;
      this.elementRef = elementRef;
      this.editable = true;
      this.filler = '';
      this.iconAlign = this.options.iconAlign;
      // TODO: 3.0 Remove null
      this.iconContent = null;
      this.iconCleaner = this.options.iconCleaner;
      this.readOnly = false;
      this.invalid = false;
      this.disabled = false;
      this.prefix = '';
      this.postfix = '';
      this.value = '';
      this.valueChange = new core_js_.EventEmitter();
      /**
       * @deprecated TODO: 3.0 remove
       */
      this.autofilledChange = new core_js_.EventEmitter();
      this.autofilled = false;
    }
    get nativeFocusableElement() {
      if (this.computedDisabled || !this.focusableElement) {
        return null;
      }
      // TODO: 3.0 Refactor this after we drop built-in input element
      return this.focusableElement.nativeElement.previousElementSibling || this.focusableElement.nativeElement;
    }
    get focused() {
      return (0,taiga_ui_cdk_utils_focus/* isNativeFocusedIn */.KF)(this.elementRef.nativeElement);
    }
    get size() {
      return this.controller.size;
    }
    get computedInvalid() {
      return !this.readOnly && !this.disabled && this.invalid;
    }
    get inputHidden() {
      var _a;
      return !!((_a = this.content) === null || _a === void 0 ? void 0 : _a.length);
    }
    get hasValue() {
      return !!this.value;
    }
    get hasCleaner() {
      return this.controller.cleaner && this.hasValue && !this.disabled && !this.readOnly;
    }
    get hasTooltip() {
      var _a;
      return !!((_a = this.hintController) === null || _a === void 0 ? void 0 : _a.content) && !this.disabled;
    }
    get hasCustomContent() {
      return !!this.controller.customContent;
    }
    get showOnlyPlaceholder() {
      return this.focused && this.placeholderVisible && (this.size === 's' || this.size === 'm' && !this.placeholderRaisable);
    }
    get placeholderVisible() {
      var _a;
      const hasDecor = this.controller.exampleText || this.prefix || this.postfix || ((_a = this.nativeFocusableElement) === null || _a === void 0 ? void 0 : _a.placeholder);
      const showDecor = hasDecor && !this.readOnly && this.computedFocused;
      return !this.hasValue && !showDecor;
    }
    get hasPlaceholder() {
      return !this.showOnlyPlaceholder && (this.placeholderRaisable || this.placeholderVisible);
    }
    get placeholderRaised() {
      return this.placeholderRaisable && (this.computedFocused && !this.readOnly || this.hasValue || this.autofilled);
    }
    get borderStart() {
      return this.iconAlignLeft ? this.iconPaddingLeft : 0;
    }
    get borderEnd() {
      return (0,taiga_ui_core_utils_miscellaneous/* getBorder */.ub)(this.iconAlignRight, this.hasCleaner, this.hasTooltip, this.hasCustomContent);
    }
    get iconAlignLeft() {
      return this.hasIcon && this.iconAlign === 'left';
    }
    get iconAlignRight() {
      return this.hasIcon && this.iconAlign === 'right';
    }
    // Safari expiration date autofill workaround
    get name() {
      return this.controller.autocomplete === "cc-exp" /* CcExp */ ? 'ccexpiryyear' : null;
    }
    get computedId() {
      var _a;
      return ((_a = this.nativeFocusableElement) === null || _a === void 0 ? void 0 : _a.id) || '';
    }
    onFocused(focused) {
      this.updateFocused(focused);
    }
    getIndent$(element) {
      return (0,fromEvent/* fromEvent */.R)(element, 'scroll').pipe((0,operators_map/* map */.U)(() => -1 * element.scrollLeft));
    }
    clear() {
      if (this.nativeFocusableElement) {
        this.nativeFocusableElement.value = '';
      }
      this.updateValue('');
    }
    onMouseDown(event) {
      const {
        nativeFocusableElement
      } = this;
      if (!nativeFocusableElement || event.target === nativeFocusableElement) {
        return;
      }
      event.preventDefault();
      (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(nativeFocusableElement);
    }
    onModelChange(value) {
      this.updateValue(value);
    }
    onHovered(hovered) {
      this.updateHovered(hovered);
    }
    onAutofilled(autofilled) {
      this.updateAutofilled(autofilled);
    }
    get iconPaddingLeft() {
      return this.size === 's' ? ICON_PADDING_S : ICON_PADDING;
    }
    get placeholderRaisable() {
      return this.size !== 's' && !this.controller.labelOutside;
    }
    get hasIcon() {
      return !!this.iconContent;
    }
    updateAutofilled(autofilled) {
      if (this.autofilled === autofilled) {
        return;
      }
      this.autofilled = autofilled;
      this.autofilledChange.emit(autofilled);
    }
    updateValue(value) {
      this.value = value;
      this.valueChange.emit(value);
    }
  };
  TuiPrimitiveTextfieldComponent.ɵfac = function TuiPrimitiveTextfieldComponent_Factory(t) {
    return new (t || TuiPrimitiveTextfieldComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_MODE */.Au), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_TEXTFIELD_APPEARANCE */.jt), core_js_["ɵɵdirectiveInject"](TUI_TEXTFIELD_WATCHED_CONTROLLER), core_js_["ɵɵdirectiveInject"](TUI_HINT_WATCHED_CONTROLLER), core_js_["ɵɵdirectiveInject"](TUI_PRIMITIVE_TEXTFIELD_OPTIONS), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef));
  };
  TuiPrimitiveTextfieldComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiPrimitiveTextfieldComponent,
    selectors: [["tui-primitive-textfield"]],
    contentQueries: function TuiPrimitiveTextfieldComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        core_js_["ɵɵcontentQuery"](dirIndex, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, 4);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.content = _t);
      }
    },
    viewQuery: function TuiPrimitiveTextfieldComponent_Query(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵviewQuery"](taiga_ui_core_components_primitive_textfield_c0, 5);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.focusableElement = _t.first);
      }
    },
    hostVars: 15,
    hostBindings: function TuiPrimitiveTextfieldComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("$.data-mode.attr", function TuiPrimitiveTextfieldComponent___data_mode_attr_HostBindingHandler() {
          return ctx.mode$;
        })("focusin", function TuiPrimitiveTextfieldComponent_focusin_HostBindingHandler() {
          return ctx.onFocused(true);
        })("focusout", function TuiPrimitiveTextfieldComponent_focusout_HostBindingHandler() {
          return ctx.onFocused(false);
        });
      }
      if (rf & 2) {
        core_js_["ɵɵattribute"]("data-size", ctx.size);
        core_js_["ɵɵstyleProp"]("--border-start", ctx.borderStart, "rem")("--border-end", ctx.borderEnd, "rem");
        core_js_["ɵɵclassProp"]("_autofilled", ctx.autofilled)("_label-outside", ctx.controller.labelOutside)("_readonly", ctx.readOnly)("_invalid", ctx.computedInvalid)("_hidden", ctx.inputHidden);
      }
    },
    inputs: {
      editable: "editable",
      filler: "filler",
      iconAlign: "iconAlign",
      iconContent: "iconContent",
      iconCleaner: "iconCleaner",
      readOnly: "readOnly",
      invalid: "invalid",
      disabled: "disabled",
      prefix: "prefix",
      postfix: "postfix",
      value: "value"
    },
    outputs: {
      valueChange: "valueChange",
      autofilledChange: "autofilledChange"
    },
    features: [core_js_["ɵɵProvidersFeature"](TUI_PRIMITIVE_TEXTFIELD_PROVIDERS), core_js_["ɵɵInheritDefinitionFeature"]],
    ngContentSelectors: _c3,
    decls: 20,
    vars: 40,
    consts: [[4, "ngIf"], ["automation-id", "tui-primitive-textfield__wrapper", 3, "appearance", "readOnly", "disabled", "focused", "hovered", "pressed", "invalid", "mousedown", "click.prevent.silent", "tuiHoveredChange", "tuiAutofilledChange"], ["tuiMaskAccessor", "", "automation-id", "tui-primitive-textfield__native-input", 1, "t-input", 3, "autocomplete", "type", "id", "readOnly", "tuiInputMode", "tuiFocusable", "tuiDescribedBy", "ngModel", "ngModelChange"], ["focusableElement", ""], ["automation-id", "tui-primitive-textfield__value", "class", "t-input t-input_template", 4, "ngIf"], [1, "t-content"], ["polymorpheus-outlet", "", "class", "t-icon t-icon_left", 3, "content", "context", 4, "ngIf"], [1, "t-wrapper"], ["automation-id", "tui-primitive-textfield__placeholder", "class", "t-placeholder", 3, "t-placeholder_raised", "for", 4, "ngIf"], [1, "t-wrapper-value-decoration"], ["automation-id", "tui-primitive-textfield__value-decoration", "aria-hidden", "true", 1, "t-value-decoration"], ["decor", ""], ["polymorpheus-outlet", "", "automation-id", "tui-primitive-textfield__custom-content", "class", "t-custom-content", 3, "content", 4, "ngIf"], ["polymorpheus-outlet", "", "automation-id", "tui-primitive-textfield__cleaner", "class", "t-cleaner", 3, "content", "click.stop", 4, "ngIf"], ["automation-id", "tui-primitive-textfield__tooltip", 3, "describeId", "content", "direction", "mode", "showDelay", "hideDelay", 4, "ngIf"], ["polymorpheus-outlet", "", "class", "t-icon", 3, "content", "context", 4, "ngIf"], ["automation-id", "tui-primitive-textfield__value", 1, "t-input", "t-input_template"], ["polymorpheus-outlet", "", 1, "t-icon", "t-icon_left", 3, "content", "context"], [3, "src"], ["automation-id", "tui-primitive-textfield__placeholder", 1, "t-placeholder", 3, "for"], ["polymorpheus-outlet", "", "automation-id", "tui-primitive-textfield__custom-content", 1, "t-custom-content", 3, "content"], [1, "t-custom-icon", 3, "src"], ["polymorpheus-outlet", "", "automation-id", "tui-primitive-textfield__cleaner", 1, "t-cleaner", 3, "content", "click.stop"], ["automation-id", "tui-primitive-textfield__tooltip", 3, "describeId", "content", "direction", "mode", "showDelay", "hideDelay"], ["polymorpheus-outlet", "", 1, "t-icon", 3, "content", "context"]],
    template: function TuiPrimitiveTextfieldComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"](taiga_ui_core_components_primitive_textfield_c2);
        core_js_["ɵɵtemplate"](0, TuiPrimitiveTextfieldComponent_ng_container_0_Template, 1, 0, "ng-container", 0);
        core_js_["ɵɵpipe"](1, "async");
        core_js_["ɵɵelementStart"](2, "tui-wrapper", 1);
        core_js_["ɵɵlistener"]("mousedown", function TuiPrimitiveTextfieldComponent_Template_tui_wrapper_mousedown_2_listener($event) {
          return ctx.onMouseDown($event);
        })("click.prevent.silent", function TuiPrimitiveTextfieldComponent_Template_tui_wrapper_click_prevent_silent_2_listener() {
          return 0;
        })("tuiHoveredChange", function TuiPrimitiveTextfieldComponent_Template_tui_wrapper_tuiHoveredChange_2_listener($event) {
          return ctx.onHovered($event);
        })("tuiAutofilledChange", function TuiPrimitiveTextfieldComponent_Template_tui_wrapper_tuiAutofilledChange_2_listener($event) {
          return ctx.onAutofilled($event);
        });
        core_js_["ɵɵpipe"](3, "async");
        core_js_["ɵɵprojection"](4);
        core_js_["ɵɵelementStart"](5, "input", 2, 3);
        core_js_["ɵɵlistener"]("ngModelChange", function TuiPrimitiveTextfieldComponent_Template_input_ngModelChange_5_listener($event) {
          return ctx.onModelChange($event);
        });
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](7, TuiPrimitiveTextfieldComponent_div_7_Template, 2, 0, "div", 4);
        core_js_["ɵɵelementStart"](8, "div", 5);
        core_js_["ɵɵtemplate"](9, TuiPrimitiveTextfieldComponent_div_9_Template, 2, 4, "div", 6);
        core_js_["ɵɵelementStart"](10, "div", 7);
        core_js_["ɵɵtemplate"](11, TuiPrimitiveTextfieldComponent_label_11_Template, 2, 3, "label", 8);
        core_js_["ɵɵelementStart"](12, "div", 9);
        core_js_["ɵɵelementStart"](13, "tui-value-decoration", 10, 11);
        core_js_["ɵɵpipe"](15, "async");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](16, TuiPrimitiveTextfieldComponent_div_16_Template, 2, 1, "div", 12);
        core_js_["ɵɵtemplate"](17, TuiPrimitiveTextfieldComponent_span_17_Template, 2, 1, "span", 13);
        core_js_["ɵɵtemplate"](18, TuiPrimitiveTextfieldComponent_tui_tooltip_18_Template, 1, 6, "tui-tooltip", 14);
        core_js_["ɵɵtemplate"](19, TuiPrimitiveTextfieldComponent_div_19_Template, 2, 4, "div", 15);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        const _r1 = core_js_["ɵɵreference"](6);
        const _r5 = core_js_["ɵɵreference"](14);
        core_js_["ɵɵproperty"]("ngIf", core_js_["ɵɵpipeBind1"](1, 34, ctx.content == null ? null : ctx.content.changes));
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵstyleProp"]("--text-indent", core_js_["ɵɵpipeBind1"](3, 36, _r5.pre$), "px");
        core_js_["ɵɵproperty"]("appearance", ctx.appearance)("readOnly", ctx.readOnly)("disabled", ctx.disabled)("focused", ctx.computedFocused)("hovered", ctx.computedHovered)("pressed", ctx.computedPressed)("invalid", ctx.computedInvalid);
        core_js_["ɵɵadvance"](3);
        core_js_["ɵɵproperty"]("autocomplete", ctx.controller.autocomplete)("type", ctx.controller.type)("id", ctx.id)("readOnly", ctx.readOnly || !ctx.editable)("tuiInputMode", ctx.controller.inputMode)("tuiFocusable", ctx.computedFocusable)("tuiDescribedBy", ctx.id)("ngModel", ctx.value);
        core_js_["ɵɵattribute"]("disabled", ctx.computedDisabled || null)("maxLength", ctx.controller.maxLength)("name", ctx.name)("aria-placeholder", ctx.controller.exampleText)("aria-invalid", ctx.computedInvalid);
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵproperty"]("ngIf", ctx.inputHidden);
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵproperty"]("ngIf", ctx.iconAlignLeft);
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵproperty"]("ngIf", ctx.hasPlaceholder);
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵstyleProp"]("text-indent", core_js_["ɵɵpipeBind1"](15, 38, ctx.getIndent$(_r1)), "px");
        core_js_["ɵɵclassProp"]("t-has-value", ctx.value);
        core_js_["ɵɵadvance"](3);
        core_js_["ɵɵproperty"]("ngIf", ctx.hasCustomContent);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.hasCleaner);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.hasTooltip);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.iconAlignRight);
      }
    },
    directives: function () {
      return [common_js_.NgIf, taiga_ui_core_directives_wrapper/* TuiWrapperDirective */.o, TuiHoveredDirective, TuiAutofilledDirective, TuiMaskAccessorDirective, TuiInputModeDirective, fesm2015_forms.DefaultValueAccessor, TuiFocusableDirective, TuiDescribedByDirective, fesm2015_forms.NgControlStatus, fesm2015_forms.NgModel, TuiValueDecorationComponent, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, taiga_ui_core_components_svg/* TuiSvgComponent */.P, TuiTooltipComponent];
    },
    pipes: function () {
      return [common_js_.AsyncPipe];
    },
    styles: ["[_nghost-%COMP%]{font:var(--tui-font-text-s);color:var(--tui-text-01);position:relative;display:block;border-radius:var(--tui-radius-m);text-align:left}[data-size='s'][_nghost-%COMP%]{height:var(--tui-height-s);min-height:var(--tui-height-s);max-height:var(--tui-height-s)}[data-size='m'][_nghost-%COMP%]{height:var(--tui-height-m);min-height:var(--tui-height-m);max-height:var(--tui-height-m)}[data-size='l'][_nghost-%COMP%]{height:var(--tui-height-l);min-height:var(--tui-height-l);max-height:var(--tui-height-l);font:var(--tui-font-text-m);line-height:1.25rem}.t-input[_ngcontent-%COMP%]{font:var(--tui-font-text-s);color:var(--tui-text-01);padding:0;margin:0;border:0;border-radius:inherit;background:0 0;font-size:inherit;line-height:inherit;font-weight:inherit;color:inherit;caret-color:currentColor;outline:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;word-break:keep-all;-webkit-text-fill-color:currentColor;position:absolute;top:0;left:0;width:100%;height:100%;padding:0 var(--tui-padding-m);border:solid transparent;border-width:0 var(--border-end,0) 0 var(--border-start,0);border-inline-start-width:var(--border-start,0);border-inline-end-width:var(--border-end,0);text-indent:var(--text-indent);text-align:inherit;box-sizing:border-box;white-space:nowrap;overflow:hidden;text-transform:inherit;resize:none}.t-input[_ngcontent-%COMP%]:-webkit-autofill, .t-input[_ngcontent-%COMP%]:-webkit-autofill:focus, .t-input[_ngcontent-%COMP%]:-webkit-autofill:hover{caret-color:var(--tui-base-09);border-radius:inherit;color:inherit!important;background-color:transparent!important;-webkit-text-fill-color:var(--tui-text-01)!important;border-color:var(--tui-autofill);-webkit-box-shadow:0 0 0 100rem var(--tui-autofill) inset!important}.t-input   tui-primitive-textfield[data-mode=onDark][_nghost-%COMP%]:-webkit-autofill, tui-primitive-textfield[data-mode=onDark]   [_nghost-%COMP%]:-webkit-autofill, .t-input   tui-primitive-textfield[data-mode=onDark][_nghost-%COMP%]:-webkit-autofill:focus, tui-primitive-textfield[data-mode=onDark]   [_nghost-%COMP%]:-webkit-autofill:focus, .t-input   tui-primitive-textfield[data-mode=onDark][_nghost-%COMP%]:-webkit-autofill:hover, tui-primitive-textfield[data-mode=onDark]   [_nghost-%COMP%]:-webkit-autofill:hover, .t-input   tui-text-area[data-mode=onDark][_nghost-%COMP%]:-webkit-autofill, tui-text-area[data-mode=onDark]   [_nghost-%COMP%]:-webkit-autofill, .t-input   tui-text-area[data-mode=onDark][_nghost-%COMP%]:-webkit-autofill:focus, tui-text-area[data-mode=onDark]   [_nghost-%COMP%]:-webkit-autofill:focus, .t-input   tui-text-area[data-mode=onDark][_nghost-%COMP%]:-webkit-autofill:hover, tui-text-area[data-mode=onDark]   [_nghost-%COMP%]:-webkit-autofill:hover, [data-mode=onDark][_nghost-%COMP%]   .t-input[_ngcontent-%COMP%]:-webkit-autofill, [data-mode=onDark][_nghost-%COMP%]   .t-input[_ngcontent-%COMP%]:-webkit-autofill:focus, [data-mode=onDark][_nghost-%COMP%]   .t-input[_ngcontent-%COMP%]:-webkit-autofill:hover{caret-color:var(--tui-base-09);border-radius:inherit;color:inherit!important;background-color:transparent!important;-webkit-text-fill-color:var(--tui-text-01-night)!important;border-color:var(--tui-autofill-night);-webkit-box-shadow:0 0 0 100rem var(--tui-autofill-night) inset!important}.t-input   tui-primitive-textfield[data-size='s'][_nghost-%COMP%]:not(tui-primitive-textfield), tui-primitive-textfield[data-size='s']   [_nghost-%COMP%]:not(tui-primitive-textfield), .t-input   tui-text-area[data-size='s'][_nghost-%COMP%]:not(tui-text-area), tui-text-area[data-size='s']   [_nghost-%COMP%]:not(tui-text-area), [data-size='s'][_nghost-%COMP%]   .t-input[_ngcontent-%COMP%]{padding:0 var(--tui-padding-s)}.t-input   tui-primitive-textfield[data-size='l'][_nghost-%COMP%]:not(tui-primitive-textfield), tui-primitive-textfield[data-size='l']   [_nghost-%COMP%]:not(tui-primitive-textfield), .t-input   tui-text-area[data-size='l'][_nghost-%COMP%]:not(tui-text-area), tui-text-area[data-size='l']   [_nghost-%COMP%]:not(tui-text-area), [data-size='l'][_nghost-%COMP%]   .t-input[_ngcontent-%COMP%]{padding:0 var(--tui-padding-l)}.t-input   tui-primitive-textfield._disabled[_nghost-%COMP%], tui-primitive-textfield._disabled   [_nghost-%COMP%], .t-input   tui-text-area._disabled[_nghost-%COMP%], tui-text-area._disabled   [_nghost-%COMP%], ._disabled[_nghost-%COMP%]   .t-input[_ngcontent-%COMP%]{pointer-events:none}.t-input   tui-primitive-textfield[data-size='l']:not(._label-outside)[_nghost-%COMP%]:not(tui-primitive-textfield), tui-primitive-textfield[data-size='l']:not(._label-outside)   [_nghost-%COMP%]:not(tui-primitive-textfield), [data-size='l'][_nghost-%COMP%]:not(._label-outside)   .t-input[_ngcontent-%COMP%]{padding-top:1.25rem}.t-input   tui-primitive-textfield[data-size='l']:not(._label-outside)[_nghost-%COMP%]:not(tui-primitive-textfield):-webkit-autofill + .t-content[_ngcontent-%COMP%]   .t-placeholder[_ngcontent-%COMP%], tui-primitive-textfield[data-size='l']:not(._label-outside)   [_nghost-%COMP%]:not(tui-primitive-textfield):-webkit-autofill + .t-content[_ngcontent-%COMP%]   .t-placeholder[_ngcontent-%COMP%], [data-size='l'][_nghost-%COMP%]:not(._label-outside)   .t-input[_ngcontent-%COMP%]:-webkit-autofill + .t-content[_ngcontent-%COMP%]   .t-placeholder[_ngcontent-%COMP%]{font-size:.8156rem;transform:translateY(-.625rem)}.t-input   tui-primitive-textfield[data-size='m']:not(._label-outside)[_nghost-%COMP%]:not(tui-primitive-textfield), tui-primitive-textfield[data-size='m']:not(._label-outside)   [_nghost-%COMP%]:not(tui-primitive-textfield), [data-size='m'][_nghost-%COMP%]:not(._label-outside)   .t-input[_ngcontent-%COMP%]{padding-top:1.125rem}.t-input   tui-primitive-textfield[data-size='m']:not(._label-outside)[_nghost-%COMP%]:not(tui-primitive-textfield):-webkit-autofill + .t-content[_ngcontent-%COMP%]   .t-placeholder[_ngcontent-%COMP%], tui-primitive-textfield[data-size='m']:not(._label-outside)   [_nghost-%COMP%]:not(tui-primitive-textfield):-webkit-autofill + .t-content[_ngcontent-%COMP%]   .t-placeholder[_ngcontent-%COMP%], [data-size='m'][_nghost-%COMP%]:not(._label-outside)   .t-input[_ngcontent-%COMP%]:-webkit-autofill + .t-content[_ngcontent-%COMP%]   .t-placeholder[_ngcontent-%COMP%]{font-size:.69rem;transform:translateY(-.5rem)}.t-input   tui-primitive-textfield._hidden[_nghost-%COMP%], tui-primitive-textfield._hidden   [_nghost-%COMP%], ._hidden[_nghost-%COMP%]   input.t-input[_ngcontent-%COMP%]{opacity:0;text-indent:-10em;-webkit-user-select:none}.t-content[_ngcontent-%COMP%]{display:flex;height:100%;width:100%;padding:0 var(--tui-padding-m);box-sizing:border-box;align-items:center;overflow:hidden}[data-size='s'][_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{padding:0 var(--tui-padding-s)}[data-size='l'][_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{padding:0 var(--tui-padding-l)}.t-content[_ngcontent-%COMP%]:after{content:'';margin-right:-.25rem}[data-size='m'][_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]:after{display:none}.t-wrapper[_ngcontent-%COMP%]{flex:1;min-width:0;padding-right:.25rem;-webkit-padding-end:.25rem;padding-inline-end:.25rem;-webkit-padding-start:0;padding-inline-start:0}.t-placeholder[_ngcontent-%COMP%]{transition-property:transform,font-size,color,letter-spacing;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;font:var(--tui-font-text-s);color:var(--tui-text-01);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;width:100%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;color:var(--tui-text-02);pointer-events:none;will-change:transform;transform:translateY(0)}.t-placeholder_raised[_ngcontent-%COMP%]{transform:translateY(-.625rem)}[data-size='m'][_nghost-%COMP%]   .t-placeholder_raised[_ngcontent-%COMP%]{font:var(--tui-font-text-xs);transform:translateY(-.5rem);letter-spacing:.025rem}._invalid[_nghost-%COMP%]:not(._focused)   .t-placeholder_raised[_ngcontent-%COMP%], ._invalid[_nghost-%COMP%]:not(._focused):hover   .t-placeholder_raised[_ngcontent-%COMP%]{color:var(--tui-error-fill)}[data-mode=onDark]._invalid[_nghost-%COMP%]:not(._focused)   .t-placeholder_raised[_ngcontent-%COMP%], [data-mode=onDark]._invalid[_nghost-%COMP%]:not(._focused):hover   .t-placeholder_raised[_ngcontent-%COMP%]{color:var(--tui-error-fill-night)}._focused[_nghost-%COMP%]   .t-placeholder[_ngcontent-%COMP%], [data-size='l']._focused._label-outside[_nghost-%COMP%]   .t-placeholder[_ngcontent-%COMP%], [data-size='m']._focused._label-outside[_nghost-%COMP%]   .t-placeholder[_ngcontent-%COMP%]{color:var(--tui-text-03)}[data-size='l'][_nghost-%COMP%]   .t-placeholder[_ngcontent-%COMP%]{font-size:.9375rem}[data-size='l'][_nghost-%COMP%]   .t-placeholder_raised[_ngcontent-%COMP%]{font-size:.8156rem}[data-size='l']._focused[_nghost-%COMP%]:not(._label-outside)   .t-placeholder[_ngcontent-%COMP%], [data-size='m']._focused[_nghost-%COMP%]:not(._label-outside)   .t-placeholder[_ngcontent-%COMP%]{color:var(--tui-text-01)}[data-mode=onDark][_nghost-%COMP%]   .t-placeholder[_ngcontent-%COMP%]{color:var(--tui-text-02-night)}[data-size='l'][data-mode=onDark]._focused[_nghost-%COMP%]:not(._label-outside)   .t-placeholder[_ngcontent-%COMP%], [data-size='m'][data-mode=onDark]._focused[_nghost-%COMP%]:not(._label-outside)   .t-placeholder[_ngcontent-%COMP%]{color:var(--tui-text-01-night)}[data-mode=onDark]._focused[_nghost-%COMP%]   .t-placeholder[_ngcontent-%COMP%], [data-size='l'][data-mode=onDark]._focused._label-outside[_nghost-%COMP%]   .t-placeholder[_ngcontent-%COMP%], [data-size='m'][data-mode=onDark]._focused._label-outside[_nghost-%COMP%]   .t-placeholder[_ngcontent-%COMP%]{color:var(--tui-text-02-night)}@supports (-webkit-hyphens:none){.t-placeholder[_ngcontent-%COMP%]{will-change:unset;transition-property:transform,color,letter-spacing}}.t-cleaner[_ngcontent-%COMP%]{transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;display:flex;width:1.5rem;height:1.5rem;align-items:center;justify-content:center;color:var(--tui-text-03);position:relative;box-sizing:border-box;cursor:pointer;transition-property:color,transform}.t-cleaner[_ngcontent-%COMP%]:hover{color:var(--tui-text-02)}._disabled[_nghost-%COMP%]   .t-cleaner[_ngcontent-%COMP%], ._readonly[_nghost-%COMP%]   .t-cleaner[_ngcontent-%COMP%]{pointer-events:none}[data-mode=onDark][_nghost-%COMP%]   .t-cleaner[_ngcontent-%COMP%]{color:var(--tui-text-03-night)}[data-mode=onDark][_nghost-%COMP%]   .t-cleaner[_ngcontent-%COMP%]:hover{color:var(--tui-text-01-night)}.t-icon[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;color:var(--tui-text-03)}.t-icon_left[_ngcontent-%COMP%]{margin:0 .5rem 0 -.25rem;-webkit-margin-start:-.25rem;margin-inline-start:-.25rem;-webkit-margin-end:.5rem;margin-inline-end:.5rem}[data-size='s'][_nghost-%COMP%]   .t-icon_left[_ngcontent-%COMP%]{margin-right:.25rem;-webkit-margin-end:.25rem;margin-inline-end:.25rem}._autofilled[_nghost-%COMP%]   .t-value-decoration[_ngcontent-%COMP%]:not(.t-has-value){visibility:hidden}._autofilled[data-size='m'][_nghost-%COMP%]:not(._focused)   .t-placeholder[_ngcontent-%COMP%], ._autofilled[data-size='s'][_nghost-%COMP%]:not(._focused)   .t-placeholder[_ngcontent-%COMP%]{visibility:hidden}.t-custom-content[_ngcontent-%COMP%]{position:relative;display:flex;align-items:center;justify-content:center;min-width:2rem;height:2rem;margin-right:.25rem;pointer-events:none}.t-custom-icon[_ngcontent-%COMP%]{width:2rem;height:100%}.t-icon[_ngcontent-%COMP%]{transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;display:flex;width:1.5rem;height:1.5rem;align-items:center;justify-content:center;color:var(--tui-text-03);box-sizing:border-box;cursor:pointer;transition-property:color,transform;position:relative;pointer-events:none}.t-icon[_ngcontent-%COMP%]:hover{color:var(--tui-text-02)}._disabled[_nghost-%COMP%]   .t-icon[_ngcontent-%COMP%], ._readonly[_nghost-%COMP%]   .t-icon[_ngcontent-%COMP%]{pointer-events:none}[data-mode=onDark][_nghost-%COMP%]   .t-icon[_ngcontent-%COMP%]{color:var(--tui-text-03-night)}[data-mode=onDark][_nghost-%COMP%]   .t-icon[_ngcontent-%COMP%]:hover{color:var(--tui-text-01-night)}[_nghost-%COMP%]:hover:not(._readonly)   .t-icon[_ngcontent-%COMP%]{color:var(--tui-text-02)}[data-mode=onDark][_nghost-%COMP%]:hover:not(._readonly)   .t-icon[_ngcontent-%COMP%]{color:var(--tui-text-01-night)}[data-mode=onLight][_nghost-%COMP%]:hover:not(._readonly)   .t-icon[_ngcontent-%COMP%]{color:var(--tui-text-01)}.t-input[_ngcontent-%COMP%]:not(:first-child){display:none}[data-size][_nghost-%COMP%]   .t-input_template[_ngcontent-%COMP%]{display:flex;width:calc(100% - 1rem);max-width:calc(100% - 1rem);align-items:center;pointer-events:none;-webkit-padding-end:0;padding-inline-end:0}.t-input[_ngcontent-%COMP%]:-webkit-autofill, .t-input[_ngcontent-%COMP%]:-webkit-autofill::first-line{font-size:inherit;line-height:inherit}.t-input[_ngcontent-%COMP%]::-webkit-caps-lock-indicator, .t-input[_ngcontent-%COMP%]::-webkit-contacts-auto-fill-button, .t-input[_ngcontent-%COMP%]::-webkit-credentials-auto-fill-button, .t-input[_ngcontent-%COMP%]::-webkit-credit-card-auto-fill-button, .t-input[_ngcontent-%COMP%]::-webkit-strong-password-auto-fill-button{content:none!important;position:absolute;left:-62.4375rem;top:-62.4375rem;z-index:-999;display:none!important;background:0 0!important;pointer-events:none!important}.t-text-template[_ngcontent-%COMP%]{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.t-wrapper-value-decoration[_ngcontent-%COMP%]{position:relative;pointer-events:none}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('focusableElement')], TuiPrimitiveTextfieldComponent.prototype, "focusableElement", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveTextfieldComponent.prototype, "editable", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveTextfieldComponent.prototype, "filler", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveTextfieldComponent.prototype, "iconAlign", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveTextfieldComponent.prototype, "iconContent", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveTextfieldComponent.prototype, "iconCleaner", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._readonly'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveTextfieldComponent.prototype, "readOnly", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveTextfieldComponent.prototype, "invalid", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveTextfieldComponent.prototype, "disabled", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveTextfieldComponent.prototype, "prefix", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveTextfieldComponent.prototype, "postfix", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveTextfieldComponent.prototype, "value", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiPrimitiveTextfieldComponent.prototype, "valueChange", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiPrimitiveTextfieldComponent.prototype, "autofilledChange", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChildren)(tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1)], TuiPrimitiveTextfieldComponent.prototype, "content", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('attr.data-size')], TuiPrimitiveTextfieldComponent.prototype, "size", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._invalid')], TuiPrimitiveTextfieldComponent.prototype, "computedInvalid", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._hidden')], TuiPrimitiveTextfieldComponent.prototype, "inputHidden", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('style.--border-start.rem')], TuiPrimitiveTextfieldComponent.prototype, "borderStart", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('style.--border-end.rem')], TuiPrimitiveTextfieldComponent.prototype, "borderEnd", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('focusin', ['true']), (0,core_js_.HostListener)('focusout', ['false'])], TuiPrimitiveTextfieldComponent.prototype, "onFocused", null);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiPrimitiveTextfieldComponent.prototype, "getIndent$", null);
  TuiPrimitiveTextfieldComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_MODE */.Au)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_TEXTFIELD_APPEARANCE */.jt)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(TUI_TEXTFIELD_WATCHED_CONTROLLER)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TUI_HINT_WATCHED_CONTROLLER)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(TUI_PRIMITIVE_TEXTFIELD_OPTIONS)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(core_js_.ElementRef))], TuiPrimitiveTextfieldComponent);
  return TuiPrimitiveTextfieldComponent;
})();
var TuiPrimitiveTextfieldDirective_1;
let TuiPrimitiveTextfieldDirective = TuiPrimitiveTextfieldDirective_1 = class TuiPrimitiveTextfieldDirective extends TuiAbstractTextfieldHost {
  constructor(textfield) {
    /**
     * TuiPrimitiveTextfieldComponent satisfies all required parts of
     * AbstractTuiControl interface. A new interface is not introduced
     * so AbstractTuiControl is automatically injected for all other controls.
     */
    super(textfield);
    this.textfield = textfield;
  }
  get readOnly() {
    return this.textfield.readOnly || !this.textfield.editable;
  }
  onValueChange(value) {
    this.textfield.onModelChange(value);
  }
};
TuiPrimitiveTextfieldDirective.ɵfac = function TuiPrimitiveTextfieldDirective_Factory(t) {
  return new (t || TuiPrimitiveTextfieldDirective)(core_js_["ɵɵdirectiveInject"](TuiPrimitiveTextfieldComponent));
};
TuiPrimitiveTextfieldDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiPrimitiveTextfieldDirective,
  selectors: [["tui-primitive-textfield"]],
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_core_tokens/* TUI_TEXTFIELD_HOST */.S0,
    useExisting: (0,core_js_.forwardRef)(() => TuiPrimitiveTextfieldDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
TuiPrimitiveTextfieldDirective.ctorParameters = () => [{
  type: TuiPrimitiveTextfieldComponent,
  decorators: [{
    type: core_js_.Inject,
    args: [TuiPrimitiveTextfieldComponent]
  }]
}];
TuiPrimitiveTextfieldDirective = TuiPrimitiveTextfieldDirective_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TuiPrimitiveTextfieldComponent))], TuiPrimitiveTextfieldDirective);

// @dynamic
let TuiTextfieldComponent = /*#__PURE__*/(() => {
  let TuiTextfieldComponent = class TuiTextfieldComponent {
    constructor(host, controller, elementRef, describedBy, idService) {
      this.host = host;
      this.controller = controller;
      this.elementRef = elementRef;
      this.describedBy = describedBy;
      this.idService = idService;
      this.host.process(this.elementRef.nativeElement);
    }
    get computedDescribedBy() {
      return this.describedBy.computedDescribedBy;
    }
    get id() {
      return this.elementRef.nativeElement.id || this.idService.generate();
    }
    ngDoCheck() {
      this.describedBy.tuiDescribedBy = this.id;
    }
  };
  TuiTextfieldComponent.ɵfac = function TuiTextfieldComponent_Factory(t) {
    return new (t || TuiTextfieldComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_TEXTFIELD_HOST */.S0), core_js_["ɵɵdirectiveInject"](TUI_TEXTFIELD_WATCHED_CONTROLLER), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](TuiDescribedByDirective), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiIdService */.ll));
  };
  TuiTextfieldComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiTextfieldComponent,
    selectors: [["input", "tuiTextfield", ""], ["textarea", "tuiTextfield", ""]],
    hostAttrs: ["type", "text"],
    hostVars: 8,
    hostBindings: function TuiTextfieldComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("input", function TuiTextfieldComponent_input_HostBindingHandler($event) {
          return ctx.host.onValueChange($event.target.value);
        });
      }
      if (rf & 2) {
        core_js_["ɵɵhostProperty"]("tabIndex", ctx.host.focusable ? 0 : -1)("readOnly", ctx.host.readOnly)("value", ctx.host.value)("id", ctx.id);
        core_js_["ɵɵattribute"]("aria-placeholder", ctx.controller.exampleText)("aria-invalid", ctx.host.invalid)("disabled", ctx.host.disabled || null)("aria-describedby", ctx.computedDescribedBy);
      }
    },
    features: [core_js_["ɵɵProvidersFeature"]([TuiDescribedByDirective, TUI_DESCRIBED_BY_PROVIDERS, TEXTFIELD_CONTROLLER_PROVIDER])],
    attrs: _c4,
    decls: 0,
    vars: 0,
    template: function TuiTextfieldComponent_Template(rf, ctx) {},
    styles: ["[_nghost-%COMP%]{font:var(--tui-font-text-s);color:var(--tui-text-01);padding:0;margin:0;border:0;border-radius:inherit;background:0 0;font-size:inherit;line-height:inherit;font-weight:inherit;color:inherit;caret-color:currentColor;outline:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;word-break:keep-all;-webkit-text-fill-color:currentColor;position:absolute;top:0;left:0;width:100%;height:100%;padding:0 var(--tui-padding-m);border:solid transparent;border-width:0 var(--border-end,0) 0 var(--border-start,0);border-inline-start-width:var(--border-start,0);border-inline-end-width:var(--border-end,0);text-indent:var(--text-indent);text-align:inherit;box-sizing:border-box;white-space:nowrap;overflow:hidden;text-transform:inherit;resize:none}[_nghost-%COMP%]:-webkit-autofill, [_nghost-%COMP%]:-webkit-autofill:focus, [_nghost-%COMP%]:-webkit-autofill:hover{caret-color:var(--tui-base-09);border-radius:inherit;color:inherit!important;background-color:transparent!important;-webkit-text-fill-color:var(--tui-text-01)!important;border-color:var(--tui-autofill);-webkit-box-shadow:0 0 0 100rem var(--tui-autofill) inset!important}[_nghost-%COMP%]   tui-primitive-textfield[data-mode=onDark][_nghost-%COMP%]:-webkit-autofill, tui-primitive-textfield[data-mode=onDark]   [_nghost-%COMP%]:-webkit-autofill, [_nghost-%COMP%]   tui-primitive-textfield[data-mode=onDark][_nghost-%COMP%]:-webkit-autofill:focus, tui-primitive-textfield[data-mode=onDark]   [_nghost-%COMP%]:-webkit-autofill:focus, [_nghost-%COMP%]   tui-primitive-textfield[data-mode=onDark][_nghost-%COMP%]:-webkit-autofill:hover, tui-primitive-textfield[data-mode=onDark]   [_nghost-%COMP%]:-webkit-autofill:hover, [_nghost-%COMP%]   tui-text-area[data-mode=onDark][_nghost-%COMP%]:-webkit-autofill, tui-text-area[data-mode=onDark]   [_nghost-%COMP%]:-webkit-autofill, [_nghost-%COMP%]   tui-text-area[data-mode=onDark][_nghost-%COMP%]:-webkit-autofill:focus, tui-text-area[data-mode=onDark]   [_nghost-%COMP%]:-webkit-autofill:focus, [_nghost-%COMP%]   tui-text-area[data-mode=onDark][_nghost-%COMP%]:-webkit-autofill:hover, tui-text-area[data-mode=onDark]   [_nghost-%COMP%]:-webkit-autofill:hover, [data-mode=onDark][_nghost-%COMP%]   [_ngcontent-%COMP%]:-webkit-autofill, [data-mode=onDark][_nghost-%COMP%]   [_ngcontent-%COMP%]:-webkit-autofill:focus, [data-mode=onDark][_nghost-%COMP%]   [_ngcontent-%COMP%]:-webkit-autofill:hover{caret-color:var(--tui-base-09);border-radius:inherit;color:inherit!important;background-color:transparent!important;-webkit-text-fill-color:var(--tui-text-01-night)!important;border-color:var(--tui-autofill-night);-webkit-box-shadow:0 0 0 100rem var(--tui-autofill-night) inset!important}[_nghost-%COMP%]   tui-primitive-textfield[data-size='s'][_nghost-%COMP%]:not(tui-primitive-textfield), tui-primitive-textfield[data-size='s']   [_nghost-%COMP%]:not(tui-primitive-textfield), [_nghost-%COMP%]   tui-text-area[data-size='s'][_nghost-%COMP%]:not(tui-text-area), tui-text-area[data-size='s']   [_nghost-%COMP%]:not(tui-text-area), [data-size='s'][_nghost-%COMP%]   -shadowcsshost{padding:0 var(--tui-padding-s)}[_nghost-%COMP%]   tui-primitive-textfield[data-size='l'][_nghost-%COMP%]:not(tui-primitive-textfield), tui-primitive-textfield[data-size='l']   [_nghost-%COMP%]:not(tui-primitive-textfield), [_nghost-%COMP%]   tui-text-area[data-size='l'][_nghost-%COMP%]:not(tui-text-area), tui-text-area[data-size='l']   [_nghost-%COMP%]:not(tui-text-area), [data-size='l'][_nghost-%COMP%]   -shadowcsshost{padding:0 var(--tui-padding-l)}[_nghost-%COMP%]   tui-primitive-textfield._disabled[_nghost-%COMP%], tui-primitive-textfield._disabled   [_nghost-%COMP%], [_nghost-%COMP%]   tui-text-area._disabled[_nghost-%COMP%], tui-text-area._disabled   [_nghost-%COMP%], ._disabled[_nghost-%COMP%]   -shadowcsshost{pointer-events:none}[_nghost-%COMP%]   tui-primitive-textfield[data-size='l']:not(._label-outside)[_nghost-%COMP%]:not(tui-primitive-textfield), tui-primitive-textfield[data-size='l']:not(._label-outside)   [_nghost-%COMP%]:not(tui-primitive-textfield), [data-size='l'][_nghost-%COMP%]:not(._label-outside)   -shadowcsshost{padding-top:1.25rem}[_nghost-%COMP%]   tui-primitive-textfield[data-size='l']:not(._label-outside)[_nghost-%COMP%]:not(tui-primitive-textfield):-webkit-autofill + .t-content[_ngcontent-%COMP%]   .t-placeholder[_ngcontent-%COMP%], tui-primitive-textfield[data-size='l']:not(._label-outside)   [_nghost-%COMP%]:not(tui-primitive-textfield):-webkit-autofill + .t-content[_ngcontent-%COMP%]   .t-placeholder[_ngcontent-%COMP%], [data-size='l'][_nghost-%COMP%]:not(._label-outside)   [_ngcontent-%COMP%]:-webkit-autofill + .t-content[_ngcontent-%COMP%]   .t-placeholder[_ngcontent-%COMP%]{font-size:.8156rem;transform:translateY(-.625rem)}[_nghost-%COMP%]   tui-primitive-textfield[data-size='m']:not(._label-outside)[_nghost-%COMP%]:not(tui-primitive-textfield), tui-primitive-textfield[data-size='m']:not(._label-outside)   [_nghost-%COMP%]:not(tui-primitive-textfield), [data-size='m'][_nghost-%COMP%]:not(._label-outside)   -shadowcsshost{padding-top:1.125rem}[_nghost-%COMP%]   tui-primitive-textfield[data-size='m']:not(._label-outside)[_nghost-%COMP%]:not(tui-primitive-textfield):-webkit-autofill + .t-content[_ngcontent-%COMP%]   .t-placeholder[_ngcontent-%COMP%], tui-primitive-textfield[data-size='m']:not(._label-outside)   [_nghost-%COMP%]:not(tui-primitive-textfield):-webkit-autofill + .t-content[_ngcontent-%COMP%]   .t-placeholder[_ngcontent-%COMP%], [data-size='m'][_nghost-%COMP%]:not(._label-outside)   [_ngcontent-%COMP%]:-webkit-autofill + .t-content[_ngcontent-%COMP%]   .t-placeholder[_ngcontent-%COMP%]{font-size:.69rem;transform:translateY(-.5rem)}[_nghost-%COMP%]   tui-primitive-textfield._hidden[_nghost-%COMP%], tui-primitive-textfield._hidden   [_nghost-%COMP%], ._hidden[_nghost-%COMP%]   input[_ngcontent-%COMP%]{opacity:0;text-indent:-10em;-webkit-user-select:none}[_nghost-%COMP%]::-ms-input-placeholder{color:var(--tui-text-03);opacity:0}[_nghost-%COMP%]::placeholder{color:var(--tui-text-03);opacity:0}[_nghost-%COMP%]   tui-primitive-textfield[data-mode=onDark][_nghost-%COMP%]::-ms-input-placeholder, tui-primitive-textfield[data-mode=onDark]   [_nghost-%COMP%]::-ms-input-placeholder, [_nghost-%COMP%]   tui-text-area[data-mode=onDark][_nghost-%COMP%]::-ms-input-placeholder, tui-text-area[data-mode=onDark]   [_nghost-%COMP%]::-ms-input-placeholder{color:var(--tui-text-03-night)}[_nghost-%COMP%]   tui-primitive-textfield[data-mode=onDark][_nghost-%COMP%]::placeholder, tui-primitive-textfield[data-mode=onDark]   [_nghost-%COMP%]::placeholder, [_nghost-%COMP%]   tui-text-area[data-mode=onDark][_nghost-%COMP%]::placeholder, tui-text-area[data-mode=onDark]   [_nghost-%COMP%]::placeholder{color:var(--tui-text-03-night)}[_nghost-%COMP%]   tui-primitive-textfield._focused:not(._readonly)[_nghost-%COMP%]::-ms-input-placeholder, tui-primitive-textfield._focused:not(._readonly)   [_nghost-%COMP%]::-ms-input-placeholder, [_nghost-%COMP%]   tui-text-area._focused:not(._readonly)[_nghost-%COMP%]::-ms-input-placeholder, tui-text-area._focused:not(._readonly)   [_nghost-%COMP%]::-ms-input-placeholder{opacity:1}[_nghost-%COMP%]   tui-primitive-textfield._focused:not(._readonly)[_nghost-%COMP%]::placeholder, tui-primitive-textfield._focused:not(._readonly)   [_nghost-%COMP%]::placeholder, [_nghost-%COMP%]   tui-text-area._focused:not(._readonly)[_nghost-%COMP%]::placeholder, tui-text-area._focused:not(._readonly)   [_nghost-%COMP%]::placeholder{opacity:1}[_nghost-%COMP%]::-webkit-caps-lock-indicator, [_nghost-%COMP%]::-webkit-contacts-auto-fill-button, [_nghost-%COMP%]::-webkit-credentials-auto-fill-button, [_nghost-%COMP%]::-webkit-credit-card-auto-fill-button, [_nghost-%COMP%]::-webkit-strong-password-auto-fill-button{content:none!important;position:absolute;left:-62.4375rem;top:-62.4375rem;z-index:-999;display:none!important;background:0 0!important;pointer-events:none!important}textarea[_nghost-%COMP%]{white-space:normal}textarea[_nghost-%COMP%]   tui-text-area._ios[_nghost-%COMP%], tui-text-area._ios   [_nghost-%COMP%]{padding-left:.8125rem}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('attr.aria-describedby')], TuiTextfieldComponent.prototype, "computedDescribedBy", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('id')], TuiTextfieldComponent.prototype, "id", null);
  TuiTextfieldComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_TEXTFIELD_HOST */.S0)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_TEXTFIELD_WATCHED_CONTROLLER)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TuiDescribedByDirective)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiIdService */.ll))], TuiTextfieldComponent);
  return TuiTextfieldComponent;
})();
let TuiValueDecorationComponent = /*#__PURE__*/(() => {
  let TuiValueDecorationComponent = class TuiValueDecorationComponent {
    constructor(textfield, controller) {
      this.textfield = textfield;
      this.controller = controller;
      this.prefix$ = new internal_BehaviorSubject/* BehaviorSubject */.X('');
      this.pre$ = this.prefix$.pipe((0,delay/* delay */.g)(0), (0,operators_filter/* filter */.h)(() => {
        var _a;
        return !!((_a = this.pre) === null || _a === void 0 ? void 0 : _a.nativeElement.isConnected);
      }), (0,operators_distinctUntilChanged/* distinctUntilChanged */.x)(), (0,operators_map/* map */.U)(() => {
        var _a;
        return ((_a = this.pre) === null || _a === void 0 ? void 0 : _a.nativeElement.offsetWidth) || 0;
      }));
    }
    get isContextTable() {
      return this.textfield.appearance === "table" /* Table */;
    }

    get value() {
      return this.textfield.value;
    }
    get filler() {
      const {
        focused,
        placeholder,
        exampleText,
        value,
        textfield
      } = this;
      if (placeholder && exampleText) {
        return '';
      }
      return focused ? exampleText || textfield.filler.slice(value.length) : '';
    }
    get prefix() {
      return this.decorationsVisible ? this.textfield.prefix : '';
    }
    get postfix() {
      return this.decorationsVisible ? this.computedPostfix : '';
    }
    ngDoCheck() {
      this.prefix$.next(this.prefix);
    }
    get placeholder() {
      var _a;
      return ((_a = this.textfield.nativeFocusableElement) === null || _a === void 0 ? void 0 : _a.placeholder) || '';
    }
    get exampleText() {
      const exampleText = this.controller.exampleText || this.placeholder;
      return !this.value && this.focused ? exampleText : '';
    }
    get decorationsVisible() {
      return !!this.value || this.focused;
    }
    get focused() {
      return this.textfield.computedFocused && !this.textfield.readOnly;
    }
    get computedPostfix() {
      return this.textfield.postfix && (this.filler || this.value) ? ` ${this.textfield.postfix}` : this.textfield.postfix;
    }
  };
  TuiValueDecorationComponent.ɵfac = function TuiValueDecorationComponent_Factory(t) {
    return new (t || TuiValueDecorationComponent)(core_js_["ɵɵdirectiveInject"](TuiPrimitiveTextfieldComponent), core_js_["ɵɵdirectiveInject"](TUI_TEXTFIELD_WATCHED_CONTROLLER));
  };
  TuiValueDecorationComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiValueDecorationComponent,
    selectors: [["tui-value-decoration"]],
    viewQuery: function TuiValueDecorationComponent_Query(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵviewQuery"](_c5, 7, core_js_.ElementRef);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.pre = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function TuiValueDecorationComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("animationstart", function TuiValueDecorationComponent_animationstart_HostBindingHandler() {
          return ctx.ngDoCheck();
        });
      }
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("_table", ctx.isContextTable);
      }
    },
    decls: 5,
    vars: 4,
    consts: [[1, "t-prefix", "t-inline", 3, "textContent"], ["pre", ""], [1, "t-ghost", "t-inline", 3, "textContent"], [1, "t-filler", "t-inline", 3, "textContent"], [1, "t-postfix", "t-inline", 3, "textContent"]],
    template: function TuiValueDecorationComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵelement"](0, "span", 0, 1);
        core_js_["ɵɵelement"](2, "span", 2);
        core_js_["ɵɵelement"](3, "span", 3);
        core_js_["ɵɵelement"](4, "span", 4);
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("textContent", ctx.prefix);
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵproperty"]("textContent", ctx.value);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("textContent", ctx.filler);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("textContent", ctx.postfix);
      }
    },
    styles: ["[_nghost-%COMP%]{position:absolute;display:block;height:1.25rem;line-height:1;width:100%;margin:-1.25rem 0;padding:.625rem 0;box-sizing:content-box;color:var(--tui-text-01);animation:1s tuiPresent}._table[_nghost-%COMP%]{position:static}tui-textfield[data-mode=onDark]   [_nghost-%COMP%]{color:var(--tui-text-01-night)}[_nghost-%COMP%]:after{content:'';display:inline-block;vertical-align:middle;height:100%}.t-ghost[_ngcontent-%COMP%]{visibility:hidden;white-space:pre;text-overflow:clip}.t-postfix[_ngcontent-%COMP%], .t-prefix[_ngcontent-%COMP%]{white-space:pre}.t-filler[_ngcontent-%COMP%]{overflow:hidden;color:var(--tui-text-03);text-overflow:ellipsis;max-width:100%;white-space:nowrap}tui-textfield[data-mode=onDark][_nghost-%COMP%]   .t-filler[_ngcontent-%COMP%], tui-textfield[data-mode=onDark]   [_nghost-%COMP%]   .t-filler[_ngcontent-%COMP%]{color:var(--tui-text-03-night)}.t-inline[_ngcontent-%COMP%]{display:inline-block;vertical-align:middle}"]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('pre', {
    read: core_js_.ElementRef,
    static: true
  })], TuiValueDecorationComponent.prototype, "pre", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._table')], TuiValueDecorationComponent.prototype, "isContextTable", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('animationstart')], TuiValueDecorationComponent.prototype, "ngDoCheck", null);
  TuiValueDecorationComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TuiPrimitiveTextfieldComponent)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_TEXTFIELD_WATCHED_CONTROLLER))], TuiValueDecorationComponent);
  return TuiValueDecorationComponent;
})();
let TuiPrimitiveTextfieldModule = /*#__PURE__*/(() => {
  let TuiPrimitiveTextfieldModule = class TuiPrimitiveTextfieldModule {};
  TuiPrimitiveTextfieldModule.ɵfac = function TuiPrimitiveTextfieldModule_Factory(t) {
    return new (t || TuiPrimitiveTextfieldModule)();
  };
  TuiPrimitiveTextfieldModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiPrimitiveTextfieldModule
  });
  TuiPrimitiveTextfieldModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, fesm2015_forms.FormsModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiMaskAccessorModule, TuiFocusableModule, TuiHoveredModule, TuiInputModeModule, taiga_ui_core_directives_wrapper/* TuiWrapperModule */.W, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiTooltipModule, TuiAutofilledModule, TuiDescribedByModule]]
  });
  return TuiPrimitiveTextfieldModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiPrimitiveTextfieldModule, {
    declarations: function () {
      return [TuiPrimitiveTextfieldComponent, TuiPrimitiveTextfieldDirective, TuiTextfieldComponent, TuiValueDecorationComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, fesm2015_forms.FormsModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiMaskAccessorModule, TuiFocusableModule, TuiHoveredModule, TuiInputModeModule, taiga_ui_core_directives_wrapper/* TuiWrapperModule */.W, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiTooltipModule, TuiAutofilledModule, TuiDescribedByModule];
    },
    exports: function () {
      return [TuiPrimitiveTextfieldComponent, TuiPrimitiveTextfieldDirective, TuiTextfieldComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-primitive-textfield.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-obscured.js








/**
 * Directive that monitors element visibility
 */



let TuiObscuredDirective = /*#__PURE__*/(() => {
  let TuiObscuredDirective = class TuiObscuredDirective {
    constructor(activeZone, obscured$) {
      this.enabled$ = new internal_Subject/* Subject */.xQ();
      const mapped$ = obscured$.pipe((0,operators_map/* map */.U)(obscuredBy => !!obscuredBy && (!activeZone || !obscuredBy.length || obscuredBy.every(element => !activeZone.contains(element)))));
      this.tuiObscured = this.enabled$.pipe((0,operators_switchMap/* switchMap */.w)(enabled => enabled ? mapped$ : observable_empty/* EMPTY */.E));
    }
    set tuiObscuredEnabled(enabled) {
      this.enabled$.next(enabled);
    }
  };
  TuiObscuredDirective.ɵfac = function TuiObscuredDirective_Factory(t) {
    return new (t || TuiObscuredDirective)(core_js_["ɵɵdirectiveInject"](TuiActiveZoneDirective, 8), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiObscuredService */.AQ, 2));
  };
  TuiObscuredDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiObscuredDirective,
    selectors: [["", "tuiObscured", ""]],
    inputs: {
      tuiObscuredEnabled: "tuiObscuredEnabled"
    },
    outputs: {
      tuiObscured: "tuiObscured"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiObscuredService */.AQ, taiga_ui_cdk_services/* TuiParentsScrollService */.b0, taiga_ui_cdk_services/* TuiDestroyService */.a3])]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiRequiredSetter */.NH)()], TuiObscuredDirective.prototype, "tuiObscuredEnabled", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiObscuredDirective.prototype, "tuiObscured", void 0);
  TuiObscuredDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TuiActiveZoneDirective)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiObscuredService */.AQ))], TuiObscuredDirective);
  return TuiObscuredDirective;
})();
let TuiObscuredModule = /*#__PURE__*/(() => {
  let TuiObscuredModule = class TuiObscuredModule {};
  TuiObscuredModule.ɵfac = function TuiObscuredModule_Factory(t) {
    return new (t || TuiObscuredModule)();
  };
  TuiObscuredModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiObscuredModule
  });
  TuiObscuredModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiObscuredModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiObscuredModule, {
    declarations: [TuiObscuredDirective],
    exports: [TuiObscuredDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-obscured.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-directives-dropdown-controller.js






const TUI_DROPDOWN_CONTROLLER = new core_js_.InjectionToken(`Controls configuration of hints`, {
  factory: () => new TuiDropdownControllerDirective()
});
var TuiDropdownControllerDirective_1;
let TuiDropdownControllerDirective = TuiDropdownControllerDirective_1 = class TuiDropdownControllerDirective extends taiga_ui_cdk_abstract/* TuiController */.td {
  constructor() {
    super(...arguments);
    this.align = 'right';
    this.direction = null;
    this.limitWidth = 'auto';
    this.minHeight = taiga_ui_core_constants/* DEFAULT_MIN_HEIGHT */.q_;
    this.maxHeight = taiga_ui_core_constants/* DEFAULT_MAX_HEIGHT */.ze;
    this.sided = false;
  }
};
TuiDropdownControllerDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiDropdownControllerDirective_BaseFactory;
  return function TuiDropdownControllerDirective_Factory(t) {
    return (ɵTuiDropdownControllerDirective_BaseFactory || (ɵTuiDropdownControllerDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiDropdownControllerDirective)))(t || TuiDropdownControllerDirective);
  };
}();
TuiDropdownControllerDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiDropdownControllerDirective,
  selectors: [["", "tuiDropdownAlign", ""], ["", "tuiDropdownDirection", ""], ["", "tuiDropdownLimitWidth", ""], ["", "tuiDropdownMinHeight", ""], ["", "tuiDropdownMaxHeight", ""], ["", "tuiDropdownSided", ""]],
  inputs: {
    align: ["tuiDropdownAlign", "align"],
    direction: ["tuiDropdownDirection", "direction"],
    limitWidth: ["tuiDropdownLimitWidth", "limitWidth"],
    minHeight: ["tuiDropdownMinHeight", "minHeight"],
    maxHeight: ["tuiDropdownMaxHeight", "maxHeight"],
    sided: ["tuiDropdownSided", "sided"]
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: TUI_DROPDOWN_CONTROLLER,
    useExisting: (0,core_js_.forwardRef)(() => TuiDropdownControllerDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdownAlign'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDropdownControllerDirective.prototype, "align", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdownDirection'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDropdownControllerDirective.prototype, "direction", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdownLimitWidth'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDropdownControllerDirective.prototype, "limitWidth", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdownMinHeight'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDropdownControllerDirective.prototype, "minHeight", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdownMaxHeight'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDropdownControllerDirective.prototype, "maxHeight", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiDropdownSided'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDropdownControllerDirective.prototype, "sided", void 0);
let TuiDropdownControllerModule = /*#__PURE__*/(() => {
  let TuiDropdownControllerModule = class TuiDropdownControllerModule {};
  TuiDropdownControllerModule.ɵfac = function TuiDropdownControllerModule_Factory(t) {
    return new (t || TuiDropdownControllerModule)();
  };
  TuiDropdownControllerModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDropdownControllerModule
  });
  TuiDropdownControllerModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiDropdownControllerModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDropdownControllerModule, {
    declarations: [TuiDropdownControllerDirective],
    exports: [TuiDropdownControllerDirective]
  });
})();
const TUI_DROPDOWN_WATCHED_CONTROLLER = new core_js_.InjectionToken(`watched dropdown controller`);
// TODO: 3.0 remove in ivy compilation
const DROPDOWN_CONTROLLER_FACTORY = taiga_ui_core_providers/* watchedControllerFactory */.my;
const DROPDOWN_CONTROLLER_PROVIDER = [taiga_ui_cdk_services/* TuiDestroyService */.a3, {
  provide: TUI_DROPDOWN_WATCHED_CONTROLLER,
  deps: [TUI_DROPDOWN_CONTROLLER, core_js_.ChangeDetectorRef, taiga_ui_cdk_services/* TuiDestroyService */.a3],
  useFactory: DROPDOWN_CONTROLLER_FACTORY
}];

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-directives-dropdown-controller.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-hosted-dropdown.js













const taiga_ui_core_components_hosted_dropdown_c0 = ["wrapper"];
const taiga_ui_core_components_hosted_dropdown_c1 = function (a0) {
  return {
    $implicit: a0
  };
};
function TuiHostedDropdownComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "div", 4, 5);
    core_js_["ɵɵlistener"]("keydown.esc", function TuiHostedDropdownComponent_ng_template_3_Template_div_keydown_esc_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r5);
      const ctx_r4 = core_js_["ɵɵnextContext"]();
      return ctx_r4.onKeyDownEsc($event);
    })("keydown", function TuiHostedDropdownComponent_ng_template_3_Template_div_keydown_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r5);
      const ctx_r6 = core_js_["ɵɵnextContext"]();
      return ctx_r6.onKeydown($event);
    });
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelement"](2, "div");
  }
  if (rf & 2) {
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    const _r0 = core_js_["ɵɵreference"](1);
    core_js_["ɵɵproperty"]("content", ctx_r2.content)("context", core_js_["ɵɵpureFunction1"](2, taiga_ui_core_components_hosted_dropdown_c1, _r0));
  }
}
const taiga_ui_core_components_hosted_dropdown_c2 = ["*"];
let TuiHostedDropdownConnectorDirective = /*#__PURE__*/(() => {
  let TuiHostedDropdownConnectorDirective = class TuiHostedDropdownConnectorDirective {};
  TuiHostedDropdownConnectorDirective.ɵfac = function TuiHostedDropdownConnectorDirective_Factory(t) {
    return new (t || TuiHostedDropdownConnectorDirective)();
  };
  TuiHostedDropdownConnectorDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiHostedDropdownConnectorDirective,
    selectors: [["", "tuiHostedDropdownHost", ""]]
  });
  return TuiHostedDropdownConnectorDirective;
})();
var TuiHostedDropdownComponent_1;
let TuiHostedDropdownComponent = TuiHostedDropdownComponent_1 = class TuiHostedDropdownComponent {
  constructor(elementRef, controller) {
    this.elementRef = elementRef;
    this.controller = controller;
    this.content = '';
    this.canOpen = true;
    this.open = false;
    this.openChange = new core_js_.EventEmitter();
    this.focusedChange = new core_js_.EventEmitter();
  }
  get host() {
    return this.dropdownHost ? this.dropdownHost.nativeElement : this.elementRef.nativeElement;
  }
  get dropdown() {
    return !this.dropdownDirective || this.dropdownDirective.dropdownBoxRef === null ? null : this.dropdownDirective.dropdownBoxRef.location.nativeElement;
  }
  get nativeFocusableElement() {
    return (0,taiga_ui_cdk_utils_focus/* isNativeKeyboardFocusable */.Wb)(this.host) ? this.host : (0,taiga_ui_cdk_utils_focus/* getClosestFocusable */.kA)(this.host, false, this.elementRef.nativeElement);
  }
  get focused() {
    return (0,taiga_ui_cdk_utils_focus/* isNativeFocusedIn */.KF)(this.host) || this.open && !!this.wrapper && (0,taiga_ui_cdk_utils_focus/* isNativeFocusedIn */.KF)(this.wrapper.nativeElement);
  }
  onFocusIn(target) {
    const host = this.dropdownHost ? this.dropdownHost.nativeElement : this.nativeFocusableElement || this.elementRef.nativeElement;
    if (!host.contains(target)) {
      this.updateOpen(false);
    }
  }
  onClick(target) {
    const host = this.nativeFocusableElement || this.host;
    const dropdownHost = this.dropdownHost ? this.dropdownHost.nativeElement : host;
    if (!this.hostEditable && dropdownHost.contains(target)) {
      this.updateOpen(!this.open);
    }
  }
  onKeyDownEsc(event) {
    if (!this.canOpen || !this.open) {
      return;
    }
    event.stopPropagation();
    this.closeDropdown();
  }
  onArrow(event, down) {
    this.focusDropdown(event, down);
  }
  onKeydown({
    key,
    target,
    defaultPrevented
  }) {
    if (!defaultPrevented && (0,taiga_ui_core_utils_miscellaneous/* isEditingKey */.Rb)(key) && this.hostEditable &&
    // TODO: iframe warning
    target instanceof HTMLElement && !(0,taiga_ui_cdk_utils_miscellaneous/* isElementEditable */.rT)(target)) {
      this.focusHost();
    }
  }
  onActiveZone(active) {
    this.updateFocused(active);
    if (!active) {
      this.updateOpen(false);
    }
  }
  onHostObscured(obscured) {
    if (obscured) {
      this.closeDropdown();
    }
  }
  updateOpen(open) {
    if (open && !this.canOpen) {
      return;
    }
    this.open = open;
    this.openChange.emit(open);
  }
  get hostEditable() {
    const host = this.nativeFocusableElement || this.host;
    // TODO: iframe warning
    return host instanceof HTMLElement && (0,taiga_ui_cdk_utils_miscellaneous/* isElementEditable */.rT)(host);
  }
  focusDropdown(event, first) {
    const host = this.nativeFocusableElement;
    // TODO: iframe warning
    if (!host || !(host instanceof HTMLElement) || !(event.target instanceof Node) || !host.contains(event.target)) {
      return;
    }
    if (!this.wrapper || !this.open || this.dropdown === null ||
    // TODO: iframe warning
    !(this.wrapper.nativeElement.nextElementSibling instanceof HTMLElement)) {
      this.updateOpen(true);
      if (!(0,taiga_ui_cdk_utils_miscellaneous/* isElementEditable */.rT)(host)) {
        event.preventDefault();
      }
      return;
    }
    const initial = first ? this.wrapper.nativeElement : this.wrapper.nativeElement.nextElementSibling;
    const focusable = (0,taiga_ui_cdk_utils_focus/* getClosestFocusable */.kA)(initial, !first, this.wrapper.nativeElement);
    if (focusable === null) {
      return;
    }
    (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(focusable);
    event.preventDefault();
  }
  closeDropdown() {
    if (this.focused) {
      this.focusHost();
    }
    this.updateOpen(false);
  }
  focusHost() {
    const host = this.nativeFocusableElement;
    if (host !== null) {
      (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(host, true, true);
    }
  }
  updateFocused(focused) {
    this.focusedChange.emit(focused);
  }
};
TuiHostedDropdownComponent.ɵfac = function TuiHostedDropdownComponent_Factory(t) {
  return new (t || TuiHostedDropdownComponent)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](TUI_DROPDOWN_WATCHED_CONTROLLER));
};
TuiHostedDropdownComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiHostedDropdownComponent,
  selectors: [["tui-hosted-dropdown"]],
  contentQueries: function TuiHostedDropdownComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      core_js_["ɵɵcontentQuery"](dirIndex, TuiHostedDropdownConnectorDirective, 5, core_js_.ElementRef);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.dropdownHost = _t.first);
    }
  },
  viewQuery: function TuiHostedDropdownComponent_Query(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵviewQuery"](taiga_ui_core_components_hosted_dropdown_c0, 5, core_js_.ElementRef);
      core_js_["ɵɵviewQuery"](TuiDropdownDirective, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.wrapper = _t.first);
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.dropdownDirective = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function TuiHostedDropdownComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵlistener"]("focusin", function TuiHostedDropdownComponent_focusin_HostBindingHandler($event) {
        return ctx.onFocusIn($event.target);
      })("click", function TuiHostedDropdownComponent_click_HostBindingHandler($event) {
        return ctx.onClick($event.target);
      })("keydown.esc", function TuiHostedDropdownComponent_keydown_esc_HostBindingHandler($event) {
        return ctx.onKeyDownEsc($event);
      })("keydown.arrowDown", function TuiHostedDropdownComponent_keydown_arrowDown_HostBindingHandler($event) {
        return ctx.onArrow($event, true);
      })("keydown.arrowUp", function TuiHostedDropdownComponent_keydown_arrowUp_HostBindingHandler($event) {
        return ctx.onArrow($event, false);
      });
    }
    if (rf & 2) {
      core_js_["ɵɵclassProp"]("_hosted_dropdown_focused", ctx.focused);
    }
  },
  inputs: {
    content: "content",
    canOpen: "canOpen",
    open: "open"
  },
  outputs: {
    openChange: "openChange",
    focusedChange: "focusedChange"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ,
    useExisting: (0,core_js_.forwardRef)(() => TuiHostedDropdownComponent_1)
  }, DROPDOWN_CONTROLLER_PROVIDER])],
  ngContentSelectors: taiga_ui_core_components_hosted_dropdown_c2,
  decls: 5,
  vars: 10,
  consts: [[1, "t-wrapper", 3, "tuiDropdownAlign", "tuiDropdownDirection", "tuiDropdownHost", "tuiDropdownLimitWidth", "tuiDropdownMinHeight", "tuiDropdownMaxHeight", "tuiDropdownSided", "tuiDropdownContent", "tuiDropdown", "tuiObscuredEnabled", "tuiObscured", "tuiActiveZoneChange"], ["activeZone", "tuiActiveZone"], ["polymorpheus", ""], ["dropdown", "polymorpheus"], ["polymorpheus-outlet", "", 3, "content", "context", "keydown.esc", "keydown"], ["wrapper", ""]],
  template: function TuiHostedDropdownComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"]();
      core_js_["ɵɵelementStart"](0, "div", 0, 1);
      core_js_["ɵɵlistener"]("tuiObscured", function TuiHostedDropdownComponent_Template_div_tuiObscured_0_listener($event) {
        return ctx.onHostObscured($event);
      })("tuiActiveZoneChange", function TuiHostedDropdownComponent_Template_div_tuiActiveZoneChange_0_listener($event) {
        return ctx.onActiveZone($event);
      });
      core_js_["ɵɵprojection"](2);
      core_js_["ɵɵtemplate"](3, TuiHostedDropdownComponent_ng_template_3_Template, 3, 4, "ng-template", 2, 3, core_js_["ɵɵtemplateRefExtractor"]);
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      const _r1 = core_js_["ɵɵreference"](4);
      core_js_["ɵɵproperty"]("tuiDropdownAlign", ctx.controller.align)("tuiDropdownDirection", ctx.controller.direction)("tuiDropdownHost", ctx.nativeFocusableElement)("tuiDropdownLimitWidth", ctx.controller.limitWidth)("tuiDropdownMinHeight", ctx.controller.minHeight)("tuiDropdownMaxHeight", ctx.controller.maxHeight)("tuiDropdownSided", ctx.controller.sided)("tuiDropdownContent", _r1)("tuiDropdown", ctx.open && ctx.canOpen)("tuiObscuredEnabled", ctx.open);
    }
  },
  directives: [TuiDropdownDirective, TuiObscuredDirective, TuiActiveZoneDirective, tinkoff_ng_polymorpheus/* PolymorpheusTemplate */.GL, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1],
  styles: ["[_nghost-%COMP%]{display:inline-flex}.t-wrapper[_ngcontent-%COMP%]{border-radius:inherit;height:inherit;flex:1 1 auto;width:100%}"],
  changeDetection: 0
});
TuiHostedDropdownComponent.ctorParameters = () => [{
  type: core_js_.ElementRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ElementRef]
  }]
}, {
  type: TuiDropdownControllerDirective,
  decorators: [{
    type: core_js_.Inject,
    args: [TUI_DROPDOWN_WATCHED_CONTROLLER]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChild)(TuiHostedDropdownConnectorDirective, {
  read: core_js_.ElementRef
})], TuiHostedDropdownComponent.prototype, "dropdownHost", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('wrapper', {
  read: core_js_.ElementRef
})], TuiHostedDropdownComponent.prototype, "wrapper", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)(TuiDropdownDirective)], TuiHostedDropdownComponent.prototype, "dropdownDirective", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHostedDropdownComponent.prototype, "content", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHostedDropdownComponent.prototype, "canOpen", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiHostedDropdownComponent.prototype, "open", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiHostedDropdownComponent.prototype, "openChange", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiHostedDropdownComponent.prototype, "focusedChange", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._hosted_dropdown_focused')], TuiHostedDropdownComponent.prototype, "focused", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('focusin', ['$event.target'])], TuiHostedDropdownComponent.prototype, "onFocusIn", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('click', ['$event.target'])], TuiHostedDropdownComponent.prototype, "onClick", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('keydown.esc', ['$event'])], TuiHostedDropdownComponent.prototype, "onKeyDownEsc", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('keydown.arrowDown', ['$event', 'true']), (0,core_js_.HostListener)('keydown.arrowUp', ['$event', 'false'])], TuiHostedDropdownComponent.prototype, "onArrow", null);
TuiHostedDropdownComponent = TuiHostedDropdownComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_DROPDOWN_WATCHED_CONTROLLER))], TuiHostedDropdownComponent);
let TuiHostedDropdownModule = /*#__PURE__*/(() => {
  let TuiHostedDropdownModule = class TuiHostedDropdownModule {};
  TuiHostedDropdownModule.ɵfac = function TuiHostedDropdownModule_Factory(t) {
    return new (t || TuiHostedDropdownModule)();
  };
  TuiHostedDropdownModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiHostedDropdownModule
  });
  TuiHostedDropdownModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, TuiObscuredModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiActiveZoneModule, TuiDropdownModule]]
  });
  return TuiHostedDropdownModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiHostedDropdownModule, {
    declarations: function () {
      return [TuiHostedDropdownComponent, TuiHostedDropdownConnectorDirective];
    },
    imports: function () {
      return [common_js_.CommonModule, TuiObscuredModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiActiveZoneModule, TuiDropdownModule];
    },
    exports: function () {
      return [TuiHostedDropdownComponent, TuiHostedDropdownConnectorDirective];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-hosted-dropdown.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-arrow.js






// TODO: 3.0 remove in ivy compilation




function TuiArrowComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 1);
  }
  if (rf & 2) {
    const icon_r1 = ctx.$implicit;
    core_js_["ɵɵproperty"]("src", icon_r1);
  }
}
const TUI_ARROW_ICON_SMALL = `tuiIconChevronDown`;
const TUI_ARROW_ICON_LARGE = `tuiIconChevronDownLarge`;
/** Default values for arrow options */
const TUI_ARROW_DEFAULT_OPTIONS = {
  iconSmall: TUI_ARROW_ICON_SMALL,
  iconLarge: TUI_ARROW_ICON_LARGE
};
const TUI_ARROW_OPTIONS = new core_js_.InjectionToken(`Default parameters for arrow component`, {
  factory: () => TUI_ARROW_DEFAULT_OPTIONS
});
const tuiArrowOptionsProvider = options => ({
  provide: TUI_ARROW_OPTIONS,
  useValue: Object.assign(Object.assign({}, TUI_ARROW_DEFAULT_OPTIONS), options)
});
const TUI_ARROW_MODE = new core_js_.InjectionToken(`Type of icon in dropdowns for interactive or disable mode`, {
  factory: () => ({
    interactive: TUI_ARROW,
    disabled: TUI_ARROW
  })
});
const tuiArrowModeProvider = options => ({
  provide: TUI_ARROW_MODE,
  useValue: Object.assign({
    interactive: TUI_ARROW,
    disabled: TUI_ARROW
  }, options)
});
let TuiArrowComponent = /*#__PURE__*/(() => {
  let TuiArrowComponent = class TuiArrowComponent {
    constructor(dropdown, textfieldSize, options) {
      this.dropdown = dropdown;
      this.textfieldSize = textfieldSize;
      this.options = options;
    }
    get arrowIcon() {
      return (0,taiga_ui_core_utils_miscellaneous/* sizeBigger */.Bb)(this.textfieldSize.size) ? this.options.iconLarge : this.options.iconSmall;
    }
  };
  TuiArrowComponent.ɵfac = function TuiArrowComponent_Factory(t) {
    return new (t || TuiArrowComponent)(core_js_["ɵɵdirectiveInject"](TuiHostedDropdownComponent), core_js_["ɵɵdirectiveInject"](TUI_TEXTFIELD_SIZE), core_js_["ɵɵdirectiveInject"](TUI_ARROW_OPTIONS));
  };
  TuiArrowComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiArrowComponent,
    selectors: [["tui-arrow"]],
    decls: 3,
    vars: 5,
    consts: [["polymorpheus-outlet", "", 1, "t-icon", 3, "content"], [3, "src"]],
    template: function TuiArrowComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵelementStart"](0, "span", 0);
        core_js_["ɵɵpipe"](1, "async");
        core_js_["ɵɵtemplate"](2, TuiArrowComponent_ng_template_2_Template, 1, 1, "ng-template");
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("t-icon_rotated", core_js_["ɵɵpipeBind1"](1, 3, ctx.dropdown.openChange));
        core_js_["ɵɵproperty"]("content", ctx.arrowIcon);
      }
    },
    directives: [tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, taiga_ui_core_components_svg/* TuiSvgComponent */.P],
    pipes: [common_js_.AsyncPipe],
    styles: [".t-icon[_ngcontent-%COMP%]{transition-property:transform;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;display:block;cursor:pointer;pointer-events:none}.t-icon_rotated[_ngcontent-%COMP%]{transform:rotate(180deg)}"],
    changeDetection: 0
  });
  TuiArrowComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TuiHostedDropdownComponent)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_TEXTFIELD_SIZE)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(TUI_ARROW_OPTIONS))], TuiArrowComponent);
  return TuiArrowComponent;
})();
const TUI_ARROW = new tinkoff_ng_polymorpheus/* PolymorpheusComponent */.Al(TuiArrowComponent);
let TuiArrowModule = /*#__PURE__*/(() => {
  let TuiArrowModule = class TuiArrowModule {};
  TuiArrowModule.ɵfac = function TuiArrowModule_Factory(t) {
    return new (t || TuiArrowModule)();
  };
  TuiArrowModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiArrowModule
  });
  TuiArrowModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq]]
  });
  return TuiArrowModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiArrowModule, {
    declarations: function () {
      return [TuiArrowComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq];
    },
    exports: function () {
      return [TuiArrowComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-arrow.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-directives-scroll-into-view.js








/**
 * Directive scrolls element into view inside tui-scrollbar
 */
// @dynamic


let TuiScrollIntoViewDirective = /*#__PURE__*/(() => {
  let TuiScrollIntoViewDirective = class TuiScrollIntoViewDirective {
    constructor(elementRef, documentRef, destroy$) {
      this.elementRef = elementRef;
      this.documentRef = documentRef;
      this.destroy$ = destroy$;
    }
    set tuiScrollIntoView(scroll) {
      if (!scroll) {
        return;
      }
      // Timeout is necessary in order to give element render cycle to get into its final spot
      // (for example if it is inside dropdown box which has to be positioned first)
      (0,observable_timer/* timer */.H)(0).pipe((0,operators_takeUntil/* takeUntil */.R)(this.destroy$)).subscribe(() => {
        this.elementRef.nativeElement.dispatchEvent((0,taiga_ui_cdk_utils_dom/* tuiCustomEvent */.hO)(taiga_ui_core_constants/* TUI_SCROLL_INTO_VIEW */.fe, {
          bubbles: true,
          detail: this.elementRef.nativeElement
        }, this.documentRef));
      });
    }
  };
  TuiScrollIntoViewDirective.ɵfac = function TuiScrollIntoViewDirective_Factory(t) {
    return new (t || TuiScrollIntoViewDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](common_js_.DOCUMENT), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3));
  };
  TuiScrollIntoViewDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiScrollIntoViewDirective,
    selectors: [["", "tuiScrollIntoView", ""]],
    inputs: {
      tuiScrollIntoView: "tuiScrollIntoView"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiRequiredSetter */.NH)()], TuiScrollIntoViewDirective.prototype, "tuiScrollIntoView", null);
  TuiScrollIntoViewDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(common_js_.DOCUMENT)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3))], TuiScrollIntoViewDirective);
  return TuiScrollIntoViewDirective;
})();
let TuiScrollIntoViewModule = /*#__PURE__*/(() => {
  let TuiScrollIntoViewModule = class TuiScrollIntoViewModule {};
  TuiScrollIntoViewModule.ɵfac = function TuiScrollIntoViewModule_Factory(t) {
    return new (t || TuiScrollIntoViewModule)();
  };
  TuiScrollIntoViewModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiScrollIntoViewModule
  });
  TuiScrollIntoViewModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiScrollIntoViewModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiScrollIntoViewModule, {
    declarations: [TuiScrollIntoViewDirective],
    exports: [TuiScrollIntoViewDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-directives-scroll-into-view.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-select-option.js













function TuiSelectOptionComponent_tui_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 3);
  }
  if (rf & 2) {
    core_js_["ɵɵproperty"]("tuiScrollIntoView", true);
  }
}
function TuiSelectOptionComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "span", 4);
  }
}
let TuiSelectOptionComponent = /*#__PURE__*/(() => {
  let TuiSelectOptionComponent = class TuiSelectOptionComponent {
    constructor(context, host, elementRef, option, control) {
      var _a;
      this.context = context;
      this.host = host;
      this.elementRef = elementRef;
      this.option = option;
      this.control = control;
      this.selected$ = (0,observable_merge/* merge */.T)((_a = this.control.valueChanges) !== null && _a !== void 0 ? _a : observable_empty/* EMPTY */.E, (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(this.elementRef.nativeElement, 'animationstart')).pipe((0,operators_startWith/* startWith */.O)(null), (0,operators_map/* map */.U)(() => this.selected), (0,operators_distinctUntilChanged/* distinctUntilChanged */.x)());
    }
    get matcher() {
      return this.host.identityMatcher || taiga_ui_cdk_constants/* TUI_DEFAULT_IDENTITY_MATCHER */.bg;
    }
    ngOnInit() {
      /**
       * This would cause changes inside already checked parent component (during the same change detection cycle),
       * and it might cause ExpressionChanged error due to potential HostBinding
       * (for example, inside {@link https://github.com/angular/angular/blob/main/packages/forms/src/directives/ng_control_status.ts#L99 NgControlStatus}).
       * Microtask keeps it in the same frame but allows change detection to run.
       */
      // eslint-disable-next-line @typescript-eslint/no-floating-promises
      Promise.resolve().then(() => {
        if ((0,taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN)(this.option.value) && this.host.checkOption) {
          this.host.checkOption(this.option.value);
        }
      });
    }
    get selected() {
      return (0,taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN)(this.option.value) && (0,taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN)(this.control.value) && this.matcher(this.control.value, this.option.value);
    }
  };
  TuiSelectOptionComponent.ɵfac = function TuiSelectOptionComponent_Factory(t) {
    return new (t || TuiSelectOptionComponent)(core_js_["ɵɵdirectiveInject"](tinkoff_ng_polymorpheus/* POLYMORPHEUS_CONTEXT */.yf), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_DATA_LIST_HOST */.N1), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](TuiOptionComponent), core_js_["ɵɵdirectiveInject"](fesm2015_forms.NgControl));
  };
  TuiSelectOptionComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiSelectOptionComponent,
    selectors: [["tui-select-option"]],
    decls: 5,
    vars: 5,
    consts: [[3, "ngTemplateOutlet"], ["automation-id", "tui-select-option__checkmark", "src", "tuiIconCheckLarge", "class", "t-checkmark", 3, "tuiScrollIntoView", 4, "ngIf", "ngIfElse"], ["dummy", ""], ["automation-id", "tui-select-option__checkmark", "src", "tuiIconCheckLarge", 1, "t-checkmark", 3, "tuiScrollIntoView"], [1, "t-dummy"]],
    template: function TuiSelectOptionComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵelementContainer"](0, 0);
        core_js_["ɵɵtemplate"](1, TuiSelectOptionComponent_tui_svg_1_Template, 1, 1, "tui-svg", 1);
        core_js_["ɵɵpipe"](2, "async");
        core_js_["ɵɵtemplate"](3, TuiSelectOptionComponent_ng_template_3_Template, 1, 0, "ng-template", null, 2, core_js_["ɵɵtemplateRefExtractor"]);
      }
      if (rf & 2) {
        const _r1 = core_js_["ɵɵreference"](4);
        core_js_["ɵɵproperty"]("ngTemplateOutlet", ctx.context.$implicit);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", core_js_["ɵɵpipeBind1"](2, 3, ctx.selected$))("ngIfElse", _r1);
      }
    },
    directives: [common_js_.NgTemplateOutlet, common_js_.NgIf, taiga_ui_core_components_svg/* TuiSvgComponent */.P, TuiScrollIntoViewDirective],
    pipes: [common_js_.AsyncPipe],
    styles: ["@keyframes retrigger{from{left:1px}to{left:2px}}[_nghost-%COMP%]{display:flex;flex:1;align-items:center;max-width:100%;animation:1s retrigger}.t-checkmark[_ngcontent-%COMP%]{margin:0 -.375rem 0 auto;border-left:5px solid transparent}.t-dummy[_ngcontent-%COMP%]{width:1.5rem}"],
    changeDetection: 0
  });
  TuiSelectOptionComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(tinkoff_ng_polymorpheus/* POLYMORPHEUS_CONTEXT */.yf)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_DATA_LIST_HOST */.N1)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TuiOptionComponent)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(fesm2015_forms.NgControl))], TuiSelectOptionComponent);
  return TuiSelectOptionComponent;
})();
const TUI_SELECT_OPTION = new tinkoff_ng_polymorpheus/* PolymorpheusComponent */.Al(TuiSelectOptionComponent);
let TuiSelectOptionModule = /*#__PURE__*/(() => {
  let TuiSelectOptionModule = class TuiSelectOptionModule {};
  TuiSelectOptionModule.ɵfac = function TuiSelectOptionModule_Factory(t) {
    return new (t || TuiSelectOptionModule)();
  };
  TuiSelectOptionModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiSelectOptionModule
  });
  TuiSelectOptionModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiScrollIntoViewModule]]
  });
  return TuiSelectOptionModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiSelectOptionModule, {
    declarations: function () {
      return [TuiSelectOptionComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiScrollIntoViewModule];
    },
    exports: function () {
      return [TuiSelectOptionComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-select-option.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-pipes-month.js






// @dynamic


let TuiMonthPipe = /*#__PURE__*/(() => {
  let TuiMonthPipe = class TuiMonthPipe {
    constructor(months$) {
      this.months$ = months$;
    }
    transform({
      month
    }) {
      return this.months$.pipe((0,operators_map/* map */.U)(months => months[month]));
    }
  };
  TuiMonthPipe.ɵfac = function TuiMonthPipe_Factory(t) {
    return new (t || TuiMonthPipe)(core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_MONTHS */.$R, 16));
  };
  TuiMonthPipe.ɵpipe = /*@__PURE__*/core_js_["ɵɵdefinePipe"]({
    name: "tuiMonth",
    type: TuiMonthPipe,
    pure: true
  });
  TuiMonthPipe = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_MONTHS */.$R))], TuiMonthPipe);
  return TuiMonthPipe;
})();
let TuiMonthPipeModule = /*#__PURE__*/(() => {
  let TuiMonthPipeModule = class TuiMonthPipeModule {};
  TuiMonthPipeModule.ɵfac = function TuiMonthPipeModule_Factory(t) {
    return new (t || TuiMonthPipeModule)();
  };
  TuiMonthPipeModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiMonthPipeModule
  });
  TuiMonthPipeModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiMonthPipeModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiMonthPipeModule, {
    declarations: [TuiMonthPipe],
    exports: [TuiMonthPipe]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-pipes-month.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/identity.js
var util_identity = __webpack_require__(4487);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-providers.js






const TUI_MONTH_FORMATTER_PROVIDER = {
  provide: TUI_MONTH_FORMATTER,
  deps: [TuiMonthPipe],
  useFactory: monthFormatterFactory
};
/**
 * Range.setStart/set-end, except it uses offset in characters only
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function monthFormatterFactory(pipe) {
  return month => month ? pipe.transform(month).pipe((0,operators_map/* map */.U)(formatted => `${formatted} ${month.formattedYear}`)) : (0,observable_of.of)(``);
}

// eslint-disable-next-line @typescript-eslint/naming-convention
function fixedDropdownControllerFactory(directive) {
  directive = directive || new TuiDropdownControllerDirective();
  directive.limitWidth = `fixed`;
  return directive;
}
const FIXED_DROPDOWN_CONTROLLER_PROVIDER = [{
  provide: TUI_DROPDOWN_CONTROLLER,
  deps: [[new core_js_.Optional(), TuiDropdownControllerDirective]],
  useFactory: fixedDropdownControllerFactory
}];
// eslint-disable-next-line @typescript-eslint/naming-convention
function leftAlignedDropdownControllerFactory(directive) {
  directive = directive || new TuiDropdownControllerDirective();
  directive.align = `left`;
  return directive;
}
const LEFT_ALIGNED_DROPDOWN_CONTROLLER_PROVIDER = [{
  provide: TUI_DROPDOWN_CONTROLLER,
  deps: [[new core_js_.Optional(), TuiDropdownControllerDirective]],
  useFactory: leftAlignedDropdownControllerFactory
}];

// TODO: 3.0 remove in ivy compilation
const IDENTITY = util_identity/* identity */.y;
const TUI_VALUE_ACCESSOR_PROVIDER = {
  provide: taiga_ui_core_tokens/* TUI_VALUE_ACCESSOR */.sE,
  deps: [[new core_js_.Optional(), new core_js_.Self(), fesm2015_forms.NG_VALUE_ACCESSOR]],
  useFactory: IDENTITY
};

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-providers.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-select.js












// TODO: 3.0 remove in ivy compilation






function TuiSelectComponent_div_4_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 4);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const primitiveValue_r2 = ctx.$implicit;
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate"](primitiveValue_r2);
  }
}
const taiga_ui_kit_components_select_c0 = function (a0, a1) {
  return {
    $implicit: a0,
    active: a1
  };
};
function TuiSelectComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 3);
    core_js_["ɵɵtemplate"](1, TuiSelectComponent_div_4_ng_template_1_Template, 2, 1, "ng-template");
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("content", ctx_r0.computedContent)("context", core_js_["ɵɵpureFunction2"](2, taiga_ui_kit_components_select_c0, ctx_r0.value, ctx_r0.computedFocused));
  }
}
const taiga_ui_kit_components_select_c1 = ["*", [["input"]]];
const taiga_ui_kit_components_select_c2 = ["*", "input"];
const SELECT_OPTION = TUI_SELECT_OPTION;
const TUI_SELECT_PROVIDERS = [{
  provide: taiga_ui_cdk_abstract/* AbstractTuiControl */.M$,
  useExisting: (0,core_js_.forwardRef)(() => TuiSelectComponent)
}, {
  provide: taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ,
  useExisting: (0,core_js_.forwardRef)(() => TuiSelectComponent)
}, {
  provide: taiga_ui_core_tokens/* TUI_DATA_LIST_HOST */.N1,
  useExisting: (0,core_js_.forwardRef)(() => TuiSelectComponent)
}, {
  provide: taiga_ui_core_tokens/* TUI_OPTION_CONTENT */.IQ,
  useValue: SELECT_OPTION
}, FIXED_DROPDOWN_CONTROLLER_PROVIDER];
const TUI_SELECT_DEFAULT_OPTIONS = {
  valueContent: ``
};
const TUI_SELECT_OPTIONS = new core_js_.InjectionToken(`Default parameters for select component`, {
  factory: () => TUI_SELECT_DEFAULT_OPTIONS
});
const tuiSelectOptionsProvider = options => ({
  provide: TUI_SELECT_OPTIONS,
  useValue: Object.assign(Object.assign({}, TUI_SELECT_DEFAULT_OPTIONS), options)
});
let TuiSelectComponent = /*#__PURE__*/(() => {
  let TuiSelectComponent = class TuiSelectComponent extends taiga_ui_cdk_abstract/* AbstractTuiNullableControl */.F9 {
    constructor(control, changeDetectorRef, textfieldCleaner, arrowMode, itemsHandlers, options) {
      super(control, changeDetectorRef);
      this.textfieldCleaner = textfieldCleaner;
      this.arrowMode = arrowMode;
      this.itemsHandlers = itemsHandlers;
      this.options = options;
      this.stringify = this.itemsHandlers.stringify;
      this.identityMatcher = this.itemsHandlers.identityMatcher;
      this.valueContent = this.options.valueContent;
      this.datalist = '';
    }
    get arrow() {
      return !this.interactive ? this.arrowMode.disabled : this.arrowMode.interactive;
    }
    get nativeFocusableElement() {
      return this.textfield ? this.textfield.nativeFocusableElement : null;
    }
    get focused() {
      return (0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(this.nativeFocusableElement) || !!this.hostedDropdown && this.hostedDropdown.focused;
    }
    get computedValue() {
      return this.value === null ? '' : this.stringify(this.value) || ' ';
    }
    get computedContent() {
      return this.valueContent || this.computedValue;
    }
    onValueChange(value) {
      if (!value) {
        this.updateValue(null);
      }
    }
    onActiveZone(active) {
      this.updateFocused(active);
    }
    onHovered(hovered) {
      this.updateHovered(hovered);
    }
    onKeyDownDelete() {
      if (this.textfieldCleaner.cleaner) {
        this.updateValue(null);
      }
    }
    handleOption(option) {
      var _a;
      this.focusInput();
      this.updateValue(option);
      (_a = this.hostedDropdown) === null || _a === void 0 ? void 0 : _a.updateOpen(false);
    }
    focusInput(preventScroll = false) {
      if (this.nativeFocusableElement) {
        (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(this.nativeFocusableElement, true, preventScroll);
      }
    }
  };
  TuiSelectComponent.ɵfac = function TuiSelectComponent_Factory(t) {
    return new (t || TuiSelectComponent)(core_js_["ɵɵdirectiveInject"](fesm2015_forms.NgControl, 10), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](TUI_TEXTFIELD_CLEANER), core_js_["ɵɵdirectiveInject"](TUI_ARROW_MODE), core_js_["ɵɵdirectiveInject"](TUI_ITEMS_HANDLERS), core_js_["ɵɵdirectiveInject"](TUI_SELECT_OPTIONS));
  };
  TuiSelectComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiSelectComponent,
    selectors: [["tui-select"]],
    contentQueries: function TuiSelectComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        core_js_["ɵɵcontentQuery"](dirIndex, TuiDataListDirective, 5, core_js_.TemplateRef);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.datalist = _t.first);
      }
    },
    viewQuery: function TuiSelectComponent_Query(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵviewQuery"](TuiPrimitiveTextfieldComponent, 5);
        core_js_["ɵɵviewQuery"](TuiHostedDropdownComponent, 5);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.textfield = _t.first);
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.hostedDropdown = _t.first);
      }
    },
    inputs: {
      stringify: "stringify",
      identityMatcher: "identityMatcher",
      valueContent: "valueContent"
    },
    features: [core_js_["ɵɵProvidersFeature"](TUI_SELECT_PROVIDERS), core_js_["ɵɵInheritDefinitionFeature"]],
    ngContentSelectors: taiga_ui_kit_components_select_c2,
    decls: 5,
    vars: 14,
    consts: [[1, "t-hosted", 3, "canOpen", "content", "tuiActiveZoneChange"], ["automation-id", "tui-select__textfield", 1, "t-textfield", 3, "editable", "pseudoFocused", "pseudoHovered", "pseudoPressed", "invalid", "nativeId", "readOnly", "iconContent", "disabled", "focusable", "value", "valueChange", "hoveredChange", "keydown.delete.prevent", "keydown.backspace.prevent"], ["polymorpheus-outlet", "", "automation-id", "tui-select__value", "class", "t-value", 3, "content", "context", 4, "ngIf"], ["polymorpheus-outlet", "", "automation-id", "tui-select__value", 1, "t-value", 3, "content", "context"], [1, "t-primitive-value"]],
    template: function TuiSelectComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"](taiga_ui_kit_components_select_c1);
        core_js_["ɵɵelementStart"](0, "tui-hosted-dropdown", 0);
        core_js_["ɵɵlistener"]("tuiActiveZoneChange", function TuiSelectComponent_Template_tui_hosted_dropdown_tuiActiveZoneChange_0_listener($event) {
          return ctx.onActiveZone($event);
        });
        core_js_["ɵɵelementStart"](1, "tui-primitive-textfield", 1);
        core_js_["ɵɵlistener"]("valueChange", function TuiSelectComponent_Template_tui_primitive_textfield_valueChange_1_listener($event) {
          return ctx.onValueChange($event);
        })("hoveredChange", function TuiSelectComponent_Template_tui_primitive_textfield_hoveredChange_1_listener($event) {
          return ctx.onHovered($event);
        })("keydown.delete.prevent", function TuiSelectComponent_Template_tui_primitive_textfield_keydown_delete_prevent_1_listener() {
          return ctx.onKeyDownDelete();
        })("keydown.backspace.prevent", function TuiSelectComponent_Template_tui_primitive_textfield_keydown_backspace_prevent_1_listener() {
          return ctx.onKeyDownDelete();
        });
        core_js_["ɵɵprojection"](2);
        core_js_["ɵɵprojection"](3, 1, ["ngProjectAs", "input", 5, ["input"]]);
        core_js_["ɵɵtemplate"](4, TuiSelectComponent_div_4_Template, 2, 5, "div", 2);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("canOpen", ctx.interactive)("content", ctx.datalist || "");
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("editable", false)("pseudoFocused", ctx.computedFocused)("pseudoHovered", ctx.pseudoHovered)("pseudoPressed", ctx.pseudoPressed)("invalid", ctx.computedInvalid)("nativeId", ctx.nativeId)("readOnly", ctx.readOnly)("iconContent", ctx.arrow)("disabled", ctx.computedDisabled)("focusable", ctx.computedFocusable)("value", ctx.computedValue);
        core_js_["ɵɵadvance"](3);
        core_js_["ɵɵproperty"]("ngIf", ctx.value !== null);
      }
    },
    directives: [TuiHostedDropdownComponent, TuiActiveZoneDirective, TuiPrimitiveTextfieldComponent, TuiPrimitiveTextfieldDirective, common_js_.NgIf, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1],
    styles: ["[_nghost-%COMP%]{display:block;border-radius:var(--tui-radius-m);text-align:left}[_nghost-%COMP%]:not(._readonly)     input:not(:disabled){cursor:pointer}._readonly[_nghost-%COMP%]     input{cursor:default}.t-hosted[_ngcontent-%COMP%]{display:block;border-radius:inherit}.t-textfield[_ngcontent-%COMP%]{border-radius:inherit;text-align:inherit}.t-value[_ngcontent-%COMP%]{display:flex;width:100%;align-items:center}.t-primitive-value[_ngcontent-%COMP%]{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)(TuiPrimitiveTextfieldComponent)], TuiSelectComponent.prototype, "textfield", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)(TuiHostedDropdownComponent)], TuiSelectComponent.prototype, "hostedDropdown", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiSelectComponent.prototype, "stringify", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiSelectComponent.prototype, "identityMatcher", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiSelectComponent.prototype, "valueContent", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChild)(TuiDataListDirective, {
    read: core_js_.TemplateRef
  })], TuiSelectComponent.prototype, "datalist", void 0);
  TuiSelectComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(fesm2015_forms.NgControl)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(TUI_TEXTFIELD_CLEANER)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TUI_ARROW_MODE)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(TUI_ITEMS_HANDLERS)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(TUI_SELECT_OPTIONS))], TuiSelectComponent);
  return TuiSelectComponent;
})();
var TuiSelectDirective_1;
let TuiSelectDirective = TuiSelectDirective_1 = class TuiSelectDirective extends TuiAbstractTextfieldHost {
  get readOnly() {
    return true;
  }
  get value() {
    return this.host.computedValue;
  }
  onValueChange(value) {
    this.host.onValueChange(value);
  }
};
TuiSelectDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiSelectDirective_BaseFactory;
  return function TuiSelectDirective_Factory(t) {
    return (ɵTuiSelectDirective_BaseFactory || (ɵTuiSelectDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiSelectDirective)))(t || TuiSelectDirective);
  };
}();
TuiSelectDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiSelectDirective,
  selectors: [["tui-select"]],
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_core_tokens/* TUI_TEXTFIELD_HOST */.S0,
    useExisting: (0,core_js_.forwardRef)(() => TuiSelectDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
let TuiSelectModule = /*#__PURE__*/(() => {
  let TuiSelectModule = class TuiSelectModule {};
  TuiSelectModule.ɵfac = function TuiSelectModule_Factory(t) {
    return new (t || TuiSelectModule)();
  };
  TuiSelectModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiSelectModule
  });
  TuiSelectModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiActiveZoneModule, TuiPrimitiveTextfieldModule, TuiHostedDropdownModule, TuiSelectOptionModule, TuiArrowModule]]
  });
  return TuiSelectModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiSelectModule, {
    declarations: function () {
      return [TuiSelectComponent, TuiSelectDirective];
    },
    imports: function () {
      return [common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiActiveZoneModule, TuiPrimitiveTextfieldModule, TuiHostedDropdownModule, TuiSelectOptionModule, TuiArrowModule];
    },
    exports: function () {
      return [TuiSelectComponent, TuiSelectDirective, TuiTextfieldComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-select.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-pressed.js





let TuiPressedDirective = /*#__PURE__*/(() => {
  let TuiPressedDirective = class TuiPressedDirective {
    constructor(elementRef, takeOnlyTrustedEvents) {
      this.elementRef = elementRef;
      this.takeOnlyTrustedEvents = takeOnlyTrustedEvents;
      this.tuiPressedChange = (0,taiga_ui_cdk_observables/* pressedObservable */._d)(this.elementRef.nativeElement, {
        onlyTrusted: this.takeOnlyTrustedEvents
      });
    }
  };
  TuiPressedDirective.ɵfac = function TuiPressedDirective_Factory(t) {
    return new (t || TuiPressedDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_TAKE_ONLY_TRUSTED_EVENTS */.wx));
  };
  TuiPressedDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiPressedDirective,
    selectors: [["", "tuiPressedChange", ""]],
    outputs: {
      tuiPressedChange: "tuiPressedChange"
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiPressedDirective.prototype, "tuiPressedChange", void 0);
  TuiPressedDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_TAKE_ONLY_TRUSTED_EVENTS */.wx))], TuiPressedDirective);
  return TuiPressedDirective;
})();
let TuiPressedModule = /*#__PURE__*/(() => {
  let TuiPressedModule = class TuiPressedModule {};
  TuiPressedModule.ɵfac = function TuiPressedModule_Factory(t) {
    return new (t || TuiPressedModule)();
  };
  TuiPressedModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiPressedModule
  });
  TuiPressedModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiPressedModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiPressedModule, {
    declarations: [TuiPressedDirective],
    exports: [TuiPressedDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-pressed.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-checked.js



let TuiCheckedDirective = /*#__PURE__*/(() => {
  let TuiCheckedDirective = class TuiCheckedDirective {
    constructor(element, renderer) {
      this.element = element;
      this.renderer = renderer;
      this.tuiCheckedChange = new core_js_.EventEmitter();
      this.updateProperty('checked', false);
    }
    set tuiChecked(checked) {
      this.updateProperty('checked', checked || false);
      this.updateProperty('indeterminate', checked === null);
    }
    onChange({
      checked
    }) {
      this.updateProperty('indeterminate', false);
      this.tuiCheckedChange.emit(checked);
    }
    updateProperty(property, value) {
      this.renderer.setProperty(this.element.nativeElement, property, value);
    }
  };
  TuiCheckedDirective.ɵfac = function TuiCheckedDirective_Factory(t) {
    return new (t || TuiCheckedDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.Renderer2));
  };
  TuiCheckedDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiCheckedDirective,
    selectors: [["input", "tuiChecked", ""], ["input", "tuiCheckedChange", ""]],
    hostBindings: function TuiCheckedDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("change", function TuiCheckedDirective_change_HostBindingHandler($event) {
          return ctx.onChange($event.target);
        });
      }
    },
    inputs: {
      tuiChecked: "tuiChecked"
    },
    outputs: {
      tuiCheckedChange: "tuiCheckedChange"
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiCheckedDirective.prototype, "tuiChecked", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiCheckedDirective.prototype, "tuiCheckedChange", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('change', ['$event.target'])], TuiCheckedDirective.prototype, "onChange", null);
  TuiCheckedDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.Renderer2))], TuiCheckedDirective);
  return TuiCheckedDirective;
})();
let TuiCheckedModule = /*#__PURE__*/(() => {
  let TuiCheckedModule = class TuiCheckedModule {};
  TuiCheckedModule.ɵfac = function TuiCheckedModule_Factory(t) {
    return new (t || TuiCheckedModule)();
  };
  TuiCheckedModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiCheckedModule
  });
  TuiCheckedModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiCheckedModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiCheckedModule, {
    declarations: [TuiCheckedDirective],
    exports: [TuiCheckedDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-checked.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-focused.js







/**
 * Directive to monitor focus/blur status, works with focusIn/focus-out
 * instead of focus/blur to sync events order with Internet Explorer and
 * other focus related directives that require bubbling
 */

let TuiFocusedDirective = /*#__PURE__*/(() => {
  let TuiFocusedDirective = class TuiFocusedDirective {
    constructor({
      nativeElement
    }, ngZone) {
      this.tuiFocusedChange = (0,observable_merge/* merge */.T)((0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, 'focusin'), (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, 'focusout')).pipe((0,operators_map/* map */.U)(() => (0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(nativeElement)), (0,operators_startWith/* startWith */.O)(false), (0,operators_distinctUntilChanged/* distinctUntilChanged */.x)(), skip(1), (0,taiga_ui_cdk_observables/* tuiZoneOptimized */.Yr)(ngZone));
    }
  };
  TuiFocusedDirective.ɵfac = function TuiFocusedDirective_Factory(t) {
    return new (t || TuiFocusedDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.NgZone));
  };
  TuiFocusedDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiFocusedDirective,
    selectors: [["", "tuiFocusedChange", ""]],
    outputs: {
      tuiFocusedChange: "tuiFocusedChange"
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiFocusedDirective.prototype, "tuiFocusedChange", void 0);
  TuiFocusedDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.NgZone))], TuiFocusedDirective);
  return TuiFocusedDirective;
})();
let TuiFocusedModule = /*#__PURE__*/(() => {
  let TuiFocusedModule = class TuiFocusedModule {};
  TuiFocusedModule.ɵfac = function TuiFocusedModule_Factory(t) {
    return new (t || TuiFocusedModule)();
  };
  TuiFocusedModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiFocusedModule
  });
  TuiFocusedModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiFocusedModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiFocusedModule, {
    declarations: [TuiFocusedDirective],
    exports: [TuiFocusedDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-focused.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-focus-visible.js





/**
 * Directive to imitate :focus-visible
 * (https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible)
 * in browsers that do not support it
 * @dynamic
 */


let TuiFocusVisibleDirective = /*#__PURE__*/(() => {
  let TuiFocusVisibleDirective = class TuiFocusVisibleDirective {
    constructor(tuiFocusVisibleChange) {
      this.tuiFocusVisibleChange = tuiFocusVisibleChange;
    }
  };
  TuiFocusVisibleDirective.ɵfac = function TuiFocusVisibleDirective_Factory(t) {
    return new (t || TuiFocusVisibleDirective)(core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiFocusVisibleService */.ku));
  };
  TuiFocusVisibleDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiFocusVisibleDirective,
    selectors: [["", "tuiFocusVisibleChange", ""]],
    outputs: {
      tuiFocusVisibleChange: "tuiFocusVisibleChange"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3, taiga_ui_cdk_services/* TuiFocusVisibleService */.ku])]
  });
  TuiFocusVisibleDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiFocusVisibleService */.ku))], TuiFocusVisibleDirective);
  return TuiFocusVisibleDirective;
})();
let TuiFocusVisibleModule = /*#__PURE__*/(() => {
  let TuiFocusVisibleModule = class TuiFocusVisibleModule {};
  TuiFocusVisibleModule.ɵfac = function TuiFocusVisibleModule_Factory(t) {
    return new (t || TuiFocusVisibleModule)();
  };
  TuiFocusVisibleModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiFocusVisibleModule
  });
  TuiFocusVisibleModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiFocusVisibleModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiFocusVisibleModule, {
    declarations: [TuiFocusVisibleDirective],
    exports: [TuiFocusVisibleDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-focus-visible.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-radio-group.js




const taiga_ui_kit_components_radio_group_c0 = ["*"];
var TuiRadioGroupComponent_1;
let TuiRadioGroupComponent = TuiRadioGroupComponent_1 = class TuiRadioGroupComponent {
  constructor() {
    this.name = `tui-radio-group-${TuiRadioGroupComponent_1.index++}`;
  }
};
TuiRadioGroupComponent.ɵfac = function TuiRadioGroupComponent_Factory(t) {
  return new (t || TuiRadioGroupComponent)();
};
TuiRadioGroupComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiRadioGroupComponent,
  selectors: [["tui-radio-group"]],
  inputs: {
    name: "name"
  },
  ngContentSelectors: taiga_ui_kit_components_radio_group_c0,
  decls: 1,
  vars: 0,
  template: function TuiRadioGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"]();
      core_js_["ɵɵprojection"](0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
TuiRadioGroupComponent.index = 0;
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiRadioGroupComponent.prototype, "name", void 0);
let TuiRadioGroupModule = /*#__PURE__*/(() => {
  let TuiRadioGroupModule = class TuiRadioGroupModule {};
  TuiRadioGroupModule.ɵfac = function TuiRadioGroupModule_Factory(t) {
    return new (t || TuiRadioGroupModule)();
  };
  TuiRadioGroupModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiRadioGroupModule
  });
  TuiRadioGroupModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiRadioGroupModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiRadioGroupModule, {
    declarations: [TuiRadioGroupComponent],
    exports: [TuiRadioGroupComponent]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-radio-group.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-radio.js








/** Default values for the checkbox options. */






const taiga_ui_kit_components_radio_c0 = ["focusableElement"];
function TuiRadioComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "div", 4);
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("@tuiScaleIn", ctx_r0.animation);
  }
}
const TUI_RADIO_DEFAULT_OPTIONS = {
  size: `m`,
  appearances: {
    unchecked: "outline" /* Outline */,
    checked: "primary" /* Primary */
  }
};

const TUI_RADIO_OPTIONS = new core_js_.InjectionToken(`Default parameters for radio component`, {
  factory: () => TUI_RADIO_DEFAULT_OPTIONS
});
const tuiRadioOptionsProvider = options => ({
  provide: TUI_RADIO_OPTIONS,
  useValue: Object.assign(Object.assign({}, TUI_RADIO_DEFAULT_OPTIONS), options)
});
var TuiRadioComponent_1;
// @dynamic
let TuiRadioComponent = TuiRadioComponent_1 = class TuiRadioComponent extends taiga_ui_cdk_abstract/* AbstractTuiNullableControl */.F9 {
  constructor(control, changeDetectorRef, animationOptions, options, radioGroup) {
    super(control, changeDetectorRef);
    this.animationOptions = animationOptions;
    this.options = options;
    this.radioGroup = radioGroup;
    this.identityMatcher = taiga_ui_cdk_constants/* TUI_DEFAULT_IDENTITY_MATCHER */.bg;
    this.name = null;
    this.size = this.options.size;
    this.pseudoDisabled = false;
    this.animation = Object.assign({
      value: ''
    }, this.animationOptions);
  }
  get appearance() {
    return this.checked ? this.options.appearances.checked : this.options.appearances.unchecked;
  }
  get computedDisabled() {
    return this.disabled || this.pseudoDisabled;
  }
  get nativeFocusableElement() {
    return !this.focusableElement || this.computedDisabled ? null : this.focusableElement.nativeElement;
  }
  get focused() {
    return (0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(this.nativeFocusableElement);
  }
  get checked() {
    return this.value === null ? this.item === null : this.item !== undefined && this.item !== null && this.identityMatcher(this.value, this.item);
  }
  get computedName() {
    return this.name || this.radioGroupName || this.controlName || '';
  }
  get isFocusable() {
    return !this.readOnly && this.computedFocusable;
  }
  onChecked(checked) {
    if (checked) {
      this.updateValue(this.item !== undefined ? this.item : this.fallbackValue);
    }
  }
  onFocused(focused) {
    this.updateFocused(focused);
  }
  onHovered(hovered) {
    this.updateHovered(hovered);
  }
  onPressed(pressed) {
    this.updatePressed(pressed);
  }
  onFocusVisible(focusVisible) {
    this.updateFocusVisible(focusVisible);
  }
  get radioGroupName() {
    return this.radioGroup === null ? null : this.radioGroup.name;
  }
};
TuiRadioComponent.ɵfac = function TuiRadioComponent_Factory(t) {
  return new (t || TuiRadioComponent)(core_js_["ɵɵdirectiveInject"](fesm2015_forms.NgControl, 10), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw), core_js_["ɵɵdirectiveInject"](TUI_RADIO_OPTIONS), core_js_["ɵɵdirectiveInject"](TuiRadioGroupComponent, 8));
};
TuiRadioComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiRadioComponent,
  selectors: [["tui-radio"]],
  viewQuery: function TuiRadioComponent_Query(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵviewQuery"](taiga_ui_kit_components_radio_c0, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.focusableElement = _t.first);
    }
  },
  hostVars: 3,
  hostBindings: function TuiRadioComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      core_js_["ɵɵattribute"]("data-size", ctx.size);
      core_js_["ɵɵclassProp"]("_disabled", ctx.computedDisabled);
    }
  },
  inputs: {
    identityMatcher: "identityMatcher",
    name: "name",
    size: "size",
    pseudoDisabled: "pseudoDisabled",
    item: "item"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ,
    useExisting: (0,core_js_.forwardRef)(() => TuiRadioComponent_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]],
  decls: 4,
  vars: 12,
  consts: [[3, "appearance", "disabled", "focused", "hovered", "pressed", "invalid"], ["class", "t-mark", 4, "ngIf"], ["type", "radio", 1, "t-native", 3, "id", "disabled", "tuiChecked", "tuiFocusable", "tuiFocusedChange", "tuiHoveredChange", "tuiPressedChange", "tuiCheckedChange", "tuiFocusVisibleChange"], ["focusableElement", ""], [1, "t-mark"]],
  template: function TuiRadioComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵelementStart"](0, "tui-wrapper", 0);
      core_js_["ɵɵtemplate"](1, TuiRadioComponent_div_1_Template, 1, 1, "div", 1);
      core_js_["ɵɵelementStart"](2, "input", 2, 3);
      core_js_["ɵɵlistener"]("tuiFocusedChange", function TuiRadioComponent_Template_input_tuiFocusedChange_2_listener($event) {
        return ctx.onFocused($event);
      })("tuiHoveredChange", function TuiRadioComponent_Template_input_tuiHoveredChange_2_listener($event) {
        return ctx.onHovered($event);
      })("tuiPressedChange", function TuiRadioComponent_Template_input_tuiPressedChange_2_listener($event) {
        return ctx.onPressed($event);
      })("tuiCheckedChange", function TuiRadioComponent_Template_input_tuiCheckedChange_2_listener($event) {
        return ctx.onChecked($event);
      })("tuiFocusVisibleChange", function TuiRadioComponent_Template_input_tuiFocusVisibleChange_2_listener($event) {
        return ctx.onFocusVisible($event);
      });
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      core_js_["ɵɵproperty"]("appearance", ctx.appearance)("disabled", ctx.computedDisabled)("focused", ctx.computedFocusVisible)("hovered", ctx.computedHovered)("pressed", ctx.computedPressed)("invalid", ctx.computedInvalid);
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵproperty"]("ngIf", ctx.checked);
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵproperty"]("id", ctx.id)("disabled", ctx.computedDisabled)("tuiChecked", ctx.checked)("tuiFocusable", ctx.isFocusable);
      core_js_["ɵɵattribute"]("name", ctx.computedName);
    }
  },
  directives: [taiga_ui_core_directives_wrapper/* TuiWrapperDirective */.o, common_js_.NgIf, TuiCheckedDirective, TuiFocusableDirective, TuiFocusedDirective, TuiHoveredDirective, TuiPressedDirective, TuiFocusVisibleDirective],
  styles: ["[_nghost-%COMP%]{font:var(--tui-font-text-s);color:var(--tui-text-01);position:relative;display:block;flex-shrink:0;border-radius:100%}[data-size='m'][_nghost-%COMP%]{width:1rem;height:1rem}[data-size='l'][_nghost-%COMP%]{width:1.5rem;height:1.5rem}._readonly[_nghost-%COMP%]{pointer-events:none}.t-mark[_ngcontent-%COMP%]{position:absolute;background-color:currentColor;border-radius:100%}[data-size='m'][_nghost-%COMP%]   .t-mark[_ngcontent-%COMP%]{margin:.25rem;width:.5rem;height:.5rem}[data-size='l'][_nghost-%COMP%]   .t-mark[_ngcontent-%COMP%]{margin:.4375rem;width:.625rem;height:.625rem}.t-native[_ngcontent-%COMP%]{padding:0;margin:0;border:0;border-radius:inherit;background:0 0;font-size:inherit;line-height:inherit;font-weight:inherit;color:inherit;caret-color:currentColor;outline:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;word-break:keep-all;-webkit-text-fill-color:currentColor;position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;cursor:pointer}.t-native[_ngcontent-%COMP%]:-webkit-autofill, .t-native[_ngcontent-%COMP%]:-webkit-autofill:focus, .t-native[_ngcontent-%COMP%]:-webkit-autofill:hover{caret-color:var(--tui-base-09);border-radius:inherit;color:inherit!important;background-color:transparent!important;-webkit-text-fill-color:var(--tui-text-01)!important;border-color:var(--tui-autofill);-webkit-box-shadow:0 0 0 100rem var(--tui-autofill) inset!important}._disabled[_nghost-%COMP%]   .t-native[_ngcontent-%COMP%]{cursor:default}"],
  data: {
    animation: [tuiScaleIn]
  },
  changeDetection: 0
});
TuiRadioComponent.ctorParameters = () => [{
  type: fesm2015_forms.NgControl,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.Self
  }, {
    type: core_js_.Inject,
    args: [fesm2015_forms.NgControl]
  }]
}, {
  type: core_js_.ChangeDetectorRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ChangeDetectorRef]
  }]
}, {
  type: undefined,
  decorators: [{
    type: core_js_.Inject,
    args: [taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw]
  }]
}, {
  type: undefined,
  decorators: [{
    type: core_js_.Inject,
    args: [TUI_RADIO_OPTIONS]
  }]
}, {
  type: TuiRadioGroupComponent,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.Inject,
    args: [TuiRadioGroupComponent]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('focusableElement')], TuiRadioComponent.prototype, "focusableElement", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiRadioComponent.prototype, "item", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiRadioComponent.prototype, "identityMatcher", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiRadioComponent.prototype, "name", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-size'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiRadioComponent.prototype, "size", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiRadioComponent.prototype, "pseudoDisabled", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._disabled')], TuiRadioComponent.prototype, "computedDisabled", null);
TuiRadioComponent = TuiRadioComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(fesm2015_forms.NgControl)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TUI_RADIO_OPTIONS)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(TuiRadioGroupComponent))], TuiRadioComponent);
let TuiRadioModule = /*#__PURE__*/(() => {
  let TuiRadioModule = class TuiRadioModule {};
  TuiRadioModule.ɵfac = function TuiRadioModule_Factory(t) {
    return new (t || TuiRadioModule)();
  };
  TuiRadioModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiRadioModule
  });
  TuiRadioModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, TuiCheckedModule, TuiFocusableModule, TuiFocusedModule, TuiHoveredModule, TuiPressedModule, TuiFocusVisibleModule, taiga_ui_core_directives_wrapper/* TuiWrapperModule */.W]]
  });
  return TuiRadioModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiRadioModule, {
    declarations: function () {
      return [TuiRadioComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, TuiCheckedModule, TuiFocusableModule, TuiFocusedModule, TuiHoveredModule, TuiPressedModule, TuiFocusVisibleModule, taiga_ui_core_directives_wrapper/* TuiWrapperModule */.W];
    },
    exports: function () {
      return [TuiRadioComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-radio.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-radio-block.js











const taiga_ui_kit_components_radio_block_c0 = ["*"];
var TuiRadioBlockComponent_1;
let TuiRadioBlockComponent = TuiRadioBlockComponent_1 = class TuiRadioBlockComponent extends taiga_ui_cdk_abstract/* AbstractTuiNullableControl */.F9 {
  constructor(control, changeDetectorRef, modeDirective) {
    super(control, changeDetectorRef);
    this.modeDirective = modeDirective;
    this.identityMatcher = taiga_ui_cdk_constants/* TUI_DEFAULT_IDENTITY_MATCHER */.bg;
    this.contentAlign = 'right';
    this.size = 'l';
    this.hideRadio = false;
    this.pseudoDisabled = false;
  }
  get nativeFocusableElement() {
    return this.radio ? this.radio.nativeFocusableElement : null;
  }
  get focused() {
    return !!this.radio && this.radio.focused;
  }
  get computedDisabled() {
    return this.disabled || this.pseudoDisabled;
  }
  get checked() {
    return this.value === this.item && this.hideRadio;
  }
  get checkboxSize() {
    return this.size === 'l' ? 'l' : 'm';
  }
  get appearance() {
    var _a;
    if (!((_a = this.modeDirective) === null || _a === void 0 ? void 0 : _a.mode)) {
      return this.checked ? "whiteblock-active" /* WhiteblockActive */ : "whiteblock" /* Whiteblock */;
    }

    return this.checked ? "primary" /* Primary */ : "secondary" /* Secondary */;
  }

  onFocused(focused) {
    this.updateFocused(focused);
  }
  onHovered(hovered) {
    this.updateHovered(hovered);
  }
  onPressed(pressed) {
    this.updatePressed(pressed);
  }
  onFocusVisible(focusVisible) {
    this.updateFocusVisible(focusVisible);
  }
  onModelChange(value) {
    this.updateValue(value);
  }
};
TuiRadioBlockComponent.ɵfac = function TuiRadioBlockComponent_Factory(t) {
  return new (t || TuiRadioBlockComponent)(core_js_["ɵɵdirectiveInject"](fesm2015_forms.NgControl, 10), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_directives_mode/* TuiModeDirective */.w, 8));
};
TuiRadioBlockComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiRadioBlockComponent,
  selectors: [["tui-radio-block"]],
  viewQuery: function TuiRadioBlockComponent_Query(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵviewQuery"](TuiRadioComponent, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.radio = _t.first);
    }
  },
  hostVars: 8,
  hostBindings: function TuiRadioBlockComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      core_js_["ɵɵattribute"]("data-tui-host-align", ctx.contentAlign)("data-size", ctx.size);
      core_js_["ɵɵclassProp"]("_hidden_radio", ctx.hideRadio)("_disabled", ctx.computedDisabled)("_active", ctx.checked);
    }
  },
  inputs: {
    identityMatcher: "identityMatcher",
    contentAlign: "contentAlign",
    size: "size",
    hideRadio: "hideRadio",
    pseudoDisabled: "pseudoDisabled",
    item: "item"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ,
    useExisting: (0,core_js_.forwardRef)(() => TuiRadioBlockComponent_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]],
  ngContentSelectors: taiga_ui_kit_components_radio_block_c0,
  decls: 7,
  vars: 19,
  consts: [[1, "t-wrapper", 3, "tuiHoveredChange", "tuiPressedChange"], [3, "appearance", "disabled", "focused", "hovered", "pressed", "invalid"], [1, "t-content-wrapper"], [1, "t-content"], [1, "t-view", 3, "focusable", "identityMatcher", "item", "name", "nativeId", "readOnly", "pseudoDisabled", "pseudoInvalid", "pseudoFocused", "pseudoHovered", "pseudoPressed", "size", "ngModel", "ngModelChange", "focusedChange", "focusVisibleChange"], [1, "t-label"]],
  template: function TuiRadioBlockComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"]();
      core_js_["ɵɵelementStart"](0, "label", 0);
      core_js_["ɵɵlistener"]("tuiHoveredChange", function TuiRadioBlockComponent_Template_label_tuiHoveredChange_0_listener($event) {
        return ctx.onHovered($event);
      })("tuiPressedChange", function TuiRadioBlockComponent_Template_label_tuiPressedChange_0_listener($event) {
        return ctx.onPressed($event);
      });
      core_js_["ɵɵelementStart"](1, "tui-wrapper", 1);
      core_js_["ɵɵelementStart"](2, "div", 2);
      core_js_["ɵɵelementStart"](3, "div", 3);
      core_js_["ɵɵelementStart"](4, "tui-radio", 4);
      core_js_["ɵɵlistener"]("ngModelChange", function TuiRadioBlockComponent_Template_tui_radio_ngModelChange_4_listener($event) {
        return ctx.onModelChange($event);
      })("focusedChange", function TuiRadioBlockComponent_Template_tui_radio_focusedChange_4_listener($event) {
        return ctx.onFocused($event);
      })("focusVisibleChange", function TuiRadioBlockComponent_Template_tui_radio_focusVisibleChange_4_listener($event) {
        return ctx.onFocusVisible($event);
      });
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementStart"](5, "div", 5);
      core_js_["ɵɵprojection"](6);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵproperty"]("appearance", ctx.appearance)("disabled", ctx.computedDisabled)("focused", ctx.computedFocusVisible)("hovered", ctx.computedHovered)("pressed", ctx.computedPressed)("invalid", ctx.computedInvalid);
      core_js_["ɵɵadvance"](3);
      core_js_["ɵɵproperty"]("focusable", ctx.focusable)("identityMatcher", ctx.identityMatcher)("item", ctx.item)("name", ctx.computedName || "")("nativeId", ctx.nativeId)("readOnly", ctx.readOnly)("pseudoDisabled", ctx.computedDisabled)("pseudoInvalid", ctx.computedInvalid)("pseudoFocused", false)("pseudoHovered", ctx.computedHovered)("pseudoPressed", ctx.computedPressed)("size", ctx.checkboxSize)("ngModel", ctx.value);
    }
  },
  directives: [TuiHoveredDirective, TuiPressedDirective, taiga_ui_core_directives_wrapper/* TuiWrapperDirective */.o, TuiRadioComponent, fesm2015_forms.NgControlStatus, fesm2015_forms.NgModel],
  styles: ["[_nghost-%COMP%]{font:var(--tui-font-text-s);color:var(--tui-text-01);display:inline-block;vertical-align:top;border-radius:var(--tui-radius-m)}[data-size='l'][_nghost-%COMP%], [data-size='m'][_nghost-%COMP%]{font:var(--tui-font-text-m)}._readonly[_nghost-%COMP%]{pointer-events:none}.t-wrapper[_ngcontent-%COMP%]{position:relative;border-radius:inherit;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}._disabled[_nghost-%COMP%]   .t-wrapper[_ngcontent-%COMP%]{cursor:default}.t-content-wrapper[_ngcontent-%COMP%]{display:flex;flex-direction:column}[data-size='s'][_nghost-%COMP%]   .t-content-wrapper[_ngcontent-%COMP%]{min-height:var(--tui-height-s)}[data-size='m'][_nghost-%COMP%]   .t-content-wrapper[_ngcontent-%COMP%]{min-height:var(--tui-height-m)}[data-size='l'][_nghost-%COMP%]   .t-content-wrapper[_ngcontent-%COMP%]{min-height:var(--tui-height-l)}.t-content[_ngcontent-%COMP%]{display:flex;align-items:center;min-height:inherit}[data-tui-host-align=right][_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{flex-direction:row-reverse}[data-size='s'][_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{padding:0 1rem 0 .5rem}[data-size='s'][data-tui-host-align=right][_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{padding:0 .5rem 0 1rem}[data-size='s']._hidden_radio[_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{padding:0 1rem}[data-size='m'][_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{padding:0 1rem 0 .75rem}[data-size='m'][data-tui-host-align=right][_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{padding:0 .75rem 0 1rem}[data-size='m']._hidden_radio[_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{padding:0 1.5rem}[data-size='l'][_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{padding:0 1rem}[data-size='l']._hidden_radio[_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{padding:0 2.25rem}.t-view[_ngcontent-%COMP%]{margin-top:.75rem;margin-right:.75rem;align-self:flex-start}[data-tui-host-align=right][_nghost-%COMP%]   .t-view[_ngcontent-%COMP%]{margin-left:.75rem;margin-right:0}[data-size='s'][_nghost-%COMP%]   .t-view[_ngcontent-%COMP%]{margin-top:.5rem;margin-right:.5rem}[data-size='s'][data-tui-host-align=right][_nghost-%COMP%]   .t-view[_ngcontent-%COMP%]{margin-left:.5rem}[data-size='m'][_nghost-%COMP%]   .t-view[_ngcontent-%COMP%]{margin-top:.875rem}[data-size='l'][_nghost-%COMP%]   .t-view[_ngcontent-%COMP%]{margin-top:1rem}[data-size='l'][data-tui-host-align=right][_nghost-%COMP%]   .t-view[_ngcontent-%COMP%]{margin-left:1rem;margin-right:0}._hidden_radio[_nghost-%COMP%]   .t-view[_ngcontent-%COMP%]{position:absolute;height:1px;width:1px;margin:-1px;border:0;padding:0;overflow:hidden;clip:rect(0,0,0,0);-webkit-clip-path:inset(0);clip-path:inset(0)}.t-label[_ngcontent-%COMP%]{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;flex-grow:1}._hidden_radio[_nghost-%COMP%]   .t-label[_ngcontent-%COMP%]{text-align:center}"],
  changeDetection: 0
});
TuiRadioBlockComponent.ctorParameters = () => [{
  type: fesm2015_forms.NgControl,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.Self
  }, {
    type: core_js_.Inject,
    args: [fesm2015_forms.NgControl]
  }]
}, {
  type: core_js_.ChangeDetectorRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ChangeDetectorRef]
  }]
}, {
  type: taiga_ui_core_directives_mode/* TuiModeDirective */.w,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.Inject,
    args: [taiga_ui_core_directives_mode/* TuiModeDirective */.w]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)(TuiRadioComponent)], TuiRadioBlockComponent.prototype, "radio", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiRadioBlockComponent.prototype, "item", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiRadioBlockComponent.prototype, "identityMatcher", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-tui-host-align'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiRadioBlockComponent.prototype, "contentAlign", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-size'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiRadioBlockComponent.prototype, "size", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._hidden_radio'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiRadioBlockComponent.prototype, "hideRadio", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiRadioBlockComponent.prototype, "pseudoDisabled", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._disabled')], TuiRadioBlockComponent.prototype, "computedDisabled", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._active')], TuiRadioBlockComponent.prototype, "checked", null);
TuiRadioBlockComponent = TuiRadioBlockComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(fesm2015_forms.NgControl)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_core_directives_mode/* TuiModeDirective */.w))], TuiRadioBlockComponent);
let TuiRadioBlockModule = /*#__PURE__*/(() => {
  let TuiRadioBlockModule = class TuiRadioBlockModule {};
  TuiRadioBlockModule.ɵfac = function TuiRadioBlockModule_Factory(t) {
    return new (t || TuiRadioBlockModule)();
  };
  TuiRadioBlockModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiRadioBlockModule
  });
  TuiRadioBlockModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[fesm2015_forms.FormsModule, TuiHoveredModule, TuiPressedModule, TuiRadioModule, taiga_ui_core_directives_wrapper/* TuiWrapperModule */.W]]
  });
  return TuiRadioBlockModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiRadioBlockModule, {
    declarations: function () {
      return [TuiRadioBlockComponent];
    },
    imports: function () {
      return [fesm2015_forms.FormsModule, TuiHoveredModule, TuiPressedModule, TuiRadioModule, taiga_ui_core_directives_wrapper/* TuiWrapperModule */.W];
    },
    exports: function () {
      return [TuiRadioBlockComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-radio-block.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-primitive-checkbox.js







/** Default values for the checkbox options. */




function TuiPrimitiveCheckboxComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 2);
  }
  if (rf & 2) {
    const icon_r1 = ctx.$implicit;
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵclassProp"]("t-mark_on", !ctx_r0.empty);
    core_js_["ɵɵproperty"]("src", icon_r1);
  }
}
const taiga_ui_core_components_primitive_checkbox_c0 = function (a0) {
  return {
    $implicit: a0
  };
};
const taiga_ui_core_components_primitive_checkbox_c1 = ["*"];
const TUI_CHECKBOX_DEFAULT_OPTIONS = {
  size: `m`,
  appearances: {
    unchecked: "outline" /* Outline */,
    checked: "primary" /* Primary */,
    indeterminate: "primary" /* Primary */
  },

  icons: {
    checked({
      $implicit
    }) {
      return $implicit === `m` ? `tuiIconCheck` : `tuiIconCheckLarge`;
    },
    indeterminate({
      $implicit
    }) {
      return $implicit === `m` ? `tuiIconMinus` : `tuiIconMinusLarge`;
    }
  }
};
const TUI_CHECKBOX_OPTIONS = new core_js_.InjectionToken(`Default parameters for checkbox component`, {
  factory: () => TUI_CHECKBOX_DEFAULT_OPTIONS
});
const tuiCheckboxOptionsProvider = options => ({
  provide: TUI_CHECKBOX_OPTIONS,
  useValue: Object.assign(Object.assign({}, TUI_CHECKBOX_DEFAULT_OPTIONS), options)
});

// @dynamic
let TuiPrimitiveCheckboxComponent = /*#__PURE__*/(() => {
  let TuiPrimitiveCheckboxComponent = class TuiPrimitiveCheckboxComponent {
    constructor(options) {
      this.options = options;
      this.size = this.options.size;
      this.disabled = false;
      this.focused = false;
      this.hovered = false;
      this.pressed = false;
      this.invalid = false;
      this.icon = this.options.icons.checked;
      this.value = false;
    }
    set valueSetter(value) {
      if (value !== false) {
        this.setCurrentIcon(value);
      }
      this.value = value;
    }
    get appearance() {
      switch (this.value) {
        case false:
          return this.options.appearances.unchecked;
        case true:
          return this.options.appearances.checked;
        default:
          return this.options.appearances.indeterminate;
      }
    }
    get empty() {
      return this.value === false;
    }
    setCurrentIcon(value) {
      this.icon = value === null ? this.options.icons.indeterminate : this.options.icons.checked;
    }
  };
  TuiPrimitiveCheckboxComponent.ɵfac = function TuiPrimitiveCheckboxComponent_Factory(t) {
    return new (t || TuiPrimitiveCheckboxComponent)(core_js_["ɵɵdirectiveInject"](TUI_CHECKBOX_OPTIONS));
  };
  TuiPrimitiveCheckboxComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiPrimitiveCheckboxComponent,
    selectors: [["tui-primitive-checkbox"]],
    hostVars: 1,
    hostBindings: function TuiPrimitiveCheckboxComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("data-size", ctx.size);
      }
    },
    inputs: {
      size: "size",
      disabled: "disabled",
      focused: "focused",
      hovered: "hovered",
      pressed: "pressed",
      invalid: "invalid",
      valueSetter: ["value", "valueSetter"]
    },
    ngContentSelectors: taiga_ui_core_components_primitive_checkbox_c1,
    decls: 4,
    vars: 10,
    consts: [[3, "appearance", "disabled", "focused", "hovered", "pressed", "invalid"], ["polymorpheus-outlet", "", 3, "content", "context"], [1, "t-mark", 3, "src"]],
    template: function TuiPrimitiveCheckboxComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵelementStart"](0, "tui-wrapper", 0);
        core_js_["ɵɵelementStart"](1, "span", 1);
        core_js_["ɵɵtemplate"](2, TuiPrimitiveCheckboxComponent_ng_template_2_Template, 1, 3, "ng-template");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵprojection"](3);
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("appearance", ctx.appearance)("disabled", ctx.disabled)("focused", ctx.focused)("hovered", ctx.hovered)("pressed", ctx.pressed)("invalid", ctx.invalid);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("content", ctx.icon)("context", core_js_["ɵɵpureFunction1"](8, taiga_ui_core_components_primitive_checkbox_c0, ctx.size));
      }
    },
    directives: [taiga_ui_core_directives_wrapper/* TuiWrapperDirective */.o, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, taiga_ui_core_components_svg/* TuiSvgComponent */.P],
    styles: ["[_nghost-%COMP%]{display:block;font-size:0;flex-shrink:0}[data-size='m'][_nghost-%COMP%]{width:1rem;height:1rem;border-radius:var(--tui-radius-xs)}[data-size='l'][_nghost-%COMP%]{width:1.5rem;height:1.5rem;border-radius:var(--tui-radius-s)}.t-mark[_ngcontent-%COMP%]{transition-property:transform;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;display:block;width:100%;height:100%;transform:scale(0)}.t-mark_on[_ngcontent-%COMP%]{transform:scale(1)}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-size'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveCheckboxComponent.prototype, "size", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveCheckboxComponent.prototype, "disabled", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveCheckboxComponent.prototype, "focused", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveCheckboxComponent.prototype, "hovered", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveCheckboxComponent.prototype, "pressed", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveCheckboxComponent.prototype, "invalid", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('value'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPrimitiveCheckboxComponent.prototype, "valueSetter", null);
  TuiPrimitiveCheckboxComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TUI_CHECKBOX_OPTIONS))], TuiPrimitiveCheckboxComponent);
  return TuiPrimitiveCheckboxComponent;
})();
let TuiPrimitiveCheckboxModule = /*#__PURE__*/(() => {
  let TuiPrimitiveCheckboxModule = class TuiPrimitiveCheckboxModule {};
  TuiPrimitiveCheckboxModule.ɵfac = function TuiPrimitiveCheckboxModule_Factory(t) {
    return new (t || TuiPrimitiveCheckboxModule)();
  };
  TuiPrimitiveCheckboxModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiPrimitiveCheckboxModule
  });
  TuiPrimitiveCheckboxModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[taiga_ui_core_components_svg/* TuiSvgModule */.E, taiga_ui_core_directives_wrapper/* TuiWrapperModule */.W, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq]]
  });
  return TuiPrimitiveCheckboxModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiPrimitiveCheckboxModule, {
    declarations: function () {
      return [TuiPrimitiveCheckboxComponent];
    },
    imports: function () {
      return [taiga_ui_core_components_svg/* TuiSvgModule */.E, taiga_ui_core_directives_wrapper/* TuiWrapperModule */.W, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq];
    },
    exports: function () {
      return [TuiPrimitiveCheckboxComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-primitive-checkbox.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-checkbox.js










const taiga_ui_kit_components_checkbox_c0 = ["focusableElement"];
var TuiCheckboxComponent_1;
let TuiCheckboxComponent = TuiCheckboxComponent_1 = class TuiCheckboxComponent extends taiga_ui_cdk_abstract/* AbstractTuiNullableControl */.F9 {
  constructor(control, options, changeDetectorRef) {
    super(control, changeDetectorRef);
    this.options = options;
    this.size = this.options.size;
  }
  get nativeFocusableElement() {
    return !this.focusableElement || this.computedDisabled ? null : this.focusableElement.nativeElement;
  }
  get focused() {
    return (0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(this.nativeFocusableElement);
  }
  get computedFocusable() {
    return this.interactive && this.focusable;
  }
  onChecked(checked) {
    this.updateValue(checked);
  }
  onFocused(focused) {
    this.updateFocused(focused);
  }
  onHovered(hovered) {
    this.updateHovered(hovered);
  }
  onPressed(pressed) {
    this.updatePressed(pressed);
  }
  onFocusVisible(focusVisible) {
    this.updateFocusVisible(focusVisible);
  }
};
TuiCheckboxComponent.ɵfac = function TuiCheckboxComponent_Factory(t) {
  return new (t || TuiCheckboxComponent)(core_js_["ɵɵdirectiveInject"](fesm2015_forms.NgControl, 10), core_js_["ɵɵdirectiveInject"](TUI_CHECKBOX_OPTIONS), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef));
};
TuiCheckboxComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiCheckboxComponent,
  selectors: [["tui-checkbox"]],
  viewQuery: function TuiCheckboxComponent_Query(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵviewQuery"](taiga_ui_kit_components_checkbox_c0, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.focusableElement = _t.first);
    }
  },
  hostVars: 1,
  hostBindings: function TuiCheckboxComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      core_js_["ɵɵattribute"]("data-size", ctx.size);
    }
  },
  inputs: {
    size: "size"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ,
    useExisting: (0,core_js_.forwardRef)(() => TuiCheckboxComponent_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]],
  decls: 3,
  vars: 11,
  consts: [[3, "size", "disabled", "focused", "hovered", "pressed", "invalid", "value"], ["type", "checkbox", "automation-id", "tui-checkbox__native", 1, "t-native", 3, "disabled", "id", "tuiChecked", "tuiFocusable", "tuiFocusedChange", "tuiHoveredChange", "tuiPressedChange", "tuiCheckedChange", "tuiFocusVisibleChange"], ["focusableElement", ""]],
  template: function TuiCheckboxComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵelementStart"](0, "tui-primitive-checkbox", 0);
      core_js_["ɵɵelementStart"](1, "input", 1, 2);
      core_js_["ɵɵlistener"]("tuiFocusedChange", function TuiCheckboxComponent_Template_input_tuiFocusedChange_1_listener($event) {
        return ctx.onFocused($event);
      })("tuiHoveredChange", function TuiCheckboxComponent_Template_input_tuiHoveredChange_1_listener($event) {
        return ctx.onHovered($event);
      })("tuiPressedChange", function TuiCheckboxComponent_Template_input_tuiPressedChange_1_listener($event) {
        return ctx.onPressed($event);
      })("tuiCheckedChange", function TuiCheckboxComponent_Template_input_tuiCheckedChange_1_listener($event) {
        return ctx.onChecked($event);
      })("tuiFocusVisibleChange", function TuiCheckboxComponent_Template_input_tuiFocusVisibleChange_1_listener($event) {
        return ctx.onFocusVisible($event);
      });
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      core_js_["ɵɵproperty"]("size", ctx.size)("disabled", ctx.disabled)("focused", ctx.computedFocusVisible)("hovered", ctx.computedHovered)("pressed", ctx.computedPressed)("invalid", ctx.computedInvalid)("value", ctx.value);
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵproperty"]("disabled", ctx.disabled)("id", ctx.id)("tuiChecked", ctx.value)("tuiFocusable", ctx.computedFocusable);
    }
  },
  directives: [TuiPrimitiveCheckboxComponent, TuiCheckedDirective, TuiFocusableDirective, TuiFocusedDirective, TuiHoveredDirective, TuiPressedDirective, TuiFocusVisibleDirective],
  styles: ["[_nghost-%COMP%]{font:var(--tui-font-text-s);color:var(--tui-text-01);position:relative;display:block;flex-shrink:0}[data-size='m'][_nghost-%COMP%]{width:1rem;height:1rem}[data-size='l'][_nghost-%COMP%]{width:1.5rem;height:1.5rem}._disabled[_nghost-%COMP%], ._readonly[_nghost-%COMP%]{pointer-events:none}.t-native[_ngcontent-%COMP%]{padding:0;margin:0;border:0;border-radius:inherit;background:0 0;font-size:inherit;line-height:inherit;font-weight:inherit;color:inherit;caret-color:currentColor;outline:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;word-break:keep-all;-webkit-text-fill-color:currentColor;position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;cursor:pointer}.t-native[_ngcontent-%COMP%]:-webkit-autofill, .t-native[_ngcontent-%COMP%]:-webkit-autofill:focus, .t-native[_ngcontent-%COMP%]:-webkit-autofill:hover{caret-color:var(--tui-base-09);border-radius:inherit;color:inherit!important;background-color:transparent!important;-webkit-text-fill-color:var(--tui-text-01)!important;border-color:var(--tui-autofill);-webkit-box-shadow:0 0 0 100rem var(--tui-autofill) inset!important}"],
  changeDetection: 0
});
TuiCheckboxComponent.ctorParameters = () => [{
  type: fesm2015_forms.NgControl,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.Self
  }, {
    type: core_js_.Inject,
    args: [fesm2015_forms.NgControl]
  }]
}, {
  type: undefined,
  decorators: [{
    type: core_js_.Inject,
    args: [TUI_CHECKBOX_OPTIONS]
  }]
}, {
  type: core_js_.ChangeDetectorRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ChangeDetectorRef]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('focusableElement')], TuiCheckboxComponent.prototype, "focusableElement", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-size'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiCheckboxComponent.prototype, "size", void 0);
TuiCheckboxComponent = TuiCheckboxComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(fesm2015_forms.NgControl)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_CHECKBOX_OPTIONS)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.ChangeDetectorRef))], TuiCheckboxComponent);
let TuiCheckboxModule = /*#__PURE__*/(() => {
  let TuiCheckboxModule = class TuiCheckboxModule {};
  TuiCheckboxModule.ɵfac = function TuiCheckboxModule_Factory(t) {
    return new (t || TuiCheckboxModule)();
  };
  TuiCheckboxModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiCheckboxModule
  });
  TuiCheckboxModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, TuiCheckedModule, TuiFocusableModule, TuiFocusedModule, TuiHoveredModule, TuiPressedModule, TuiFocusVisibleModule, TuiPrimitiveCheckboxModule]]
  });
  return TuiCheckboxModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiCheckboxModule, {
    declarations: function () {
      return [TuiCheckboxComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, TuiCheckedModule, TuiFocusableModule, TuiFocusedModule, TuiHoveredModule, TuiPressedModule, TuiFocusVisibleModule, TuiPrimitiveCheckboxModule];
    },
    exports: function () {
      return [TuiCheckboxComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-checkbox.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-checkbox-labeled.js












const taiga_ui_kit_components_checkbox_labeled_c0 = ["*"];
var TuiCheckboxLabeledComponent_1;
let TuiCheckboxLabeledComponent = TuiCheckboxLabeledComponent_1 = class TuiCheckboxLabeledComponent extends taiga_ui_cdk_abstract/* AbstractTuiNullableControl */.F9 {
  constructor(control, changeDetectorRef, modeDirective) {
    super(control, changeDetectorRef);
    this.modeDirective = modeDirective;
    this.size = 'm';
  }
  get focused() {
    return (0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(this.nativeFocusableElement);
  }
  get nativeFocusableElement() {
    return this.checkbox ? this.checkbox.nativeFocusableElement : null;
  }
  get hostMode() {
    return this.modeDirective ? this.modeDirective.mode : null;
  }
  onFocused(focused) {
    this.updateFocused(focused);
  }
  onHovered(hovered) {
    this.updateHovered(hovered);
  }
  onPressed(pressed) {
    this.updatePressed(pressed);
  }
  onModelChange(value) {
    this.updateValue(value);
  }
};
TuiCheckboxLabeledComponent.ɵfac = function TuiCheckboxLabeledComponent_Factory(t) {
  return new (t || TuiCheckboxLabeledComponent)(core_js_["ɵɵdirectiveInject"](fesm2015_forms.NgControl, 10), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_directives_mode/* TuiModeDirective */.w, 8));
};
TuiCheckboxLabeledComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiCheckboxLabeledComponent,
  selectors: [["tui-checkbox-labeled"]],
  viewQuery: function TuiCheckboxLabeledComponent_Query(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵviewQuery"](TuiCheckboxComponent, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.checkbox = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function TuiCheckboxLabeledComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      core_js_["ɵɵattribute"]("data-size", ctx.size)("data-mode", ctx.hostMode);
    }
  },
  inputs: {
    size: "size"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ,
    useExisting: (0,core_js_.forwardRef)(() => TuiCheckboxLabeledComponent_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]],
  ngContentSelectors: taiga_ui_kit_components_checkbox_labeled_c0,
  decls: 4,
  vars: 12,
  consts: [[1, "t-wrapper", 3, "tuiHoveredChange", "tuiPressedChange"], [3, "disabled", "readOnly", "focusable", "nativeId", "pseudoInvalid", "pseudoFocused", "pseudoHovered", "pseudoPressed", "size", "ngModel", "ngModelChange", "focusedChange"], [1, "t-content"]],
  template: function TuiCheckboxLabeledComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"]();
      core_js_["ɵɵelementStart"](0, "label", 0);
      core_js_["ɵɵlistener"]("tuiHoveredChange", function TuiCheckboxLabeledComponent_Template_label_tuiHoveredChange_0_listener($event) {
        return ctx.onHovered($event);
      })("tuiPressedChange", function TuiCheckboxLabeledComponent_Template_label_tuiPressedChange_0_listener($event) {
        return ctx.onPressed($event);
      });
      core_js_["ɵɵelementStart"](1, "tui-checkbox", 1);
      core_js_["ɵɵlistener"]("ngModelChange", function TuiCheckboxLabeledComponent_Template_tui_checkbox_ngModelChange_1_listener($event) {
        return ctx.onModelChange($event);
      })("focusedChange", function TuiCheckboxLabeledComponent_Template_tui_checkbox_focusedChange_1_listener($event) {
        return ctx.onFocused($event);
      });
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementStart"](2, "div", 2);
      core_js_["ɵɵprojection"](3);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵproperty"]("disabled", ctx.computedDisabled)("readOnly", ctx.readOnly)("focusable", ctx.focusable)("nativeId", ctx.nativeId)("pseudoInvalid", ctx.computedInvalid)("pseudoFocused", ctx.pseudoFocused)("pseudoHovered", ctx.computedHovered)("pseudoPressed", ctx.computedPressed)("size", ctx.size)("ngModel", ctx.value);
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵclassProp"]("t-content_disabled", ctx.computedDisabled);
    }
  },
  directives: [TuiHoveredDirective, TuiPressedDirective, TuiCheckboxComponent, fesm2015_forms.NgControlStatus, fesm2015_forms.NgModel],
  styles: ["[_nghost-%COMP%]{position:relative;display:block;line-height:0}._disabled[_nghost-%COMP%], ._readonly[_nghost-%COMP%]{pointer-events:none}.t-wrapper[_ngcontent-%COMP%]{display:inline-flex;max-width:100%;cursor:pointer}._disabled[_nghost-%COMP%]   .t-wrapper[_ngcontent-%COMP%]{cursor:default}[data-mode=onDark][_nghost-%COMP%]   .t-wrapper[_ngcontent-%COMP%]{color:var(--tui-text-01-night)}.t-content[_ngcontent-%COMP%]{font:var(--tui-font-text-s);line-height:1rem;word-wrap:break-word;min-width:0}.t-content_disabled[_ngcontent-%COMP%]{opacity:var(--tui-disabled-opacity)}[data-size='m'][_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{margin-left:.5rem}[data-size='l'][_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{font:var(--tui-font-text-m);margin-left:.75rem}"],
  changeDetection: 0
});
TuiCheckboxLabeledComponent.ctorParameters = () => [{
  type: fesm2015_forms.NgControl,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.Self
  }, {
    type: core_js_.Inject,
    args: [fesm2015_forms.NgControl]
  }]
}, {
  type: core_js_.ChangeDetectorRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ChangeDetectorRef]
  }]
}, {
  type: taiga_ui_core_directives_mode/* TuiModeDirective */.w,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.Inject,
    args: [taiga_ui_core_directives_mode/* TuiModeDirective */.w]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)(TuiCheckboxComponent)], TuiCheckboxLabeledComponent.prototype, "checkbox", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-size'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiCheckboxLabeledComponent.prototype, "size", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('attr.data-mode')], TuiCheckboxLabeledComponent.prototype, "hostMode", null);
TuiCheckboxLabeledComponent = TuiCheckboxLabeledComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(fesm2015_forms.NgControl)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_core_directives_mode/* TuiModeDirective */.w))], TuiCheckboxLabeledComponent);
let TuiCheckboxLabeledModule = /*#__PURE__*/(() => {
  let TuiCheckboxLabeledModule = class TuiCheckboxLabeledModule {};
  TuiCheckboxLabeledModule.ɵfac = function TuiCheckboxLabeledModule_Factory(t) {
    return new (t || TuiCheckboxLabeledModule)();
  };
  TuiCheckboxLabeledModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiCheckboxLabeledModule
  });
  TuiCheckboxLabeledModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, fesm2015_forms.FormsModule, TuiHoveredModule, TuiPressedModule, TuiCheckboxModule]]
  });
  return TuiCheckboxLabeledModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiCheckboxLabeledModule, {
    declarations: function () {
      return [TuiCheckboxLabeledComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, fesm2015_forms.FormsModule, TuiHoveredModule, TuiPressedModule, TuiCheckboxModule];
    },
    exports: function () {
      return [TuiCheckboxLabeledComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-checkbox-labeled.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-element.js



let TuiElementDirective = /*#__PURE__*/(() => {
  let TuiElementDirective = class TuiElementDirective {
    constructor({
      nativeElement
    }) {
      /**
       * @note:
       * Typically, when your constructor is invoked with new,
       * an object is created, its constructor is assigned to
       * the invoked constructor and the object is then assigned
       * to this before executing any operations specified
       * in your constructor method.
       *
       * ERROR TypeError: Class constructor ElementRef cannot be invoked without 'new'
       * https://github.com/Tinkoff/taiga-ui/issues/3072
       *
       * This way we can instantiate object creation
       * without additional prototype chain for possible fix bug.
       */
      return new core_js_.ElementRef(nativeElement);
    }
  };
  TuiElementDirective.ɵfac = function TuiElementDirective_Factory(t) {
    return new (t || TuiElementDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef));
  };
  TuiElementDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiElementDirective,
    selectors: [["", "tuiElement", ""]],
    exportAs: ["elementRef"]
  });
  TuiElementDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef))], TuiElementDirective);
  return TuiElementDirective;
})();
let TuiElementModule = /*#__PURE__*/(() => {
  let TuiElementModule = class TuiElementModule {};
  TuiElementModule.ɵfac = function TuiElementModule_Factory(t) {
    return new (t || TuiElementModule)();
  };
  TuiElementModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiElementModule
  });
  TuiElementModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiElementModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiElementModule, {
    declarations: [TuiElementDirective],
    exports: [TuiElementDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-element.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-loader.js
var taiga_ui_core_components_loader = __webpack_require__(719);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-data-list-wrapper.js














const taiga_ui_kit_components_data_list_wrapper_c0 = ["labels", ""];
function TuiDataListGroupWrapperComponent_tui_data_list_0_tui_opt_group_1_button_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "button", 6, 7);
    core_js_["ɵɵelement"](2, "span", 8);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const item_r7 = ctx.$implicit;
    const _r8 = core_js_["ɵɵreference"](1);
    const ctx_r6 = core_js_["ɵɵnextContext"](3);
    core_js_["ɵɵproperty"]("size", ctx_r6.size)("value", item_r7)("disabled", ctx_r6.disabledItemHandler(item_r7));
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵproperty"]("content", ctx_r6.itemContent)("context", ctx_r6.getContext(item_r7, _r8));
  }
}
function TuiDataListGroupWrapperComponent_tui_data_list_0_tui_opt_group_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "tui-opt-group", 4);
    core_js_["ɵɵtemplate"](1, TuiDataListGroupWrapperComponent_tui_data_list_0_tui_opt_group_1_button_1_Template, 3, 5, "button", 5);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const group_r4 = ctx.$implicit;
    const index_r5 = ctx.index;
    const ctx_r3 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵproperty"]("label", ctx_r3.labels[index_r5]);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", group_r4);
  }
}
function TuiDataListGroupWrapperComponent_tui_data_list_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "tui-data-list", 2);
    core_js_["ɵɵtemplate"](1, TuiDataListGroupWrapperComponent_tui_data_list_0_tui_opt_group_1_Template, 2, 2, "tui-opt-group", 3);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("emptyContent", ctx_r0.emptyContent);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", ctx_r0.items);
  }
}
function TuiDataListGroupWrapperComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-loader", 9);
  }
}
function TuiDataListWrapperComponent_tui_data_list_0_button_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "button", 4, 5);
    core_js_["ɵɵelement"](2, "span", 6);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const item_r4 = ctx.$implicit;
    const _r5 = core_js_["ɵɵreference"](1);
    const ctx_r3 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵproperty"]("size", ctx_r3.size)("value", item_r4)("disabled", ctx_r3.disabledItemHandler(item_r4));
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵproperty"]("content", ctx_r3.itemContent)("context", ctx_r3.getContext(item_r4, _r5));
  }
}
function TuiDataListWrapperComponent_tui_data_list_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "tui-data-list", 2);
    core_js_["ɵɵtemplate"](1, TuiDataListWrapperComponent_tui_data_list_0_button_1_Template, 3, 5, "button", 3);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("emptyContent", ctx_r0.emptyContent);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", ctx_r0.items);
  }
}
function TuiDataListWrapperComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-loader", 7);
  }
}
const taiga_ui_kit_components_data_list_wrapper_c1 = "[_nghost-%COMP%]{display:block}.t-content[_ngcontent-%COMP%]{flex:1}.t-loader[_ngcontent-%COMP%]{margin:.75rem 0}";
let AbstractTuiDataListWrapper = /*#__PURE__*/(() => {
  let AbstractTuiDataListWrapper = class AbstractTuiDataListWrapper {
    constructor(itemsHandlers) {
      this.itemsHandlers = itemsHandlers;
      this.optionsQuery = taiga_ui_cdk_constants/* EMPTY_QUERY */.Mm;
      this.disabledItemHandler = this.itemsHandlers.disabledItemHandler;
      this.emptyContent = ``;
      this.size = `m`;
      this.itemContent = ({
        $implicit
      }) => this.itemsHandlers.stringify($implicit);
    }
    getContext($implicit, {
      nativeElement
    }) {
      return {
        $implicit,
        active: (0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(nativeElement)
      };
    }
    getOptions(includeDisabled = false) {
      return this.optionsQuery.toArray().filter(({
        disabled
      }) => includeDisabled || !disabled).map(({
        value
      }) => value).filter(taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN);
    }
  };
  AbstractTuiDataListWrapper.ɵfac = function AbstractTuiDataListWrapper_Factory(t) {
    return new (t || AbstractTuiDataListWrapper)(core_js_["ɵɵdirectiveInject"](undefined));
  };
  AbstractTuiDataListWrapper.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: AbstractTuiDataListWrapper,
    viewQuery: function AbstractTuiDataListWrapper_Query(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵviewQuery"](TuiOptionComponent, 5);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.optionsQuery = _t);
      }
    },
    inputs: {
      disabledItemHandler: "disabledItemHandler",
      emptyContent: "emptyContent",
      size: "size",
      itemContent: "itemContent"
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChildren)((0,core_js_.forwardRef)(() => TuiOptionComponent))], AbstractTuiDataListWrapper.prototype, "optionsQuery", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiDataListWrapper.prototype, "disabledItemHandler", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiDataListWrapper.prototype, "emptyContent", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiDataListWrapper.prototype, "size", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], AbstractTuiDataListWrapper.prototype, "itemContent", void 0);
  return AbstractTuiDataListWrapper;
})();
var TuiDataListGroupWrapperComponent_1;
let TuiDataListGroupWrapperComponent = TuiDataListGroupWrapperComponent_1 = class TuiDataListGroupWrapperComponent extends AbstractTuiDataListWrapper {
  constructor(itemsHandlers) {
    super(itemsHandlers);
    this.items = [];
    this.labels = [];
  }
};
TuiDataListGroupWrapperComponent.ɵfac = function TuiDataListGroupWrapperComponent_Factory(t) {
  return new (t || TuiDataListGroupWrapperComponent)(core_js_["ɵɵdirectiveInject"](TUI_ITEMS_HANDLERS));
};
TuiDataListGroupWrapperComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiDataListGroupWrapperComponent,
  selectors: [["tui-data-list-wrapper", "labels", ""]],
  inputs: {
    items: "items",
    labels: "labels"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_core_tokens/* TUI_DATA_LIST_ACCESSOR */.Cc,
    useExisting: (0,core_js_.forwardRef)(() => TuiDataListGroupWrapperComponent_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]],
  attrs: taiga_ui_kit_components_data_list_wrapper_c0,
  decls: 3,
  vars: 2,
  consts: [[3, "emptyContent", 4, "ngIf", "ngIfElse"], ["loading", ""], [3, "emptyContent"], [3, "label", 4, "ngFor", "ngForOf"], [3, "label"], ["tuiElement", "", "tuiOption", "", "automation-id", "tui-data-list-wrapper__option", 3, "size", "value", "disabled", 4, "ngFor", "ngForOf"], ["tuiElement", "", "tuiOption", "", "automation-id", "tui-data-list-wrapper__option", 3, "size", "value", "disabled"], ["elementRef", "elementRef"], ["polymorpheus-outlet", "", 1, "t-content", 3, "content", "context"], [1, "t-loader"]],
  template: function TuiDataListGroupWrapperComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵtemplate"](0, TuiDataListGroupWrapperComponent_tui_data_list_0_Template, 2, 2, "tui-data-list", 0);
      core_js_["ɵɵtemplate"](1, TuiDataListGroupWrapperComponent_ng_template_1_Template, 1, 0, "ng-template", null, 1, core_js_["ɵɵtemplateRefExtractor"]);
    }
    if (rf & 2) {
      const _r1 = core_js_["ɵɵreference"](2);
      core_js_["ɵɵproperty"]("ngIf", ctx.items)("ngIfElse", _r1);
    }
  },
  directives: [common_js_.NgIf, TuiDataListComponent, common_js_.NgForOf, TuiOptGroupDirective, TuiOptionComponent, TuiElementDirective, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, taiga_ui_core_components_loader/* TuiLoaderComponent */.kM],
  styles: [taiga_ui_kit_components_data_list_wrapper_c1],
  changeDetection: 0
});
TuiDataListGroupWrapperComponent.ctorParameters = () => [{
  type: undefined,
  decorators: [{
    type: core_js_.Inject,
    args: [TUI_ITEMS_HANDLERS]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDataListGroupWrapperComponent.prototype, "items", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDataListGroupWrapperComponent.prototype, "labels", void 0);
TuiDataListGroupWrapperComponent = TuiDataListGroupWrapperComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TUI_ITEMS_HANDLERS))], TuiDataListGroupWrapperComponent);
var TuiDataListWrapperComponent_1;
let TuiDataListWrapperComponent = TuiDataListWrapperComponent_1 = class TuiDataListWrapperComponent extends AbstractTuiDataListWrapper {
  constructor(itemsHandlers) {
    super(itemsHandlers);
    this.items = [];
  }
};
TuiDataListWrapperComponent.ɵfac = function TuiDataListWrapperComponent_Factory(t) {
  return new (t || TuiDataListWrapperComponent)(core_js_["ɵɵdirectiveInject"](TUI_ITEMS_HANDLERS));
};
TuiDataListWrapperComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiDataListWrapperComponent,
  selectors: [["tui-data-list-wrapper", 3, "labels", ""]],
  inputs: {
    items: "items"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_core_tokens/* TUI_DATA_LIST_ACCESSOR */.Cc,
    useExisting: (0,core_js_.forwardRef)(() => TuiDataListWrapperComponent_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]],
  decls: 3,
  vars: 2,
  consts: [[3, "emptyContent", 4, "ngIf", "ngIfElse"], ["loading", ""], [3, "emptyContent"], ["tuiElement", "", "tuiOption", "", "automation-id", "tui-data-list-wrapper__option", 3, "size", "value", "disabled", 4, "ngFor", "ngForOf"], ["tuiElement", "", "tuiOption", "", "automation-id", "tui-data-list-wrapper__option", 3, "size", "value", "disabled"], ["elementRef", "elementRef"], ["polymorpheus-outlet", "", 1, "t-content", 3, "content", "context"], ["automation-id", "tui-data-list-wrapper__loader", 1, "t-loader"]],
  template: function TuiDataListWrapperComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵtemplate"](0, TuiDataListWrapperComponent_tui_data_list_0_Template, 2, 2, "tui-data-list", 0);
      core_js_["ɵɵtemplate"](1, TuiDataListWrapperComponent_ng_template_1_Template, 1, 0, "ng-template", null, 1, core_js_["ɵɵtemplateRefExtractor"]);
    }
    if (rf & 2) {
      const _r1 = core_js_["ɵɵreference"](2);
      core_js_["ɵɵproperty"]("ngIf", ctx.items)("ngIfElse", _r1);
    }
  },
  directives: [common_js_.NgIf, TuiDataListComponent, common_js_.NgForOf, TuiOptionComponent, TuiElementDirective, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, taiga_ui_core_components_loader/* TuiLoaderComponent */.kM],
  styles: [taiga_ui_kit_components_data_list_wrapper_c1],
  changeDetection: 0
});
TuiDataListWrapperComponent.ctorParameters = () => [{
  type: undefined,
  decorators: [{
    type: core_js_.Inject,
    args: [TUI_ITEMS_HANDLERS]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDataListWrapperComponent.prototype, "items", void 0);
TuiDataListWrapperComponent = TuiDataListWrapperComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TUI_ITEMS_HANDLERS))], TuiDataListWrapperComponent);
let TuiDataListWrapperModule = /*#__PURE__*/(() => {
  let TuiDataListWrapperModule = class TuiDataListWrapperModule {};
  TuiDataListWrapperModule.ɵfac = function TuiDataListWrapperModule_Factory(t) {
    return new (t || TuiDataListWrapperModule)();
  };
  TuiDataListWrapperModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDataListWrapperModule
  });
  TuiDataListWrapperModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiElementModule, TuiDataListModule, taiga_ui_core_components_loader/* TuiLoaderModule */.dS]]
  });
  return TuiDataListWrapperModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDataListWrapperModule, {
    declarations: function () {
      return [TuiDataListWrapperComponent, TuiDataListGroupWrapperComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiElementModule, TuiDataListModule, taiga_ui_core_components_loader/* TuiLoaderModule */.dS];
    },
    exports: function () {
      return [TuiDataListWrapperComponent, TuiDataListGroupWrapperComponent, TuiDataListDirective];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-data-list-wrapper.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-badge.js








const taiga_ui_kit_components_badge_c0 = ["*"];
let TuiBadgeComponent = /*#__PURE__*/(() => {
  let TuiBadgeComponent = class TuiBadgeComponent {
    constructor(mode$) {
      this.mode$ = mode$;
      this.value = '';
      this.size = 'm';
      this.status = 'default';
      this.hoverable = false;
    }
    get padding() {
      if (this.isEmpty) {
        return 'none';
      }
      return (0,taiga_ui_cdk_utils_miscellaneous/* isNumber */.hj)(this.value.valueOf()) ? 'm' : 'l';
    }
    get outputValue() {
      if ((0,taiga_ui_cdk_utils_miscellaneous/* isNumber */.hj)(this.value.valueOf()) && this.value.valueOf() > 99) {
        return '99+';
      }
      return String(this.value);
    }
    get isEmpty() {
      return this.value === '';
    }
  };
  TuiBadgeComponent.ɵfac = function TuiBadgeComponent_Factory(t) {
    return new (t || TuiBadgeComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_MODE */.Au));
  };
  TuiBadgeComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiBadgeComponent,
    selectors: [["tui-badge"]],
    hostVars: 7,
    hostBindings: function TuiBadgeComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("$.data-mode.attr", function TuiBadgeComponent___data_mode_attr_HostBindingHandler() {
          return ctx.mode$;
        });
      }
      if (rf & 2) {
        core_js_["ɵɵattribute"]("data-size", ctx.size)("data-tui-host-status", ctx.status)("data-tui-host-padding", ctx.padding);
        core_js_["ɵɵclassProp"]("_hoverable", ctx.hoverable)("_empty-value", ctx.isEmpty);
      }
    },
    inputs: {
      value: "value",
      size: "size",
      status: "status",
      hoverable: "hoverable"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_core_providers/* MODE_PROVIDER */.CV])],
    ngContentSelectors: taiga_ui_kit_components_badge_c0,
    decls: 3,
    vars: 1,
    consts: [[1, "left-content"]],
    template: function TuiBadgeComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵelementStart"](0, "span", 0);
        core_js_["ɵɵprojection"](1);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtext"](2);
      }
      if (rf & 2) {
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵtextInterpolate1"]("\n", ctx.outputValue, "\n");
      }
    },
    styles: ["[_nghost-%COMP%]{transition-property:background-color;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;--left-content-color:currentColor;position:relative;display:inline-flex;font:var(--tui-font-text-s);align-items:center;justify-content:center;box-sizing:border-box;color:var(--tui-base-01);border-radius:6.25rem;white-space:nowrap;overflow:hidden;vertical-align:middle}[_nghost-%COMP%]:after{transition-property:background;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;position:absolute;top:0;left:0;width:100%;height:100%;content:'';box-sizing:border-box;border-radius:inherit;pointer-events:none}._hoverable[_nghost-%COMP%]:active[data-tui-host-status=custom]:after, ._hoverable[_nghost-%COMP%]:hover[data-tui-host-status=custom]:after{background-color:var(--tui-clear)}[data-tui-host-status=primary][_nghost-%COMP%]{background-color:var(--tui-primary);color:var(--tui-primary-text)}[data-tui-host-status=primary]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-primary-hover)}[data-tui-host-status=primary]._hoverable[_nghost-%COMP%]:active{background-color:var(--tui-primary-active)}[data-tui-host-status=error][_nghost-%COMP%]{--left-content-color:var(--tui-error-fill);background-color:var(--tui-error-bg);color:var(--tui-text-01)}[data-tui-host-status=error]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=error]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-error-bg-hover)}[data-tui-host-status=error][data-mode=onDark][_nghost-%COMP%]{background-color:var(--tui-error-bg-night);color:var(--tui-text-01-night)}[data-tui-host-status=error][data-mode=onDark]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=error][data-mode=onDark]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-error-bg-night-hover)}[data-tui-host-status=success][_nghost-%COMP%]{--left-content-color:var(--tui-success-fill);background-color:var(--tui-success-bg);color:var(--tui-text-01)}[data-tui-host-status=success]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=success]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-success-bg-hover)}[data-tui-host-status=success][data-mode=onDark][_nghost-%COMP%]{background-color:var(--tui-success-bg-night);color:var(--tui-text-01-night)}[data-tui-host-status=success][data-mode=onDark]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=success][data-mode=onDark]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-success-bg-night-hover)}[data-tui-host-status=warning][_nghost-%COMP%]{--left-content-color:var(--tui-warning-fill);background-color:var(--tui-warning-bg);color:var(--tui-text-01)}[data-tui-host-status=warning]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=warning]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-warning-bg-hover)}[data-tui-host-status=warning][data-mode=onDark][_nghost-%COMP%]{background-color:var(--tui-warning-bg-night);color:var(--tui-text-01-night)}[data-tui-host-status=warning][data-mode=onDark]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=warning][data-mode=onDark]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-warning-bg-night-hover)}[data-tui-host-status=info][_nghost-%COMP%]{--left-content-color:var(--tui-info-fill);background-color:var(--tui-info-bg);color:var(--tui-text-01)}[data-tui-host-status=info]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=info]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-info-bg-hover)}[data-tui-host-status=info][data-mode=onDark][_nghost-%COMP%]{background-color:var(--tui-info-bg-night);color:var(--tui-text-01-night)}[data-tui-host-status=info][data-mode=onDark]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=info][data-mode=onDark]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-info-bg-night-hover)}[data-tui-host-status=neutral][_nghost-%COMP%]{--left-content-color:var(--tui-neutral-fill);background-color:var(--tui-neutral-bg);color:var(--tui-text-01)}[data-tui-host-status=neutral]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=neutral]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-neutral-bg-hover)}[data-tui-host-status=neutral][data-mode=onDark][_nghost-%COMP%]{background-color:var(--tui-neutral-bg-night);color:var(--tui-text-01-night)}[data-tui-host-status=neutral][data-mode=onDark]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=neutral][data-mode=onDark]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-neutral-bg-night-hover)}[data-tui-host-status=default][_nghost-%COMP%]{background-color:var(--tui-base-06)}[data-tui-host-status=default][_nghost-%COMP%]:not([data-mode])._hoverable:hover{background-color:var(--tui-base-07)}[data-tui-host-status=default][_nghost-%COMP%]:not([data-mode])._hoverable:active{background-color:var(--tui-base-08)}[data-tui-host-status=default][data-mode=onDark][_nghost-%COMP%]{background-color:var(--tui-clear-inverse-hover)}[data-tui-host-status=default][data-mode=onDark]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-clear-inverse-active)}[data-tui-host-status=default][data-mode=onDark]._hoverable[_nghost-%COMP%]:active{background-color:var(--tui-clear-inverse-active)}[data-tui-host-status=default][data-mode=onDark][_nghost-%COMP%]:focus:after{border:2px solid var(--tui-base-01)}[data-tui-host-status=default][data-mode=onLight][_nghost-%COMP%]{background-color:var(--tui-clear);color:var(--tui-text-01)}[data-tui-host-status=default][data-mode=onLight]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-clear-hover)}[data-tui-host-status=default][data-mode=onLight]._hoverable[_nghost-%COMP%]:active{background-color:var(--tui-clear-active)}._hoverable[_nghost-%COMP%]{cursor:pointer}[data-tui-host-padding='m'][_nghost-%COMP%]{padding:0 .5rem}[data-tui-host-padding='m'][data-size=xs][_nghost-%COMP%]{padding:0 .25rem}[data-tui-host-padding='m'][data-size='s'][_nghost-%COMP%]{padding:0 .375rem}[data-tui-host-padding='m'][data-size='l'][_nghost-%COMP%]{padding:0 .625rem}[data-tui-host-padding='l'][_nghost-%COMP%]{padding:0 .625rem}[data-tui-host-padding='l'][data-size=xs][_nghost-%COMP%]{padding:0 .375rem}[data-tui-host-padding='l'][data-size='s'][_nghost-%COMP%]{padding:0 .5rem}[data-tui-host-padding='l'][data-size='l'][_nghost-%COMP%]{padding:0 .75rem}[data-size=xs][_nghost-%COMP%]{font:var(--tui-font-text-xs);height:1rem;min-width:1rem}[data-size=xs][_nghost-%COMP%]   .left-content[_ngcontent-%COMP%]:before{width:.34375rem;height:.34375rem}[data-size='s'][_nghost-%COMP%]{font:var(--tui-font-text-xs);height:1.25rem;min-width:1.25rem}[data-size='s'][_nghost-%COMP%]   .left-content[_ngcontent-%COMP%]:before{width:.25rem;height:.25rem}[data-size='m'][_nghost-%COMP%]{height:var(--tui-height-xs);line-height:var(--tui-height-xs);min-width:var(--tui-height-xs)}[data-size='l'][_nghost-%COMP%]{height:var(--tui-height-s);line-height:var(--tui-height-s);min-width:var(--tui-height-s)}[data-size='l'][_nghost-%COMP%]   .left-content[_ngcontent-%COMP%]:before{margin:0 .5rem 0 0;width:.5rem;height:.5rem}._empty-value[_nghost-%COMP%]   .left-content[_ngcontent-%COMP%]{margin:0 -.25rem}._empty-value[_nghost-%COMP%]   .left-content[_ngcontent-%COMP%]:before{margin:0}.left-content[_ngcontent-%COMP%]{display:none;color:var(--left-content-color);line-height:0}.left-content[_ngcontent-%COMP%]:not(:empty){display:block;margin-left:-.25rem}.left-content[_ngcontent-%COMP%]:not(:empty):before{content:none}[data-tui-host-status=error][_nghost-%COMP%]   .left-content[_ngcontent-%COMP%], [data-tui-host-status=info][_nghost-%COMP%]   .left-content[_ngcontent-%COMP%], [data-tui-host-status=neutral][_nghost-%COMP%]   .left-content[_ngcontent-%COMP%], [data-tui-host-status=success][_nghost-%COMP%]   .left-content[_ngcontent-%COMP%], [data-tui-host-status=warning][_nghost-%COMP%]   .left-content[_ngcontent-%COMP%]{display:block}.left-content[_ngcontent-%COMP%]:before{content:'';display:block;background:currentColor;margin:0 .375rem 0 0;width:.375rem;height:.375rem;border-radius:100%}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiBadgeComponent.prototype, "value", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-size'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiBadgeComponent.prototype, "size", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-tui-host-status'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiBadgeComponent.prototype, "status", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._hoverable'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiBadgeComponent.prototype, "hoverable", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('attr.data-tui-host-padding')], TuiBadgeComponent.prototype, "padding", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._empty-value')], TuiBadgeComponent.prototype, "isEmpty", null);
  TuiBadgeComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_MODE */.Au))], TuiBadgeComponent);
  return TuiBadgeComponent;
})();
let TuiBadgeModule = /*#__PURE__*/(() => {
  let TuiBadgeModule = class TuiBadgeModule {};
  TuiBadgeModule.ɵfac = function TuiBadgeModule_Factory(t) {
    return new (t || TuiBadgeModule)();
  };
  TuiBadgeModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiBadgeModule
  });
  TuiBadgeModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule]]
  });
  return TuiBadgeModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiBadgeModule, {
    declarations: function () {
      return [TuiBadgeComponent];
    },
    imports: function () {
      return [common_js_.CommonModule];
    },
    exports: function () {
      return [TuiBadgeComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-badge.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-toggle.js








/** Default values for the toggle options. */






const taiga_ui_kit_components_toggle_c0 = ["focusableElement"];
function TuiToggleComponent_tui_loader_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-loader", 7);
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("size", ctx_r0.loaderSize)("inheritColor", true)("showLoader", ctx_r0.checked);
  }
}
function TuiToggleComponent_ng_template_4_tui_svg_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 9);
  }
  if (rf & 2) {
    const icon_r5 = core_js_["ɵɵnextContext"]().$implicit;
    core_js_["ɵɵproperty"]("src", icon_r5);
  }
}
function TuiToggleComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵtemplate"](0, TuiToggleComponent_ng_template_4_tui_svg_0_Template, 1, 1, "tui-svg", 8);
  }
  if (rf & 2) {
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("ngIf", ctx_r1.showIcons && !ctx_r1.showLoader);
  }
}
function TuiToggleComponent_tui_loader_6_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-loader", 7);
  }
  if (rf & 2) {
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("size", ctx_r2.loaderSize)("inheritColor", true)("showLoader", !ctx_r2.checked);
  }
}
function TuiToggleComponent_ng_template_8_tui_svg_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 11);
  }
  if (rf & 2) {
    const icon_r8 = core_js_["ɵɵnextContext"]().$implicit;
    core_js_["ɵɵproperty"]("src", icon_r8);
  }
}
function TuiToggleComponent_ng_template_8_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵtemplate"](0, TuiToggleComponent_ng_template_8_tui_svg_0_Template, 1, 1, "tui-svg", 10);
  }
  if (rf & 2) {
    const ctx_r3 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("ngIf", ctx_r3.showIcons && !ctx_r3.showLoader);
  }
}
const taiga_ui_kit_components_toggle_c1 = function (a0) {
  return {
    $implicit: a0
  };
};
const TUI_TOGGLE_DEFAULT_OPTIONS = {
  icons: {
    toggleOff({
      $implicit
    }) {
      return $implicit === `m` ? `tuiIconToggleOff` : `tuiIconToggleOffLarge`;
    },
    toggleOn({
      $implicit
    }) {
      return $implicit === `m` ? `tuiIconToggleOn` : `tuiIconToggleOnLarge`;
    }
  },
  singleColor: false,
  showIcons: false,
  size: `m`
};
const TUI_TOGGLE_OPTIONS = new core_js_.InjectionToken(`Default parameters for toggle component`, {
  factory: () => TUI_TOGGLE_DEFAULT_OPTIONS
});
const tuiToggleOptionsProvider = options => ({
  provide: TUI_TOGGLE_OPTIONS,
  useValue: Object.assign(Object.assign({}, TUI_TOGGLE_DEFAULT_OPTIONS), options)
});
var TuiToggleComponent_1;
let TuiToggleComponent = TuiToggleComponent_1 = class TuiToggleComponent extends taiga_ui_cdk_abstract/* AbstractTuiControl */.M$ {
  constructor(control, changeDetectorRef, modeDirective, options) {
    super(control, changeDetectorRef);
    this.modeDirective = modeDirective;
    this.options = options;
    this.singleColor = this.options.singleColor;
    this.showIcons = this.options.showIcons;
    this.showLoader = false;
    this.size = this.options.size;
  }
  get iconOn() {
    return this.options.icons.toggleOn;
  }
  get iconOff() {
    return this.options.icons.toggleOff;
  }
  get nativeFocusableElement() {
    return this.focusableElement ? this.focusableElement.nativeElement : null;
  }
  get focused() {
    return (0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(this.nativeFocusableElement);
  }
  get appearance() {
    return this.singleColor || this.checked ? "primary" /* Primary */ : "secondary" /* Secondary */;
  }

  get sizeM() {
    return this.size === 'm';
  }
  get checked() {
    return this.value;
  }
  get loaderSize() {
    return this.sizeM ? 'xs' : 's';
  }
  get hostMode() {
    return this.modeDirective ? this.modeDirective.mode : null;
  }
  onChecked(checked) {
    this.updateValue(checked);
  }
  onFocused(focused) {
    this.updateFocused(focused);
  }
  onHovered(hovered) {
    this.updateHovered(hovered);
  }
  onPressed(pressed) {
    this.updatePressed(pressed);
  }
  onFocusVisible(focusVisible) {
    this.updateFocusVisible(focusVisible);
  }
  getFallbackValue() {
    return false;
  }
};
TuiToggleComponent.ɵfac = function TuiToggleComponent_Factory(t) {
  return new (t || TuiToggleComponent)(core_js_["ɵɵdirectiveInject"](fesm2015_forms.NgControl, 10), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_directives_mode/* TuiModeDirective */.w, 8), core_js_["ɵɵdirectiveInject"](TUI_TOGGLE_OPTIONS));
};
TuiToggleComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiToggleComponent,
  selectors: [["tui-toggle"]],
  viewQuery: function TuiToggleComponent_Query(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵviewQuery"](taiga_ui_kit_components_toggle_c0, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.focusableElement = _t.first);
    }
  },
  hostVars: 4,
  hostBindings: function TuiToggleComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      core_js_["ɵɵattribute"]("data-size", ctx.size)("data-mode", ctx.hostMode);
      core_js_["ɵɵclassProp"]("_checked", ctx.checked);
    }
  },
  inputs: {
    singleColor: "singleColor",
    showIcons: "showIcons",
    showLoader: "showLoader",
    size: "size"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ,
    useExisting: (0,core_js_.forwardRef)(() => TuiToggleComponent_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]],
  decls: 11,
  vars: 22,
  consts: [[3, "appearance", "readOnly", "disabled", "focused", "hovered", "pressed", "invalid"], [1, "t-toggle"], ["class", "t-loader", 3, "size", "inheritColor", "showLoader", 4, "ngIf"], ["polymorpheus-outlet", "", 1, "t-icon-wrapper", 3, "content", "context"], [1, "t-circle"], ["type", "checkbox", "role", "switch", "automation-id", "tui-toggle__checkbox", 1, "t-checkbox", 3, "id", "disabled", "tuiChecked", "tuiFocusable", "tuiCheckedChange", "tuiFocusedChange", "tuiHoveredChange", "tuiPressedChange", "tuiFocusVisibleChange"], ["focusableElement", ""], [1, "t-loader", 3, "size", "inheritColor", "showLoader"], ["automation-id", "tui-toggle__check-icon", "class", "t-icon", 3, "src", 4, "ngIf"], ["automation-id", "tui-toggle__check-icon", 1, "t-icon", 3, "src"], ["automation-id", "tui-toggle__cancel-icon", "class", "t-icon t-icon_off", 3, "src", 4, "ngIf"], ["automation-id", "tui-toggle__cancel-icon", 1, "t-icon", "t-icon_off", 3, "src"]],
  template: function TuiToggleComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵelementStart"](0, "tui-wrapper", 0);
      core_js_["ɵɵelementStart"](1, "div", 1);
      core_js_["ɵɵtemplate"](2, TuiToggleComponent_tui_loader_2_Template, 1, 3, "tui-loader", 2);
      core_js_["ɵɵelementStart"](3, "span", 3);
      core_js_["ɵɵtemplate"](4, TuiToggleComponent_ng_template_4_Template, 1, 1, "ng-template");
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelement"](5, "div", 4);
      core_js_["ɵɵtemplate"](6, TuiToggleComponent_tui_loader_6_Template, 1, 3, "tui-loader", 2);
      core_js_["ɵɵelementStart"](7, "span", 3);
      core_js_["ɵɵtemplate"](8, TuiToggleComponent_ng_template_8_Template, 1, 1, "ng-template");
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementStart"](9, "input", 5, 6);
      core_js_["ɵɵlistener"]("tuiCheckedChange", function TuiToggleComponent_Template_input_tuiCheckedChange_9_listener($event) {
        return ctx.onChecked($event);
      })("tuiFocusedChange", function TuiToggleComponent_Template_input_tuiFocusedChange_9_listener($event) {
        return ctx.onFocused($event);
      })("tuiHoveredChange", function TuiToggleComponent_Template_input_tuiHoveredChange_9_listener($event) {
        return ctx.onHovered($event);
      })("tuiPressedChange", function TuiToggleComponent_Template_input_tuiPressedChange_9_listener($event) {
        return ctx.onPressed($event);
      })("tuiFocusVisibleChange", function TuiToggleComponent_Template_input_tuiFocusVisibleChange_9_listener($event) {
        return ctx.onFocusVisible($event);
      });
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      core_js_["ɵɵproperty"]("appearance", ctx.appearance)("readOnly", ctx.readOnly)("disabled", ctx.computedDisabled)("focused", ctx.computedFocusVisible)("hovered", ctx.computedHovered)("pressed", ctx.computedPressed)("invalid", ctx.computedInvalid);
      core_js_["ɵɵadvance"](2);
      core_js_["ɵɵproperty"]("ngIf", ctx.showLoader);
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵproperty"]("content", ctx.iconOn)("context", core_js_["ɵɵpureFunction1"](18, taiga_ui_kit_components_toggle_c1, ctx.size));
      core_js_["ɵɵadvance"](3);
      core_js_["ɵɵproperty"]("ngIf", ctx.showLoader);
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵproperty"]("content", ctx.iconOff)("context", core_js_["ɵɵpureFunction1"](20, taiga_ui_kit_components_toggle_c1, ctx.size));
      core_js_["ɵɵadvance"](2);
      core_js_["ɵɵproperty"]("id", ctx.id)("disabled", ctx.disabled)("tuiChecked", ctx.checked)("tuiFocusable", ctx.focusable);
      core_js_["ɵɵattribute"]("aria-checked", ctx.value);
    }
  },
  directives: [taiga_ui_core_directives_wrapper/* TuiWrapperDirective */.o, common_js_.NgIf, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, TuiCheckedDirective, TuiFocusableDirective, TuiFocusedDirective, TuiHoveredDirective, TuiPressedDirective, TuiFocusVisibleDirective, taiga_ui_core_components_loader/* TuiLoaderComponent */.kM, taiga_ui_core_components_svg/* TuiSvgComponent */.P],
  styles: ["[_nghost-%COMP%]{position:relative;display:inline-block;vertical-align:middle;overflow:hidden;border-radius:6.25rem}[data-size='m'][_nghost-%COMP%]{width:2rem;height:1rem}[data-size='l'][_nghost-%COMP%]{width:3rem;height:1.5rem}.t-checkbox[_ngcontent-%COMP%]{padding:0;margin:0;border:0;border-radius:inherit;background:0 0;font-size:inherit;line-height:inherit;font-weight:inherit;color:inherit;caret-color:currentColor;outline:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;word-break:keep-all;-webkit-text-fill-color:currentColor;position:absolute;top:0;left:0;height:100%;width:100%;opacity:0;cursor:pointer}.t-checkbox[_ngcontent-%COMP%]:-webkit-autofill, .t-checkbox[_ngcontent-%COMP%]:-webkit-autofill:focus, .t-checkbox[_ngcontent-%COMP%]:-webkit-autofill:hover{caret-color:var(--tui-base-09);border-radius:inherit;color:inherit!important;background-color:transparent!important;-webkit-text-fill-color:var(--tui-text-01)!important;border-color:var(--tui-autofill);-webkit-box-shadow:0 0 0 100rem var(--tui-autofill) inset!important}._disabled[_nghost-%COMP%]   .t-checkbox[_ngcontent-%COMP%]{pointer-events:none;cursor:default}.t-toggle[_ngcontent-%COMP%]{transition-property:transform;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;display:flex;align-items:center;justify-content:center}[data-size='m'][_nghost-%COMP%]   .t-toggle[_ngcontent-%COMP%]{width:3rem;height:1rem;transform:translateX(-1rem)}[data-size='l'][_nghost-%COMP%]   .t-toggle[_ngcontent-%COMP%]{width:4.5rem;height:1.5rem;transform:translateX(-1.5rem)}._checked[_nghost-%COMP%]   .t-toggle[_ngcontent-%COMP%]{transform:translateX(0)}.t-circle[_ngcontent-%COMP%]{margin:.125rem 0;flex-shrink:0;border-radius:100%;background-color:var(--tui-base-01)}._disabled[_nghost-%COMP%]   .t-circle_light[_ngcontent-%COMP%]{opacity:.24}[data-size='m'][_nghost-%COMP%]   .t-circle[_ngcontent-%COMP%]{width:.75rem;height:.75rem}[data-size='l'][_nghost-%COMP%]   .t-circle[_ngcontent-%COMP%]{width:1rem;height:1rem}._disabled[_nghost-%COMP%]   .t-circle[_ngcontent-%COMP%]{background-color:var(--tui-base-01)}[_nghost-%COMP%]:not(._checked)   .t-loader[_ngcontent-%COMP%]{color:var(--tui-base-06)}[_nghost-%COMP%]:not(._checked)._disabled   .t-loader[_ngcontent-%COMP%]{color:var(--tui-base-05)}[_nghost-%COMP%]:not(._checked)[data-mode=onDark]   .t-loader[_ngcontent-%COMP%]{color:var(--tui-text-03-night)}[_nghost-%COMP%]:not(._checked)[data-mode=onDark]._disabled   .t-loader[_ngcontent-%COMP%]{color:var(--tui-clear-inverse-active)}[_nghost-%COMP%]:not(._checked)[data-mode=onLight]   .t-loader[_ngcontent-%COMP%]{color:var(--tui-text-03)}[_nghost-%COMP%]:not(._checked)[data-mode=onLight]._disabled   .t-loader[_ngcontent-%COMP%]{color:var(--tui-clear-active)}[data-size='m'][_nghost-%COMP%]   .t-loader[_ngcontent-%COMP%]{width:.75rem;margin:0 .2rem;transform:scale(.75)}[data-size='l'][_nghost-%COMP%]   .t-loader[_ngcontent-%COMP%]{width:1rem;margin:0 .25rem}.t-icon-wrapper[_ngcontent-%COMP%]{display:flex}.t-icon[_ngcontent-%COMP%]{opacity:.8}.t-icon_off[_ngcontent-%COMP%]{color:var(--tui-base-06)}._disabled[_nghost-%COMP%]   .t-icon_off[_ngcontent-%COMP%]{color:var(--tui-base-05)}[data-mode=onDark][_nghost-%COMP%]   .t-icon_off[_ngcontent-%COMP%]{color:var(--tui-text-03-night)}[data-mode=onDark]._disabled[_nghost-%COMP%]   .t-icon_off[_ngcontent-%COMP%]{color:var(--tui-clear-inverse-active)}[data-mode=onLight][_nghost-%COMP%]   .t-icon_off[_ngcontent-%COMP%]{color:var(--tui-text-03)}[data-mode=onLight]._disabled[_nghost-%COMP%]   .t-icon_off[_ngcontent-%COMP%]{color:var(--tui-clear-active)}[data-size='m'][_nghost-%COMP%]   .t-icon[_ngcontent-%COMP%]{width:1rem;height:1rem;transform:scale(.75)}[data-size='l'][_nghost-%COMP%]   .t-icon[_ngcontent-%COMP%]{margin:0 .125rem;width:1.5rem;height:1.5rem}[_nghost-%COMP%]:hover   .t-icon[_ngcontent-%COMP%]{opacity:1}"],
  changeDetection: 0
});
TuiToggleComponent.ctorParameters = () => [{
  type: fesm2015_forms.NgControl,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.Self
  }, {
    type: core_js_.Inject,
    args: [fesm2015_forms.NgControl]
  }]
}, {
  type: core_js_.ChangeDetectorRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ChangeDetectorRef]
  }]
}, {
  type: taiga_ui_core_directives_mode/* TuiModeDirective */.w,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.Inject,
    args: [taiga_ui_core_directives_mode/* TuiModeDirective */.w]
  }]
}, {
  type: undefined,
  decorators: [{
    type: core_js_.Inject,
    args: [TUI_TOGGLE_OPTIONS]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('focusableElement')], TuiToggleComponent.prototype, "focusableElement", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiToggleComponent.prototype, "singleColor", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiToggleComponent.prototype, "showIcons", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiToggleComponent.prototype, "showLoader", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-size'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiToggleComponent.prototype, "size", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._checked')], TuiToggleComponent.prototype, "checked", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('attr.data-mode')], TuiToggleComponent.prototype, "hostMode", null);
TuiToggleComponent = TuiToggleComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(fesm2015_forms.NgControl)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_core_directives_mode/* TuiModeDirective */.w)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TUI_TOGGLE_OPTIONS))], TuiToggleComponent);
let TuiToggleModule = /*#__PURE__*/(() => {
  let TuiToggleModule = class TuiToggleModule {};
  TuiToggleModule.ɵfac = function TuiToggleModule_Factory(t) {
    return new (t || TuiToggleModule)();
  };
  TuiToggleModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiToggleModule
  });
  TuiToggleModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, TuiFocusedModule, TuiFocusableModule, TuiHoveredModule, TuiPressedModule, TuiFocusVisibleModule, TuiCheckedModule, taiga_ui_core_directives_wrapper/* TuiWrapperModule */.W, taiga_ui_core_components_svg/* TuiSvgModule */.E, taiga_ui_core_components_loader/* TuiLoaderModule */.dS, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq]]
  });
  return TuiToggleModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiToggleModule, {
    declarations: function () {
      return [TuiToggleComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, TuiFocusedModule, TuiFocusableModule, TuiHoveredModule, TuiPressedModule, TuiFocusVisibleModule, TuiCheckedModule, taiga_ui_core_directives_wrapper/* TuiWrapperModule */.W, taiga_ui_core_components_svg/* TuiSvgModule */.E, taiga_ui_core_components_loader/* TuiLoaderModule */.dS, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq];
    },
    exports: function () {
      return [TuiToggleComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-toggle.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-utils-format.js


/**
 * @deprecated: use {@link tuiCapitalize} instead
 * Capitalizes a given string, replacing it with a lowercase string and making
 * the first letter of each word uppercase.
 *
 * @param value the input string
 * @return the capitalized string
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function capitalize(value) {
  return value.toLowerCase().replace(/(?:^|\s)\S/g, char => char.toUpperCase());
}
const tuiCapitalize = (/* unused pure expression or super */ null && (capitalize));

/**
 * @deprecated: use {@link tuiCapitalizeFirstLetter} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function capitalizeFirstLetter(value) {
  return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;
}
const tuiCapitalizeFirstLetter = capitalizeFirstLetter;

/**
 * @deprecated: use {@link tuiNumberToStringWithoutExp} instead
 * Convert number to string with replacing exponent part on decimals
 *
 * @param value the number
 * @return string representation of a number
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function numberToStringWithoutExp(value) {
  const valueAsString = String(value);
  const [numberPart, expPart] = valueAsString.split(`e-`);
  let valueWithoutExp = valueAsString;
  if (expPart) {
    const [, fractionalPart] = numberPart.split(`.`);
    const decimalDigits = Number(expPart) + ((fractionalPart === null || fractionalPart === void 0 ? void 0 : fractionalPart.length) || 0);
    valueWithoutExp = value.toFixed(decimalDigits);
  }
  return valueWithoutExp;
}
const tuiNumberToStringWithoutExp = (/* unused pure expression or super */ null && (numberToStringWithoutExp));

/**
 * @deprecated: use {@link tuiGetFractionPartPadded} instead
 * Return fractional part of number
 *
 * @param value the number
 * @param precision number of digits of decimal part, null to keep untouched
 * @return the fractional part of number
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getFractionPartPadded(value, precision) {
  const [, fractionPartPadded = ``] = numberToStringWithoutExp(value).split(`.`);
  return typeof precision === `number` ? fractionPartPadded.slice(0, Math.max(0, precision)) : fractionPartPadded;
}
const tuiGetFractionPartPadded = (/* unused pure expression or super */ null && (getFractionPartPadded));

// TODO: refactor later to `formatNumber(value: number, options: Partial<AllTheStuff>)`
/**
 * @deprecated: use {@link tuiFormatNumber} instead
 * Formats number adding a thousand separators and correct decimal separator
 * padding decimal part with zeroes to given length
 *
 * @param value the input number
 * @param decimalLimit number of digits of decimal part, null to keep untouched
 * @param decimalSeparator separator between the integer and the decimal part
 * @param thousandSeparator separator between thousands
 * @param zeroPadding enable zeros at the end of decimal part
 * @return the formatted string
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function formatNumber(value, decimalLimit = null, decimalSeparator = `,`, thousandSeparator = taiga_ui_cdk_constants/* CHAR_NO_BREAK_SPACE */.f$, zeroPadding = true) {
  const integerPartString = String(Math.floor(Math.abs(value)));
  let fractionPartPadded = getFractionPartPadded(value, decimalLimit);
  if (decimalLimit !== null) {
    if (zeroPadding) {
      const zeroPaddingSize = Math.max(decimalLimit - fractionPartPadded.length, 0);
      const zeroPartString = `0`.repeat(zeroPaddingSize);
      fractionPartPadded = `${fractionPartPadded}${zeroPartString}`;
    } else {
      fractionPartPadded = fractionPartPadded.replace(/0*$/, ``);
    }
  }
  const remainder = integerPartString.length % 3;
  const sign = value < 0 ? taiga_ui_cdk_constants/* CHAR_HYPHEN */.fv : ``;
  let result = sign + integerPartString.charAt(0);
  for (let i = 1; i < integerPartString.length; i++) {
    if (i % 3 === remainder && integerPartString.length > 3) {
      result += thousandSeparator;
    }
    result += integerPartString.charAt(i);
  }
  return fractionPartPadded ? result + decimalSeparator + fractionPartPadded : result;
}
const tuiFormatNumber = (/* unused pure expression or super */ null && (formatNumber));

/**
 * @deprecated: use {@link tuiFormatPhone} instead
 * Formats a string with the phone format +7XXXXXXXXXXXX or XXXXXXXXXXXX,
 * adding parentheses and hyphens.
 *
 * @param value the input string
 * @param countryCode a country code
 * @param phoneMask a phone number mask
 * @return the formatted phone string of the form +7 XXX XXX-XX-XX
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function formatPhone(value, countryCode, phoneMask) {
  if (!value) {
    return ``;
  }
  let result = countryCode;
  countryCode = countryCode.replace(/[()]/g, ``);
  if (!value.startsWith(countryCode)) {
    value = countryCode + value.replace(CHAR_PLUS, ``);
  }
  const splitPhoneMask = phoneMask.split(``);
  const splitValue = value.slice(countryCode.length).split(``);
  result += ` `;
  if (splitValue.length === 0) {
    return result;
  }
  for (let i = 0; i < splitPhoneMask.length; i++) {
    if (splitValue.length === 0) {
      break;
    }
    if (splitPhoneMask[i] === `#`) {
      result += splitValue[0] || ``;
      splitValue.splice(0, 1);
    } else {
      result += splitPhoneMask[i];
    }
  }
  return result;
}
const tuiFormatPhone = (/* unused pure expression or super */ null && (formatPhone));

/**
 * @deprecated: use {@link tuiOtherDecimalSymbol} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function otherDecimalSymbol(symbol) {
  return symbol === `.` ? `,` : `.`;
}
const tuiOtherDecimalSymbol = (/* unused pure expression or super */ null && (otherDecimalSymbol));

/**
 * Selects the correct plural form to display.
 *
 * @param value the input number
 * @param args an array of three plural forms, e.g. ['год', 'года', 'лет']
 * @deprecated This implementation targets Russian.
 * Use https://angular.io/api/common/NgPlural for your implementations.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function pluralize(value, [one, few, many]) {
  const ten = value % 10;
  const hundred = value % 100;
  // 1, 21, 101, 121, но не 11, 111, 211...
  if (ten === 1 && hundred !== 11) {
    return one;
  }
  // 2, 3, 4, 22, 33, 44, 152, 163, 174, но не 12, 13, 14, 112, 213, 314...
  if (ten >= 2 && ten <= 4 && (hundred < 10 || hundred >= 20)) {
    return few;
  }
  return many;
}

// TODO: 3.0 remove in 3.0
/**
 * Temporary util for mapping TuiPluralize array to ICU format
 */
function tuiPluralizeToICU(pluralize) {
  return {
    one: pluralize[0],
    few: pluralize[1],
    many: pluralize[2],
    other: pluralize[2]
  };
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-utils-format.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-utils-mask.js




/**
 * Used to finish a number with zeros to a given precision
 */
function tuiCreateAutoCorrectedNumberPipe(decimalLimit = 0, decimalSymbol = `,`, thousandSymbol = CHAR_NO_BREAK_SPACE, nativeInput, allowNegative, isIOS = false) {
  tuiAssert.assert(Number.isInteger(decimalLimit));
  tuiAssert.assert(decimalLimit >= 0);
  // Guess for which browser I need this :)
  let previousCaret = -1;
  const unlucky = !!nativeInput && isSafari(nativeInput) || isIOS;
  if (nativeInput && unlucky) {
    nativeInput.addEventListener(`beforeinput`, () => {
      previousCaret = nativeInput.selectionStart || 0;
    });
  }
  return (conformedValue, config) => {
    // Removing everything by selecting and pressing '-'
    if (!conformedValue && config.rawValue === CHAR_HYPHEN && allowNegative) {
      return CHAR_HYPHEN;
    }
    // remove these hacks after text mask library has changed
    if (nativeInput && unlucky && isNativeFocused(nativeInput)) {
      const caret = calculateSafariCaret(config.previousConformedValue, conformedValue, previousCaret);
      setTimeout(() => {
        nativeInput.setSelectionRange(caret, caret);
      });
    }
    if (nativeInput && nativeInput.ownerDocument !== getDocumentOrShadowRoot(nativeInput) && isNativeFocused(nativeInput) && config.currentCaretPosition) {
      const realCaretPosition = config.currentCaretPosition + calculateCaretGap(config.previousConformedValue, conformedValue, thousandSymbol);
      setTimeout(() => {
        nativeInput.setSelectionRange(realCaretPosition, realCaretPosition);
      });
    }
    if (conformedValue === `` || !decimalLimit) {
      return {
        value: conformedValue
      };
    }
    const withDecimalSymbol = addDecimalSymbolIfNeeded(conformedValue, decimalSymbol);
    const decimalPart = withDecimalSymbol.split(decimalSymbol)[1];
    const zeroPaddingSize = decimalLimit - decimalPart.length;
    return {
      value: withDecimalSymbol + `0`.repeat(zeroPaddingSize)
    };
  };
}
function addDecimalSymbolIfNeeded(value, decimalSymbol = `,`) {
  return !value.includes(decimalSymbol) ? value + decimalSymbol : value;
}
function calculateSafariCaret(previousValue = ``, current, previousCaret, decimalSymbol = `,`) {
  const tailRegex = new RegExp(`${decimalSymbol}.+`);
  const previousWithoutTail = previousValue.replace(tailRegex, ``);
  const currentWithoutTail = current.replace(tailRegex, ``);
  const pasteOrCutOperation = Math.abs(previousWithoutTail.length - currentWithoutTail.length) > 2;
  if (pasteOrCutOperation) {
    return current.length;
  }
  if (previousValue.length === current.length) {
    if (previousValue.indexOf(decimalSymbol) <= previousCaret) {
      return calculateChangedTailIndex(previousValue, current);
    }
    return previousWithoutTail === currentWithoutTail ? previousCaret - 1 : previousCaret + 1;
  }
  if (previousValue.length === 0) {
    return 1;
  }
  const changeLength = current.length - previousValue.length;
  return previousCaret + changeLength;
}
function calculateChangedTailIndex(previous, current) {
  for (let i = 0; i < current.length; i++) {
    if (previous[i] !== current[i]) {
      return current[i] === `0` ? i : i + 1;
    }
  }
  return current.length;
}
function calculateCaretGap(previousValue = ``, current, thousandSymbol) {
  const pasteOrCutOperation = Math.abs(previousValue.length - current.length) > 2;
  if (pasteOrCutOperation) {
    return 0;
  }
  const wereSpaces = previousValue.split(thousandSymbol).length;
  const nowSpaces = current.split(thousandSymbol).length;
  return nowSpaces - wereSpaces;
}
const ASSERTION = (/* unused pure expression or super */ null && (`Correction function must return single char or null`));
function tuiCreateCorrectionMask(allowed, correctionHandler) {
  return rawValue => {
    const mask = rawValue.split(``).reduce((result, char, index) => {
      const corrected = correctionHandler(char, index);
      tuiAssert.assert(corrected === null || corrected.length === 1, ASSERTION);
      if (!allowed.test(char) && !corrected) {
        return result;
      }
      if (allowed.test(char)) {
        return [...result, allowed];
      }
      if (corrected) {
        return [...result, corrected, MASK_CARET_TRAP];
      }
      return result;
    }, []);
    const lastIndex = mask.lastIndexOf(MASK_CARET_TRAP);
    const filtered = mask.filter((item, index) => item !== MASK_CARET_TRAP || index === lastIndex);
    return filtered.some(item => item !== allowed) ? [...filtered, allowed] : filtered;
  };
}
const NON_ZERO_DIGIT = /[1-9]/;
/**
 * Adaptation for {@link https://github.com/text-mask/text-mask/tree/master/addons#createnumbermask `createNumberMask`}
 */
function tuiCreateNumberMask({
  allowDecimal = false,
  decimalSymbol = `,`,
  thousandSymbol = taiga_ui_cdk_constants/* CHAR_NO_BREAK_SPACE */.f$,
  autoCorrectDecimalSymbol = true,
  decimalLimit = 2,
  requireDecimal = false,
  allowNegative = false,
  integerLimit = 0
} = {}) {
  taiga_ui_cdk_classes/* tuiAssert */.zU.assert(Number.isInteger(decimalLimit));
  taiga_ui_cdk_classes/* tuiAssert */.zU.assert(decimalLimit >= 0);
  taiga_ui_cdk_classes/* tuiAssert */.zU.assert(Number.isInteger(integerLimit));
  taiga_ui_cdk_classes/* tuiAssert */.zU.assert(integerLimit >= 0);
  return (rawValue, {
    previousConformedValue
  }) => {
    if (previousConformedValue && requireDecimal) {
      const conformedWithoutSeparator = rawValue.split(thousandSymbol).join(``);
      const previousConformedValueWithoutDecimalSymbolAndSeparator = previousConformedValue.split(thousandSymbol).join(``).split(decimalSymbol).join(``);
      // Forbid removal of decimal separator if decimal part is required
      if (conformedWithoutSeparator === previousConformedValueWithoutDecimalSymbolAndSeparator) {
        rawValue = previousConformedValue;
      }
    }
    const isNegative = (rawValue[0] === taiga_ui_cdk_constants/* CHAR_HYPHEN */.fv || rawValue[0] === taiga_ui_cdk_constants/* CHAR_EN_DASH */.F) && allowNegative;
    if (isDecimalSymbol(rawValue, decimalSymbol, autoCorrectDecimalSymbol) && allowDecimal) {
      return [`0`, decimalSymbol, taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW];
    }
    if (isNegative) {
      rawValue = rawValue.slice(1);
    }
    const decimalIndex = getDecimalSymbolIndex(rawValue, decimalSymbol, autoCorrectDecimalSymbol);
    const hasDecimal = decimalIndex !== -1;
    const integer = hasDecimal ? rawValue.slice(0, decimalIndex) : rawValue;
    const thousandSeparators = integer.match(new RegExp(thousandSymbol, `g`)) || [];
    const integerCapped = integerLimit ? integer.slice(0, integerLimit + thousandSeparators.length) : integer;
    const integerCappedClean = integerCapped.replace(taiga_ui_core_constants/* TUI_NON_DIGITS_REGEXP */.R3, ``);
    const [leadingZerosMatch] = integerCappedClean.match(taiga_ui_core_constants/* TUI_LEADING_ZEROES_REGEXP */.s9) || [``];
    const leadingZerosAmount = leadingZerosMatch.length;
    const integerCappedZerosClean = integerCappedClean.replace(/^0+(?!\.|$)/, ``).trim();
    const withSeparator = addThousandsSeparator(integerCappedZerosClean, thousandSymbol);
    const mask = convertToMask(withSeparator);
    if (hasDecimal && allowDecimal || requireDecimal) {
      const fraction = hasDecimal ? convertToMask(rawValue.slice(decimalIndex + 1).replace(taiga_ui_core_constants/* TUI_NON_DIGITS_REGEXP */.R3, ``)) : [];
      const fractionCapped = decimalLimit ? fraction.slice(0, decimalLimit) : fraction;
      if (rawValue[decimalIndex] !== otherDecimalSymbol(decimalSymbol)) {
        mask.push(taiga_ui_core_constants/* MASK_CARET_TRAP */.v1);
      }
      mask.push(decimalSymbol, taiga_ui_core_constants/* MASK_CARET_TRAP */.v1, ...fractionCapped);
      for (let i = 0; i < decimalLimit - fractionCapped.length; i++) {
        mask.push(taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW);
      }
    }
    const isOnlyZeroDigit = mask.length === 1 && integerCappedZerosClean === `0`;
    if (isNegative) {
      if (mask.length === 0) {
        mask.push(taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW);
      }
      mask.unshift(taiga_ui_cdk_constants/* CHAR_HYPHEN */.fv);
    }
    return preventLeadingZeroes(mask, isOnlyZeroDigit, leadingZerosAmount);
  };
}
function preventLeadingZeroes(mask, isOnlyZeroDigit = false, leadingZerosAmount = 0) {
  if (isOnlyZeroDigit || leadingZerosAmount === 0) {
    return mask;
  }
  const firstDigitIndex = mask.indexOf(taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW);
  if (firstDigitIndex === -1) {
    return mask;
  }
  const secondMaskDigit = mask[firstDigitIndex + 1];
  const isCaretTrap = secondMaskDigit === taiga_ui_core_constants/* MASK_CARET_TRAP */.v1;
  if (isCaretTrap && leadingZerosAmount === 1) {
    return mask;
  }
  if (isCaretTrap) {
    mask.unshift(NON_ZERO_DIGIT);
    return mask;
  }
  mask[firstDigitIndex] = NON_ZERO_DIGIT;
  return mask;
}
function getDecimalSymbolIndex(str, decimalSymbol, autoCorrectDecimalSymbol) {
  if (!autoCorrectDecimalSymbol) {
    return str.lastIndexOf(decimalSymbol);
  }
  return Math.max(str.lastIndexOf(decimalSymbol), str.lastIndexOf(otherDecimalSymbol(decimalSymbol)));
}
function isDecimalSymbol(str, decimalSymbol, autoCorrectDecimalSymbol) {
  if (autoCorrectDecimalSymbol) {
    return /^[,.]$/.test(str);
  }
  return str === decimalSymbol;
}
function convertToMask(strNumber) {
  return strNumber.split(``).map(char => taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW.test(char) ? taiga_ui_core_constants/* TUI_DIGIT_REGEXP */.hW : char);
}
function addThousandsSeparator(strNumber, thousandSymbol) {
  return strNumber.length > 3 ?
  // TODO: investigate to disallow potentially catastrophic exponential-time regular expressions.
  // eslint-disable-next-line unicorn/no-unsafe-regex
  strNumber.replace(/\B(?=(\d{3})+(?!\d))/g, thousandSymbol) : strNumber;
}
function tuiEnableAutoCorrectDecimalSymbol({
  thousandSeparator
}) {
  return !TUI_DECIMAL_SYMBOLS.includes(thousandSeparator);
}

/**
 * @deprecated: use {@link tuiMaskedMoneyValueIsEmpty} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function maskedMoneyValueIsEmpty(value) {
  switch (value) {
    case ``:
    case CHAR_HYPHEN:
    case `,`:
    case `${CHAR_HYPHEN},`:
      return true;
    default:
      return false;
  }
}
const tuiMaskedMoneyValueIsEmpty = (/* unused pure expression or super */ null && (maskedMoneyValueIsEmpty));

/**
 * @deprecated: use {@link tuiMaskedNumberStringToNumber} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function maskedNumberStringToNumber(value, decimalsSymbol, thousandSymbol) {
  return parseFloat(value.split(thousandSymbol).join(``).split(decimalsSymbol).join(`.`));
}
const tuiMaskedNumberStringToNumber = maskedNumberStringToNumber;

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-utils-mask.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-button.js
var taiga_ui_core_components_button = __webpack_require__(2628);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-directives-value-accessor.js




let TuiValueAccessorDirective = /*#__PURE__*/(() => {
  let TuiValueAccessorDirective = class TuiValueAccessorDirective {};
  TuiValueAccessorDirective.ɵfac = function TuiValueAccessorDirective_Factory(t) {
    return new (t || TuiValueAccessorDirective)();
  };
  TuiValueAccessorDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiValueAccessorDirective,
    selectors: [["", "tuiValueAccessor", ""]],
    features: [core_js_["ɵɵProvidersFeature"]([TUI_VALUE_ACCESSOR_PROVIDER])]
  });
  return TuiValueAccessorDirective;
})();
let TuiValueAccessorModule = /*#__PURE__*/(() => {
  let TuiValueAccessorModule = class TuiValueAccessorModule {};
  TuiValueAccessorModule.ɵfac = function TuiValueAccessorModule_Factory(t) {
    return new (t || TuiValueAccessorModule)();
  };
  TuiValueAccessorModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiValueAccessorModule
  });
  TuiValueAccessorModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiValueAccessorModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiValueAccessorModule, {
    declarations: [TuiValueAccessorDirective],
    exports: [TuiValueAccessorDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-directives-value-accessor.js.map
// EXTERNAL MODULE: ./node_modules/angular2-text-mask/dist/angular2TextMask.js
var angular2TextMask = __webpack_require__(1120);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-input-count.js












// TODO: 3.0 remove in ivy compilation







function TuiInputCountComponent_ng_container_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵelementStart"](1, "section", 2);
    core_js_["ɵɵelementStart"](2, "button", 3);
    core_js_["ɵɵlistener"]("mousedown", function TuiInputCountComponent_ng_container_3_ng_container_1_Template_button_mousedown_2_listener($event) {
      core_js_["ɵɵrestoreView"](_r4);
      const ctx_r3 = core_js_["ɵɵnextContext"](2);
      return ctx_r3.onButtonMouseDown($event, ctx_r3.plusButtonDisabled);
    })("click", function TuiInputCountComponent_ng_container_3_ng_container_1_Template_button_click_2_listener() {
      core_js_["ɵɵrestoreView"](_r4);
      const ctx_r5 = core_js_["ɵɵnextContext"](2);
      return ctx_r5.increaseValue();
    });
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementStart"](3, "button", 4);
    core_js_["ɵɵlistener"]("mousedown", function TuiInputCountComponent_ng_container_3_ng_container_1_Template_button_mousedown_3_listener($event) {
      core_js_["ɵɵrestoreView"](_r4);
      const ctx_r6 = core_js_["ɵɵnextContext"](2);
      return ctx_r6.onButtonMouseDown($event, ctx_r6.minusButtonDisabled);
    })("click", function TuiInputCountComponent_ng_container_3_ng_container_1_Template_button_click_3_listener() {
      core_js_["ɵɵrestoreView"](_r4);
      const ctx_r7 = core_js_["ɵɵnextContext"](2);
      return ctx_r7.decreaseValue();
    });
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const texts_r2 = ctx.ngIf;
    const ctx_r1 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵproperty"]("icon", ctx_r1.iconUp)("appearance", ctx_r1.options.appearance)("title", texts_r2[0])("disabled", ctx_r1.plusButtonDisabled)("focusable", false);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("icon", ctx_r1.iconDown)("appearance", ctx_r1.options.appearance)("disabled", ctx_r1.minusButtonDisabled)("focusable", false)("title", texts_r2[1]);
  }
}
function TuiInputCountComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiInputCountComponent_ng_container_3_ng_container_1_Template, 4, 10, "ng-container", 1);
    core_js_["ɵɵpipe"](2, "async");
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", core_js_["ɵɵpipeBind1"](2, 1, ctx_r0.minusTexts$));
  }
}
const taiga_ui_kit_components_input_count_c0 = ["*", [["input"]]];
const taiga_ui_kit_components_input_count_c1 = ["*", "input"];
const PASSWORD_ICON_UP = `tuiIconPlus`;
const PASSWORD_ICON_DOWN = `tuiIconMinus`;
/** Default values for the input count options. */
const TUI_INPUT_COUNT_DEFAULT_OPTIONS = {
  icons: {
    up: PASSWORD_ICON_UP,
    down: PASSWORD_ICON_DOWN
  },
  appearance: `textfield`,
  hideButtons: false,
  min: 0,
  max: Infinity,
  step: 1,
  postfix: ``
};
const TUI_INPUT_COUNT_OPTIONS = new core_js_.InjectionToken(`Default parameters for input count component`, {
  factory: () => TUI_INPUT_COUNT_DEFAULT_OPTIONS
});
const tuiInputCountOptionsProvider = options => ({
  provide: TUI_INPUT_COUNT_OPTIONS,
  useValue: Object.assign(Object.assign({}, TUI_INPUT_COUNT_DEFAULT_OPTIONS), options)
});
var TuiInputCountComponent_1;
// @dynamic
let TuiInputCountComponent = TuiInputCountComponent_1 = class TuiInputCountComponent extends taiga_ui_cdk_abstract/* AbstractTuiNullableControl */.F9 {
  constructor(control, changeDetectorRef, appearance, textfieldSize, minusTexts$, isMobile, options, numberFormat) {
    super(control, changeDetectorRef);
    this.appearance = appearance;
    this.textfieldSize = textfieldSize;
    this.minusTexts$ = minusTexts$;
    this.isMobile = isMobile;
    this.options = options;
    this.numberFormat = numberFormat;
    this.unfinishedValue = '';
    this.step = this.options.step;
    this.min = this.options.min;
    this.max = this.options.max;
    this.hideButtons = this.options.hideButtons;
    this.prefix = '';
    this.postfix = this.options.postfix;
  }
  getMask(allowNegative) {
    return {
      mask: tuiCreateNumberMask({
        allowNegative,
        decimalSymbol: this.numberFormat.decimalSeparator,
        thousandSymbol: this.numberFormat.thousandSeparator
      }),
      guide: false
    };
  }
  // TODO: 3.0 Remove in v.3
  get buttonsHidden() {
    return this.hideButtons || this.appearance === 'table';
  }
  get iconUp() {
    return this.options.icons.up;
  }
  get iconDown() {
    return this.options.icons.down;
  }
  get nativeFocusableElement() {
    return !this.primitiveTextfield || this.computedDisabled ? null : this.primitiveTextfield.nativeFocusableElement;
  }
  get size() {
    return this.textfieldSize.size;
  }
  get focused() {
    return (0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(this.nativeFocusableElement);
  }
  get exampleText() {
    return String(this.min);
  }
  get computedValue() {
    return this.focused ? this.nativeValue : this.formatNumber(this.value);
  }
  get minusButtonDisabled() {
    return !this.interactive || (0,taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN)(this.value) && this.value <= this.min;
  }
  get plusButtonDisabled() {
    return !this.interactive || (0,taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN)(this.value) && this.value >= this.max;
  }
  onButtonMouseDown(event, disabled = false) {
    if (disabled || !this.nativeFocusableElement || this.isMobile) {
      return;
    }
    event.preventDefault();
    (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(this.nativeFocusableElement);
  }
  onFocused(focused) {
    if (!focused) {
      this.onBlur();
    }
    this.updateFocused(focused);
  }
  onHovered(hovered) {
    this.updateHovered(hovered);
  }
  onPressed(pressed) {
    this.updatePressed(pressed);
  }
  onValueChange() {
    if (this.isNativeValueNotFinished) {
      this.unfinishedValue = this.nativeValue;
      return;
    }
    this.unfinishedValue = null;
    const capped = this.capValue(this.nativeNumberValue);
    if (this.isNotNumber(capped)) {
      this.updateValue(null);
      return;
    }
    const newValue = this.formatNumber(capped);
    if (this.nativeValue !== newValue) {
      this.nativeValue = newValue;
    }
    this.updateValue(capped);
  }
  decreaseValue() {
    if (this.readOnly) {
      return;
    }
    const newValue = (this.value || 0) - this.step;
    this.safeUpdateValue(newValue);
  }
  increaseValue() {
    if (this.readOnly) {
      return;
    }
    const newValue = (this.value || 0) + this.step;
    this.safeUpdateValue(newValue);
  }
  onKeydown(event) {
    switch (event.key) {
      case 'ArrowUp':
      case 'Up':
        this.increaseValue();
        event.preventDefault();
        break;
      case 'ArrowDown':
      case 'Down':
        this.decreaseValue();
        event.preventDefault();
        break;
      default:
        break;
    }
  }
  get nativeNumberValue() {
    return parseInt(this.nativeValue.split(this.numberFormat.thousandSeparator).join(''), 10);
  }
  get nativeValue() {
    return this.nativeFocusableElement ? this.nativeFocusableElement.value : '';
  }
  set nativeValue(value) {
    if (!this.nativeFocusableElement) {
      return;
    }
    this.nativeFocusableElement.value = value;
  }
  safeUpdateValue(newValue) {
    const value = (0,taiga_ui_cdk_utils_math/* clamp */.uZ)(newValue, this.min, this.max);
    this.updateValue(value);
    this.nativeValue = this.formatNumber(value);
  }
  capValue(value) {
    const capped = Math.min(value, this.max);
    return Number.isNaN(capped) || capped < this.min ? null : capped;
  }
  onBlur() {
    const nativeNumberValue = this.unfinishedValue ? tuiMaskedNumberStringToNumber(this.unfinishedValue, this.numberFormat.decimalSeparator, this.numberFormat.thousandSeparator) : this.nativeNumberValue;
    this.unfinishedValue = null;
    if (this.isNotNumber(nativeNumberValue)) {
      this.updateValue(null);
      return;
    }
    const value = Math.max(nativeNumberValue || 0, this.min);
    const formattedValue = this.formatNumber(value);
    this.nativeValue = formattedValue;
    this.updateValue(value);
    if (this.primitiveTextfield) {
      this.primitiveTextfield.value = formattedValue;
    }
  }
  formatNumber(value) {
    return this.isNotNumber(value) ? '' : formatNumber(value, null, this.numberFormat.decimalSeparator, this.numberFormat.thousandSeparator);
  }
  isNotNumber(value) {
    return !(0,taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN)(value) || Number.isNaN(value);
  }
  get isNativeValueNotFinished() {
    const {
      nativeNumberValue
    } = this;
    return nativeNumberValue < 0 ? nativeNumberValue > this.max : nativeNumberValue < this.min;
  }
};
TuiInputCountComponent.ɵfac = function TuiInputCountComponent_Factory(t) {
  return new (t || TuiInputCountComponent)(core_js_["ɵɵdirectiveInject"](fesm2015_forms.NgControl, 10), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_TEXTFIELD_APPEARANCE */.jt), core_js_["ɵɵdirectiveInject"](TUI_TEXTFIELD_SIZE), core_js_["ɵɵdirectiveInject"](TUI_PLUS_MINUS_TEXTS), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL), core_js_["ɵɵdirectiveInject"](TUI_INPUT_COUNT_OPTIONS), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_NUMBER_FORMAT */.HO));
};
TuiInputCountComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiInputCountComponent,
  selectors: [["tui-input-count"]],
  viewQuery: function TuiInputCountComponent_Query(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵviewQuery"](TuiPrimitiveTextfieldComponent, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.primitiveTextfield = _t.first);
    }
  },
  hostVars: 3,
  hostBindings: function TuiInputCountComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      core_js_["ɵɵattribute"]("data-size", ctx.size);
      core_js_["ɵɵclassProp"]("_hide-buttons", ctx.buttonsHidden);
    }
  },
  inputs: {
    step: "step",
    min: "min",
    max: "max",
    hideButtons: "hideButtons",
    prefix: "prefix",
    postfix: "postfix"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ,
    useExisting: (0,core_js_.forwardRef)(() => TuiInputCountComponent_1)
  }, {
    provide: taiga_ui_cdk_abstract/* AbstractTuiControl */.M$,
    useExisting: (0,core_js_.forwardRef)(() => TuiInputCountComponent_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]],
  ngContentSelectors: taiga_ui_kit_components_input_count_c1,
  decls: 4,
  vars: 14,
  consts: [["tuiValueAccessor", "", "tuiTextfieldAutocomplete", "off", "tuiTextfieldInputMode", "numeric", 1, "t-textfield", 3, "tuiTextfieldMaxLength", "pseudoFocused", "pseudoHovered", "pseudoPressed", "focusable", "nativeId", "prefix", "postfix", "disabled", "readOnly", "textMask", "invalid", "value", "valueChange", "keydown", "focusedChange", "hoveredChange", "pressedChange"], [4, "ngIf"], [1, "t-buttons"], ["tuiIconButton", "", "type", "button", "automation-id", "tui-input-count__plus-button", "size", "s", 1, "t-button", "t-button_plus", 3, "icon", "appearance", "title", "disabled", "focusable", "mousedown", "click"], ["tuiIconButton", "", "type", "button", "automation-id", "tui-input-count__minus-button", "size", "s", 1, "t-button", "t-button_minus", 3, "icon", "appearance", "disabled", "focusable", "title", "mousedown", "click"]],
  template: function TuiInputCountComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"](taiga_ui_kit_components_input_count_c0);
      core_js_["ɵɵelementStart"](0, "tui-primitive-textfield", 0);
      core_js_["ɵɵlistener"]("valueChange", function TuiInputCountComponent_Template_tui_primitive_textfield_valueChange_0_listener() {
        return ctx.onValueChange();
      })("keydown", function TuiInputCountComponent_Template_tui_primitive_textfield_keydown_0_listener($event) {
        return ctx.onKeydown($event);
      })("focusedChange", function TuiInputCountComponent_Template_tui_primitive_textfield_focusedChange_0_listener($event) {
        return ctx.onFocused($event);
      })("hoveredChange", function TuiInputCountComponent_Template_tui_primitive_textfield_hoveredChange_0_listener($event) {
        return ctx.onHovered($event);
      })("pressedChange", function TuiInputCountComponent_Template_tui_primitive_textfield_pressedChange_0_listener($event) {
        return ctx.onPressed($event);
      });
      core_js_["ɵɵprojection"](1);
      core_js_["ɵɵprojection"](2, 1, ["ngProjectAs", "input", 5, ["input"]]);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵtemplate"](3, TuiInputCountComponent_ng_container_3_Template, 3, 3, "ng-container", 1);
    }
    if (rf & 2) {
      core_js_["ɵɵproperty"]("tuiTextfieldMaxLength", 18)("pseudoFocused", ctx.pseudoFocused)("pseudoHovered", ctx.pseudoHovered)("pseudoPressed", ctx.pseudoPressed)("focusable", ctx.focusable)("nativeId", ctx.nativeId)("prefix", ctx.prefix)("postfix", ctx.postfix)("disabled", ctx.computedDisabled)("readOnly", ctx.readOnly)("textMask", ctx.getMask(ctx.min < 0))("invalid", ctx.computedInvalid)("value", ctx.computedValue);
      core_js_["ɵɵadvance"](3);
      core_js_["ɵɵproperty"]("ngIf", !ctx.buttonsHidden);
    }
  },
  directives: [TuiPrimitiveTextfieldComponent, TuiPrimitiveTextfieldDirective, TuiValueAccessorDirective, TuiTextfieldAutocompleteDirective, TuiTextfieldInputModeDirective, TuiTextfieldMaxLengthDirective, angular2TextMask/* MaskedInputDirective */.hd, common_js_.NgIf, taiga_ui_core_components_button/* TuiButtonComponent */.v0],
  pipes: [common_js_.AsyncPipe],
  styles: ["[_nghost-%COMP%]{display:flex;font:var(--tui-font-text-s);border-radius:var(--tui-radius-m);height:var(--tui-height-m);color:var(--tui-text-01);text-align:left}._disabled[_nghost-%COMP%]{pointer-events:none}[data-size='l'][_nghost-%COMP%]{font:var(--tui-font-text-m);height:var(--tui-height-l)}.t-textfield[_ngcontent-%COMP%]{position:relative;border-radius:inherit;text-align:inherit;flex-grow:1;min-width:0}[_nghost-%COMP%]:not(._hide-buttons)   .t-textfield[_ngcontent-%COMP%]{border-top-right-radius:0;border-bottom-right-radius:0}.t-buttons[_ngcontent-%COMP%]{display:flex;flex-direction:column;margin-left:.125rem;height:100%}.t-buttons[_ngcontent-%COMP%]   .t-button[_ngcontent-%COMP%]{display:flex;width:calc(var(--tui-height-m) * .75);height:calc(50% - .0625rem)}.t-buttons[_ngcontent-%COMP%]   .t-button_plus[_ngcontent-%COMP%]{margin-bottom:.125rem;border-radius:0 var(--tui-radius-m) 0 0}.t-buttons[_ngcontent-%COMP%]   .t-button_minus[_ngcontent-%COMP%]{border-radius:0 0 var(--tui-radius-m)}[data-size='l'][_nghost-%COMP%]   .t-buttons[_ngcontent-%COMP%]   .t-button[_ngcontent-%COMP%]{width:calc(var(--tui-height-l) * .75)}"],
  changeDetection: 0
});
TuiInputCountComponent.ctorParameters = () => [{
  type: fesm2015_forms.NgControl,
  decorators: [{
    type: core_js_.Optional
  }, {
    type: core_js_.Self
  }, {
    type: core_js_.Inject,
    args: [fesm2015_forms.NgControl]
  }]
}, {
  type: core_js_.ChangeDetectorRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ChangeDetectorRef]
  }]
}, {
  type: String,
  decorators: [{
    type: core_js_.Inject,
    args: [taiga_ui_core_tokens/* TUI_TEXTFIELD_APPEARANCE */.jt]
  }]
}, {
  type: TuiTextfieldSizeDirective,
  decorators: [{
    type: core_js_.Inject,
    args: [TUI_TEXTFIELD_SIZE]
  }]
}, {
  type: internal_Observable/* Observable */.y,
  decorators: [{
    type: core_js_.Inject,
    args: [TUI_PLUS_MINUS_TEXTS]
  }]
}, {
  type: Boolean,
  decorators: [{
    type: core_js_.Inject,
    args: [taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL]
  }]
}, {
  type: undefined,
  decorators: [{
    type: core_js_.Inject,
    args: [TUI_INPUT_COUNT_OPTIONS]
  }]
}, {
  type: undefined,
  decorators: [{
    type: core_js_.Inject,
    args: [taiga_ui_core_tokens/* TUI_NUMBER_FORMAT */.HO]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)(TuiPrimitiveTextfieldComponent)], TuiInputCountComponent.prototype, "primitiveTextfield", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiInputCountComponent.prototype, "step", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiInputCountComponent.prototype, "min", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiInputCountComponent.prototype, "max", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiInputCountComponent.prototype, "hideButtons", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiInputCountComponent.prototype, "prefix", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiInputCountComponent.prototype, "postfix", void 0);
(0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiInputCountComponent.prototype, "getMask", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._hide-buttons')], TuiInputCountComponent.prototype, "buttonsHidden", null);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('attr.data-size')], TuiInputCountComponent.prototype, "size", null);
TuiInputCountComponent = TuiInputCountComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(fesm2015_forms.NgControl)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_TEXTFIELD_APPEARANCE */.jt)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TUI_TEXTFIELD_SIZE)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(TUI_PLUS_MINUS_TEXTS)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(TUI_INPUT_COUNT_OPTIONS)), (0,tslib_es6/* __param */.fM)(7, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_NUMBER_FORMAT */.HO))], TuiInputCountComponent);
var TuiInputCountDirective_1;
let TuiInputCountDirective = TuiInputCountDirective_1 = class TuiInputCountDirective extends TuiAbstractTextfieldHost {
  onValueChange() {
    this.host.onValueChange();
  }
  process(input) {
    input.autocomplete = 'off';
    input.inputMode = 'numeric';
  }
};
TuiInputCountDirective.ɵfac = /*@__PURE__*/function () {
  let ɵTuiInputCountDirective_BaseFactory;
  return function TuiInputCountDirective_Factory(t) {
    return (ɵTuiInputCountDirective_BaseFactory || (ɵTuiInputCountDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiInputCountDirective)))(t || TuiInputCountDirective);
  };
}();
TuiInputCountDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
  type: TuiInputCountDirective,
  selectors: [["tui-input-count"]],
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_core_tokens/* TUI_TEXTFIELD_HOST */.S0,
    useExisting: (0,core_js_.forwardRef)(() => TuiInputCountDirective_1)
  }]), core_js_["ɵɵInheritDefinitionFeature"]]
});
let TuiInputCountModule = /*#__PURE__*/(() => {
  let TuiInputCountModule = class TuiInputCountModule {};
  TuiInputCountModule.ɵfac = function TuiInputCountModule_Factory(t) {
    return new (t || TuiInputCountModule)();
  };
  TuiInputCountModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiInputCountModule
  });
  TuiInputCountModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, angular2TextMask/* TextMaskModule */.QA, taiga_ui_core_components_button/* TuiButtonModule */.fN, TuiPrimitiveTextfieldModule, TuiTextfieldControllerModule, TuiValueAccessorModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq]]
  });
  return TuiInputCountModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiInputCountModule, {
    declarations: function () {
      return [TuiInputCountComponent, TuiInputCountDirective];
    },
    imports: function () {
      return [common_js_.CommonModule, angular2TextMask/* TextMaskModule */.QA, taiga_ui_core_components_button/* TuiButtonModule */.fN, TuiPrimitiveTextfieldModule, TuiTextfieldControllerModule, TuiValueAccessorModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq];
    },
    exports: function () {
      return [TuiInputCountComponent, TuiInputCountDirective, TuiTextfieldComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-input-count.js.map
// EXTERNAL MODULE: consume shared module (default) @angular/router@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/router/fesm2015/router.js)
var router_js_ = __webpack_require__(2541);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/ReplaySubject.js + 4 modules
var internal_ReplaySubject = __webpack_require__(2298);
;// CONCATENATED MODULE: ./node_modules/@ng-web-apis/mutation-observer/fesm2015/ng-web-apis-mutation-observer.js



/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */

const MUTATION_OBSERVER_INIT = new core_js_.InjectionToken('MutationObserver config');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} element
 * @param {?} attribute
 * @return {?}
 */
function booleanAttribute(element, attribute) {
  return element.getAttribute(attribute) !== null || undefined;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} __0
 * @return {?}
 */
function mutationObserverInitFactory({
  nativeElement
}) {
  /** @type {?} */
  const attributeFilterAttr = nativeElement.getAttribute('attributeFilter');
  /** @type {?} */
  const attributeFilter = attributeFilterAttr ? attributeFilterAttr.split(',').map(attr => attr.trim()) : undefined;
  return {
    attributeFilter,
    attributeOldValue: booleanAttribute(nativeElement, 'attributeOldValue'),
    attributes: booleanAttribute(nativeElement, 'attributes'),
    characterData: booleanAttribute(nativeElement, 'characterData'),
    characterDataOldValue: booleanAttribute(nativeElement, 'characterDataOldValue'),
    childList: booleanAttribute(nativeElement, 'childList'),
    subtree: booleanAttribute(nativeElement, 'subtree')
  };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ng_web_apis_mutation_observer_0 = mutationObserverInitFactory;
// @dynamic
let MutationObserverDirective = /*#__PURE__*/(() => {
  class MutationObserverDirective extends MutationObserver {
    /**
     * @param {?} __0
     * @param {?} config
     * @param {?} _1
     * @param {?} _2
     * @param {?} _3
     * @param {?} _4
     * @param {?} _5
     * @param {?} _6
     * @param {?} _7
     */
    constructor({
      nativeElement
    }, config, _1, _2, _3, _4, _5, _6, _7) {
      super(records => {
        this.waMutationObserver.emit(records);
      });
      this.waMutationObserver = new core_js_.EventEmitter();
      this.observe(nativeElement, config);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
      this.disconnect();
    }
  }
  MutationObserverDirective.ɵfac = function MutationObserverDirective_Factory(t) {
    return new (t || MutationObserverDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](MUTATION_OBSERVER_INIT), core_js_["ɵɵinjectAttribute"]('attributeFilter'), core_js_["ɵɵinjectAttribute"]('attributeOldValue'), core_js_["ɵɵinjectAttribute"]('attributes'), core_js_["ɵɵinjectAttribute"]('characterData'), core_js_["ɵɵinjectAttribute"]('characterDataOldValue'), core_js_["ɵɵinjectAttribute"]('childList'), core_js_["ɵɵinjectAttribute"]('subtree'));
  };
  MutationObserverDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: MutationObserverDirective,
    selectors: [["", "waMutationObserver", ""]],
    outputs: {
      waMutationObserver: "waMutationObserver"
    },
    exportAs: ["MutationObserver"],
    features: [core_js_["ɵɵProvidersFeature"]([{
      provide: MUTATION_OBSERVER_INIT,
      deps: [core_js_.ElementRef],
      useFactory: ng_web_apis_mutation_observer_0
    }]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  /** @nocollapse */
  return MutationObserverDirective;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @dynamic
let MutationObserverService = /*#__PURE__*/(() => {
  class MutationObserverService extends internal_Observable/* Observable */.y {
    /**
     * @param {?} __0
     * @param {?} config
     */
    constructor({
      nativeElement
    }, config) {
      super(subscriber => {
        /** @type {?} */
        const observer = new MutationObserver(records => {
          subscriber.next(records);
        });
        observer.observe(nativeElement, config);
        return () => {
          observer.disconnect();
        };
      });
    }
  }
  MutationObserverService.ɵfac = function MutationObserverService_Factory(t) {
    return new (t || MutationObserverService)(core_js_["ɵɵinject"](core_js_.ElementRef), core_js_["ɵɵinject"](MUTATION_OBSERVER_INIT));
  };
  MutationObserverService.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: MutationObserverService,
    factory: MutationObserverService.ɵfac
  });
  /** @nocollapse */
  return MutationObserverService;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
let MutationObserverModule = /*#__PURE__*/(() => {
  class MutationObserverModule {}
  MutationObserverModule.ɵfac = function MutationObserverModule_Factory(t) {
    return new (t || MutationObserverModule)();
  };
  MutationObserverModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: MutationObserverModule
  });
  MutationObserverModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return MutationObserverModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](MutationObserverModule, {
    declarations: [MutationObserverDirective],
    exports: [MutationObserverDirective]
  });
})();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */



//# sourceMappingURL=ng-web-apis-mutation-observer.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/share.js + 1 modules
var share = __webpack_require__(8819);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-tabs.js




















const taiga_ui_kit_components_tabs_c0 = ["tuiTab", ""];
function TuiTabComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0);
  }
}
const taiga_ui_kit_components_tabs_c1 = ["*"];
function TuiTabsComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0);
  }
}
function TuiTabsComponent_tui_underline_3_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-underline", 2);
  }
  if (rf & 2) {
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("element", ctx_r1.activeElement);
  }
}
function TuiTabsWithMoreComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0);
  }
}
function TuiTabsWithMoreComponent_ng_container_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0, 12);
  }
  if (rf & 2) {
    const item_r7 = core_js_["ɵɵnextContext"]().$implicit;
    core_js_["ɵɵproperty"]("ngTemplateOutlet", item_r7);
  }
}
function TuiTabsWithMoreComponent_ng_container_4_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div");
    core_js_["ɵɵelementContainer"](1, 12);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r13 = core_js_["ɵɵnextContext"]();
    const index_r8 = ctx_r13.index;
    const item_r7 = ctx_r13.$implicit;
    const ctx_r11 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵclassProp"]("t-overflown", ctx_r11.isOverflown(index_r8));
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngTemplateOutlet", item_r7);
  }
}
function TuiTabsWithMoreComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiTabsWithMoreComponent_ng_container_4_ng_container_1_Template, 1, 1, "ng-container", 10);
    core_js_["ɵɵtemplate"](2, TuiTabsWithMoreComponent_ng_container_4_ng_template_2_Template, 2, 3, "ng-template", null, 11, core_js_["ɵɵtemplateRefExtractor"]);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const index_r8 = ctx.index;
    const _r10 = core_js_["ɵɵreference"](3);
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", index_r8 <= ctx_r1.lastVisibleIndex)("ngIfElse", _r10);
  }
}
function TuiTabsWithMoreComponent_ng_template_8_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵtext"](0);
    core_js_["ɵɵpipe"](1, "async");
    core_js_["ɵɵelement"](2, "tui-svg", 13);
  }
  if (rf & 2) {
    const ctx_r3 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵtextInterpolate1"](" ", core_js_["ɵɵpipeBind1"](1, 3, ctx_r3.moreWord$), " ");
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵclassProp"]("t-icon_rotated", ctx_r3.open);
  }
}
function TuiTabsWithMoreComponent_ng_template_10_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0, 12);
  }
  if (rf & 2) {
    const item_r16 = core_js_["ɵɵnextContext"]().$implicit;
    core_js_["ɵɵproperty"]("ngTemplateOutlet", item_r16);
  }
}
function TuiTabsWithMoreComponent_ng_template_10_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r21 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "div", 17);
    core_js_["ɵɵlistener"]("tui-tab-activate", function TuiTabsWithMoreComponent_ng_template_10_div_2_Template_div_tui_tab_activate_0_listener() {
      const restoredCtx = core_js_["ɵɵrestoreView"](_r21);
      const index_r17 = restoredCtx.index;
      const ctx_r20 = core_js_["ɵɵnextContext"](2);
      return ctx_r20.onClick(index_r17);
    });
    core_js_["ɵɵtemplate"](1, TuiTabsWithMoreComponent_ng_template_10_div_2_ng_container_1_Template, 1, 1, "ng-container", 18);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const index_r17 = ctx.index;
    const ctx_r15 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", ctx_r15.shouldShow(index_r17));
  }
}
function TuiTabsWithMoreComponent_ng_template_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r23 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "div", 14, 15);
    core_js_["ɵɵlistener"]("keydown.arrowUp.prevent", function TuiTabsWithMoreComponent_ng_template_10_Template_div_keydown_arrowUp_prevent_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r23);
      const _r14 = core_js_["ɵɵreference"](1);
      const ctx_r22 = core_js_["ɵɵnextContext"]();
      return ctx_r22.onWrapperArrow($event, _r14, true);
    })("keydown.arrowDown.prevent", function TuiTabsWithMoreComponent_ng_template_10_Template_div_keydown_arrowDown_prevent_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r23);
      const _r14 = core_js_["ɵɵreference"](1);
      const ctx_r24 = core_js_["ɵɵnextContext"]();
      return ctx_r24.onWrapperArrow($event, _r14, false);
    });
    core_js_["ɵɵtemplate"](2, TuiTabsWithMoreComponent_ng_template_10_div_2_Template, 2, 1, "div", 16);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r5 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵproperty"]("ngForOf", ctx_r5.items);
  }
}
function TuiTabsWithMoreComponent_tui_underline_12_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-underline", 19);
  }
  if (rf & 2) {
    const ctx_r6 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("element", ctx_r6.activeElement);
  }
}
let TuiTabDirective = /*#__PURE__*/(() => {
  let TuiTabDirective = class TuiTabDirective {
    constructor(template) {
      this.template = template;
    }
  };
  TuiTabDirective.ɵfac = function TuiTabDirective_Factory(t) {
    return new (t || TuiTabDirective)(core_js_["ɵɵdirectiveInject"](core_js_.TemplateRef));
  };
  TuiTabDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiTabDirective,
    selectors: [["ng-template", "tuiTab", ""]]
  });
  TuiTabDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.TemplateRef))], TuiTabDirective);
  return TuiTabDirective;
})();
const TUI_TAB_ACTIVATE = `tui-tab-activate`;
const TUI_TAB_EVENT = new core_js_.InjectionToken(`Stream of tab activation events`);
const TUI_TAB_PROVIDERS = [taiga_ui_cdk_services/* TuiDestroyService */.a3, taiga_ui_cdk_services/* TuiFocusVisibleService */.ku, taiga_ui_core_services/* TuiRouterLinkActiveService */.Ok, {
  provide: TUI_TAB_EVENT,
  deps: [core_js_.ElementRef, common_js_.DOCUMENT, taiga_ui_core_services/* TuiRouterLinkActiveService */.Ok, [new core_js_.Optional(), MutationObserverService], [new core_js_.Optional(), router_js_.RouterLinkActive]],
  useFactory: tabActiveFactory
}, taiga_ui_core_providers/* MODE_PROVIDER */.CV];
// eslint-disable-next-line @typescript-eslint/naming-convention
function tabActiveFactory({
  nativeElement
}, documentRef, routerLinkActiveService, mutationObserverService, routerLinkActive) {
  const mutationObserver = routerLinkActive && mutationObserverService ? mutationObserverService.pipe((0,operators_filter/* filter */.h)(() => routerLinkActive.isActive)) : observable_empty/* EMPTY */.E;
  return (0,observable_merge/* merge */.T)(mutationObserver, routerLinkActiveService.pipe((0,operators_filter/* filter */.h)(util_identity/* identity */.y)), nativeElement.matches(`button`) ? (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, `click`) : observable_empty/* EMPTY */.E).pipe((0,operators_map/* map */.U)(() => nativeElement.dispatchEvent((0,taiga_ui_cdk_utils_dom/* tuiCustomEvent */.hO)(TUI_TAB_ACTIVATE, {
    bubbles: true
  }, documentRef))));
}
let TuiTabComponent = /*#__PURE__*/(() => {
  let TuiTabComponent = class TuiTabComponent {
    constructor(routerLinkActive, elementRef, mode$, event$, margin, mobileAware, isIos, isAndroid, focusVisible$) {
      this.routerLinkActive = routerLinkActive;
      this.elementRef = elementRef;
      this.mode$ = mode$;
      this.event$ = event$;
      this.margin = margin;
      this.focusVisible = false;
      this.isIos = mobileAware && isIos;
      this.isAndroid = mobileAware && isAndroid;
      focusVisible$.subscribe(visible => {
        this.focusVisible = visible;
      });
    }
    get isActive() {
      return !!this.routerLinkActive && this.routerLinkActive.isActive;
    }
    ngOnDestroy() {
      if ((0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(this.elementRef.nativeElement)) {
        (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(this.elementRef.nativeElement, false);
      }
    }
  };
  TuiTabComponent.ɵfac = function TuiTabComponent_Factory(t) {
    return new (t || TuiTabComponent)(core_js_["ɵɵdirectiveInject"](router_js_.RouterLinkActive, 8), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_MODE */.Au), core_js_["ɵɵdirectiveInject"](TUI_TAB_EVENT), core_js_["ɵɵdirectiveInject"](TUI_TAB_MARGIN), core_js_["ɵɵdirectiveInject"](TUI_MOBILE_AWARE), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_IOS */.FA), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_ANDROID */.XG), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiFocusVisibleService */.ku));
  };
  TuiTabComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiTabComponent,
    selectors: [["a", "tuiTab", "", 3, "routerLink", ""], ["a", "tuiTab", "", "routerLink", "", "routerLinkActive", ""], ["button", "tuiTab", ""]],
    hostAttrs: ["type", "button"],
    hostVars: 10,
    hostBindings: function TuiTabComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("$.data-mode.attr", function TuiTabComponent___data_mode_attr_HostBindingHandler() {
          return ctx.mode$;
        });
      }
      if (rf & 2) {
        core_js_["ɵɵstyleProp"]("--tui-tab-margin", ctx.margin, "px");
        core_js_["ɵɵclassProp"]("_focus-visible", ctx.focusVisible)("_ios", ctx.isIos)("_android", ctx.isAndroid)("_active", ctx.isActive);
      }
    },
    features: [core_js_["ɵɵProvidersFeature"](TUI_TAB_PROVIDERS)],
    attrs: taiga_ui_kit_components_tabs_c0,
    ngContentSelectors: taiga_ui_kit_components_tabs_c1,
    decls: 4,
    vars: 3,
    consts: [[4, "ngIf"], [1, "t-highlight"]],
    template: function TuiTabComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵtemplate"](0, TuiTabComponent_ng_container_0_Template, 1, 0, "ng-container", 0);
        core_js_["ɵɵpipe"](1, "async");
        core_js_["ɵɵelementStart"](2, "span", 1);
        core_js_["ɵɵprojection"](3);
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngIf", core_js_["ɵɵpipeBind1"](1, 1, ctx.event$));
      }
    },
    directives: [common_js_.NgIf],
    pipes: [common_js_.AsyncPipe],
    styles: ["._underline[_nghost-%COMP%]:hover, ._underline   [_nghost-%COMP%]:hover{box-shadow:inset 0 -2px var(--tui-base-03)}[tuiTabs] > [_nghost-%COMP%]:first-child, [tuiTabs] > [_nghost-%COMP%]:first-child, [tuiTabs] > :first-child[_nghost-%COMP%], [tuiTabs] > :first-child   [_nghost-%COMP%], tui-tabs > [_nghost-%COMP%]:first-child, tui-tabs > [_nghost-%COMP%]:first-child, tui-tabs > :first-child[_nghost-%COMP%], tui-tabs > :first-child   [_nghost-%COMP%]{margin-left:0}[_nghost-%COMP%]{transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:0;border:0;background:0 0;font-size:inherit;line-height:inherit;position:relative;display:flex;flex-shrink:0;height:100%;box-sizing:border-box;justify-content:space-between;align-items:center;white-space:nowrap;cursor:pointer;outline:0;text-decoration:none;color:inherit;transition-property:color,box-shadow,opacity;margin-left:var(--tui-tab-margin,1.5rem)}[_nghost-%COMP%]:disabled{opacity:var(--tui-disabled-opacity);pointer-events:none}[_nghost-%COMP%]:not([data-mode])._active{opacity:1;color:var(--tui-text-01);box-shadow:none}[data-mode=onDark][_nghost-%COMP%]{color:rgba(255,255,255,.72)}[data-mode=onDark]._active[_nghost-%COMP%], [data-mode=onDark][_nghost-%COMP%]:hover{color:#fff}[data-mode=onDark]._focus-visible[_nghost-%COMP%]   .t-highlight[_ngcontent-%COMP%]{background:var(--tui-clear-inverse);color:var(--tui-text-01)}[data-mode=onLight][_nghost-%COMP%]{color:var(--tui-text-02)}[data-mode=onLight]._active[_nghost-%COMP%], [data-mode=onLight][_nghost-%COMP%]:hover{color:var(--tui-text-01)}[data-mode=onLight]._focus-visible[_nghost-%COMP%]   .t-highlight[_ngcontent-%COMP%]{background:var(--tui-text-01);color:#fff}._focus-visible[_nghost-%COMP%]   .t-highlight[_ngcontent-%COMP%]{background:var(--tui-selection)}._android[_nghost-%COMP%]{transition-property:opacity;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;height:3rem;flex:1;flex-shrink:0;justify-content:center;margin:0;text-transform:uppercase;color:var(--tui-base-09);opacity:.5;font-size:.875rem;font-weight:500;letter-spacing:-.008125rem;font-family:-apple-system,BlinkMacSystemFont,Roboto,'Helvetica Neue',sans-serif}._android[_nghost-%COMP%]:hover{box-shadow:none}._android._active[_nghost-%COMP%]{opacity:1;color:var(--tui-base-09)}._android[_nghost-%COMP%]   .t-highlight[_ngcontent-%COMP%]{width:auto}._ios[_nghost-%COMP%]{height:1.75rem;flex:1;flex-shrink:0;justify-content:center;margin:0;color:var(--tui-base-01);opacity:1;font-size:.8125rem;font-weight:500;letter-spacing:-.005rem;font-family:-apple-system,BlinkMacSystemFont,Roboto,'Helvetica Neue',sans-serif}._ios[_nghost-%COMP%]:hover{box-shadow:none}._ios._active[_nghost-%COMP%]{font-size:.875rem;font-weight:600;color:var(--tui-link)}._ios[_nghost-%COMP%]   .t-highlight[_ngcontent-%COMP%]{width:auto}@media (hover:hover){[_nghost-%COMP%]:hover{color:var(--tui-text-01)}}.t-highlight[_ngcontent-%COMP%]{display:inline-flex;width:100%;align-items:center;justify-content:inherit}.t-highlight[_ngcontent-%COMP%]    >*{flex-shrink:0}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._ios')], TuiTabComponent.prototype, "isIos", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._android')], TuiTabComponent.prototype, "isAndroid", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._focus-visible')], TuiTabComponent.prototype, "focusVisible", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._active')], TuiTabComponent.prototype, "isActive", null);
  TuiTabComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(router_js_.RouterLinkActive)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_MODE */.Au)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TUI_TAB_EVENT)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(TUI_TAB_MARGIN)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(TUI_MOBILE_AWARE)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_IOS */.FA)), (0,tslib_es6/* __param */.fM)(7, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_ANDROID */.XG)), (0,tslib_es6/* __param */.fM)(8, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiFocusVisibleService */.ku))], TuiTabComponent);
  return TuiTabComponent;
})();
const TUI_TABS_DEFAULT_OPTIONS = {
  underline: true,
  exposeActive: true,
  itemsLimit: Infinity,
  minMoreWidth: 0
};
const TUI_TABS_OPTIONS = new core_js_.InjectionToken(`Default parameters for tabs component`, {
  factory: () => TUI_TABS_DEFAULT_OPTIONS
});
const tuiTabsOptionsProvider = options => ({
  provide: TUI_TABS_OPTIONS,
  useValue: Object.assign(Object.assign({}, TUI_TABS_DEFAULT_OPTIONS), options)
});
const TAB_ACTIVE_CLASS = '_active';
// TODO: 3.0 remove in ivy compilation
const OBSERVER_INIT = {
  childList: true
};
// @dynamic
let TuiTabsComponent = /*#__PURE__*/(() => {
  let TuiTabsComponent = class TuiTabsComponent {
    constructor(options, elementRef, renderer, changeDetectorRef, resize$, isIos, isAndroid, mobileAware) {
      this.options = options;
      this.elementRef = elementRef;
      this.renderer = renderer;
      this.children = taiga_ui_cdk_constants/* EMPTY_QUERY */.Mm;
      this.underline = this.options.underline;
      this.activeItemIndexChange = new core_js_.EventEmitter();
      this.activeItemIndex = 0;
      this.isIos = mobileAware && isIos;
      this.isAndroid = mobileAware && isAndroid;
      resize$.pipe((0,operators_filter/* filter */.h)(() => this.underline)).subscribe(() => {
        changeDetectorRef.detectChanges();
      });
    }
    set activeItemIndexSetter(index) {
      this.activeItemIndex = index;
      this.scrollTo(this.tabs[index]);
    }
    get tabs() {
      return Array.from(this.elementRef.nativeElement.querySelectorAll('[tuiTab]'));
    }
    get activeElement() {
      return this.tabs[this.activeItemIndex] || null;
    }
    onActivate(element) {
      const index = this.tabs.findIndex(tab => tab === element);
      if (index === this.activeItemIndex) {
        return;
      }
      this.activeItemIndexSetter = index;
      this.activeItemIndexChange.emit(index);
    }
    onKeyDownArrow(current, step) {
      const {
        tabs
      } = this;
      (0,taiga_ui_cdk_utils_focus/* moveFocus */.pr)(tabs.indexOf(current), tabs, step);
    }
    ngAfterViewChecked() {
      const {
        tabs,
        activeElement
      } = this;
      tabs.forEach(nativeElement => {
        this.renderer.removeClass(nativeElement, TAB_ACTIVE_CLASS);
        this.renderer.setAttribute(nativeElement, 'tabIndex', '-1');
      });
      if (activeElement) {
        this.renderer.addClass(activeElement, TAB_ACTIVE_CLASS);
        this.renderer.setAttribute(activeElement, 'tabIndex', '0');
      }
    }
    scrollTo(element) {
      if (!element) {
        return;
      }
      const {
        offsetLeft,
        offsetWidth
      } = element;
      const {
        nativeElement
      } = this.elementRef;
      if (offsetLeft < nativeElement.scrollLeft) {
        nativeElement.scrollLeft = offsetLeft;
      }
      if (offsetLeft + offsetWidth > nativeElement.scrollLeft + nativeElement.offsetWidth) {
        nativeElement.scrollLeft = offsetLeft + offsetWidth - nativeElement.offsetWidth;
      }
    }
  };
  TuiTabsComponent.ɵfac = function TuiTabsComponent_Factory(t) {
    return new (t || TuiTabsComponent)(core_js_["ɵɵdirectiveInject"](TUI_TABS_OPTIONS), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.Renderer2), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiResizeService */.tl), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_IOS */.FA), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_ANDROID */.XG), core_js_["ɵɵdirectiveInject"](TUI_MOBILE_AWARE));
  };
  TuiTabsComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiTabsComponent,
    selectors: [["tui-tabs"], ["nav", "tuiTabs", ""]],
    contentQueries: function TuiTabsComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        core_js_["ɵɵcontentQuery"](dirIndex, TuiTabComponent, 4);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.children = _t);
      }
    },
    hostVars: 6,
    hostBindings: function TuiTabsComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("tui-tab-activate.stop", function TuiTabsComponent_tui_tab_activate_stop_HostBindingHandler($event) {
          return ctx.onActivate($event.target);
        })("keydown.arrowRight.prevent", function TuiTabsComponent_keydown_arrowRight_prevent_HostBindingHandler($event) {
          return ctx.onKeyDownArrow($event.target, 1);
        })("keydown.arrowLeft.prevent", function TuiTabsComponent_keydown_arrowLeft_prevent_HostBindingHandler($event) {
          return ctx.onKeyDownArrow($event.target, -1);
        });
      }
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("_underline", ctx.underline)("_ios", ctx.isIos)("_android", ctx.isAndroid);
      }
    },
    inputs: {
      underline: "underline",
      activeItemIndexSetter: ["activeItemIndex", "activeItemIndexSetter"]
    },
    outputs: {
      activeItemIndexChange: "activeItemIndexChange"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3, taiga_ui_cdk_services/* TuiResizeService */.tl, MutationObserverService, {
      provide: MUTATION_OBSERVER_INIT,
      useValue: OBSERVER_INIT
    }])],
    ngContentSelectors: taiga_ui_kit_components_tabs_c1,
    decls: 4,
    vars: 4,
    consts: [[4, "ngIf"], ["class", "t-underline", 3, "element", 4, "ngIf"], [1, "t-underline", 3, "element"]],
    template: function TuiTabsComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵtemplate"](0, TuiTabsComponent_ng_container_0_Template, 1, 0, "ng-container", 0);
        core_js_["ɵɵpipe"](1, "async");
        core_js_["ɵɵprojection"](2);
        core_js_["ɵɵtemplate"](3, TuiTabsComponent_tui_underline_3_Template, 1, 1, "tui-underline", 1);
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngIf", core_js_["ɵɵpipeBind1"](1, 2, ctx.children.changes));
        core_js_["ɵɵadvance"](3);
        core_js_["ɵɵproperty"]("ngIf", ctx.underline);
      }
    },
    directives: function () {
      return [common_js_.NgIf, TuiUnderlineComponent];
    },
    pipes: function () {
      return [common_js_.AsyncPipe];
    },
    styles: ["[_nghost-%COMP%]{scrollbar-width:none;-ms-overflow-style:none;position:relative;z-index:0;display:flex;font:var(--tui-font-text-m);height:var(--tui-height-l);color:var(--tui-text-02);box-shadow:inset 0 -1px var(--tui-base-03);overflow:auto}[_nghost-%COMP%]::-webkit-scrollbar, [_nghost-%COMP%]::-webkit-scrollbar-thumb{background:0 0;width:0;height:0}._android[_nghost-%COMP%]{height:auto}._ios[_nghost-%COMP%]{height:auto;border:2px solid transparent;border-radius:.5625rem;background:var(--tui-link);box-shadow:none}.t-underline[_ngcontent-%COMP%]{z-index:-1}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChildren)((0,core_js_.forwardRef)(() => TuiTabComponent))], TuiTabsComponent.prototype, "children", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._underline'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTabsComponent.prototype, "underline", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('activeItemIndex')], TuiTabsComponent.prototype, "activeItemIndexSetter", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiTabsComponent.prototype, "activeItemIndexChange", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._ios')], TuiTabsComponent.prototype, "isIos", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._android')], TuiTabsComponent.prototype, "isAndroid", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)(`${TUI_TAB_ACTIVATE}.stop`, ['$event.target'])], TuiTabsComponent.prototype, "onActivate", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('keydown.arrowRight.prevent', ['$event.target', '1']), (0,core_js_.HostListener)('keydown.arrowLeft.prevent', ['$event.target', '-1'])], TuiTabsComponent.prototype, "onKeyDownArrow", null);
  TuiTabsComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TUI_TABS_OPTIONS)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.Renderer2)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiResizeService */.tl)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_IOS */.FA)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_ANDROID */.XG)), (0,tslib_es6/* __param */.fM)(7, (0,core_js_.Inject)(TUI_MOBILE_AWARE))], TuiTabsComponent);

  // eslint-disable-next-line @typescript-eslint/naming-convention
  return TuiTabsComponent;
})();
function tabsRefreshFactory(resize$, mutations$, destroy$, {
  body
}, {
  nativeElement
}, changeDetectorRef) {
  return (0,observable_merge/* merge */.T)(resize$, mutations$.pipe((0,operators_tap/* tap */.b)(() => changeDetectorRef.detectChanges()))).pipe(
  // Ignoring cases when host is detached from DOM
  (0,operators_filter/* filter */.h)(() => body.contains(nativeElement)), (0,operators_debounceTime/* debounceTime */.b)(0), (0,operators_startWith/* startWith */.O)(null), (0,operators_takeUntil/* takeUntil */.R)(destroy$));
}
// TODO: 3.0 remove in ivy compilation
const MUTATION_CONFIG = {
  childList: true,
  subtree: true,
  characterData: true
};
const TABS_REFRESH = new core_js_.InjectionToken(`Refresh stream`);
const TABS_PROVIDERS = [taiga_ui_cdk_services/* TuiResizeService */.tl, taiga_ui_cdk_services/* TuiDestroyService */.a3, MutationObserverService, {
  provide: MUTATION_OBSERVER_INIT,
  useValue: MUTATION_CONFIG
}, {
  provide: TABS_REFRESH,
  deps: [taiga_ui_cdk_services/* TuiResizeService */.tl, MutationObserverService, taiga_ui_cdk_services/* TuiDestroyService */.a3, common_js_.DOCUMENT, core_js_.ElementRef, core_js_.ChangeDetectorRef],
  useFactory: tabsRefreshFactory
}];

// @dynamic
let TuiTabsWithMoreComponent = /*#__PURE__*/(() => {
  let TuiTabsWithMoreComponent = class TuiTabsWithMoreComponent {
    constructor(options, margin, refresh$, elementRef, changeDetectorRef, moreWord$) {
      this.options = options;
      this.margin = margin;
      this.refresh$ = refresh$;
      this.elementRef = elementRef;
      this.changeDetectorRef = changeDetectorRef;
      this.moreWord$ = moreWord$;
      this.maxIndex = Infinity;
      this.moreContent = '';
      this.dropdownContent = '';
      this.underline = this.options.underline;
      this.activeItemIndex = 0;
      this.itemsLimit = this.options.itemsLimit;
      this.activeItemIndexChange = new core_js_.EventEmitter();
      this.items = taiga_ui_cdk_constants/* EMPTY_QUERY */.Mm;
      this.open = false;
    }
    // TODO: Improve performance
    get tabs() {
      return Array.from(this.elementRef.nativeElement.querySelectorAll('[tuiTab]'));
    }
    get activeElement() {
      var _a;
      const {
        tabs
      } = this;
      const safeActiveIndex = (0,taiga_ui_cdk_utils_math/* tuiClamp */.Ki)(this.activeItemIndex || 0, 0, tabs.length - 2);
      return this.options.exposeActive || this.lastVisibleIndex >= safeActiveIndex ? tabs[safeActiveIndex] || null : ((_a = this.moreButton) === null || _a === void 0 ? void 0 : _a.nativeElement) || null;
    }
    get isMoreVisible() {
      return this.lastVisibleIndex < this.items.length - 1;
    }
    get isMoreFocusable() {
      return !!this.moreButton && (0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(this.moreButton.nativeElement);
    }
    get isMoreActive() {
      return this.open || !this.options.exposeActive && this.lastVisibleIndex < this.activeItemIndex;
    }
    get isMoreAlone() {
      return this.lastVisibleIndex < 0 && !this.options.exposeActive;
    }
    get lastVisibleIndex() {
      if (this.itemsLimit + 1 >= this.items.length) {
        return this.maxIndex;
      }
      const offset = this.itemsLimit - 1 > this.activeItemIndex || !this.options.exposeActive ? 1 : 2;
      return Math.min(this.itemsLimit - offset, this.maxIndex);
    }
    ngAfterViewInit() {
      this.refresh$.pipe((0,operators_map/* map */.U)(() => this.getMaxIndex()), (0,operators_filter/* filter */.h)(maxIndex => this.maxIndex !== maxIndex)).subscribe(maxIndex => {
        this.maxIndex = maxIndex;
        this.changeDetectorRef.detectChanges();
      });
    }
    onActiveItemIndexChange(activeItemIndex) {
      this.updateActiveItemIndex(activeItemIndex);
    }
    onClick(index) {
      this.open = false;
      this.focusMore();
      this.updateActiveItemIndex(index);
    }
    onArrowRight(event) {
      (0,taiga_ui_cdk_classes/* tuiAssertIsHTMLElement */.HU)(event.target);
      if ((0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(event.target)) {
        this.focusMore();
      }
    }
    onArrowLeft() {
      const {
        tabs
      } = this;
      let index = tabs.length - 2;
      while (index >= 0) {
        (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(tabs[index]);
        if ((0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(tabs[index])) {
          return;
        }
        index--;
      }
    }
    onWrapperArrow(event, wrapper, prev) {
      const button = event.target;
      const target = (0,taiga_ui_cdk_utils_focus/* getClosestFocusable */.kA)(button, prev, wrapper);
      if (target) {
        (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(target);
      }
    }
    isOverflown(index) {
      return index !== this.activeItemIndex || !this.options.exposeActive;
    }
    shouldShow(index) {
      return index > this.lastVisibleIndex && this.isOverflown(index);
    }
    focusMore() {
      if (this.moreButton) {
        (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(this.moreButton.nativeElement);
      }
    }
    getMaxIndex() {
      const {
        tabs,
        activeItemIndex,
        margin
      } = this;
      if (tabs.length < 2) {
        return 0;
      }
      const {
        exposeActive,
        minMoreWidth
      } = this.options;
      const {
        clientWidth
      } = this.elementRef.nativeElement;
      const activeWidth = tabs[activeItemIndex] ? tabs[activeItemIndex].scrollWidth : 0;
      const moreWidth = Math.max(tabs[tabs.length - 1].scrollWidth, minMoreWidth);
      let maxIndex = tabs.length - 2;
      let total = tabs.reduce((acc, {
        scrollWidth
      }) => acc + scrollWidth, 0) + maxIndex * margin - tabs[tabs.length - 1].scrollWidth;
      if (total <= clientWidth) {
        return Infinity;
      }
      while (maxIndex) {
        total -= tabs[maxIndex].scrollWidth + margin;
        maxIndex--;
        const activeDisplaced = exposeActive && activeItemIndex > maxIndex;
        const activeOffset = activeDisplaced ? activeWidth + margin : 0;
        const currentWidth = total + activeOffset + moreWidth + margin;
        // Needed for different rounding of visible and hidden elements scrollWidth
        const safetyOffset = (0,taiga_ui_cdk_utils_math/* toInt */.Hq)(this.maxIndex === maxIndex - 1);
        if (currentWidth + safetyOffset < clientWidth) {
          return maxIndex;
        }
      }
      return -1;
    }
    updateActiveItemIndex(activeItemIndex) {
      this.activeItemIndex = activeItemIndex;
      this.activeItemIndexChange.emit(activeItemIndex);
      this.maxIndex = this.getMaxIndex();
    }
  };
  TuiTabsWithMoreComponent.ɵfac = function TuiTabsWithMoreComponent_Factory(t) {
    return new (t || TuiTabsWithMoreComponent)(core_js_["ɵɵdirectiveInject"](TUI_TABS_OPTIONS), core_js_["ɵɵdirectiveInject"](TUI_TAB_MARGIN), core_js_["ɵɵdirectiveInject"](TABS_REFRESH), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](TUI_MORE_WORD));
  };
  TuiTabsWithMoreComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiTabsWithMoreComponent,
    selectors: [["tui-tabs-with-more"], ["nav", "tuiTabsWithMore", ""]],
    contentQueries: function TuiTabsWithMoreComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        core_js_["ɵɵcontentQuery"](dirIndex, TuiTabDirective, 4, core_js_.TemplateRef);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.items = _t);
      }
    },
    viewQuery: function TuiTabsWithMoreComponent_Query(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵviewQuery"](TuiTabComponent, 5, core_js_.ElementRef);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.moreButton = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function TuiTabsWithMoreComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("_underline", ctx.underline);
      }
    },
    inputs: {
      moreContent: "moreContent",
      dropdownContent: "dropdownContent",
      underline: "underline",
      activeItemIndex: "activeItemIndex",
      itemsLimit: "itemsLimit"
    },
    outputs: {
      activeItemIndexChange: "activeItemIndexChange"
    },
    features: [core_js_["ɵɵProvidersFeature"](TABS_PROVIDERS)],
    decls: 13,
    vars: 17,
    consts: [[4, "ngIf"], [1, "t-wrapper"], [1, "t-tabs", 3, "underline", "activeItemIndex", "activeItemIndexChange", "keydown.arrowRight"], [4, "ngFor", "ngForOf"], [1, "t-more_wrapper", 3, "content", "open", "openChange"], ["tuiTab", "", 3, "tuiFocusable", "keydown.arrowLeft.prevent"], ["polymorpheus-outlet", "", 3, "content"], ["more", ""], ["dropdown", ""], [3, "element", 4, "ngIf"], [3, "ngTemplateOutlet", 4, "ngIf", "ngIfElse"], ["hidden", ""], [3, "ngTemplateOutlet"], ["src", "tuiIconChevronDown", 1, "t-icon"], [1, "t-dropdown", 3, "keydown.arrowUp.prevent", "keydown.arrowDown.prevent"], ["element", ""], [3, "tui-tab-activate", 4, "ngFor", "ngForOf"], [3, "tui-tab-activate"], [3, "ngTemplateOutlet", 4, "ngIf"], [3, "element"]],
    template: function TuiTabsWithMoreComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵtemplate"](0, TuiTabsWithMoreComponent_ng_container_0_Template, 1, 0, "ng-container", 0);
        core_js_["ɵɵpipe"](1, "async");
        core_js_["ɵɵelementStart"](2, "div", 1);
        core_js_["ɵɵelementStart"](3, "tui-tabs", 2);
        core_js_["ɵɵlistener"]("activeItemIndexChange", function TuiTabsWithMoreComponent_Template_tui_tabs_activeItemIndexChange_3_listener($event) {
          return ctx.onActiveItemIndexChange($event);
        })("keydown.arrowRight", function TuiTabsWithMoreComponent_Template_tui_tabs_keydown_arrowRight_3_listener($event) {
          return ctx.onArrowRight($event);
        });
        core_js_["ɵɵtemplate"](4, TuiTabsWithMoreComponent_ng_container_4_Template, 4, 2, "ng-container", 3);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](5, "tui-hosted-dropdown", 4);
        core_js_["ɵɵlistener"]("openChange", function TuiTabsWithMoreComponent_Template_tui_hosted_dropdown_openChange_5_listener($event) {
          return ctx.open = $event;
        });
        core_js_["ɵɵelementStart"](6, "button", 5);
        core_js_["ɵɵlistener"]("keydown.arrowLeft.prevent", function TuiTabsWithMoreComponent_Template_button_keydown_arrowLeft_prevent_6_listener() {
          return ctx.onArrowLeft();
        });
        core_js_["ɵɵelement"](7, "span", 6);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](8, TuiTabsWithMoreComponent_ng_template_8_Template, 3, 5, "ng-template", null, 7, core_js_["ɵɵtemplateRefExtractor"]);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](10, TuiTabsWithMoreComponent_ng_template_10_Template, 3, 1, "ng-template", null, 8, core_js_["ɵɵtemplateRefExtractor"]);
        core_js_["ɵɵtemplate"](12, TuiTabsWithMoreComponent_tui_underline_12_Template, 1, 1, "tui-underline", 9);
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        const _r2 = core_js_["ɵɵreference"](9);
        const _r4 = core_js_["ɵɵreference"](11);
        core_js_["ɵɵproperty"]("ngIf", core_js_["ɵɵpipeBind1"](1, 15, ctx.items.changes));
        core_js_["ɵɵadvance"](3);
        core_js_["ɵɵproperty"]("underline", false)("activeItemIndex", ctx.activeItemIndex);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngForOf", ctx.items);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵclassProp"]("t-overflown", !ctx.isMoreVisible);
        core_js_["ɵɵproperty"]("content", ctx.dropdownContent || _r4)("open", ctx.open);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵclassProp"]("_active", ctx.isMoreActive)("t-no-margin", ctx.isMoreAlone);
        core_js_["ɵɵproperty"]("tuiFocusable", ctx.isMoreFocusable);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("content", ctx.moreContent || _r2);
        core_js_["ɵɵadvance"](5);
        core_js_["ɵɵproperty"]("ngIf", ctx.underline);
      }
    },
    directives: function () {
      return [common_js_.NgIf, TuiTabsComponent, common_js_.NgForOf, TuiHostedDropdownComponent, TuiTabComponent, TuiFocusableDirective, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, common_js_.NgTemplateOutlet, taiga_ui_core_components_svg/* TuiSvgComponent */.P, TuiUnderlineComponent];
    },
    pipes: function () {
      return [common_js_.AsyncPipe];
    },
    styles: ["[_nghost-%COMP%]{position:relative;display:flex;font:var(--tui-font-text-m);height:var(--tui-height-l);box-sizing:border-box;color:var(--tui-text-02);box-shadow:inset 0 -1px var(--tui-base-03);overflow:hidden}.t-wrapper[_ngcontent-%COMP%]{position:relative;display:flex}.t-tabs[_ngcontent-%COMP%]{height:inherit;font-size:inherit;font-weight:inherit;overflow:visible;box-shadow:none;color:inherit}.t-overflown[_ngcontent-%COMP%]{display:flex;margin:0;width:0;max-width:0;overflow:hidden;visibility:hidden}.t-more_wrapper[_ngcontent-%COMP%]{height:100%;pointer-events:none}.t-more_wrapper[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{pointer-events:auto}.t-icon[_ngcontent-%COMP%]{transition-property:transform;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;margin-right:-.25rem;vertical-align:bottom}.t-icon_rotated[_ngcontent-%COMP%]{transform:rotate(180deg)}.t-dropdown[_ngcontent-%COMP%]{padding:.5rem 0}.t-dropdown[_ngcontent-%COMP%]     [tuiTab]{width:100%;height:2.75rem;justify-content:flex-start;margin:0;padding:0 1rem;color:var(--tui-text-02)}.t-dropdown[_ngcontent-%COMP%]     [tuiTab]:before{display:none}.t-dropdown[_ngcontent-%COMP%]     [tuiTab]._active, .t-dropdown[_ngcontent-%COMP%]     [tuiTab]:focus, .t-dropdown[_ngcontent-%COMP%]     [tuiTab]:hover{box-shadow:none;color:var(--tui-base-08);background:var(--tui-base-02)}.t-no-margin[_ngcontent-%COMP%]{margin-left:0}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)(TuiTabComponent, {
    read: core_js_.ElementRef
  })], TuiTabsWithMoreComponent.prototype, "moreButton", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTabsWithMoreComponent.prototype, "moreContent", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTabsWithMoreComponent.prototype, "dropdownContent", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._underline'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTabsWithMoreComponent.prototype, "underline", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTabsWithMoreComponent.prototype, "activeItemIndex", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTabsWithMoreComponent.prototype, "itemsLimit", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiTabsWithMoreComponent.prototype, "activeItemIndexChange", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChildren)(TuiTabDirective, {
    read: core_js_.TemplateRef
  })], TuiTabsWithMoreComponent.prototype, "items", void 0);
  TuiTabsWithMoreComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TUI_TABS_OPTIONS)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_TAB_MARGIN)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(TABS_REFRESH)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(TUI_MORE_WORD))], TuiTabsWithMoreComponent);
  return TuiTabsWithMoreComponent;
})();
let TuiUnderlineComponent = /*#__PURE__*/(() => {
  let TuiUnderlineComponent = class TuiUnderlineComponent {
    constructor({
      nativeElement
    }, ngZone, animationFrame$, mobileAware, ios, android, mode$) {
      this.ngZone = ngZone;
      this.animationFrame$ = animationFrame$;
      this.mobileAware = mobileAware;
      this.ios = ios;
      this.android = android;
      this.mode$ = mode$;
      this.element$ = new internal_ReplaySubject/* ReplaySubject */.t(1);
      this.refresh$ = this.element$.pipe((0,operators_switchMap/* switchMap */.w)(element => element ? this.animationFrame$.pipe((0,operators_mapTo/* mapTo */.h)(element), (0,taiga_ui_cdk_observables/* tuiZonefree */.fL)(this.ngZone)) : (0,observable_of.of)(null)), (0,share/* share */.B)());
      this.isIos = this.mobileAware && this.ios;
      this.isAndroid = this.mobileAware && this.android;
      this.transition$ = asCallable(this.element$.pipe((0,operators_map/* map */.U)(element => element && 'all'), (0,operators_debounceTime/* debounceTime */.b)(50)));
      this.transform$ = asCallable(this.refresh$.pipe((0,operators_map/* map */.U)(element => element ? `translate3d(${px(element.offsetLeft)}, 0, 0)` : null)));
      this.width$ = asCallable(this.refresh$.pipe((0,operators_map/* map */.U)(element => (element === null || element === void 0 ? void 0 : element.clientWidth) || 0)));
      nativeElement['$.style.transitionProperty'] = this.transition$;
      nativeElement['$.style.transform'] = this.transform$;
      nativeElement['$.style.width.px'] = this.width$;
    }
    set element(element) {
      this.element$.next(element);
    }
  };
  TuiUnderlineComponent.ɵfac = function TuiUnderlineComponent_Factory(t) {
    return new (t || TuiUnderlineComponent)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.NgZone), core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* ANIMATION_FRAME */.L1), core_js_["ɵɵdirectiveInject"](TUI_MOBILE_AWARE), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_IOS */.FA), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_ANDROID */.XG), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_MODE */.Au));
  };
  TuiUnderlineComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiUnderlineComponent,
    selectors: [["tui-underline"]],
    hostVars: 4,
    hostBindings: function TuiUnderlineComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("$.data-mode.attr", function TuiUnderlineComponent___data_mode_attr_HostBindingHandler() {
          return ctx.mode$;
        })("$.style.transitionProperty", function TuiUnderlineComponent___style_transitionProperty_HostBindingHandler() {
          return ctx.transition$();
        })("$.style.transform", function TuiUnderlineComponent___style_transform_HostBindingHandler() {
          return ctx.transform$();
        })("$.style.width.px", function TuiUnderlineComponent___style_width_px_HostBindingHandler() {
          return ctx.width$();
        });
      }
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("_ios", ctx.isIos)("_android", ctx.isAndroid);
      }
    },
    inputs: {
      element: "element"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_core_providers/* MODE_PROVIDER */.CV])],
    decls: 0,
    vars: 0,
    template: function TuiUnderlineComponent_Template(rf, ctx) {},
    styles: ["[_nghost-%COMP%]{transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;position:absolute;left:0;height:100%;color:var(--tui-primary);transform:scale(0);box-shadow:inset 0 -.1875rem 0 -.0625rem;transition-property:none;pointer-events:none}._ios[_nghost-%COMP%]{border-radius:.4375rem;background:var(--tui-base-01);box-shadow:0 .1875rem .0625rem rgba(0,0,0,.04),0 .1875rem .5rem rgba(0,0,0,.12)}._android[_nghost-%COMP%]{box-shadow:inset 0 -.1875rem var(--tui-link)}[data-mode=onDark][_nghost-%COMP%]{color:var(--tui-text-01-night)}[data-mode=onLight][_nghost-%COMP%]{color:var(--tui-text-02)}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiUnderlineComponent.prototype, "element", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._ios')], TuiUnderlineComponent.prototype, "isIos", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._android')], TuiUnderlineComponent.prototype, "isAndroid", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('$.style.transitionProperty')], TuiUnderlineComponent.prototype, "transition$", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('$.style.transform')], TuiUnderlineComponent.prototype, "transform$", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('$.style.width.px')], TuiUnderlineComponent.prototype, "width$", void 0);
  TuiUnderlineComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.NgZone)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(ng_web_apis_common/* ANIMATION_FRAME */.L1)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TUI_MOBILE_AWARE)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_IOS */.FA)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_ANDROID */.XG)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_MODE */.Au))], TuiUnderlineComponent);
  return TuiUnderlineComponent;
})();
let TuiTabsModule = /*#__PURE__*/(() => {
  let TuiTabsModule = class TuiTabsModule {};
  TuiTabsModule.ɵfac = function TuiTabsModule_Factory(t) {
    return new (t || TuiTabsModule)();
  };
  TuiTabsModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiTabsModule
  });
  TuiTabsModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, TuiHostedDropdownModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiFocusableModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq]]
  });
  return TuiTabsModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiTabsModule, {
    declarations: function () {
      return [TuiTabsWithMoreComponent, TuiTabsComponent, TuiTabComponent, TuiUnderlineComponent, TuiTabDirective];
    },
    imports: function () {
      return [common_js_.CommonModule, TuiHostedDropdownModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiFocusableModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq];
    },
    exports: function () {
      return [TuiTabsWithMoreComponent, TuiTabsComponent, TuiTabComponent, TuiTabDirective];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-tabs.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/pairwise.js
var pairwise = __webpack_require__(9328);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-group.js






const taiga_ui_core_components_group_c0 = ["*"];
let TuiGroupStylesComponent = /*#__PURE__*/(() => {
  let TuiGroupStylesComponent = class TuiGroupStylesComponent {};
  TuiGroupStylesComponent.ɵfac = function TuiGroupStylesComponent_Factory(t) {
    return new (t || TuiGroupStylesComponent)();
  };
  TuiGroupStylesComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiGroupStylesComponent,
    selectors: [["ng-component"]],
    decls: 0,
    vars: 0,
    template: function TuiGroupStylesComponent_Template(rf, ctx) {},
    styles: [".tui-group{position:relative;z-index:0;display:flex}.tui-group>*{flex:1 1 0;min-width:0}.tui-group>:nth-child(n){border-radius:0}.tui-group>:not(:last-child){margin-right:.125rem}.tui-group_collapsed>*{z-index:1}.tui-group_collapsed>:not(:last-child){margin-right:-1px}.tui-group_collapsed>._disabled,.tui-group_collapsed>._disabled:hover,.tui-group_collapsed>._readonly,.tui-group_collapsed>._readonly:hover{z-index:0}.tui-group_collapsed>._hovered,.tui-group_collapsed>._pressed,.tui-group_collapsed>:hover{z-index:3}.tui-group_collapsed>._invalid{z-index:2}.tui-group_collapsed>._invalid._hovered,.tui-group_collapsed>._invalid._pressed,.tui-group_collapsed>._invalid:hover{z-index:4}.tui-group_collapsed>._focus-visible,.tui-group_collapsed>._focused.ng-touched,.tui-group_collapsed>._focused.ng-untouched,.tui-group_collapsed>._hosted_dropdown_focused{z-index:5}.tui-group_collapsed>._active,.tui-group_collapsed>[data-appearance=whiteblock-active]{z-index:6}.tui-group_collapsed>._focus-visible._active,.tui-group_collapsed>._focus-visible._focused,.tui-group_collapsed>._focus-visible[data-appearance=whiteblock-active]{z-index:7}.tui-group_orientation_vertical{display:inline-flex;flex-direction:column}.tui-group_orientation_vertical>*{min-height:auto;flex:0 0 auto}.tui-group_orientation_vertical>:not(:last-child){margin-right:0;margin-bottom:.125rem}.tui-group_orientation_vertical.tui-group_collapsed>:not(:last-child){margin-right:0;margin-bottom:-1px}.tui-group_rounded.tui-group_orientation_horizontal>:first-child{border-top-left-radius:var(--tui-radius-m);border-bottom-left-radius:var(--tui-radius-m)}.tui-group_rounded.tui-group_orientation_horizontal>:last-child{border-top-right-radius:var(--tui-radius-m);border-bottom-right-radius:var(--tui-radius-m)}.tui-group_rounded.tui-group_orientation_horizontal.tui-group_radius_large>:first-child{border-top-left-radius:var(--tui-radius-l);border-bottom-left-radius:var(--tui-radius-l)}.tui-group_rounded.tui-group_orientation_horizontal.tui-group_radius_large>:last-child{border-top-right-radius:var(--tui-radius-l);border-bottom-right-radius:var(--tui-radius-l)}.tui-group_rounded.tui-group_orientation_vertical>:first-child{border-top-left-radius:var(--tui-radius-m);border-top-right-radius:var(--tui-radius-m)}.tui-group_rounded.tui-group_orientation_vertical>:last-child{border-bottom-left-radius:var(--tui-radius-m);border-bottom-right-radius:var(--tui-radius-m)}.tui-group_rounded.tui-group_orientation_vertical.tui-group_radius_large>:first-child{border-top-left-radius:var(--tui-radius-l);border-top-right-radius:var(--tui-radius-l)}.tui-group_rounded.tui-group_orientation_vertical.tui-group_radius_large>:last-child{border-bottom-left-radius:var(--tui-radius-l);border-bottom-right-radius:var(--tui-radius-l)}@media screen and (max-width:47.9625em){.tui-group_rounded.tui-group_adaptive.tui-group_orientation_horizontal>:first-child:not(:last-child),.tui-group_rounded.tui-group_adaptive.tui-group_orientation_horizontal>:last-child:not(:first-child),.tui-group_rounded.tui-group_adaptive.tui-group_orientation_vertical:not(.tui-group_collapsed)>:first-child:not(:last-child),.tui-group_rounded.tui-group_adaptive.tui-group_orientation_vertical:not(.tui-group_collapsed)>:last-child:not(:first-child){border-radius:var(--tui-radius-m)}.tui-group_rounded.tui-group_adaptive.tui-group_radius_large.tui-group_orientation_horizontal>:first-child:not(:last-child),.tui-group_rounded.tui-group_adaptive.tui-group_radius_large.tui-group_orientation_horizontal>:last-child:not(:first-child),.tui-group_rounded.tui-group_adaptive.tui-group_radius_large.tui-group_orientation_vertical:not(.tui-group_collapsed)>:first-child:not(:last-child),.tui-group_rounded.tui-group_adaptive.tui-group_radius_large.tui-group_orientation_vertical:not(.tui-group_collapsed)>:last-child:not(:first-child){border-radius:var(--tui-radius-l)}.tui-group_adaptive.tui-group_orientation_vertical{width:100%}.tui-group_adaptive.tui-group_orientation_vertical>:nth-child(n):not(:only-child){border-radius:var(--tui-radius-m)}.tui-group_adaptive.tui-group_orientation_vertical>:not(:last-child){margin-bottom:1rem}.tui-group_adaptive.tui-group_orientation_vertical.tui-group_collapsed>:nth-child(n):not(:only-child){border-radius:0}.tui-group_adaptive.tui-group_orientation_vertical.tui-group_collapsed>:first-child:not(:last-child){border-radius:var(--tui-radius-m) var(--tui-radius-m) 0 0}.tui-group_adaptive.tui-group_orientation_vertical.tui-group_collapsed>:last-child:not(:first-child){border-radius:0 0 var(--tui-radius-m) var(--tui-radius-m)}.tui-group_adaptive.tui-group_orientation_vertical.tui-group_collapsed>:not(:last-child){margin-bottom:-1px}.tui-group_adaptive.tui-group_orientation_horizontal{flex-direction:column;width:100%}.tui-group_adaptive.tui-group_orientation_horizontal>:nth-child(n):not(:only-child){border-radius:var(--tui-radius-m)}.tui-group_adaptive.tui-group_orientation_horizontal>:not(:last-child){margin-right:0;margin-bottom:1rem}.tui-group_adaptive.tui-group_orientation_horizontal.tui-group_collapsed>:nth-child(n):not(:only-child){border-radius:0}.tui-group_adaptive.tui-group_orientation_horizontal.tui-group_collapsed>:first-child:not(:last-child){border-radius:var(--tui-radius-m) var(--tui-radius-m) 0 0}.tui-group_adaptive.tui-group_orientation_horizontal.tui-group_collapsed>:last-child:not(:first-child){border-radius:0 0 var(--tui-radius-m) var(--tui-radius-m)}.tui-group_adaptive.tui-group_orientation_horizontal.tui-group_collapsed>:not(:last-child){margin-right:0;margin-bottom:-1px}.tui-group_adaptive.tui-group_radius_large.tui-group_orientation_vertical>:nth-child(n):not(:only-child){border-radius:var(--tui-radius-l)}.tui-group_adaptive.tui-group_radius_large.tui-group_orientation_vertical.tui-group_collapsed>:nth-child(n):not(:only-child){border-radius:0}.tui-group_adaptive.tui-group_radius_large.tui-group_orientation_vertical.tui-group_collapsed>:first-child:not(:last-child){border-radius:var(--tui-radius-l) var(--tui-radius-l) 0 0}.tui-group_adaptive.tui-group_radius_large.tui-group_orientation_vertical.tui-group_collapsed>:last-child:not(:first-child){border-radius:0 0 var(--tui-radius-l) var(--tui-radius-l)}.tui-group_adaptive.tui-group_radius_large.tui-group_orientation_horizontal>:nth-child(n):not(:only-child){border-radius:var(--tui-radius-l)}.tui-group_adaptive.tui-group_radius_large.tui-group_orientation_horizontal.tui-group_collapsed>:nth-child(n):not(:only-child){border-radius:0}.tui-group_adaptive.tui-group_radius_large.tui-group_orientation_horizontal.tui-group_collapsed>:first-child:not(:last-child){border-radius:var(--tui-radius-l) var(--tui-radius-l) 0 0}.tui-group_adaptive.tui-group_radius_large.tui-group_orientation_horizontal.tui-group_collapsed>:last-child:not(:first-child){border-radius:0 0 var(--tui-radius-l) var(--tui-radius-l)}}.tui-group__auto-width-item{min-width:auto;flex:0 0 auto}.tui-group .tui-group__inherit-item{border-radius:inherit}"],
    encapsulation: 2
  });
  return TuiGroupStylesComponent;
})();
let TuiGroupDirective = /*#__PURE__*/(() => {
  let TuiGroupDirective = class TuiGroupDirective {
    constructor(directiveStyles) {
      this.orientation = 'horizontal';
      this.adaptive = false;
      this.collapsed = false;
      this.rounded = true;
      this.size = 'm';
      directiveStyles.addComponent(TuiGroupStylesComponent);
    }
    get orientationHorizontal() {
      return this.orientation === 'horizontal';
    }
    get orientationVertical() {
      return this.orientation === 'vertical';
    }
    get sizeLarge() {
      return this.size === 'l';
    }
  };
  TuiGroupDirective.ɵfac = function TuiGroupDirective_Factory(t) {
    return new (t || TuiGroupDirective)(core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDirectiveStylesService */.gH));
  };
  TuiGroupDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiGroupDirective,
    selectors: [["", "tuiGroup", "", 5, "ng-container"]],
    hostAttrs: ["role", "group", 1, "tui-group"],
    hostVars: 12,
    hostBindings: function TuiGroupDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("tui-group_adaptive", ctx.adaptive)("tui-group_collapsed", ctx.collapsed)("tui-group_rounded", ctx.rounded)("tui-group_orientation_horizontal", ctx.orientationHorizontal)("tui-group_orientation_vertical", ctx.orientationVertical)("tui-group_radius_large", ctx.sizeLarge);
      }
    },
    inputs: {
      orientation: "orientation",
      adaptive: "adaptive",
      collapsed: "collapsed",
      rounded: "rounded",
      size: "size"
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiGroupDirective.prototype, "orientation", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class.tui-group_adaptive'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiGroupDirective.prototype, "adaptive", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class.tui-group_collapsed'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiGroupDirective.prototype, "collapsed", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class.tui-group_rounded'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiGroupDirective.prototype, "rounded", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiGroupDirective.prototype, "size", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class.tui-group_orientation_horizontal')], TuiGroupDirective.prototype, "orientationHorizontal", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class.tui-group_orientation_vertical')], TuiGroupDirective.prototype, "orientationVertical", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class.tui-group_radius_large')], TuiGroupDirective.prototype, "sizeLarge", null);
  TuiGroupDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDirectiveStylesService */.gH))], TuiGroupDirective);

  /** @deprecated */
  return TuiGroupDirective;
})();
let TuiGroupComponent = /*#__PURE__*/(() => {
  let TuiGroupComponent = class TuiGroupComponent extends TuiGroupDirective {};
  TuiGroupComponent.ɵfac = /*@__PURE__*/function () {
    let ɵTuiGroupComponent_BaseFactory;
    return function TuiGroupComponent_Factory(t) {
      return (ɵTuiGroupComponent_BaseFactory || (ɵTuiGroupComponent_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiGroupComponent)))(t || TuiGroupComponent);
    };
  }();
  TuiGroupComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiGroupComponent,
    selectors: [["tui-group"]],
    hostAttrs: ["role", "group", 1, "tui-group"],
    features: [core_js_["ɵɵInheritDefinitionFeature"]],
    ngContentSelectors: taiga_ui_core_components_group_c0,
    decls: 1,
    vars: 0,
    template: function TuiGroupComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
  return TuiGroupComponent;
})();
let TuiGroupModule = /*#__PURE__*/(() => {
  let TuiGroupModule = class TuiGroupModule {};
  TuiGroupModule.ɵfac = function TuiGroupModule_Factory(t) {
    return new (t || TuiGroupModule)();
  };
  TuiGroupModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiGroupModule
  });
  TuiGroupModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule]]
  });
  return TuiGroupModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiGroupModule, {
    declarations: function () {
      return [TuiGroupComponent, TuiGroupDirective, TuiGroupStylesComponent];
    },
    imports: function () {
      return [common_js_.CommonModule];
    },
    exports: function () {
      return [TuiGroupComponent, TuiGroupDirective, TuiGroupStylesComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-group.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-expand.js







// @bad TODO: 3.0 Replace with PolymorpheusContent



const taiga_ui_core_components_expand_c0 = ["wrapper"];
function TuiExpandComponent_ng_container_2_tui_loader_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "tui-loader", 4);
    core_js_["ɵɵelementContainer"](1, 5);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r2 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵproperty"]("overlay", true)("showLoader", ctx_r2.loading);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngTemplateOutlet", ctx_r2.content);
  }
}
function TuiExpandComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵprojection"](1);
    core_js_["ɵɵtemplate"](2, TuiExpandComponent_ng_container_2_tui_loader_2_Template, 2, 3, "tui-loader", 3);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵproperty"]("ngIf", ctx_r1.async)("ngIfElse", ctx_r1.content);
  }
}
const taiga_ui_core_components_expand_c1 = ["*"];
let TuiExpandContentDirective = /*#__PURE__*/(() => {
  let TuiExpandContentDirective = class TuiExpandContentDirective {};
  TuiExpandContentDirective.ɵfac = function TuiExpandContentDirective_Factory(t) {
    return new (t || TuiExpandContentDirective)();
  };
  TuiExpandContentDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiExpandContentDirective,
    selectors: [["", "tuiExpandContent", ""]]
  });
  return TuiExpandContentDirective;
})();
var State = /*#__PURE__*/(() => {
  (function (State) {
    State[State["Idle"] = 0] = "Idle";
    State[State["Loading"] = 1] = "Loading";
    State[State["Prepared"] = 2] = "Prepared";
    State[State["Animated"] = 3] = "Animated";
  })(State || (State = {}));
  return State;
})();
const LOADER_HEIGHT = 48;
let TuiExpandComponent = /*#__PURE__*/(() => {
  let TuiExpandComponent = class TuiExpandComponent {
    constructor(changeDetectorRef) {
      this.changeDetectorRef = changeDetectorRef;
      this.state = State.Idle;
      this.async = false;
      this.content = null;
      this.expanded = null;
    }
    set expandedSetter(expanded) {
      if (this.expanded === null) {
        this.expanded = expanded;
        return;
      }
      if (this.state !== State.Idle) {
        this.expanded = expanded;
        this.state = State.Animated;
        return;
      }
      this.expanded = expanded;
      this.retrigger(this.async && expanded ? State.Loading : State.Animated);
    }
    get overflow() {
      return this.state !== State.Idle;
    }
    get loading() {
      return !!this.expanded && this.async && this.state === State.Loading;
    }
    get height() {
      const {
        expanded,
        state,
        contentWrapper
      } = this;
      if (expanded && state === State.Prepared || !expanded && state === State.Animated) {
        return 0;
      }
      if (contentWrapper && (!expanded && state === State.Prepared || expanded && state === State.Animated)) {
        return contentWrapper.nativeElement.offsetHeight;
      }
      if (contentWrapper && expanded && state === State.Loading) {
        return Math.max(contentWrapper.nativeElement.offsetHeight, LOADER_HEIGHT);
      }
      return null;
    }
    get contentVisible() {
      return this.expanded || this.state !== State.Idle;
    }
    onTransitionEnd(event) {
      if ((0,taiga_ui_cdk_utils_dom/* isCurrentTarget */.Xr)(event) && event.propertyName === 'opacity' && this.state === State.Animated) {
        this.state = State.Idle;
      }
    }
    onExpandLoaded(event) {
      event.stopPropagation();
      if (this.state === State.Loading) {
        this.retrigger(State.Animated);
      }
    }
    retrigger(state) {
      this.state = State.Prepared;
      // We need delay to re-trigger CSS height transition from the correct number
      setTimeout(() => {
        if (this.state !== State.Prepared) {
          return;
        }
        this.state = state;
        this.changeDetectorRef.markForCheck();
      });
    }
  };
  TuiExpandComponent.ɵfac = function TuiExpandComponent_Factory(t) {
    return new (t || TuiExpandComponent)(core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef));
  };
  TuiExpandComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiExpandComponent,
    selectors: [["tui-expand"]],
    contentQueries: function TuiExpandComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        core_js_["ɵɵcontentQuery"](dirIndex, TuiExpandContentDirective, 5, core_js_.TemplateRef);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.content = _t.first);
      }
    },
    viewQuery: function TuiExpandComponent_Query(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵviewQuery"](taiga_ui_core_components_expand_c0, 5);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.contentWrapper = _t.first);
      }
    },
    hostVars: 9,
    hostBindings: function TuiExpandComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("transitionend", function TuiExpandComponent_transitionend_HostBindingHandler($event) {
          return ctx.onTransitionEnd($event);
        })("tui-expand-loaded", function TuiExpandComponent_tui_expand_loaded_HostBindingHandler($event) {
          return ctx.onExpandLoaded($event);
        });
      }
      if (rf & 2) {
        core_js_["ɵɵattribute"]("aria-expanded", ctx.expanded);
        core_js_["ɵɵstyleProp"]("height", ctx.height, "px");
        core_js_["ɵɵclassProp"]("_expanded", ctx.expanded)("_overflow", ctx.overflow)("_loading", ctx.loading);
      }
    },
    inputs: {
      async: "async",
      expandedSetter: ["expanded", "expandedSetter"]
    },
    ngContentSelectors: taiga_ui_core_components_expand_c1,
    decls: 3,
    vars: 1,
    consts: [[1, "t-wrapper"], ["wrapper", ""], [4, "ngIf"], ["size", "l", 3, "overlay", "showLoader", 4, "ngIf", "ngIfElse"], ["size", "l", 3, "overlay", "showLoader"], [3, "ngTemplateOutlet"]],
    template: function TuiExpandComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵelementStart"](0, "div", 0, 1);
        core_js_["ɵɵtemplate"](2, TuiExpandComponent_ng_container_2_Template, 3, 2, "ng-container", 2);
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵproperty"]("ngIf", ctx.contentVisible);
      }
    },
    directives: [common_js_.NgIf, taiga_ui_core_components_loader/* TuiLoaderComponent */.kM, common_js_.NgTemplateOutlet],
    styles: ["[_nghost-%COMP%]{display:block;transition-property:opacity,height,visibility;transition-duration:var(--tui-duration,300ms);opacity:0}._overflow[_nghost-%COMP%]{overflow:hidden}._expanded[_nghost-%COMP%]{opacity:1;transform:translate3d(0,0,0)}._loading[_nghost-%COMP%]{opacity:.99}.t-wrapper[_ngcontent-%COMP%]:after, .t-wrapper[_ngcontent-%COMP%]:before{content:'';display:table}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('wrapper')], TuiExpandComponent.prototype, "contentWrapper", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiExpandComponent.prototype, "async", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('expanded'), (0,taiga_ui_cdk_decorators/* tuiRequiredSetter */.NH)()], TuiExpandComponent.prototype, "expandedSetter", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChild)(TuiExpandContentDirective, {
    read: core_js_.TemplateRef
  })], TuiExpandComponent.prototype, "content", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._expanded'), (0,core_js_.HostBinding)('attr.aria-expanded')], TuiExpandComponent.prototype, "expanded", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._overflow')], TuiExpandComponent.prototype, "overflow", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._loading')], TuiExpandComponent.prototype, "loading", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('style.height.px')], TuiExpandComponent.prototype, "height", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('transitionend', ['$event'])], TuiExpandComponent.prototype, "onTransitionEnd", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)(taiga_ui_core_constants/* TUI_EXPAND_LOADED */.P8, ['$event'])], TuiExpandComponent.prototype, "onExpandLoaded", null);
  TuiExpandComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ChangeDetectorRef))], TuiExpandComponent);
  return TuiExpandComponent;
})();
let TuiExpandModule = /*#__PURE__*/(() => {
  let TuiExpandModule = class TuiExpandModule {};
  TuiExpandModule.ɵfac = function TuiExpandModule_Factory(t) {
    return new (t || TuiExpandModule)();
  };
  TuiExpandModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiExpandModule
  });
  TuiExpandModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, taiga_ui_core_components_loader/* TuiLoaderModule */.dS]]
  });
  return TuiExpandModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiExpandModule, {
    declarations: function () {
      return [TuiExpandComponent, TuiExpandContentDirective];
    },
    imports: function () {
      return [common_js_.CommonModule, taiga_ui_core_components_loader/* TuiLoaderModule */.dS];
    },
    exports: function () {
      return [TuiExpandComponent, TuiExpandContentDirective];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-expand.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-accordion.js














const taiga_ui_kit_components_accordion_c0 = ["focusableElement"];
function TuiAccordionItemComponent_tui_svg_5_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 8);
  }
  if (rf & 2) {
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵclassProp"]("t-icon_open", ctx_r1.open);
  }
}
function TuiAccordionItemComponent_div_7_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 9);
    core_js_["ɵɵprojection"](1, 1);
    core_js_["ɵɵelementEnd"]();
  }
}
function TuiAccordionItemComponent_ng_template_8_div_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "div", 11);
  }
  if (rf & 2) {
    const ctx_r4 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵproperty"]("content", ctx_r4.lazyContent);
  }
}
function TuiAccordionItemComponent_ng_template_8_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵtemplate"](0, TuiAccordionItemComponent_ng_template_8_div_0_Template, 1, 1, "div", 10);
  }
  if (rf & 2) {
    const ctx_r3 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("ngIf", ctx_r3.lazyContent);
  }
}
const taiga_ui_kit_components_accordion_c1 = ["*", [["", "tuiAccordionItemContent", ""]]];
const taiga_ui_kit_components_accordion_c2 = ["*", "[tuiAccordionItemContent]"];
const taiga_ui_kit_components_accordion_c3 = [[["tui-accordion-item"]]];
const taiga_ui_kit_components_accordion_c4 = ["tui-accordion-item"];
let TuiAccordionItemContentDirective = /*#__PURE__*/(() => {
  let TuiAccordionItemContentDirective = class TuiAccordionItemContentDirective extends tinkoff_ng_polymorpheus/* PolymorpheusTemplate */.GL {
    constructor(templateRef, changeDetectorRef) {
      super(templateRef, changeDetectorRef);
    }
  };
  TuiAccordionItemContentDirective.ɵfac = function TuiAccordionItemContentDirective_Factory(t) {
    return new (t || TuiAccordionItemContentDirective)(core_js_["ɵɵdirectiveInject"](core_js_.TemplateRef, 2), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef));
  };
  TuiAccordionItemContentDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiAccordionItemContentDirective,
    selectors: [["ng-template", "tuiAccordionItemContent", ""]],
    features: [core_js_["ɵɵInheritDefinitionFeature"]]
  });
  TuiAccordionItemContentDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.TemplateRef)), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ChangeDetectorRef))], TuiAccordionItemContentDirective);
  return TuiAccordionItemContentDirective;
})();
let TuiAccordionItemEagerContentDirective = /*#__PURE__*/(() => {
  let TuiAccordionItemEagerContentDirective = class TuiAccordionItemEagerContentDirective {};
  TuiAccordionItemEagerContentDirective.ɵfac = function TuiAccordionItemEagerContentDirective_Factory(t) {
    return new (t || TuiAccordionItemEagerContentDirective)();
  };
  TuiAccordionItemEagerContentDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiAccordionItemEagerContentDirective,
    selectors: [["", "tuiAccordionItemContent", "", 5, "ng-template"]]
  });
  return TuiAccordionItemEagerContentDirective;
})();
var TuiAccordionItemComponent_1;
let TuiAccordionItemComponent = TuiAccordionItemComponent_1 = class TuiAccordionItemComponent extends taiga_ui_cdk_abstract/* AbstractTuiInteractive */.Xn {
  constructor(changeDetectorRef, mode$) {
    super();
    this.changeDetectorRef = changeDetectorRef;
    this.mode$ = mode$;
    this.noPadding = false;
    this.showArrow = true;
    this.borders = 'all';
    this.size = 'm';
    this.disabled = false;
    this.disableHover = false;
    this.open = false;
    this.async = false;
    this.openChange = new core_js_.EventEmitter();
  }
  get nativeFocusableElement() {
    return this.disabled || !this.focusableElement ? null : this.focusableElement.nativeElement;
  }
  get focused() {
    return (0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(this.nativeFocusableElement);
  }
  onHovered(hovered) {
    if (!this.disableHover) {
      this.updateHovered(hovered);
    }
  }
  onFocused(focused) {
    this.updateFocused(focused);
  }
  onFocusVisible(focusVisible) {
    this.updateFocusVisible(focusVisible);
  }
  onRowToggle() {
    if (!this.disabled) {
      this.updateOpen(!this.open);
    }
  }
  onItemKeyDownEsc(event) {
    if (!this.focused || !this.open) {
      return;
    }
    event.stopPropagation();
    this.updateOpen(false);
  }
  onItemKeyDownSpace(event) {
    if (!this.focused) {
      return;
    }
    event.preventDefault();
    this.onRowToggle();
  }
  close() {
    this.updateOpen(false);
    this.changeDetectorRef.markForCheck();
  }
  updateOpen(open) {
    if (this.open === open) {
      return;
    }
    this.open = open;
    this.openChange.emit(open);
  }
};
TuiAccordionItemComponent.ɵfac = function TuiAccordionItemComponent_Factory(t) {
  return new (t || TuiAccordionItemComponent)(core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_MODE */.Au));
};
TuiAccordionItemComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiAccordionItemComponent,
  selectors: [["tui-accordion-item"]],
  contentQueries: function TuiAccordionItemComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      core_js_["ɵɵcontentQuery"](dirIndex, TuiAccordionItemEagerContentDirective, 5);
      core_js_["ɵɵcontentQuery"](dirIndex, TuiAccordionItemContentDirective, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.eagerContent = _t.first);
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.lazyContent = _t.first);
    }
  },
  viewQuery: function TuiAccordionItemComponent_Query(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵviewQuery"](taiga_ui_kit_components_accordion_c0, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.focusableElement = _t.first);
    }
  },
  hostVars: 8,
  hostBindings: function TuiAccordionItemComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵlistener"]("$.data-mode.attr", function TuiAccordionItemComponent___data_mode_attr_HostBindingHandler() {
        return ctx.mode$;
      });
    }
    if (rf & 2) {
      core_js_["ɵɵattribute"]("data-tui-host-borders", ctx.borders)("data-size", ctx.size);
      core_js_["ɵɵclassProp"]("_no-padding", ctx.noPadding)("_has-arrow", ctx.showArrow)("_disabled", ctx.disabled);
    }
  },
  inputs: {
    noPadding: "noPadding",
    showArrow: "showArrow",
    borders: "borders",
    size: "size",
    disabled: "disabled",
    disableHover: "disableHover",
    open: "open",
    async: "async"
  },
  outputs: {
    openChange: "openChange"
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ,
    useExisting: (0,core_js_.forwardRef)(() => TuiAccordionItemComponent_1)
  }, taiga_ui_core_providers/* MODE_PROVIDER */.CV]), core_js_["ɵɵInheritDefinitionFeature"]],
  ngContentSelectors: taiga_ui_kit_components_accordion_c2,
  decls: 9,
  vars: 9,
  consts: [["automation-id", "tui-accordion__item-wrapper", 1, "t-wrapper", 3, "tuiFocusable", "tuiFocusVisibleChange", "tuiFocusedChange", "keydown.space", "keydown.enter", "keydown.esc"], ["focusableElement", ""], ["automation-id", "tui-accordion__item-header", 1, "t-header", 3, "tuiHoveredChange", "click"], ["automation-id", "tui-accordion__item-title", 1, "t-title"], ["automation-id", "tui-accordion__item-arrow", "src", "tuiIconChevronDownLarge", "class", "t-icon", 3, "t-icon_open", 4, "ngIf"], [3, "async", "expanded"], ["class", "t-content", 4, "ngIf"], ["tuiExpandContent", ""], ["automation-id", "tui-accordion__item-arrow", "src", "tuiIconChevronDownLarge", 1, "t-icon"], [1, "t-content"], ["polymorpheus-outlet", "", "automation-id", "tui-accordion__item-content", "class", "t-content", 3, "content", 4, "ngIf"], ["polymorpheus-outlet", "", "automation-id", "tui-accordion__item-content", 1, "t-content", 3, "content"]],
  template: function TuiAccordionItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"](taiga_ui_kit_components_accordion_c1);
      core_js_["ɵɵelementStart"](0, "div", 0, 1);
      core_js_["ɵɵlistener"]("tuiFocusVisibleChange", function TuiAccordionItemComponent_Template_div_tuiFocusVisibleChange_0_listener($event) {
        return ctx.onFocusVisible($event);
      })("tuiFocusedChange", function TuiAccordionItemComponent_Template_div_tuiFocusedChange_0_listener($event) {
        return ctx.onFocused($event);
      })("keydown.space", function TuiAccordionItemComponent_Template_div_keydown_space_0_listener($event) {
        return ctx.onItemKeyDownSpace($event);
      })("keydown.enter", function TuiAccordionItemComponent_Template_div_keydown_enter_0_listener($event) {
        return ctx.onItemKeyDownSpace($event);
      })("keydown.esc", function TuiAccordionItemComponent_Template_div_keydown_esc_0_listener($event) {
        return ctx.onItemKeyDownEsc($event);
      });
      core_js_["ɵɵelementStart"](2, "div", 2);
      core_js_["ɵɵlistener"]("tuiHoveredChange", function TuiAccordionItemComponent_Template_div_tuiHoveredChange_2_listener($event) {
        return ctx.onHovered($event);
      })("click", function TuiAccordionItemComponent_Template_div_click_2_listener() {
        return ctx.onRowToggle();
      });
      core_js_["ɵɵelementStart"](3, "div", 3);
      core_js_["ɵɵprojection"](4);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵtemplate"](5, TuiAccordionItemComponent_tui_svg_5_Template, 1, 2, "tui-svg", 4);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementStart"](6, "tui-expand", 5);
      core_js_["ɵɵtemplate"](7, TuiAccordionItemComponent_div_7_Template, 2, 0, "div", 6);
      core_js_["ɵɵtemplate"](8, TuiAccordionItemComponent_ng_template_8_Template, 1, 1, "ng-template", 7);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      core_js_["ɵɵproperty"]("tuiFocusable", ctx.computedFocusable);
      core_js_["ɵɵadvance"](2);
      core_js_["ɵɵclassProp"]("t-header_open", ctx.open)("t-header_hoverable", !ctx.disableHover);
      core_js_["ɵɵadvance"](3);
      core_js_["ɵɵproperty"]("ngIf", ctx.showArrow);
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵproperty"]("async", ctx.async)("expanded", ctx.open);
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵproperty"]("ngIf", ctx.eagerContent);
    }
  },
  directives: [TuiFocusableDirective, TuiFocusVisibleDirective, TuiFocusedDirective, TuiHoveredDirective, common_js_.NgIf, TuiExpandComponent, TuiExpandContentDirective, taiga_ui_core_components_svg/* TuiSvgComponent */.P, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1],
  styles: ["[_nghost-%COMP%]{position:relative;display:block;overflow:hidden;border-radius:var(--tui-radius-l)}[data-tui-host-borders=top-bottom][_nghost-%COMP%]{border-radius:0!important}.t-wrapper[_ngcontent-%COMP%]{position:relative;border-radius:inherit}.t-wrapper[_ngcontent-%COMP%]:focus{outline:0}.t-wrapper[_ngcontent-%COMP%]:after{position:absolute;top:0;left:0;width:100%;height:100%;content:'';box-sizing:border-box;border-radius:inherit;border:1px solid var(--tui-base-04);pointer-events:none}[_nghost-%COMP%]:not([data-tui-host-borders])   .t-wrapper[_ngcontent-%COMP%]:after{border-width:0}[data-tui-host-borders=all][_nghost-%COMP%]   .t-wrapper[_ngcontent-%COMP%]:after{border-width:1px}[data-tui-host-borders=top-bottom][_nghost-%COMP%]   .t-wrapper[_ngcontent-%COMP%]:after{border-left-width:0;border-right-width:0}[data-tui-host-borders=top][_nghost-%COMP%]   .t-wrapper[_ngcontent-%COMP%]:after{border-left-width:0;border-right-width:0;border-bottom-width:0}[data-tui-host-borders=bottom][_nghost-%COMP%]   .t-wrapper[_ngcontent-%COMP%]:after{border-left-width:0;border-right-width:0;border-top-width:0}[data-mode=onDark][_nghost-%COMP%]   .t-wrapper[_ngcontent-%COMP%]:after{border-color:var(--tui-base-03)}[data-mode=onLight][_nghost-%COMP%]   .t-wrapper[_ngcontent-%COMP%]:after{border-color:var(--tui-text-01)}._focus-visible[_nghost-%COMP%]   .t-wrapper[_ngcontent-%COMP%]:after{border:2px solid var(--tui-focus)}[_nghost-%COMP%]:not([data-mode])   .t-wrapper[_ngcontent-%COMP%]{background:var(--tui-base-01)}.t-header[_ngcontent-%COMP%]{transition-property:background;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;display:flex;font:var(--tui-font-text-l);align-items:center;box-sizing:border-box;border-bottom:1px solid var(--tui-base-04);min-height:var(--tui-height-l);padding:.75rem 1.25rem;color:var(--tui-text-01);cursor:pointer}[data-mode=onDark][_nghost-%COMP%]   .t-header[_ngcontent-%COMP%]{color:var(--tui-text-01-night);border-color:var(--tui-base-03)}[data-mode=onLight][_nghost-%COMP%]   .t-header[_ngcontent-%COMP%]{border-color:var(--tui-text-01)}[_nghost-%COMP%]:not([data-tui-host-borders])   .t-header[_ngcontent-%COMP%]{border-bottom-width:0;box-shadow:none}._has-arrow[_nghost-%COMP%]   .t-header[_ngcontent-%COMP%]{padding-right:.75rem}[data-mode=onDark][_nghost-%COMP%]   .t-header_open[_ngcontent-%COMP%]{background:var(--tui-clear-inverse)}[data-mode=onLight][_nghost-%COMP%]   .t-header_open[_ngcontent-%COMP%]{background:var(--tui-clear)}[data-size='s'][_nghost-%COMP%]   .t-header[_ngcontent-%COMP%]{font:var(--tui-font-text-m);min-height:var(--tui-height-m);padding:.625rem .75rem .625rem 1rem}._no-padding[_nghost-%COMP%]   .t-header[_ngcontent-%COMP%]{padding-left:0;padding-right:0}._disabled[_nghost-%COMP%]   .t-header[_ngcontent-%COMP%]{cursor:default}[_nghost-%COMP%]:hover:not([data-mode])   .t-header_hoverable[_ngcontent-%COMP%]{background:var(--tui-base-02)}[_nghost-%COMP%]:hover[data-mode=onDark]   .t-header_hoverable[_ngcontent-%COMP%]{background:var(--tui-clear-inverse)}[_nghost-%COMP%]:hover[data-mode=onLight]   .t-header_hoverable[_ngcontent-%COMP%]{background:var(--tui-clear)}.t-title[_ngcontent-%COMP%]{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;margin-right:0;flex-grow:1}._has-arrow[_nghost-%COMP%]   .t-title[_ngcontent-%COMP%]{margin-right:.5rem}.t-icon[_ngcontent-%COMP%]{transition-property:transform,color;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;width:1.5rem;height:1.5rem;margin-left:auto;color:var(--tui-base-06)}.t-icon_open[_ngcontent-%COMP%]{transform:rotate(180deg)}[data-mode][_nghost-%COMP%]   .t-icon[_ngcontent-%COMP%]{opacity:var(--tui-disabled-opacity)}[_nghost-%COMP%]:hover[data-mode]   .t-icon[_ngcontent-%COMP%]{opacity:.8}[data-mode=onDark][_nghost-%COMP%]   .t-icon[_ngcontent-%COMP%]{color:var(--tui-text-01-night)}[data-mode=onLight][_nghost-%COMP%]   .t-icon[_ngcontent-%COMP%]{color:var(--tui-text-01)}[_nghost-%COMP%]:hover:not([data-mode])   .t-icon[_ngcontent-%COMP%]{color:var(--tui-base-07)}.t-content[_ngcontent-%COMP%]{font:var(--tui-font-text-m);padding:1.25rem;word-wrap:break-word}[data-size='s'][_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{font:var(--tui-font-text-s);padding:1rem}"],
  changeDetection: 0
});
TuiAccordionItemComponent.ctorParameters = () => [{
  type: core_js_.ChangeDetectorRef,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.ChangeDetectorRef]
  }]
}, {
  type: internal_Observable/* Observable */.y,
  decorators: [{
    type: core_js_.Inject,
    args: [taiga_ui_core_tokens/* TUI_MODE */.Au]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('focusableElement')], TuiAccordionItemComponent.prototype, "focusableElement", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._no-padding'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiAccordionItemComponent.prototype, "noPadding", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._has-arrow'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiAccordionItemComponent.prototype, "showArrow", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-tui-host-borders'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiAccordionItemComponent.prototype, "borders", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-size'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiAccordionItemComponent.prototype, "size", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._disabled'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiAccordionItemComponent.prototype, "disabled", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiAccordionItemComponent.prototype, "disableHover", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiAccordionItemComponent.prototype, "open", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiAccordionItemComponent.prototype, "async", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiAccordionItemComponent.prototype, "openChange", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChild)(TuiAccordionItemEagerContentDirective)], TuiAccordionItemComponent.prototype, "eagerContent", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChild)(TuiAccordionItemContentDirective)], TuiAccordionItemComponent.prototype, "lazyContent", void 0);
TuiAccordionItemComponent = TuiAccordionItemComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_MODE */.Au))], TuiAccordionItemComponent);
let TuiAccordionComponent = /*#__PURE__*/(() => {
  let TuiAccordionComponent = class TuiAccordionComponent {
    constructor(destroy$) {
      this.destroy$ = destroy$;
      this.closeOthers = true;
      this.rounded = true;
      this.accordionItems = taiga_ui_cdk_constants/* EMPTY_QUERY */.Mm;
    }
    ngAfterContentInit() {
      const {
        accordionItems
      } = this;
      const rows$ = (0,taiga_ui_cdk_observables/* itemsQueryListObservable */.Fp)(accordionItems);
      const newOpenRow$ = rows$.pipe((0,pairwise/* pairwise */.G)(), (0,operators_map/* map */.U)(([previous, current]) => current.find(item => !previous.includes(item) && item.open)), (0,operators_filter/* filter */.h)(taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN));
      const rowsOpen$ = (0,observable_merge/* merge */.T)(rows$.pipe((0,operators_switchMap/* switchMap */.w)(rows => (0,observable_merge/* merge */.T)(...rows.map(row => row.openChange.pipe((0,operators_filter/* filter */.h)(util_identity/* identity */.y), (0,operators_mapTo/* mapTo */.h)(row)))))), newOpenRow$).pipe((0,operators_filter/* filter */.h)(() => this.closeOthers), (0,operators_takeUntil/* takeUntil */.R)(this.destroy$));
      rowsOpen$.subscribe(currentRow => {
        accordionItems.forEach(row => {
          if (currentRow !== row) {
            row.close();
          }
        });
      });
    }
  };
  TuiAccordionComponent.ɵfac = function TuiAccordionComponent_Factory(t) {
    return new (t || TuiAccordionComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3));
  };
  TuiAccordionComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiAccordionComponent,
    selectors: [["tui-accordion"]],
    contentQueries: function TuiAccordionComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        core_js_["ɵɵcontentQuery"](dirIndex, TuiAccordionItemComponent, 4);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.accordionItems = _t);
      }
    },
    inputs: {
      closeOthers: "closeOthers",
      rounded: "rounded"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])],
    ngContentSelectors: taiga_ui_kit_components_accordion_c4,
    decls: 2,
    vars: 2,
    consts: [["tuiGroup", "", "automation-id", "tui-accordion__group", "orientation", "vertical", "size", "l", 1, "t-group", 3, "collapsed", "rounded"]],
    template: function TuiAccordionComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"](taiga_ui_kit_components_accordion_c3);
        core_js_["ɵɵelementStart"](0, "div", 0);
        core_js_["ɵɵprojection"](1);
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("collapsed", true)("rounded", ctx.rounded);
      }
    },
    directives: [TuiGroupDirective],
    styles: ["[_nghost-%COMP%]{display:block}.t-group[_ngcontent-%COMP%]{display:flex}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiAccordionComponent.prototype, "closeOthers", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiAccordionComponent.prototype, "rounded", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChildren)(TuiAccordionItemComponent)], TuiAccordionComponent.prototype, "accordionItems", void 0);
  TuiAccordionComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3))], TuiAccordionComponent);
  return TuiAccordionComponent;
})();
let TuiAccordionModule = /*#__PURE__*/(() => {
  let TuiAccordionModule = class TuiAccordionModule {};
  TuiAccordionModule.ɵfac = function TuiAccordionModule_Factory(t) {
    return new (t || TuiAccordionModule)();
  };
  TuiAccordionModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiAccordionModule
  });
  TuiAccordionModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, TuiFocusedModule, TuiFocusVisibleModule, TuiFocusableModule, TuiHoveredModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiGroupModule, TuiExpandModule]]
  });
  return TuiAccordionModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiAccordionModule, {
    declarations: function () {
      return [TuiAccordionComponent, TuiAccordionItemComponent, TuiAccordionItemContentDirective, TuiAccordionItemEagerContentDirective];
    },
    imports: function () {
      return [common_js_.CommonModule, TuiFocusedModule, TuiFocusVisibleModule, TuiFocusableModule, TuiHoveredModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiGroupModule, TuiExpandModule];
    },
    exports: function () {
      return [TuiAccordionComponent, TuiAccordionItemComponent, TuiAccordionItemContentDirective, TuiAccordionItemEagerContentDirective];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-accordion.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-prevent-default.js







/**
 * Simple prevent default on event directive when you do not need anything
 * else on event and do not want to trigger change detection
 * @dynamic
 */


let TuiPreventDefaultDirective = /*#__PURE__*/(() => {
  let TuiPreventDefaultDirective = class TuiPreventDefaultDirective {
    constructor({
      nativeElement
    }, ngZone, destroy$, eventName) {
      (0,fromEvent/* fromEvent */.R)(nativeElement, eventName, {
        passive: false
      }).pipe((0,taiga_ui_cdk_observables/* tuiZonefree */.fL)(ngZone), (0,taiga_ui_cdk_observables/* preventDefault */.PF)(), (0,operators_takeUntil/* takeUntil */.R)(destroy$)).subscribe();
    }
  };
  TuiPreventDefaultDirective.ɵfac = function TuiPreventDefaultDirective_Factory(t) {
    return new (t || TuiPreventDefaultDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.NgZone), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3), core_js_["ɵɵinjectAttribute"]('tuiPreventDefault'));
  };
  TuiPreventDefaultDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiPreventDefaultDirective,
    selectors: [["", "tuiPreventDefault", ""]],
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])]
  });
  TuiPreventDefaultDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.NgZone)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Attribute)('tuiPreventDefault'))], TuiPreventDefaultDirective);
  return TuiPreventDefaultDirective;
})();
let TuiPreventDefaultModule = /*#__PURE__*/(() => {
  let TuiPreventDefaultModule = class TuiPreventDefaultModule {};
  TuiPreventDefaultModule.ɵfac = function TuiPreventDefaultModule_Factory(t) {
    return new (t || TuiPreventDefaultModule)();
  };
  TuiPreventDefaultModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiPreventDefaultModule
  });
  TuiPreventDefaultModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiPreventDefaultModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiPreventDefaultModule, {
    declarations: [TuiPreventDefaultDirective],
    exports: [TuiPreventDefaultDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-prevent-default.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-utils-format.js
/**
 * @deprecated: use {@link tuiStringHashToHsl} instead
 * Converts a string to an HSL color
 * @param value string to convert
 * @return HSL color string
 */
// @bad TODO: convert stringHashToHsl to stringHashToRgb
// eslint-disable-next-line @typescript-eslint/naming-convention
function stringHashToHsl(value) {
  if (value === ``) {
    return ``;
  }
  let hash = 0;
  for (let i = 0; i < value.length; i++) {
    hash = value.charCodeAt(i) + ((hash << 5) - hash);
    hash &= hash;
  }
  const hue = hash % 360;
  const saturation = 60 + hash % 5;
  const lightness = 80 + hash % 5;
  return `hsl(${hue},${saturation}%,${lightness}%)`;
}
const tuiStringHashToHsl = (/* unused pure expression or super */ null && (stringHashToHsl));

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-utils-format.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-components-tag.js










/** Default values for the tag options. */







const taiga_ui_kit_components_tag_c0 = ["input"];
function TuiTagComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "div", 6);
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("content", ctx_r0.leftContent);
  }
}
function TuiTagComponent_tui_loader_4_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-loader", 7);
  }
  if (rf & 2) {
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("inheritColor", true)("size", ctx_r1.loaderSize);
  }
}
function TuiTagComponent_tui_svg_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "tui-svg", 8);
    core_js_["ɵɵlistener"]("click", function TuiTagComponent_tui_svg_5_Template_tui_svg_click_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r5);
      const ctx_r4 = core_js_["ɵɵnextContext"]();
      return ctx_r4.remove($event);
    });
    core_js_["ɵɵelementEnd"]();
  }
}
function TuiTagComponent_input_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "input", 9, 10);
    core_js_["ɵɵlistener"]("ngModelChange", function TuiTagComponent_input_6_Template_input_ngModelChange_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r8);
      const ctx_r7 = core_js_["ɵɵnextContext"]();
      return ctx_r7.onInput($event);
    })("blur", function TuiTagComponent_input_6_Template_input_blur_0_listener() {
      core_js_["ɵɵrestoreView"](_r8);
      const ctx_r9 = core_js_["ɵɵnextContext"]();
      return ctx_r9.onBlur();
    })("keydown", function TuiTagComponent_input_6_Template_input_keydown_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r8);
      const ctx_r10 = core_js_["ɵɵnextContext"]();
      return ctx_r10.onKeyDown($event);
    });
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r3 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("ngModel", ctx_r3.editedText);
    core_js_["ɵɵattribute"]("maxLength", ctx_r3.maxLength);
  }
}
const TUI_TAG_DEFAULT_OPTIONS = {
  size: `m`,
  status: `default`,
  autoColor: false
};
const TUI_TAG_OPTIONS = new core_js_.InjectionToken(`Default parameters for tag component`, {
  factory: () => TUI_TAG_DEFAULT_OPTIONS
});
const tuiTagOptionsProvider = options => ({
  provide: TUI_TAG_OPTIONS,
  useValue: Object.assign(Object.assign({}, TUI_TAG_DEFAULT_OPTIONS), options)
});
const ALLOWED_SPACE_REGEXP = new RegExp(',|[\\s]');
let TuiTagComponent = /*#__PURE__*/(() => {
  let TuiTagComponent = class TuiTagComponent {
    constructor(elementRef, mode$, options) {
      this.elementRef = elementRef;
      this.mode$ = mode$;
      this.options = options;
      // TODO: Possibly implement standard focus mechanisms and outline
      this.value = '';
      this.editable = false;
      // TODO: 3.0: Remove
      this.allowSpaces = true;
      this.separator = ',';
      this.maxLength = null;
      this.size = this.options.size;
      this.showLoader = false;
      this.status = this.options.status;
      this.hoverable = false;
      this.removable = false;
      this.disabled = false;
      this.autoColor = this.options.autoColor;
      // TODO: 3.0 Remove null
      this.leftContent = null;
      this.edited = new core_js_.EventEmitter();
      this.editing = false;
      this.editedText = null;
    }
    set input(input) {
      if (input) {
        (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(input.nativeElement);
      }
    }
    get backgroundColor() {
      return this.autoColor ? stringHashToHsl(this.value) : null;
    }
    get canRemove() {
      return this.removable && !this.disabled && !this.showLoader;
    }
    get displayText() {
      return this.editedText === null ? this.value : this.editedText;
    }
    get loaderSize() {
      return (0,taiga_ui_core_utils_miscellaneous/* sizeBigger */.Bb)(this.size) ? 's' : 'xs';
    }
    get hasIcon() {
      return this.showLoader || this.removable;
    }
    edit(event) {
      if (!this.canEdit) {
        return;
      }
      event.preventDefault();
      this.editing = true;
      this.editedText = this.value;
    }
    remove(event) {
      if (!this.canRemove) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      this.edited.emit('');
    }
    onInput(value) {
      const newTags = this.allowSpaces ? value.split(this.separator) : value.split(ALLOWED_SPACE_REGEXP);
      if (newTags.length > 1) {
        this.save(String(newTags));
        return;
      }
      this.editedText = value;
    }
    onKeyDown(event) {
      event.stopPropagation();
      switch (event.key.toLowerCase()) {
        case 'enter':
          event.preventDefault();
          this.save(this.editedText || '');
          break;
        case 'escape':
        case 'esc':
          event.preventDefault();
          this.stopEditing();
          (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(this.elementRef.nativeElement);
          break;
        default:
          break;
      }
    }
    onBlur() {
      if (this.editedText !== null) {
        this.save(this.editedText);
      }
    }
    get canEdit() {
      return this.editable && !this.disabled && !this.showLoader;
    }
    stopEditing() {
      this.editing = false;
      this.editedText = null;
    }
    save(value) {
      this.stopEditing();
      this.edited.emit(value.trim());
    }
  };
  TuiTagComponent.ɵfac = function TuiTagComponent_Factory(t) {
    return new (t || TuiTagComponent)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_MODE */.Au), core_js_["ɵɵdirectiveInject"](TUI_TAG_OPTIONS));
  };
  TuiTagComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiTagComponent,
    selectors: [["tui-tag"], ["a", "tuiTag", ""]],
    viewQuery: function TuiTagComponent_Query(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵviewQuery"](taiga_ui_kit_components_tag_c0, 5, core_js_.ElementRef);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.input = _t.first);
      }
    },
    hostVars: 12,
    hostBindings: function TuiTagComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("$.data-mode.attr", function TuiTagComponent___data_mode_attr_HostBindingHandler() {
          return ctx.mode$;
        })("keydown.enter", function TuiTagComponent_keydown_enter_HostBindingHandler($event) {
          return ctx.edit($event);
        })("keydown.delete", function TuiTagComponent_keydown_delete_HostBindingHandler($event) {
          return ctx.remove($event);
        })("keydown.backspace", function TuiTagComponent_keydown_backspace_HostBindingHandler($event) {
          return ctx.remove($event);
        });
      }
      if (rf & 2) {
        core_js_["ɵɵattribute"]("data-size", ctx.size)("data-tui-host-status", ctx.status);
        core_js_["ɵɵclassProp"]("_hoverable", ctx.hoverable)("_disabled", ctx.disabled)("_autocolor", ctx.autoColor)("_editing", ctx.editing)("_has-icon", ctx.hasIcon);
      }
    },
    inputs: {
      value: "value",
      editable: "editable",
      allowSpaces: "allowSpaces",
      separator: "separator",
      maxLength: "maxLength",
      size: "size",
      showLoader: "showLoader",
      status: "status",
      hoverable: "hoverable",
      removable: "removable",
      disabled: "disabled",
      autoColor: "autoColor",
      leftContent: "leftContent"
    },
    outputs: {
      edited: "edited"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_core_providers/* MODE_PROVIDER */.CV])],
    decls: 7,
    vars: 7,
    consts: [[1, "t-tag", 3, "dblclick"], ["polymorpheus-outlet", "", "class", "t-left-content", 3, "content", 4, "ngIf"], ["automation-id", "tui-tag__text", 1, "t-text"], ["class", "t-icon t-icon_loader", 3, "inheritColor", "size", 4, "ngIf"], ["tuiPreventDefault", "mousedown", "automation-id", "tui-tag__remove", "src", "tuiIconCloseLarge", "class", "t-icon", 3, "click", 4, "ngIf"], ["automation-id", "tui-tag__edit", "type", "text", "class", "t-edit", 3, "ngModel", "ngModelChange", "blur", "keydown", 4, "ngIf"], ["polymorpheus-outlet", "", 1, "t-left-content", 3, "content"], [1, "t-icon", "t-icon_loader", 3, "inheritColor", "size"], ["tuiPreventDefault", "mousedown", "automation-id", "tui-tag__remove", "src", "tuiIconCloseLarge", 1, "t-icon", 3, "click"], ["automation-id", "tui-tag__edit", "type", "text", 1, "t-edit", 3, "ngModel", "ngModelChange", "blur", "keydown"], ["input", ""]],
    template: function TuiTagComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵelementStart"](0, "div", 0);
        core_js_["ɵɵlistener"]("dblclick", function TuiTagComponent_Template_div_dblclick_0_listener($event) {
          return ctx.edit($event);
        });
        core_js_["ɵɵtemplate"](1, TuiTagComponent_div_1_Template, 1, 1, "div", 1);
        core_js_["ɵɵelementStart"](2, "span", 2);
        core_js_["ɵɵtext"](3);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](4, TuiTagComponent_tui_loader_4_Template, 1, 2, "tui-loader", 3);
        core_js_["ɵɵtemplate"](5, TuiTagComponent_tui_svg_5_Template, 1, 0, "tui-svg", 4);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](6, TuiTagComponent_input_6_Template, 2, 2, "input", 5);
      }
      if (rf & 2) {
        core_js_["ɵɵstyleProp"]("background-color", ctx.backgroundColor);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.leftContent);
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵtextInterpolate1"](" ", ctx.displayText, " ");
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.showLoader);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.canRemove);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.editing);
      }
    },
    directives: [common_js_.NgIf, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, taiga_ui_core_components_loader/* TuiLoaderComponent */.kM, taiga_ui_core_components_svg/* TuiSvgComponent */.P, TuiPreventDefaultDirective, fesm2015_forms.DefaultValueAccessor, fesm2015_forms.NgControlStatus, fesm2015_forms.NgModel],
    styles: ["[_nghost-%COMP%]{transition-property:background;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;position:relative;display:inline-block;font:var(--tui-font-text-s);border-radius:var(--tui-radius-s);max-width:100%;cursor:default;outline:0;text-decoration:none}[_nghost-%COMP%]:after{transition-property:background;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;position:absolute;top:0;left:0;width:100%;height:100%;content:'';box-sizing:border-box;border-radius:inherit;pointer-events:none}._hoverable[_nghost-%COMP%]:active[data-tui-host-status=custom]:after, ._hoverable[_nghost-%COMP%]:hover[data-tui-host-status=custom]:after{background-color:var(--tui-clear)}[_nghost-%COMP%]:focus:after{border:2px solid var(--tui-focus)}[data-tui-host-status=primary][_nghost-%COMP%]{background-color:var(--tui-primary);color:var(--tui-primary-text)}[data-tui-host-status=primary]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-primary-hover)}[data-tui-host-status=primary]._hoverable[_nghost-%COMP%]:active{background-color:var(--tui-primary-active)}[data-tui-host-status=error][_nghost-%COMP%]{background-color:var(--tui-error-bg);color:var(--tui-text-01)}[data-tui-host-status=error]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=error]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-error-bg-hover)}[data-tui-host-status=error][data-mode=onDark][_nghost-%COMP%]{background-color:var(--tui-error-bg-night);color:var(--tui-text-01-night)}[data-tui-host-status=error][data-mode=onDark]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=error][data-mode=onDark]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-error-bg-night-hover)}[data-tui-host-status=success][_nghost-%COMP%]{background-color:var(--tui-success-bg);color:var(--tui-text-01)}[data-tui-host-status=success]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=success]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-success-bg-hover)}[data-tui-host-status=success][data-mode=onDark][_nghost-%COMP%]{background-color:var(--tui-success-bg-night);color:var(--tui-text-01-night)}[data-tui-host-status=success][data-mode=onDark]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=success][data-mode=onDark]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-success-bg-night-hover)}[data-tui-host-status=warning][_nghost-%COMP%]{background-color:var(--tui-warning-bg);color:var(--tui-text-01)}[data-tui-host-status=warning]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=warning]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-warning-bg-hover)}[data-tui-host-status=warning][data-mode=onDark][_nghost-%COMP%]{background-color:var(--tui-warning-bg-night);color:var(--tui-text-01-night)}[data-tui-host-status=warning][data-mode=onDark]._hoverable[_nghost-%COMP%]:active, [data-tui-host-status=warning][data-mode=onDark]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-warning-bg-night-hover)}[data-tui-host-status=default][_nghost-%COMP%]{color:var(--tui-text-01-night);background-color:var(--tui-base-06)}[data-tui-host-status=default][_nghost-%COMP%]:not([data-mode])._hoverable:hover{background-color:var(--tui-base-07)}[data-tui-host-status=default][_nghost-%COMP%]:not([data-mode])._hoverable:active{background-color:var(--tui-base-08)}[data-tui-host-status=default][data-mode=onDark][_nghost-%COMP%]{color:var(--tui-text-01-night);background-color:var(--tui-clear-inverse)}[data-tui-host-status=default][data-mode=onDark]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-clear-inverse-hover)}[data-tui-host-status=default][data-mode=onDark]._hoverable[_nghost-%COMP%]:active{background-color:var(--tui-clear-inverse-active)}[data-tui-host-status=default][data-mode=onDark][_nghost-%COMP%]:focus:after{border:2px solid var(--tui-base-01)}[data-tui-host-status=default][data-mode=onLight][_nghost-%COMP%]{background-color:var(--tui-clear);color:var(--tui-text-01)}[data-tui-host-status=default][data-mode=onLight]._hoverable[_nghost-%COMP%]:hover{background-color:var(--tui-clear-hover)}[data-tui-host-status=default][data-mode=onLight]._hoverable[_nghost-%COMP%]:active{background-color:var(--tui-clear-active)}._editing[_nghost-%COMP%]{background:0 0!important}._disabled[_nghost-%COMP%]{pointer-events:none;opacity:var(--tui-disabled-opacity)}._hoverable[_nghost-%COMP%]{cursor:pointer}._autocolor[_nghost-%COMP%]{color:var(--tui-text-01)}.t-text[_ngcontent-%COMP%]{white-space:pre;overflow:hidden;text-overflow:ellipsis;padding-right:.02em}.t-tag[_ngcontent-%COMP%]{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;position:relative;display:flex;width:auto;align-items:center;border-radius:inherit}[data-size='s'][_nghost-%COMP%]   .t-tag[_ngcontent-%COMP%]{font:var(--tui-font-text-xs);height:1.25rem;padding:0 .5rem}[data-size='m'][_nghost-%COMP%]   .t-tag[_ngcontent-%COMP%]{height:var(--tui-height-xs);padding:0 .5rem}[data-size='l'][_nghost-%COMP%]   .t-tag[_ngcontent-%COMP%]{height:var(--tui-height-s);padding:0 .75rem}._has-icon[data-size='s'][_nghost-%COMP%]   .t-tag[_ngcontent-%COMP%]{padding:0 .125rem 0 .75rem;-webkit-padding-start:.75rem;padding-inline-start:.75rem;-webkit-padding-end:.125rem;padding-inline-end:.125rem}._has-icon[data-size='m'][_nghost-%COMP%]   .t-tag[_ngcontent-%COMP%]{padding:0 0 0 .75rem;-webkit-padding-start:.75rem;padding-inline-start:.75rem;-webkit-padding-end:0;padding-inline-end:0}._has-icon[data-size='l'][_nghost-%COMP%]   .t-tag[_ngcontent-%COMP%]{padding:0 .25rem 0 .75rem;-webkit-padding-start:.75rem;padding-inline-start:.75rem;-webkit-padding-end:.25rem;padding-inline-end:.25rem}._editing[_nghost-%COMP%]   .t-tag[_ngcontent-%COMP%]{visibility:hidden}._disabled._has-icon[data-size='m'][_nghost-%COMP%]   .t-tag[_ngcontent-%COMP%], ._disabled._has-icon[data-size='s'][_nghost-%COMP%]   .t-tag[_ngcontent-%COMP%]{padding:0 .5rem 0 .75rem;-webkit-padding-start:.75rem;padding-inline-start:.75rem;-webkit-padding-end:.5rem;padding-inline-end:.5rem}._disabled._has-icon[data-size='l'][_nghost-%COMP%]   .t-tag[_ngcontent-%COMP%]{padding:0 .75rem}.t-edit[_ngcontent-%COMP%]{padding:0 0 0 .5rem;margin:0;border:0;border-radius:inherit;background:0 0;font-size:inherit;line-height:inherit;font-weight:inherit;color:inherit;caret-color:currentColor;outline:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;word-break:keep-all;-webkit-text-fill-color:currentColor;position:absolute;top:0;left:0;font:var(--tui-font-text-s);color:var(--tui-text-01);width:100%;box-sizing:border-box;-webkit-padding-start:.5rem;padding-inline-start:.5rem;-webkit-padding-end:0;padding-inline-end:0}.t-edit[_ngcontent-%COMP%]:-webkit-autofill, .t-edit[_ngcontent-%COMP%]:-webkit-autofill:focus, .t-edit[_ngcontent-%COMP%]:-webkit-autofill:hover{caret-color:var(--tui-base-09);border-radius:inherit;color:inherit!important;background-color:transparent!important;-webkit-text-fill-color:var(--tui-text-01)!important;border-color:var(--tui-autofill);-webkit-box-shadow:0 0 0 100rem var(--tui-autofill) inset!important}[data-size='s'][_nghost-%COMP%]   .t-edit[_ngcontent-%COMP%]{height:1.25rem;line-height:1.25rem}[data-size='m'][_nghost-%COMP%]   .t-edit[_ngcontent-%COMP%]{height:var(--tui-height-xs);line-height:var(--tui-height-xs)}[data-size='l'][_nghost-%COMP%]   .t-edit[_ngcontent-%COMP%]{height:var(--tui-height-s);line-height:var(--tui-height-s);padding:0 0 0 .75rem;-webkit-padding-start:.75rem;padding-inline-start:.75rem;-webkit-padding-end:0;padding-inline-end:0}.t-icon[_ngcontent-%COMP%]{margin:0 0 0 .25rem;-webkit-margin-start:.25rem;margin-inline-start:.25rem;-webkit-margin-end:0;margin-inline-end:0;height:100%}.t-icon[_ngcontent-%COMP%]:not(.t-icon_loader){cursor:pointer;pointer-events:all;opacity:var(--tui-disabled-opacity)}.t-icon[_ngcontent-%COMP%]:hover{opacity:1}.t-icon_loader[_ngcontent-%COMP%]{width:1rem;height:1rem;margin:0 .25rem}[data-size='s'][_nghost-%COMP%]   .t-icon_loader[_ngcontent-%COMP%]{margin:0 .375rem 0 .75rem;-webkit-margin-start:.75rem;margin-inline-start:.75rem;-webkit-margin-end:.375rem;margin-inline-end:.375rem;width:.5rem;height:.5rem}[data-size='l'][_nghost-%COMP%]   .t-icon_loader[_ngcontent-%COMP%]{margin:0 .25rem 0 .5rem;-webkit-margin-start:.5rem;margin-inline-start:.5rem;-webkit-margin-end:.25rem;margin-inline-end:.25rem}.t-left-content[_ngcontent-%COMP%]{margin:0 .25rem 0 0;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:.25rem;margin-inline-end:.25rem;width:1rem;height:1rem}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "value", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "editable", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "allowSpaces", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "separator", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "maxLength", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-size'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "size", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "showLoader", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('attr.data-tui-host-status'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "status", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._hoverable'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "hoverable", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "removable", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._disabled'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "disabled", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,core_js_.HostBinding)('class._autocolor'), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "autoColor", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiTagComponent.prototype, "leftContent", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiTagComponent.prototype, "edited", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._editing')], TuiTagComponent.prototype, "editing", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('input', {
    read: core_js_.ElementRef
  })], TuiTagComponent.prototype, "input", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._has-icon')], TuiTagComponent.prototype, "hasIcon", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('keydown.enter', ['$event'])], TuiTagComponent.prototype, "edit", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('keydown.delete', ['$event']), (0,core_js_.HostListener)('keydown.backspace', ['$event'])], TuiTagComponent.prototype, "remove", null);
  TuiTagComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_MODE */.Au)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(TUI_TAG_OPTIONS))], TuiTagComponent);
  return TuiTagComponent;
})();
let TuiTagModule = /*#__PURE__*/(() => {
  let TuiTagModule = class TuiTagModule {};
  TuiTagModule.ɵfac = function TuiTagModule_Factory(t) {
    return new (t || TuiTagModule)();
  };
  TuiTagModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiTagModule
  });
  TuiTagModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, fesm2015_forms.FormsModule, TuiPreventDefaultModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, taiga_ui_core_components_loader/* TuiLoaderModule */.dS, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq]]
  });
  return TuiTagModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiTagModule, {
    declarations: function () {
      return [TuiTagComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, fesm2015_forms.FormsModule, TuiPreventDefaultModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, taiga_ui_core_components_loader/* TuiLoaderModule */.dS, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq];
    },
    exports: function () {
      return [TuiTagComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-kit-components-tag.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-link.js
var taiga_ui_core_components_link = __webpack_require__(2847);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-notification.js
var taiga_ui_core_components_notification = __webpack_require__(885);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/repeatWhen.js
var repeatWhen = __webpack_require__(2361);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-alert.js












// TODO: 3.0 Refactor according to new context by 3.0 and get rid of $any in template





function TuiAlertComponent_tui_notification_0_label_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "label", 5);
  }
  if (rf & 2) {
    const ctx_r3 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵproperty"]("content", ctx_r3.item.label)("context", ctx_r3.context);
  }
}
function TuiAlertComponent_tui_notification_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "tui-notification", 2);
    core_js_["ɵɵlistener"]("close", function TuiAlertComponent_tui_notification_0_Template_tui_notification_close_0_listener() {
      core_js_["ɵɵrestoreView"](_r5);
      const ctx_r4 = core_js_["ɵɵnextContext"]();
      return ctx_r4.closeNotification();
    });
    core_js_["ɵɵtemplate"](1, TuiAlertComponent_tui_notification_0_label_1_Template, 1, 2, "label", 3);
    core_js_["ɵɵelement"](2, "div", 4);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("status", ctx_r0.item.status)("hasIcon", ctx_r0.item.hasIcon);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", ctx_r0.item.label);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("content", ctx_r0.item.content)("context", ctx_r0.context);
  }
}
function TuiAlertComponent_ng_template_1_label_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "label", 5);
  }
  if (rf & 2) {
    const ctx_r6 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵproperty"]("content", ctx_r6.item.label)("context", ctx_r6.context);
  }
}
function TuiAlertComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "tui-notification", 6);
    core_js_["ɵɵtemplate"](1, TuiAlertComponent_ng_template_1_label_1_Template, 1, 2, "label", 3);
    core_js_["ɵɵelement"](2, "div", 4);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("status", ctx_r2.item.status)("hasIcon", ctx_r2.item.hasIcon);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", ctx_r2.item.label);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("content", ctx_r2.item.content)("context", ctx_r2.context);
  }
}
let TuiAlertComponent = /*#__PURE__*/(() => {
  let TuiAlertComponent = class TuiAlertComponent {
    constructor(elementRef, destroy$, options, animationOptions, item) {
      this.elementRef = elementRef;
      this.destroy$ = destroy$;
      this.options = options;
      this.animationOptions = animationOptions;
      this.item = item;
      this.autoClose = typeof this.item.autoClose === 'function' ? this.item.autoClose(this.item.status) : this.item.autoClose;
      this.animation = Object.assign({
        value: ''
      }, this.animationOptions);
    }
    ngOnInit() {
      this.initAutoClose();
    }
    get context() {
      return this.calculateContext(this.item);
    }
    closeNotification() {
      this.item.$implicit.complete();
    }
    calculateContext({
      $implicit,
      status,
      data,
      label
    }) {
      return {
        $implicit: status,
        data,
        label,
        closeHook: () => {
          $implicit.complete();
        },
        emitHook: data => {
          $implicit.next(data);
        },
        emitAndCloseHook: data => {
          $implicit.next(data);
          $implicit.complete();
        }
      };
    }
    initAutoClose() {
      if (!this.autoClose) {
        return;
      }
      (0,observable_timer/* timer */.H)((0,taiga_ui_cdk_utils_miscellaneous/* isNumber */.hj)(this.autoClose) ? this.autoClose : this.options.defaultAutoCloseTime).pipe((0,operators_takeUntil/* takeUntil */.R)((0,fromEvent/* fromEvent */.R)(this.elementRef.nativeElement, 'mouseenter')),
      // eslint-disable-next-line rxjs/no-ignored-notifier
      (0,repeatWhen/* repeatWhen */.a)(() => (0,fromEvent/* fromEvent */.R)(this.elementRef.nativeElement, 'mouseleave')), (0,operators_takeUntil/* takeUntil */.R)(this.destroy$)).subscribe(() => this.closeNotification());
    }
  };
  TuiAlertComponent.ɵfac = function TuiAlertComponent_Factory(t) {
    return new (t || TuiAlertComponent)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_NOTIFICATION_OPTIONS */.Ln), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw), core_js_["ɵɵdirectiveInject"](tinkoff_ng_polymorpheus/* POLYMORPHEUS_CONTEXT */.yf));
  };
  TuiAlertComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiAlertComponent,
    selectors: [["tui-alert"]],
    hostAttrs: ["role", "alert"],
    hostVars: 3,
    hostBindings: function TuiAlertComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵsyntheticHostProperty"]("@tuiFadeIn", ctx.animation)("@tuiSlideInRight", ctx.animation)("@tuiHeightCollapse", ctx.animation);
      }
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])],
    decls: 3,
    vars: 2,
    consts: [[3, "status", "hasIcon", "close", 4, "ngIf", "ngIfElse"], ["noClose", ""], [3, "status", "hasIcon", "close"], ["polymorpheus-outlet", "", "automation-id", "tui-notification-alert__heading", "class", "t-heading", 3, "content", "context", 4, "ngIf"], ["polymorpheus-outlet", "", "automation-id", "tui-notification-alert__content", 1, "t-content", 3, "content", "context"], ["polymorpheus-outlet", "", "automation-id", "tui-notification-alert__heading", 1, "t-heading", 3, "content", "context"], [3, "status", "hasIcon"]],
    template: function TuiAlertComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵtemplate"](0, TuiAlertComponent_tui_notification_0_Template, 3, 5, "tui-notification", 0);
        core_js_["ɵɵtemplate"](1, TuiAlertComponent_ng_template_1_Template, 3, 5, "ng-template", null, 1, core_js_["ɵɵtemplateRefExtractor"]);
      }
      if (rf & 2) {
        const _r1 = core_js_["ɵɵreference"](2);
        core_js_["ɵɵproperty"]("ngIf", ctx.item.hasCloseButton)("ngIfElse", _r1);
      }
    },
    directives: [common_js_.NgIf, taiga_ui_core_components_notification/* TuiNotificationComponent */.Ls, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1],
    styles: ["[_nghost-%COMP%]{box-shadow:0 .5rem 1rem rgba(0,0,0,.16);display:block;border-radius:var(--tui-radius-m);width:18rem;margin:2rem 3rem 0 auto}tui-root._mobile   [_nghost-%COMP%]{margin:1rem 1rem 0 auto}[_nghost-%COMP%]:not(:first-child){margin-top:.75rem}.t-heading[_ngcontent-%COMP%]{font:var(--tui-font-text-m);line-height:1.25rem;font-weight:700;margin:0}.t-content[_ngcontent-%COMP%]{color:var(--tui-text-01);word-wrap:break-word}.t-content[_ngcontent-%COMP%]:empty{display:none}"],
    data: {
      animation: [tuiFadeIn, tuiSlideInRight, tuiHeightCollapse]
    },
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('@tuiFadeIn'), (0,core_js_.HostBinding)('@tuiSlideInRight'), (0,core_js_.HostBinding)('@tuiHeightCollapse')], TuiAlertComponent.prototype, "animation", void 0);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiAlertComponent.prototype, "calculateContext", null);
  TuiAlertComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_NOTIFICATION_OPTIONS */.Ln)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(tinkoff_ng_polymorpheus/* POLYMORPHEUS_CONTEXT */.yf))], TuiAlertComponent);
  return TuiAlertComponent;
})();
let TuiAlertService = /*#__PURE__*/(() => {
  let TuiAlertService = class TuiAlertService extends taiga_ui_cdk_abstract/* AbstractTuiDialogService */.d5 {
    constructor(defaultOptions, idService) {
      super(idService);
      this.defaultOptions = defaultOptions;
      this.component = new tinkoff_ng_polymorpheus/* PolymorpheusComponent */.Al(TuiAlertComponent);
    }
  };
  TuiAlertService.ɵfac = function TuiAlertService_Factory(t) {
    return new (t || TuiAlertService)(core_js_["ɵɵinject"](taiga_ui_core_tokens/* TUI_NOTIFICATION_OPTIONS */.Ln), core_js_["ɵɵinject"](taiga_ui_cdk_services/* TuiIdService */.ll));
  };
  TuiAlertService.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function TuiAlertService_Factory() {
      return new TuiAlertService((0,core_js_["ɵɵinject"])(taiga_ui_core_tokens/* TUI_NOTIFICATION_OPTIONS */.Ln), (0,core_js_["ɵɵinject"])(taiga_ui_cdk_services/* TuiIdService */.ll));
    },
    token: TuiAlertService,
    providedIn: "root"
  });
  TuiAlertService = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_NOTIFICATION_OPTIONS */.Ln)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiIdService */.ll))], TuiAlertService);
  /** @deprecated use {@link TuiAlertService} */
  return TuiAlertService;
})();
let TuiNotificationsService = /*#__PURE__*/(() => {
  let TuiNotificationsService = class TuiNotificationsService {
    constructor(alert) {
      this.alert = alert;
    }
    show(content, options = {}) {
      return this.alert.open(content, options);
    }
  };
  TuiNotificationsService.ɵfac = function TuiNotificationsService_Factory(t) {
    return new (t || TuiNotificationsService)(core_js_["ɵɵinject"](TuiAlertService));
  };
  TuiNotificationsService.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function TuiNotificationsService_Factory() {
      return new TuiNotificationsService((0,core_js_["ɵɵinject"])(TuiAlertService));
    },
    token: TuiNotificationsService,
    providedIn: "root"
  });
  TuiNotificationsService = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TuiAlertService))], TuiNotificationsService);
  return TuiNotificationsService;
})();
let TuiAlertModule = /*#__PURE__*/(() => {
  let TuiAlertModule = class TuiAlertModule {};
  TuiAlertModule.ɵfac = function TuiAlertModule_Factory(t) {
    return new (t || TuiAlertModule)();
  };
  TuiAlertModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiAlertModule
  });
  TuiAlertModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    providers: [{
      provide: taiga_ui_cdk_tokens/* TUI_ALERTS */.bS,
      useExisting: TuiAlertService,
      multi: true
    }],
    imports: [[common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_notification/* TuiNotificationModule */.Hi]]
  });
  /** @deprecated use {@link TuiAlertModule} */
  return TuiAlertModule;
})();
let TuiNotificationsModule = /*#__PURE__*/(() => {
  let TuiNotificationsModule = class TuiNotificationsModule {};
  TuiNotificationsModule.ɵfac = function TuiNotificationsModule_Factory(t) {
    return new (t || TuiNotificationsModule)();
  };
  TuiNotificationsModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiNotificationsModule
  });
  TuiNotificationsModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[TuiAlertModule]]
  });
  return TuiNotificationsModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiAlertModule, {
    declarations: function () {
      return [TuiAlertComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_notification/* TuiNotificationModule */.Hi];
    },
    exports: function () {
      return [TuiAlertComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiNotificationsModule, {
    imports: [TuiAlertModule]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-alert.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-pipes-flag.js





let TuiFlagPipe = /*#__PURE__*/(() => {
  let TuiFlagPipe = class TuiFlagPipe {
    constructor(iconsPath) {
      this.iconsPath = iconsPath;
      this.staticPath = this.iconsPath(`tuiIcon`).replace(`tuiIcon.svg#tuiIcon`, ``);
    }
    transform(countryIsoCode) {
      if (!countryIsoCode) {
        return null;
      }
      switch (countryIsoCode) {
        case taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BL:
        case taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BQ:
        case taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CW:
        case taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GF:
        case taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GP:
        case taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MF:
        case taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MQ:
        case taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.NC:
        case taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.RE:
        case taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.YT:
          return `${this.staticPath}${taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.FR}.png`;
        case taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SX:
          return `${this.staticPath}${taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.NL}.png`;
        default:
          return `${this.staticPath}${countryIsoCode}.png`;
      }
    }
  };
  TuiFlagPipe.ɵfac = function TuiFlagPipe_Factory(t) {
    return new (t || TuiFlagPipe)(core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_ICONS_PATH */.ki, 16));
  };
  TuiFlagPipe.ɵpipe = /*@__PURE__*/core_js_["ɵɵdefinePipe"]({
    name: "tuiFlag",
    type: TuiFlagPipe,
    pure: true
  });
  TuiFlagPipe = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_ICONS_PATH */.ki))], TuiFlagPipe);
  return TuiFlagPipe;
})();
let TuiFlagPipeModule = /*#__PURE__*/(() => {
  let TuiFlagPipeModule = class TuiFlagPipeModule {};
  TuiFlagPipeModule.ɵfac = function TuiFlagPipeModule_Factory(t) {
    return new (t || TuiFlagPipeModule)();
  };
  TuiFlagPipeModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiFlagPipeModule
  });
  TuiFlagPipeModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiFlagPipeModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiFlagPipeModule, {
    declarations: [TuiFlagPipe],
    exports: [TuiFlagPipe]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-pipes-flag.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-theme-night.js




// @dynamic

let TuiThemeNightComponent = /*#__PURE__*/(() => {
  let TuiThemeNightComponent = class TuiThemeNightComponent extends taiga_ui_cdk_abstract/* AbstractTuiThemeSwitcher */.GM {};
  TuiThemeNightComponent.ɵfac = /*@__PURE__*/function () {
    let ɵTuiThemeNightComponent_BaseFactory;
    return function TuiThemeNightComponent_Factory(t) {
      return (ɵTuiThemeNightComponent_BaseFactory || (ɵTuiThemeNightComponent_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiThemeNightComponent)))(t || TuiThemeNightComponent);
    };
  }();
  TuiThemeNightComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiThemeNightComponent,
    selectors: [["tui-theme-night"]],
    features: [core_js_["ɵɵInheritDefinitionFeature"]],
    decls: 0,
    vars: 0,
    template: function TuiThemeNightComponent_Template(rf, ctx) {},
    styles: [":root{--tui-base-01:#222;--tui-base-02:#333;--tui-base-03:#808080;--tui-base-04:#959595;--tui-base-05:#b0b0b0;--tui-base-06:#d7d7d7;--tui-base-07:#ededed;--tui-base-08:#f6f6f6;--tui-base-09:#fff;--tui-focus:rgba(51, 51, 51, 0.64);--tui-secondary:rgba(255, 255, 255, 0.16);--tui-secondary-hover:rgba(255, 255, 255, 0.24);--tui-secondary-active:rgba(255, 255, 255, 0.4);--tui-clear:rgba(255, 255, 255, 0.16);--tui-clear-disabled:rgba(255, 255, 255, 0.08);--tui-clear-hover:rgba(255, 255, 255, 0.24);--tui-clear-active:rgba(255, 255, 255, 0.4);--tui-error-fill:#ff8c67;--tui-error-bg:rgba(244, 87, 37, 0.32);--tui-error-bg-hover:rgba(244, 87, 37, 0.4);--tui-success-fill:#4ac99b;--tui-success-bg:rgba(74, 201, 155, 0.32);--tui-success-bg-hover:rgba(74, 201, 155, 0.4);--tui-warning-fill:#ffc700;--tui-warning-bg:rgba(255, 199, 0, 0.32);--tui-warning-bg-hover:rgba(255, 199, 0, 0.4);--tui-info-fill:#70b6f6;--tui-info-bg:rgba(112, 182, 246, 0.32);--tui-info-bg-hover:rgba(112, 182, 246, 0.4);--tui-neutral-fill:#959ba4;--tui-neutral-bg:rgba(149, 155, 164, 0.32);--tui-neutral-bg-hover:rgba(149, 155, 164, 0.48);--tui-text-01:#ffffff;--tui-text-02:rgba(255, 255, 255, 0.72);--tui-text-03:rgba(255, 255, 255, 0.6);--tui-link:#6788ff;--tui-link-hover:#526ed3;--tui-positive:#44c596;--tui-positive-hover:#3aa981;--tui-negative:#ff8c67;--tui-negative-hover:#bb593a;--tui-autofill:var(--tui-autofill-night);--tui-elevation-01:#222;--tui-elevation-02:#222}tui-notification{--tui-base-01:#000}"],
    encapsulation: 2
  });
  return TuiThemeNightComponent;
})();
let TuiThemeNightModule = /*#__PURE__*/(() => {
  let TuiThemeNightModule = class TuiThemeNightModule {};
  TuiThemeNightModule.ɵfac = function TuiThemeNightModule_Factory(t) {
    return new (t || TuiThemeNightModule)();
  };
  TuiThemeNightModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiThemeNightModule
  });
  TuiThemeNightModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiThemeNightModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiThemeNightModule, {
    declarations: [TuiThemeNightComponent],
    exports: [TuiThemeNightComponent]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-theme-night.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-components-dropdown-host.js






/**
 * Host element for dynamically created portals, for example using {@link TuiDropdownDirective}.
 */

const taiga_ui_cdk_components_dropdown_host_c0 = ["positionFixedOffset"];
const taiga_ui_cdk_components_dropdown_host_c1 = ["*"];
let TuiDropdownHostComponent = /*#__PURE__*/(() => {
  let TuiDropdownHostComponent = class TuiDropdownHostComponent extends taiga_ui_cdk_abstract/* AbstractTuiPortalHostComponent */.Er {
    fixedPositionOffset() {
      var _a;
      return ((_a = this.positionFixedOffsetRef) === null || _a === void 0 ? void 0 : _a.nativeElement.getBoundingClientRect()) || taiga_ui_cdk_constants/* EMPTY_CLIENT_RECT */.Jy;
    }
  };
  TuiDropdownHostComponent.ɵfac = /*@__PURE__*/function () {
    let ɵTuiDropdownHostComponent_BaseFactory;
    return function TuiDropdownHostComponent_Factory(t) {
      return (ɵTuiDropdownHostComponent_BaseFactory || (ɵTuiDropdownHostComponent_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiDropdownHostComponent)))(t || TuiDropdownHostComponent);
    };
  }();
  TuiDropdownHostComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDropdownHostComponent,
    selectors: [["tui-dropdown-host"]],
    viewQuery: function TuiDropdownHostComponent_Query(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵviewQuery"](taiga_ui_cdk_components_dropdown_host_c0, 5);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.positionFixedOffsetRef = _t.first);
      }
    },
    features: [core_js_["ɵɵProvidersFeature"]([{
      provide: taiga_ui_cdk_abstract/* AbstractTuiPortalService */.N9,
      useExisting: TuiPortalService
    }]), core_js_["ɵɵInheritDefinitionFeature"]],
    ngContentSelectors: taiga_ui_cdk_components_dropdown_host_c1,
    decls: 5,
    vars: 0,
    consts: [[1, "t-position-fixed-offset"], ["positionFixedOffset", ""], ["viewContainer", ""]],
    template: function TuiDropdownHostComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵelement"](0, "div", 0, 1);
        core_js_["ɵɵprojection"](2);
        core_js_["ɵɵelementContainer"](3, null, 2);
      }
    },
    styles: ["[_nghost-%COMP%]{position:relative;z-index:0;display:block;height:100%}[_nghost-%COMP%]:before{content:'';display:block;overflow:hidden}.t-position-fixed-offset[_ngcontent-%COMP%]{position:fixed;left:0;top:0;pointer-events:none;visibility:hidden;width:100%;height:100%}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('positionFixedOffset')], TuiDropdownHostComponent.prototype, "positionFixedOffsetRef", void 0);
  return TuiDropdownHostComponent;
})();
let TuiDropdownHostModule = /*#__PURE__*/(() => {
  let TuiDropdownHostModule = class TuiDropdownHostModule {};
  TuiDropdownHostModule.ɵfac = function TuiDropdownHostModule_Factory(t) {
    return new (t || TuiDropdownHostModule)();
  };
  TuiDropdownHostModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDropdownHostModule
  });
  TuiDropdownHostModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiDropdownHostModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDropdownHostModule, {
    declarations: [TuiDropdownHostComponent],
    exports: [TuiDropdownHostComponent]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-components-dropdown-host.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-directives-focus-trap.js






// @dynamic

let TuiFocusTrapDirective = /*#__PURE__*/(() => {
  let TuiFocusTrapDirective = class TuiFocusTrapDirective {
    constructor(documentRef, elementRef, renderer) {
      this.documentRef = documentRef;
      this.elementRef = elementRef;
      this.renderer = renderer;
      this.activeElement = (0,taiga_ui_cdk_utils_focus/* getNativeFocused */.dO)(this.documentRef);
      /**
       * This would cause currently focused element to lose focus,
       * but it might cause ExpressionChanged error due to potential HostBinding.
       * Microtask keeps it in the same frame but allows change detection to run
       */
      // eslint-disable-next-line @typescript-eslint/no-floating-promises
      Promise.resolve().then(() => {
        (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(this.elementRef.nativeElement);
      });
    }
    onBlur() {
      this.renderer.removeAttribute(this.elementRef.nativeElement, 'tabIndex');
    }
    onFocusIn(node) {
      if ((0,taiga_ui_cdk_utils_dom/* containsOrAfter */.vV)(this.elementRef.nativeElement, node)) {
        return;
      }
      const focusable = (0,taiga_ui_cdk_utils_focus/* getClosestFocusable */.kA)(this.elementRef.nativeElement, false, this.elementRef.nativeElement);
      if (focusable) {
        (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(focusable);
      }
    }
    ngOnDestroy() {
      (0,taiga_ui_cdk_utils_focus/* blurNativeFocused */.PO)(this.documentRef);
      /**
       * HostListeners are triggered even after ngOnDestroy
       * {@link https://github.com/angular/angular/issues/38100}
       * so we need to delay it but stay in the same sync cycle,
       * therefore using Promise instead of setTimeout
       */
      // eslint-disable-next-line
      Promise.resolve().then(() => {
        // TODO: iframe warning
        if (this.activeElement instanceof HTMLElement) {
          (0,taiga_ui_cdk_utils_focus/* setNativeFocused */.NY)(this.activeElement);
        }
      });
    }
  };
  TuiFocusTrapDirective.ɵfac = function TuiFocusTrapDirective_Factory(t) {
    return new (t || TuiFocusTrapDirective)(core_js_["ɵɵdirectiveInject"](common_js_.DOCUMENT), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](core_js_.Renderer2));
  };
  TuiFocusTrapDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiFocusTrapDirective,
    selectors: [["", "tuiFocusTrap", ""]],
    hostAttrs: ["tabIndex", "0"],
    hostBindings: function TuiFocusTrapDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("blur", function TuiFocusTrapDirective_blur_HostBindingHandler() {
          return ctx.onBlur();
        })("focusin.silent", function TuiFocusTrapDirective_focusin_silent_HostBindingHandler($event) {
          return ctx.onFocusIn($event.target);
        }, false, core_js_["ɵɵresolveWindow"]);
      }
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('blur')], TuiFocusTrapDirective.prototype, "onBlur", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('window:focusin.silent', ['$event.target'])], TuiFocusTrapDirective.prototype, "onFocusIn", null);
  TuiFocusTrapDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(common_js_.DOCUMENT)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.Renderer2))], TuiFocusTrapDirective);
  return TuiFocusTrapDirective;
})();
let TuiFocusTrapModule = /*#__PURE__*/(() => {
  let TuiFocusTrapModule = class TuiFocusTrapModule {};
  TuiFocusTrapModule.ɵfac = function TuiFocusTrapModule_Factory(t) {
    return new (t || TuiFocusTrapModule)();
  };
  TuiFocusTrapModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiFocusTrapModule
  });
  TuiFocusTrapModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiFocusTrapModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiFocusTrapModule, {
    declarations: [TuiFocusTrapDirective],
    exports: [TuiFocusTrapDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-focus-trap.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-components-dialog-host.js





















function TuiDialogHostComponent_ng_container_0_section_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "section", 3);
  }
  if (rf & 2) {
    const item_r4 = ctx.$implicit;
    core_js_["ɵɵproperty"]("@tuiParentAnimation", undefined)("content", item_r4.component)("context", item_r4);
    core_js_["ɵɵattribute"]("aria-labelledby", item_r4.id);
  }
}
function TuiDialogHostComponent_ng_container_0_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "div", 4);
    core_js_["ɵɵlistener"]("popstate", function TuiDialogHostComponent_ng_container_0_div_2_Template_div_popstate_0_listener() {
      const restoredCtx = core_js_["ɵɵrestoreView"](_r8);
      const isDialogClosesOnBack_r5 = restoredCtx.tuiLet;
      const dialogs_r1 = core_js_["ɵɵnextContext"]().ngIf;
      const ctx_r6 = core_js_["ɵɵnextContext"]();
      return ctx_r6.closeLast(dialogs_r1, isDialogClosesOnBack_r5);
    }, false, core_js_["ɵɵresolveWindow"])("transitionend", function TuiDialogHostComponent_ng_container_0_div_2_Template_div_transitionend_0_listener($event) {
      const restoredCtx = core_js_["ɵɵrestoreView"](_r8);
      const isDialogClosesOnBack_r5 = restoredCtx.tuiLet;
      const dialogs_r1 = core_js_["ɵɵnextContext"]().ngIf;
      const ctx_r9 = core_js_["ɵɵnextContext"]();
      return ctx_r9.onDialog($event, !!dialogs_r1.length, isDialogClosesOnBack_r5);
    });
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const dialogs_r1 = core_js_["ɵɵnextContext"]().ngIf;
    core_js_["ɵɵclassProp"]("t-overlay_visible", dialogs_r1.length);
  }
}
function TuiDialogHostComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiDialogHostComponent_ng_container_0_section_1_Template, 1, 4, "section", 1);
    core_js_["ɵɵtemplate"](2, TuiDialogHostComponent_ng_container_0_div_2_Template, 1, 2, "div", 2);
    core_js_["ɵɵpipe"](3, "async");
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const dialogs_r1 = ctx.ngIf;
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", dialogs_r1);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("tuiLet", core_js_["ɵɵpipeBind1"](3, 2, ctx_r0.isDialogClosesOnBack$));
  }
}
const TUI_DIALOG_CLOSES_ON_BACK = new core_js_.InjectionToken('Is closing dialog on browser backward navigation enabled', {
  factory: () => (0,observable_of.of)(false)
});
// TODO: 3.0 remove in ivy compilation
const FAKE_HISTORY_STATE = {
  label: 'ignoreMe'
};
// TODO: 3.0 remove in ivy compilation
const isFakeHistoryState = historyState => (historyState === null || historyState === void 0 ? void 0 : historyState.label) === FAKE_HISTORY_STATE.label;
// @dynamic
let TuiDialogHostComponent = /*#__PURE__*/(() => {
  let TuiDialogHostComponent = class TuiDialogHostComponent {
    constructor(isDialogClosesOnBack$, dialogsByType, historyRef, titleService) {
      this.isDialogClosesOnBack$ = isDialogClosesOnBack$;
      this.dialogsByType = dialogsByType;
      this.historyRef = historyRef;
      this.titleService = titleService;
      this.dialogs$ = (0,combineLatest/* combineLatest */.aj)(this.dialogsByType).pipe((0,operators_map/* map */.U)(allTypesDialogs => new Array().concat(...allTypesDialogs).sort((a, b) => a.createdAt - b.createdAt)));
    }
    closeLast(dialogs, isDialogClosesOnBack) {
      if (!isDialogClosesOnBack) {
        return;
      }
      const [last] = dialogs.slice(-1);
      if (!last) {
        return;
      }
      if (dialogs.length > 1) {
        this.historyRef.pushState(FAKE_HISTORY_STATE, this.titleService.getTitle());
      }
      last.$implicit.complete();
    }
    onDialog({
      propertyName
    }, popupOpened, isDialogClosesOnBack) {
      if (!isDialogClosesOnBack || propertyName !== 'letter-spacing') {
        return;
      }
      if (popupOpened) {
        this.historyRef.pushState(FAKE_HISTORY_STATE, this.titleService.getTitle());
      } else if (isFakeHistoryState(this.historyRef.state)) {
        this.historyRef.back();
      }
    }
  };
  TuiDialogHostComponent.ɵfac = function TuiDialogHostComponent_Factory(t) {
    return new (t || TuiDialogHostComponent)(core_js_["ɵɵdirectiveInject"](TUI_DIALOG_CLOSES_ON_BACK), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_DIALOGS */.qY), core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* HISTORY */.UA), core_js_["ɵɵdirectiveInject"](platform_browser.Title));
  };
  TuiDialogHostComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDialogHostComponent,
    selectors: [["tui-dialog-host"]],
    decls: 2,
    vars: 3,
    consts: [[4, "ngIf"], ["polymorpheus-outlet", "", "tuiFocusTrap", "", "tuiScrollRef", "", "tuiOverscroll", "all", "role", "dialog", "aria-modal", "true", "class", "t-dialog", 3, "content", "context", 4, "ngFor", "ngForOf"], ["class", "t-overlay", 3, "t-overlay_visible", "popstate", "transitionend", 4, "tuiLet"], ["polymorpheus-outlet", "", "tuiFocusTrap", "", "tuiScrollRef", "", "tuiOverscroll", "all", "role", "dialog", "aria-modal", "true", 1, "t-dialog", 3, "content", "context"], [1, "t-overlay", 3, "popstate", "transitionend"]],
    template: function TuiDialogHostComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵtemplate"](0, TuiDialogHostComponent_ng_container_0_Template, 4, 4, "ng-container", 0);
        core_js_["ɵɵpipe"](1, "async");
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngIf", core_js_["ɵɵpipeBind1"](1, 1, ctx.dialogs$));
      }
    },
    directives: [common_js_.NgIf, common_js_.NgForOf, taiga_ui_cdk_directives_let/* TuiLetDirective */.Ls, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, TuiFocusTrapDirective, TuiOverscrollDirective],
    pipes: [common_js_.AsyncPipe],
    styles: ["[_nghost-%COMP%]{position:fixed;left:0;bottom:0;width:100%;height:0}.t-dialog[_ngcontent-%COMP%], .t-overlay[_ngcontent-%COMP%]{position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:flex-start;outline:0;overflow:auto;overflow:overlay}.t-dialog[_ngcontent-%COMP%]{bottom:auto;height:100%}.t-overlay[_ngcontent-%COMP%]{height:100%;pointer-events:none;touch-action:none;opacity:0;letter-spacing:normal;transition:opacity var(--tui-duration),letter-spacing 10ms;background:rgba(0,0,0,.75)}.t-overlay_visible[_ngcontent-%COMP%]{opacity:1;letter-spacing:1px}.t-dialog[_ngcontent-%COMP%]:last-of-type{z-index:1}"],
    data: {
      animation: [taiga_ui_cdk_constants/* TUI_PARENT_ANIMATION */.Kx]
    },
    changeDetection: 0
  });
  TuiDialogHostComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TUI_DIALOG_CLOSES_ON_BACK)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_DIALOGS */.qY)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(ng_web_apis_common/* HISTORY */.UA)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(platform_browser.Title))], TuiDialogHostComponent);
  return TuiDialogHostComponent;
})();
let TuiDialogHostModule = /*#__PURE__*/(() => {
  let TuiDialogHostModule = class TuiDialogHostModule {};
  TuiDialogHostModule.ɵfac = function TuiDialogHostModule_Factory(t) {
    return new (t || TuiDialogHostModule)();
  };
  TuiDialogHostModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDialogHostModule
  });
  TuiDialogHostModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiOverscrollModule, TuiFocusTrapModule, taiga_ui_cdk_directives_let/* TuiLetModule */.WD]]
  });
  return TuiDialogHostModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDialogHostModule, {
    declarations: function () {
      return [TuiDialogHostComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiOverscrollModule, TuiFocusTrapModule, taiga_ui_cdk_directives_let/* TuiLetModule */.WD];
    },
    exports: function () {
      return [TuiDialogHostComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-components-dialog-host.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-pipes-mapper.js



let TuiMapperPipe = /*#__PURE__*/(() => {
  let TuiMapperPipe = class TuiMapperPipe {
    /**
     * Maps object to an arbitrary result through a mapper function
     *
     * @param value an item to transform
     * @param mapper a mapping function
     * @param args arbitrary number of additional arguments
     */
    transform(value, mapper, ...args) {
      return mapper(value, ...args);
    }
  };
  TuiMapperPipe.ɵfac = function TuiMapperPipe_Factory(t) {
    return new (t || TuiMapperPipe)();
  };
  TuiMapperPipe.ɵpipe = /*@__PURE__*/core_js_["ɵɵdefinePipe"]({
    name: "tuiMapper",
    type: TuiMapperPipe,
    pure: true
  });
  return TuiMapperPipe;
})();
let TuiMapperPipeModule = /*#__PURE__*/(() => {
  let TuiMapperPipeModule = class TuiMapperPipeModule {};
  TuiMapperPipeModule.ɵfac = function TuiMapperPipeModule_Factory(t) {
    return new (t || TuiMapperPipeModule)();
  };
  TuiMapperPipeModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiMapperPipeModule
  });
  TuiMapperPipeModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiMapperPipeModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiMapperPipeModule, {
    declarations: [TuiMapperPipe],
    exports: [TuiMapperPipe]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-pipes-mapper.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-components-alert-host.js










function TuiAlertHostComponent_div_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0, 3);
    core_js_["ɵɵpipe"](1, "tuiMapper");
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    const ctx_r2 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵproperty"]("ngComponentOutlet", item_r3.component.component)("ngComponentOutletInjector", core_js_["ɵɵpipeBind2"](1, 2, item_r3, ctx_r2.mapper));
  }
}
function TuiAlertHostComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 1);
    core_js_["ɵɵtemplate"](1, TuiAlertHostComponent_div_0_ng_container_1_Template, 2, 5, "ng-container", 2);
    core_js_["ɵɵpipe"](2, "async");
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const alert$_r1 = ctx.$implicit;
    core_js_["ɵɵproperty"]("@tuiParentAnimation", undefined);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", core_js_["ɵɵpipeBind1"](2, 2, alert$_r1));
  }
}
let TuiAlertHostComponent = /*#__PURE__*/(() => {
  let TuiAlertHostComponent = class TuiAlertHostComponent {
    constructor(alerts, injector) {
      this.alerts = alerts;
      this.injector = injector;
      this.mapper = useValue => core_js_.Injector.create({
        providers: [{
          provide: tinkoff_ng_polymorpheus/* POLYMORPHEUS_CONTEXT */.yf,
          useValue
        }],
        parent: this.injector
      });
    }
  };
  TuiAlertHostComponent.ɵfac = function TuiAlertHostComponent_Factory(t) {
    return new (t || TuiAlertHostComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_ALERTS */.bS), core_js_["ɵɵdirectiveInject"](core_js_.INJECTOR));
  };
  TuiAlertHostComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiAlertHostComponent,
    selectors: [["tui-alert-host"]],
    decls: 1,
    vars: 1,
    consts: [["class", "t-notifications-wrapper", 4, "ngFor", "ngForOf"], [1, "t-notifications-wrapper"], [3, "ngComponentOutlet", "ngComponentOutletInjector", 4, "ngFor", "ngForOf"], [3, "ngComponentOutlet", "ngComponentOutletInjector"]],
    template: function TuiAlertHostComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵtemplate"](0, TuiAlertHostComponent_div_0_Template, 3, 4, "div", 0);
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngForOf", ctx.alerts);
      }
    },
    directives: [common_js_.NgForOf, common_js_.NgComponentOutlet],
    pipes: [common_js_.AsyncPipe, TuiMapperPipe],
    styles: ["tui-alert-host>.t-notifications-wrapper{position:fixed;top:0;left:0;display:flex;width:100%;height:100%;flex-direction:column;pointer-events:none}tui-alert-host>.t-notifications-wrapper>*{pointer-events:auto}"],
    encapsulation: 2,
    data: {
      animation: [taiga_ui_cdk_constants/* TUI_PARENT_ANIMATION */.Kx]
    },
    changeDetection: 0
  });
  TuiAlertHostComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_ALERTS */.bS)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.INJECTOR))], TuiAlertHostComponent);
  return TuiAlertHostComponent;
})();
let TuiAlertHostModule = /*#__PURE__*/(() => {
  let TuiAlertHostModule = class TuiAlertHostModule {};
  TuiAlertHostModule.ɵfac = function TuiAlertHostModule_Factory(t) {
    return new (t || TuiAlertHostModule)();
  };
  TuiAlertHostModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiAlertHostModule
  });
  TuiAlertHostModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, TuiMapperPipeModule]]
  });
  return TuiAlertHostModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiAlertHostModule, {
    declarations: function () {
      return [TuiAlertHostComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, TuiMapperPipeModule];
    },
    exports: function () {
      return [TuiAlertHostComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-components-alert-host.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-directives-pointer-hint.js








/** Default values for pointer hint options */



const TUI_POINTER_HINT_DEFAULT_OPTIONS = Object.assign(Object.assign({}, TUI_ABSTRACT_HINT_DEFAULT_OPTIONS), {
  tuiHintShowDelay: 0,
  tuiHintHideDelay: 0
});
const TUI_POINTER_HINT_OPTIONS = new core_js_.InjectionToken(`Default parameters for pointer hint directive`, {
  factory: () => TUI_POINTER_HINT_DEFAULT_OPTIONS
});
const tuiPointerHintOptionsProvider = options => ({
  provide: TUI_POINTER_HINT_OPTIONS,
  useValue: Object.assign(Object.assign({}, TUI_POINTER_HINT_DEFAULT_OPTIONS), options)
});
let TuiPointerHintDirective = /*#__PURE__*/(() => {
  let TuiPointerHintDirective = class TuiPointerHintDirective extends AbstractTuiHint {
    constructor(elementRef, hintService, destroy$, hoveredService, options) {
      super(elementRef, hintService, null, options);
      this.destroy$ = destroy$;
      this.options = options;
      this.currentMouseRect = this.mousePositionToClientRect();
      this.tuiHintShowDelay = this.options.tuiHintShowDelay;
      this.tuiHintHideDelay = this.options.tuiHintHideDelay;
      this.content = '';
      const hint$ = hoveredService.createHovered$(this.elementRef.nativeElement).pipe((0,operators_filter/* filter */.h)(() => !!this.content), (0,operators_startWith/* startWith */.O)(false), (0,operators_distinctUntilChanged/* distinctUntilChanged */.x)());
      hint$.pipe((0,operators_switchMap/* switchMap */.w)(visible => (0,observable_of.of)(visible).pipe((0,delay/* delay */.g)(visible ? this.tuiHintShowDelay : this.tuiHintHideDelay))), (0,operators_takeUntil/* takeUntil */.R)(destroy$)).subscribe({
        next: visible => {
          if (visible) {
            this.showTooltip();
          } else {
            this.hideTooltip();
          }
        },
        complete: () => {
          this.hideTooltip();
        }
      });
      this.initMouseMoveSubscription();
    }
    // TODO: 3.0 Remove null
    set tuiPointerHint(value) {
      if (!value) {
        this.hideTooltip();
        this.content = '';
        return;
      }
      this.content = value;
    }
    getElementClientRect() {
      return this.currentMouseRect;
    }
    initMouseMoveSubscription() {
      const mouseMove$ = (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(this.elementRef.nativeElement, 'mousemove');
      mouseMove$.pipe((0,operators_takeUntil/* takeUntil */.R)(this.destroy$)).subscribe(({
        clientX,
        clientY
      }) => {
        this.currentMouseRect = this.mousePositionToClientRect(clientX, clientY);
      });
    }
    mousePositionToClientRect(x = 0, y = 0) {
      return {
        left: x,
        right: x,
        top: y,
        bottom: y,
        width: 0,
        height: 0
      };
    }
  };
  TuiPointerHintDirective.ɵfac = function TuiPointerHintDirective_Factory(t) {
    return new (t || TuiPointerHintDirective)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_services/* TuiHintService */.BN), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiHoveredService */.gs), core_js_["ɵɵdirectiveInject"](TUI_POINTER_HINT_OPTIONS));
  };
  TuiPointerHintDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiPointerHintDirective,
    selectors: [["", "tuiPointerHint", "", 5, "ng-container"]],
    inputs: {
      tuiHintShowDelay: "tuiHintShowDelay",
      tuiHintHideDelay: "tuiHintHideDelay",
      tuiPointerHint: "tuiPointerHint"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPointerHintDirective.prototype, "tuiHintShowDelay", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiPointerHintDirective.prototype, "tuiHintHideDelay", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiRequiredSetter */.NH)()], TuiPointerHintDirective.prototype, "tuiPointerHint", null);
  TuiPointerHintDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_core_services/* TuiHintService */.BN)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiHoveredService */.gs)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(TUI_POINTER_HINT_OPTIONS))], TuiPointerHintDirective);
  return TuiPointerHintDirective;
})();
let TuiPointerHintModule = /*#__PURE__*/(() => {
  let TuiPointerHintModule = class TuiPointerHintModule {};
  TuiPointerHintModule.ɵfac = function TuiPointerHintModule_Factory(t) {
    return new (t || TuiPointerHintModule)();
  };
  TuiPointerHintModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiPointerHintModule
  });
  TuiPointerHintModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiPointerHintModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiPointerHintModule, {
    declarations: [TuiPointerHintDirective],
    exports: [TuiPointerHintDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-directives-pointer-hint.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-utils-mobile.js
var taiga_ui_core_utils_mobile = __webpack_require__(9557);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-hints-host.js



















const taiga_ui_core_components_hints_host_c0 = function (a0) {
  return {
    $implicit: a0
  };
};
function TuiHintsHostComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "div", 1);
  }
  if (rf & 2) {
    const hint_r1 = ctx.$implicit;
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("@tuiParentAnimation", undefined)("content", hint_r1.component || ctx_r0.component)("context", core_js_["ɵɵpureFunction1"](5, taiga_ui_core_components_hints_host_c0, hint_r1))("tuiActiveZoneParent", hint_r1.activeZone);
    core_js_["ɵɵattribute"]("id", hint_r1.id);
  }
}
const taiga_ui_core_components_hints_host_c1 = ["arrow"];
const taiga_ui_core_components_hints_host_c2 = ["hint", ""];
function TuiHintBoxComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "div", 2, 3);
  }
}
function TuiHintBoxComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "span", 4);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const text_r3 = ctx.$implicit;
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate"](text_r3);
  }
}
let TuiHintsHostComponent = /*#__PURE__*/(() => {
  let TuiHintsHostComponent = class TuiHintsHostComponent {
    constructor(elementRef, hints$) {
      this.elementRef = elementRef;
      this.hints$ = hints$;
      this.component = new tinkoff_ng_polymorpheus/* PolymorpheusComponent */.Al(TuiHintBoxComponent);
    }
    get clientRect() {
      return this.elementRef.nativeElement.getBoundingClientRect();
    }
  };
  TuiHintsHostComponent.ɵfac = function TuiHintsHostComponent_Factory(t) {
    return new (t || TuiHintsHostComponent)(core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_core_services/* TuiHintService */.BN));
  };
  TuiHintsHostComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiHintsHostComponent,
    selectors: [["tui-hints-host"]],
    hostAttrs: ["aria-live", "polite"],
    decls: 2,
    vars: 3,
    consts: [["role", "tooltip", "polymorpheus-outlet", "", 3, "content", "context", "tuiActiveZoneParent", 4, "ngFor", "ngForOf"], ["role", "tooltip", "polymorpheus-outlet", "", 3, "content", "context", "tuiActiveZoneParent"]],
    template: function TuiHintsHostComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵtemplate"](0, TuiHintsHostComponent_div_0_Template, 1, 7, "div", 0);
        core_js_["ɵɵpipe"](1, "async");
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngForOf", core_js_["ɵɵpipeBind1"](1, 1, ctx.hints$));
      }
    },
    directives: [common_js_.NgForOf, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, TuiActiveZoneDirective],
    pipes: [common_js_.AsyncPipe],
    styles: ["[_nghost-%COMP%]{position:fixed;bottom:0;left:0;width:100%;height:0}"],
    data: {
      animation: [taiga_ui_cdk_constants/* TUI_PARENT_ANIMATION */.Kx]
    },
    changeDetection: 0
  });
  TuiHintsHostComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_core_services/* TuiHintService */.BN))], TuiHintsHostComponent);
  return TuiHintsHostComponent;
})();
const SPACE = 8;
const BORDER_WIDTH = 1;
const LEFT_PADDING = 16;
const TOP_PADDING = 12;
const ARROW_SIZE = 8;
const ARROW_OFFSET = 16;
const ARROWHEAD_OFFSET = ARROW_OFFSET + ARROW_SIZE * Math.sqrt(2) / 2;
const reverseDirectionsVertical = {
  'top-left': 'bottom-left',
  'top-right': 'bottom-right',
  'bottom-left': 'top-left',
  'bottom-right': 'top-right',
  left: 'right',
  right: 'left',
  'top-middle': 'bottom-middle',
  'bottom-middle': 'top-middle'
};
const reverseDirectionsHorizontal = {
  'top-left': 'top-right',
  'top-right': 'top-left',
  'bottom-left': 'bottom-right',
  'bottom-right': 'bottom-left',
  left: 'right',
  right: 'left',
  'top-middle': 'top-middle',
  'bottom-middle': 'bottom-middle'
};
// TODO: consider abstracting UI and move to CDK, split hint and overflow
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
let TuiHintBoxComponent = /*#__PURE__*/(() => {
  let TuiHintBoxComponent = class TuiHintBoxComponent {
    constructor(animationFrame$, destroy$, ngZone, options, elementRef, windowRef, media, hintsHost, context) {
      this.options = options;
      this.elementRef = elementRef;
      this.windowRef = windowRef;
      this.media = media;
      this.hintsHost = hintsHost;
      this.context = context;
      this.animation = Object.assign({
        value: ''
      }, this.options);
      animationFrame$.pipe((0,taiga_ui_cdk_observables/* tuiZonefree */.fL)(ngZone), (0,operators_takeUntil/* takeUntil */.R)(destroy$)).subscribe(() => this.calculatePosition());
    }
    get hint() {
      return this.context.$implicit;
    }
    get isUntouchable() {
      return this.hint instanceof TuiPointerHintDirective;
    }
    get mode() {
      return this.hint.mode;
    }
    get isMobile() {
      return (0,taiga_ui_core_utils_mobile/* tuiIsMobile */.J)(this.windowRef, this.media);
    }
    onHovered(hovered) {
      if (this.hint instanceof TuiHintDirective) {
        this.hint.componentHovered$.next(hovered);
      }
    }
    /**
     * Calculates wrapper position.
     * Styles are set directly to avoid visual shake of element
     */
    calculatePosition() {
      if (this.mode !== 'overflow') {
        this.calculateCoordinates();
      } else {
        this.setOverflowStyles();
      }
    }
    calculateCoordinates() {
      if (this.isMobile) {
        this.calculateMobileCoordinates();
        return;
      }
      const hostRect = this.hint.getElementClientRect();
      const portalRect = this.hintsHost.clientRect;
      const tooltip = this.elementRef.nativeElement;
      const {
        style
      } = tooltip;
      const tooltipRect = tooltip.getBoundingClientRect();
      const isHostLong = hostRect.width > ARROWHEAD_OFFSET * 2;
      const directions = ['left', 'right', 'bottom-left', 'bottom-right', 'bottom-middle', 'top-left', 'top-right', 'top-middle'];
      let top = 0;
      let left = 0;
      let {
        direction
      } = this.hint;
      const horizontalTop = hostRect.top + hostRect.height / 2 - tooltipRect.height / 2 - portalRect.top;
      const horizontalLeft = hostRect.left - tooltipRect.width - SPACE - portalRect.left;
      const horizontalRight = hostRect.left + hostRect.width + SPACE - portalRect.left;
      const verticalBottom = hostRect.bottom + SPACE - portalRect.top;
      const verticalTop = hostRect.top - tooltipRect.height - SPACE - portalRect.top;
      const verticalRight = isHostLong ? hostRect.left - portalRect.left : hostRect.left + hostRect.width / 2 - ARROWHEAD_OFFSET - portalRect.left;
      const verticalLeft = isHostLong ? hostRect.left - tooltipRect.width + hostRect.width - portalRect.left : hostRect.left - tooltipRect.width + hostRect.width / 2 + ARROWHEAD_OFFSET - portalRect.left;
      const verticalMiddle = hostRect.left - tooltipRect.width / 2 + hostRect.width / 2 - portalRect.left;
      directions.splice(directions.indexOf(direction), 1);
      // eslint-disable-next-line no-constant-condition
      while (true) {
        switch (direction) {
          case 'left':
            top = horizontalTop;
            left = horizontalLeft;
            break;
          case 'right':
            top = horizontalTop;
            left = horizontalRight;
            break;
          case 'top-right':
            top = verticalTop;
            left = verticalRight;
            break;
          case 'top-left':
            top = verticalTop;
            left = verticalLeft;
            break;
          case 'bottom-right':
            top = verticalBottom;
            left = verticalRight;
            break;
          case 'bottom-left':
            top = verticalBottom;
            left = verticalLeft;
            break;
          case 'bottom-middle':
            top = verticalBottom;
            left = verticalMiddle;
            break;
          case 'top-middle':
            top = verticalTop;
            left = verticalMiddle;
            break;
        }
        const verticalFit = top + portalRect.top > SPACE && top + tooltipRect.height + SPACE + portalRect.top < this.windowRef.innerHeight;
        const horizontalFit = left > SPACE && left + tooltipRect.width + SPACE + portalRect.left < portalRect.width;
        if (directions.length === 0 || verticalFit && horizontalFit) {
          break;
        }
        direction = verticalFit ? reverseDirectionsHorizontal[direction] : reverseDirectionsVertical[direction];
        direction = directions.splice(directions.indexOf(direction), 1)[0] || direction;
      }
      style.top = px(top);
      style.left = px(left);
      tooltip.setAttribute('data-tui-host-direction', direction);
    }
    calculateMobileCoordinates() {
      const hostRect = this.hint.getElementClientRect();
      const portalRect = this.hintsHost.clientRect;
      const tooltip = this.elementRef.nativeElement;
      const {
        style
      } = tooltip;
      const tooltipRect = tooltip.getBoundingClientRect();
      const verticalTop = hostRect.top - tooltipRect.height - SPACE - portalRect.top;
      const verticalBottom = hostRect.bottom + SPACE - portalRect.top;
      const verticalTopFit = verticalTop + portalRect.top > SPACE && hostRect.top < this.windowRef.innerHeight;
      const verticalBottomFit = hostRect.bottom > 0 && hostRect.bottom + 2 * SPACE + tooltipRect.height < this.windowRef.innerHeight;
      const direction = this.hint.direction.includes('top') && verticalTopFit || !verticalBottomFit ? 'top' : 'bottom';
      const attemptedLeft = portalRect.left + hostRect.left + hostRect.width / 2 - tooltipRect.width / 2;
      const left = Math.max(attemptedLeft + tooltipRect.width + SPACE > portalRect.right ? portalRect.right - SPACE - tooltipRect.width : attemptedLeft, SPACE * 2);
      style.left = px(left);
      style.top = direction === 'top' ? px(verticalTop) : px(verticalBottom);
      if (this.arrow) {
        this.arrow.nativeElement.style.left = px(hostRect.left <= SPACE * 2 && hostRect.width > ARROW_OFFSET * 2 ? ARROW_OFFSET : hostRect.left + hostRect.width / 2 - left - ARROW_SIZE / 2);
      }
      tooltip.setAttribute('data-tui-host-direction', direction);
    }
    setOverflowStyles() {
      const hostRect = this.hint.getElementClientRect();
      const {
        style
      } = this.elementRef.nativeElement;
      style.top = px(hostRect.top - window.innerHeight - TOP_PADDING - BORDER_WIDTH);
      style.left = px(hostRect.left - LEFT_PADDING - BORDER_WIDTH);
      style.width = px(hostRect.width + LEFT_PADDING * 2 + BORDER_WIDTH * 2);
    }
  };
  TuiHintBoxComponent.ɵfac = function TuiHintBoxComponent_Factory(t) {
    return new (t || TuiHintBoxComponent)(core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* ANIMATION_FRAME */.L1), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3), core_js_["ɵɵdirectiveInject"](core_js_.NgZone), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* WINDOW */.m9), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_MEDIA */.J_), core_js_["ɵɵdirectiveInject"]((0,core_js_.forwardRef)(() => TuiHintsHostComponent)), core_js_["ɵɵdirectiveInject"](tinkoff_ng_polymorpheus/* POLYMORPHEUS_CONTEXT */.yf));
  };
  TuiHintBoxComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiHintBoxComponent,
    selectors: [["tui-hint-box", "hint", ""]],
    viewQuery: function TuiHintBoxComponent_Query(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵviewQuery"](taiga_ui_core_components_hints_host_c1, 5);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.arrow = _t.first);
      }
    },
    hostVars: 4,
    hostBindings: function TuiHintBoxComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("data-mode", ctx.mode);
        core_js_["ɵɵsyntheticHostProperty"]("@tuiFadeIn", ctx.animation);
        core_js_["ɵɵclassProp"]("_untouchable", ctx.isUntouchable);
      }
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])],
    attrs: taiga_ui_core_components_hints_host_c2,
    decls: 3,
    vars: 2,
    consts: [["class", "t-arrow", 4, "ngIf"], ["automation-id", "tui-hint-box__tooltip", "polymorpheus-outlet", "", 1, "t-tooltip", 3, "content", "tuiHoveredChange"], [1, "t-arrow"], ["arrow", ""], [1, "t-text"]],
    template: function TuiHintBoxComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵtemplate"](0, TuiHintBoxComponent_div_0_Template, 2, 0, "div", 0);
        core_js_["ɵɵelementStart"](1, "div", 1);
        core_js_["ɵɵlistener"]("tuiHoveredChange", function TuiHintBoxComponent_Template_div_tuiHoveredChange_1_listener($event) {
          return ctx.onHovered($event);
        });
        core_js_["ɵɵtemplate"](2, TuiHintBoxComponent_ng_template_2_Template, 2, 1, "ng-template");
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngIf", ctx.isMobile && ctx.mode !== "overflow");
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("content", ctx.hint.content);
      }
    },
    directives: [common_js_.NgIf, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, TuiHoveredDirective],
    styles: ["[_nghost-%COMP%]{position:absolute;top:0;left:0;max-width:18rem;min-height:var(--tui-height-m);padding:.75rem 1rem;background:var(--tui-primary);border-radius:var(--tui-radius-l);color:var(--tui-primary-text);box-sizing:border-box}[_nghost-%COMP%]   .t-arrow[_ngcontent-%COMP%], [_nghost-%COMP%]:not([data-mode=overflow]):before{content:'';position:absolute;width:.5rem;height:.5rem;border-radius:.125rem;box-sizing:border-box;background-color:inherit;transform:rotate(45deg)}[data-tui-host-direction=top][_nghost-%COMP%]   .t-arrow[_ngcontent-%COMP%]{bottom:-.25rem}[data-tui-host-direction=bottom][_nghost-%COMP%]   .t-arrow[_ngcontent-%COMP%]{top:-.25rem}[data-tui-host-direction=bottom][_nghost-%COMP%]:before, [data-tui-host-direction=top][_nghost-%COMP%]:before{display:none}[data-tui-host-direction=top-left][_nghost-%COMP%]:before, [data-tui-host-direction=top-middle][_nghost-%COMP%]:before, [data-tui-host-direction=top-right][_nghost-%COMP%]:before{bottom:-.25rem}[data-tui-host-direction=bottom-left][_nghost-%COMP%]:before, [data-tui-host-direction=bottom-middle][_nghost-%COMP%]:before, [data-tui-host-direction=bottom-right][_nghost-%COMP%]:before{top:-.25rem}[data-tui-host-direction=bottom-middle][_nghost-%COMP%]:before, [data-tui-host-direction=top-middle][_nghost-%COMP%]:before{left:calc(50% - .2rem)}[data-tui-host-direction=bottom-left][_nghost-%COMP%]:before, [data-tui-host-direction=top-left][_nghost-%COMP%]:before{right:1.075rem}[data-tui-host-direction=bottom-right][_nghost-%COMP%]:before, [data-tui-host-direction=top-right][_nghost-%COMP%]:before{left:1.075rem}[data-tui-host-direction=left][_nghost-%COMP%]:before, [data-tui-host-direction=right][_nghost-%COMP%]:before{top:50%;margin-top:-.25rem}[data-tui-host-direction=left][_nghost-%COMP%]:before{right:-.25rem}[data-tui-host-direction=right][_nghost-%COMP%]:before{left:-.25rem}[data-mode=error][_nghost-%COMP%]{background-color:var(--tui-error-fill)}[data-mode=onDark][_nghost-%COMP%], [data-mode=overflow][_nghost-%COMP%]{box-shadow:0 .5rem 1rem rgba(0,0,0,.16);border:1px solid var(--tui-base-03);background-color:var(--tui-base-01);color:var(--tui-text-01)}[data-mode=onDark][_nghost-%COMP%]:before, [data-mode=overflow][_nghost-%COMP%]:before{border:1px solid var(--tui-base-03)}[data-mode=onDark][data-tui-host-direction=left][_nghost-%COMP%]:before, [data-mode=overflow][data-tui-host-direction=left][_nghost-%COMP%]:before{border-left-color:transparent;border-bottom-color:transparent}[data-mode=onDark][data-tui-host-direction=right][_nghost-%COMP%]:before, [data-mode=overflow][data-tui-host-direction=right][_nghost-%COMP%]:before{border-right-color:transparent;border-top-color:transparent}[data-mode=onDark][data-tui-host-direction=top-left][_nghost-%COMP%]:before, [data-mode=onDark][data-tui-host-direction=top-middle][_nghost-%COMP%]:before, [data-mode=onDark][data-tui-host-direction=top-right][_nghost-%COMP%]:before, [data-mode=overflow][data-tui-host-direction=top-left][_nghost-%COMP%]:before, [data-mode=overflow][data-tui-host-direction=top-middle][_nghost-%COMP%]:before, [data-mode=overflow][data-tui-host-direction=top-right][_nghost-%COMP%]:before{border-left-color:transparent;border-top-color:transparent}[data-mode=onDark][data-tui-host-direction=bottom-left][_nghost-%COMP%]:before, [data-mode=onDark][data-tui-host-direction=bottom-middle][_nghost-%COMP%]:before, [data-mode=onDark][data-tui-host-direction=bottom-right][_nghost-%COMP%]:before, [data-mode=overflow][data-tui-host-direction=bottom-left][_nghost-%COMP%]:before, [data-mode=overflow][data-tui-host-direction=bottom-middle][_nghost-%COMP%]:before, [data-mode=overflow][data-tui-host-direction=bottom-right][_nghost-%COMP%]:before{border-right-color:transparent;border-bottom-color:transparent}[data-mode=overflow][_nghost-%COMP%]{max-width:none}._untouchable[_nghost-%COMP%]{pointer-events:none}.t-tooltip[_ngcontent-%COMP%]{font:var(--tui-font-text-s);word-wrap:break-word}[data-mode=overflow][_nghost-%COMP%]   .t-tooltip[_ngcontent-%COMP%]{font:inherit}.t-text[_ngcontent-%COMP%]{white-space:pre-wrap}"],
    data: {
      animation: [tuiFadeIn]
    },
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('arrow')], TuiHintBoxComponent.prototype, "arrow", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('@tuiFadeIn')], TuiHintBoxComponent.prototype, "animation", void 0);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM, (0,core_js_.HostBinding)('class._untouchable')], TuiHintBoxComponent.prototype, "isUntouchable", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('attr.data-mode')], TuiHintBoxComponent.prototype, "mode", null);
  TuiHintBoxComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(ng_web_apis_common/* ANIMATION_FRAME */.L1)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.NgZone)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(ng_web_apis_common/* WINDOW */.m9)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_MEDIA */.J_)), (0,tslib_es6/* __param */.fM)(7, (0,core_js_.Inject)((0,core_js_.forwardRef)(() => TuiHintsHostComponent))), (0,tslib_es6/* __param */.fM)(8, (0,core_js_.Inject)(tinkoff_ng_polymorpheus/* POLYMORPHEUS_CONTEXT */.yf))], TuiHintBoxComponent);
  return TuiHintBoxComponent;
})();
let TuiHintBoxModule = /*#__PURE__*/(() => {
  let TuiHintBoxModule = class TuiHintBoxModule {};
  TuiHintBoxModule.ɵfac = function TuiHintBoxModule_Factory(t) {
    return new (t || TuiHintBoxModule)();
  };
  TuiHintBoxModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiHintBoxModule
  });
  TuiHintBoxModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiHoveredModule]]
  });
  return TuiHintBoxModule;
})();
let TuiHintsHostModule = /*#__PURE__*/(() => {
  let TuiHintsHostModule = class TuiHintsHostModule {};
  TuiHintsHostModule.ɵfac = function TuiHintsHostModule_Factory(t) {
    return new (t || TuiHintsHostModule)();
  };
  TuiHintsHostModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiHintsHostModule
  });
  TuiHintsHostModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiHintBoxModule, TuiActiveZoneModule]]
  });
  return TuiHintsHostModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiHintBoxModule, {
    declarations: function () {
      return [TuiHintBoxComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiHoveredModule];
    },
    exports: function () {
      return [TuiHintBoxComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiHintsHostModule, {
    declarations: function () {
      return [TuiHintsHostComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, TuiHintBoxModule, TuiActiveZoneModule];
    },
    exports: function () {
      return [TuiHintsHostComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-hints-host.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-exceptions.js
var taiga_ui_cdk_exceptions = __webpack_require__(7788);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-utils-polyfills.js


/**
 * @deprecated
 * TODO: remove in v3.0
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function innerHTML(documentRef) {
  const svg = documentRef.createElementNS(`http://www.w3.org/2000/svg`, `svg`);
  if (svg.innerHTML !== undefined) {
    return;
  }
  const serializer = new XMLSerializer();
  const parser = new DOMParser();
  Object.defineProperty(SVGElement.prototype, `innerHTML`, {
    get() {
      const result = [];
      let childNode = this.firstChild;
      while (childNode) {
        result.push(serializer.serializeToString(childNode));
        childNode = childNode.nextSibling;
      }
      return result.join(``);
    },
    set(text) {
      while (this.firstChild) {
        this.removeChild(this.firstChild);
      }
      try {
        const svgDocElement = parser.parseFromString(text, `image/svg+xml`).documentElement;
        if (this.ownerDocument) {
          this.appendChild(this.ownerDocument.importNode(svgDocElement, true));
        }
      } catch (e) {
        throw new taiga_ui_cdk_exceptions/* TuiXmlParsingException */.gW();
      }
    }
  });
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-utils-polyfills.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-internal-svg-defs-host.js








// @dynamic




function TuiSvgDefsHostComponent__svg_ng_container_1__svg_defs_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵnamespaceSVG"]();
    core_js_["ɵɵelement"](0, "defs", 4);
  }
  if (rf & 2) {
    const def_r4 = ctx.$implicit;
    core_js_["ɵɵproperty"]("innerHTML", def_r4, core_js_["ɵɵsanitizeHtml"]);
  }
}
function TuiSvgDefsHostComponent__svg_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵnamespaceSVG"]();
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiSvgDefsHostComponent__svg_ng_container_1__svg_defs_1_Template, 1, 1, "defs", 3);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", ctx_r0.items);
  }
}
function TuiSvgDefsHostComponent__svg_ng_template_2__svg_defs_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵnamespaceSVG"]();
    core_js_["ɵɵelementStart"](0, "defs");
    core_js_["ɵɵelement"](1, "svg", 6);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const def_r6 = ctx.$implicit;
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("outerHTML", def_r6, core_js_["ɵɵsanitizeHtml"]);
  }
}
function TuiSvgDefsHostComponent__svg_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵnamespaceSVG"]();
    core_js_["ɵɵtemplate"](0, TuiSvgDefsHostComponent__svg_ng_template_2__svg_defs_0_Template, 2, 1, "defs", 5);
  }
  if (rf & 2) {
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("ngForOf", ctx_r2.items);
  }
}
let TuiSvgDefsHostComponent = /*#__PURE__*/(() => {
  let TuiSvgDefsHostComponent = class TuiSvgDefsHostComponent {
    constructor(documentRef, svgService, changeDetectorRef, destroy$, platformId) {
      this.svgService = svgService;
      this.changeDetectorRef = changeDetectorRef;
      this.destroy$ = destroy$;
      this.isBrowser = true;
      this.isBrowser = !(0,common_js_.isPlatformServer)(platformId);
      innerHTML(documentRef);
    }
    // @bad TODO: Looks like it could be async piped but it was probably written like that for a reason
    ngOnInit() {
      this.svgService.items$.pipe((0,operators_takeUntil/* takeUntil */.R)(this.destroy$)).subscribe(defsMap => {
        this.items = defsMap.values();
        this.changeDetectorRef.detectChanges();
      });
    }
  };
  TuiSvgDefsHostComponent.ɵfac = function TuiSvgDefsHostComponent_Factory(t) {
    return new (t || TuiSvgDefsHostComponent)(core_js_["ɵɵdirectiveInject"](common_js_.DOCUMENT), core_js_["ɵɵdirectiveInject"](taiga_ui_core_services/* TuiSvgService */.K5), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3), core_js_["ɵɵdirectiveInject"](core_js_.PLATFORM_ID));
  };
  TuiSvgDefsHostComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiSvgDefsHostComponent,
    selectors: [["tui-svg-defs-host"]],
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])],
    decls: 4,
    vars: 2,
    consts: [["version", "1.1", "xmlns", "http://www.w3.org/2000/svg", 0, "xmlns", "xlink", "http://www.w3.org/1999/xlink"], [4, "ngIf", "ngIfElse"], ["server", ""], [3, "innerHTML", 4, "ngFor", "ngForOf"], [3, "innerHTML"], [4, "ngFor", "ngForOf"], [3, "outerHTML"]],
    template: function TuiSvgDefsHostComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵnamespaceSVG"]();
        core_js_["ɵɵelementStart"](0, "svg", 0);
        core_js_["ɵɵtemplate"](1, TuiSvgDefsHostComponent__svg_ng_container_1_Template, 2, 1, "ng-container", 1);
        core_js_["ɵɵtemplate"](2, TuiSvgDefsHostComponent__svg_ng_template_2_Template, 1, 1, "ng-template", null, 2, core_js_["ɵɵtemplateRefExtractor"]);
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        const _r1 = core_js_["ɵɵreference"](3);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.isBrowser)("ngIfElse", _r1);
      }
    },
    directives: [common_js_.NgIf, common_js_.NgForOf],
    styles: ["[_nghost-%COMP%]{display:none}"],
    changeDetection: 0
  });
  TuiSvgDefsHostComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(common_js_.DOCUMENT)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_core_services/* TuiSvgService */.K5)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(core_js_.PLATFORM_ID))], TuiSvgDefsHostComponent);
  return TuiSvgDefsHostComponent;
})();
let TuiSvgDefsHostModule = /*#__PURE__*/(() => {
  let TuiSvgDefsHostModule = class TuiSvgDefsHostModule {};
  TuiSvgDefsHostModule.ɵfac = function TuiSvgDefsHostModule_Factory(t) {
    return new (t || TuiSvgDefsHostModule)();
  };
  TuiSvgDefsHostModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiSvgDefsHostModule
  });
  TuiSvgDefsHostModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, taiga_ui_cdk_directives_let/* TuiLetModule */.WD]]
  });
  return TuiSvgDefsHostModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiSvgDefsHostModule, {
    declarations: function () {
      return [TuiSvgDefsHostComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, taiga_ui_cdk_directives_let/* TuiLetModule */.WD];
    },
    exports: function () {
      return [TuiSvgDefsHostComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-internal-svg-defs-host.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-root.js













// @dynamic







function TuiRootComponent_tui_scroll_controls_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-scroll-controls", 2);
  }
}
const taiga_ui_core_components_root_c0 = ["*", [["tuiOverContent"]], [["tuiOverDialogs"]], [["tuiOverAlerts"]], [["tuiOverNotifications"]], [["tuiOverPortals"]], [["tuiOverHints"]]];
const taiga_ui_core_components_root_c1 = ["*", "tuiOverContent", "tuiOverDialogs", "tuiOverAlerts", "tuiOverNotifications", "tuiOverPortals", "tuiOverHints"];
let TuiRootComponent = /*#__PURE__*/(() => {
  let TuiRootComponent = class TuiRootComponent {
    constructor(duration, elementRef, dialogs, isMobile, enabled, isMobileRes$, {
      body
    }, theme) {
      this.duration = duration;
      this.elementRef = elementRef;
      this.dialogs = dialogs;
      this.isMobile = isMobile;
      this.isMobileRes$ = isMobileRes$;
      this.scrollbars$ = this.dialogs.length && !this.isMobile ? (0,combineLatest/* combineLatest */.aj)([...this.dialogs]).pipe((0,operators_map/* map */.U)(dialogs => !dialogs.some(({
        length
      }) => length))) : (0,observable_of.of)(!this.isMobile);
      taiga_ui_cdk_classes/* tuiAssert */.zU.enabled = enabled;
      body.setAttribute('data-tui-theme', theme.toLowerCase());
    }
  };
  TuiRootComponent.ɵfac = function TuiRootComponent_Factory(t) {
    return new (t || TuiRootComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_ANIMATIONS_DURATION */.dx), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_DIALOGS */.qY), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_ASSERT_ENABLED */.uW), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_IS_MOBILE_RES */.rL), core_js_["ɵɵdirectiveInject"](common_js_.DOCUMENT), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_THEME */.r2));
  };
  TuiRootComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiRootComponent,
    selectors: [["tui-root"]],
    hostAttrs: ["data-tui-version", "2.99.0"],
    hostVars: 2,
    hostBindings: function TuiRootComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("$.class._mobile", function TuiRootComponent___class__mobile_HostBindingHandler() {
          return ctx.isMobileRes$;
        });
      }
      if (rf & 2) {
        core_js_["ɵɵstyleProp"]("--tui-duration", ctx.duration + "ms");
      }
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_core_providers/* TUI_IS_MOBILE_RES_PROVIDER */.yI])],
    ngContentSelectors: taiga_ui_core_components_root_c1,
    decls: 15,
    vars: 3,
    consts: [["class", "t-scrollbar", 4, "ngIf"], [1, "t-content"], [1, "t-scrollbar"]],
    template: function TuiRootComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"](taiga_ui_core_components_root_c0);
        core_js_["ɵɵtemplate"](0, TuiRootComponent_tui_scroll_controls_0_Template, 1, 0, "tui-scroll-controls", 0);
        core_js_["ɵɵpipe"](1, "async");
        core_js_["ɵɵelement"](2, "tui-svg-defs-host");
        core_js_["ɵɵelementStart"](3, "tui-dropdown-host");
        core_js_["ɵɵelementStart"](4, "div", 1);
        core_js_["ɵɵprojection"](5);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵprojection"](6, 1);
        core_js_["ɵɵelement"](7, "tui-dialog-host");
        core_js_["ɵɵprojection"](8, 2);
        core_js_["ɵɵelement"](9, "tui-alert-host");
        core_js_["ɵɵprojection"](10, 3);
        core_js_["ɵɵprojection"](11, 4);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵprojection"](12, 5);
        core_js_["ɵɵelement"](13, "tui-hints-host");
        core_js_["ɵɵprojection"](14, 6);
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngIf", core_js_["ɵɵpipeBind1"](1, 1, ctx.scrollbars$));
      }
    },
    directives: [common_js_.NgIf, TuiSvgDefsHostComponent, TuiDropdownHostComponent, TuiDialogHostComponent, TuiAlertHostComponent, TuiHintsHostComponent, TuiScrollControlsComponent],
    pipes: [common_js_.AsyncPipe],
    styles: ["@keyframes tuiPresent{to{content:'1'}}[_nghost-%COMP%]{position:relative;display:block;flex:1;-webkit-tap-highlight-color:transparent}.t-scrollbar[_ngcontent-%COMP%]{position:fixed;top:0;left:0;bottom:0;right:0;margin:0}.t-content[_ngcontent-%COMP%]{position:relative;z-index:0;height:100%}"],
    changeDetection: 0
  });
  TuiRootComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_ANIMATIONS_DURATION */.dx)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_DIALOGS */.qY)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_ASSERT_ENABLED */.uW)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_IS_MOBILE_RES */.rL)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(common_js_.DOCUMENT)), (0,tslib_es6/* __param */.fM)(7, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_THEME */.r2))], TuiRootComponent);
  return TuiRootComponent;
})();
let TuiRootModule = /*#__PURE__*/(() => {
  let TuiRootModule = class TuiRootModule {};
  TuiRootModule.ɵfac = function TuiRootModule_Factory(t) {
    return new (t || TuiRootModule)();
  };
  TuiRootModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiRootModule
  });
  TuiRootModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, EventPluginsModule, TuiDragModule, TuiDropdownHostModule, TuiSvgDefsHostModule, TuiHintsHostModule, TuiDialogHostModule, TuiAlertHostModule, TuiScrollControlsModule]]
  });
  return TuiRootModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiRootModule, {
    declarations: function () {
      return [TuiRootComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, EventPluginsModule, TuiDragModule, TuiDropdownHostModule, TuiSvgDefsHostModule, TuiHintsHostModule, TuiDialogHostModule, TuiAlertHostModule, TuiScrollControlsModule];
    },
    exports: function () {
      return [TuiRootComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-root.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-components-dialog.js



















function TuiDialogComponent_header_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "header", 5);
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("content", ctx_r0.header)("context", ctx_r0.context);
  }
}
function TuiDialogComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵtext"](0);
    core_js_["ɵɵelementStart"](1, "div", 6);
    core_js_["ɵɵelementStart"](2, "button", 7);
    core_js_["ɵɵlistener"]("click", function TuiDialogComponent_ng_template_4_Template_button_click_2_listener() {
      core_js_["ɵɵrestoreView"](_r5);
      const ctx_r4 = core_js_["ɵɵnextContext"]();
      return ctx_r4.context.$implicit.complete();
    });
    core_js_["ɵɵtext"](3);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const text_r3 = ctx.$implicit;
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    let tmp_1_0;
    core_js_["ɵɵtextInterpolate1"](" ", text_r3, " ");
    core_js_["ɵɵadvance"](3);
    core_js_["ɵɵtextInterpolate1"](" ", ((tmp_1_0 = ctx_r1.context.data) == null ? null : tmp_1_0.button) || "OK", " ");
  }
}
function TuiDialogComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "div", 8);
    core_js_["ɵɵelementStart"](1, "button", 9);
    core_js_["ɵɵlistener"]("click", function TuiDialogComponent_div_5_Template_button_click_1_listener() {
      core_js_["ɵɵrestoreView"](_r7);
      const ctx_r6 = core_js_["ɵɵnextContext"]();
      return ctx_r6.close();
    });
    core_js_["ɵɵpipe"](2, "async");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("title", core_js_["ɵɵpipeBind1"](2, 1, ctx_r2.closeWord$));
  }
}
const TUI_DIALOGS_CLOSE = new core_js_.InjectionToken(`A stream to close dialogs`, {
  factory: () => observable_empty/* EMPTY */.E
});
const SCROLLBAR_PLACEHOLDER = 17;
// eslint-disable-next-line @typescript-eslint/naming-convention
function dialogCloseStreamFactory(documentRef, windowRef, {
  nativeElement
}, close$, destroy$, {
  dismissible
}) {
  return dismissible ? (0,observable_merge/* merge */.T)((0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, `click`).pipe((0,operators_filter/* filter */.h)(taiga_ui_cdk_utils_dom/* isCurrentTarget */.Xr)), (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(documentRef, `keydown`).pipe((0,operators_filter/* filter */.h)(event => {
    const key = event.key;
    const target = (0,taiga_ui_cdk_utils_dom/* getActualTarget */.Bq)(event);
    return key === `Escape` && (0,taiga_ui_cdk_utils_dom/* tuiIsElement */.ve)(target) && (!(0,taiga_ui_cdk_utils_dom/* tuiContainsOrAfter */.PP)(nativeElement, target) || nativeElement.contains(target));
  })), (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(documentRef, `mousedown`).pipe((0,operators_filter/* filter */.h)(event => {
    const target = (0,taiga_ui_cdk_utils_dom/* getActualTarget */.Bq)(event);
    const clientX = event.clientX;
    return (0,taiga_ui_cdk_utils_dom/* tuiIsElement */.ve)(target) && (0,taiga_ui_core_utils_dom/* tuiGetViewportWidth */.ic)(windowRef) - clientX > SCROLLBAR_PLACEHOLDER && !(0,taiga_ui_cdk_utils_dom/* tuiContainsOrAfter */.PP)(nativeElement, target);
  }), (0,operators_switchMap/* switchMap */.w)(() => (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(documentRef, `mouseup`).pipe((0,operators_take/* take */.q)(1), (0,operators_filter/* filter */.h)(event => {
    const target = (0,taiga_ui_cdk_utils_dom/* getActualTarget */.Bq)(event);
    return (0,taiga_ui_cdk_utils_dom/* tuiIsElement */.ve)(target) && !(0,taiga_ui_cdk_utils_dom/* tuiContainsOrAfter */.PP)(nativeElement, target);
  })))), close$).pipe((0,operators_takeUntil/* takeUntil */.R)(destroy$)) : close$;
}
const TUI_DIALOG_CLOSE_STREAM = new core_js_.InjectionToken(`Dialogs closing stream`);
const TUI_DIALOG_PROVIDERS = [taiga_ui_cdk_services/* TuiDestroyService */.a3, {
  provide: TUI_DIALOG_CLOSE_STREAM,
  deps: [common_js_.DOCUMENT, ng_web_apis_common/* WINDOW */.m9, core_js_.ElementRef, TUI_DIALOGS_CLOSE, taiga_ui_cdk_services/* TuiDestroyService */.a3, tinkoff_ng_polymorpheus/* POLYMORPHEUS_CONTEXT */.yf],
  useFactory: dialogCloseStreamFactory
}];
const REQUIRED_ERROR = new Error('Required dialog was dismissed');
// @dynamic
let TuiDialogComponent = /*#__PURE__*/(() => {
  let TuiDialogComponent = class TuiDialogComponent {
    constructor(duration, isMobile, context, close$, closeWord$) {
      this.duration = duration;
      this.isMobile = isMobile;
      this.context = context;
      this.closeWord$ = closeWord$;
      this.animation = {
        value: '',
        params: {
          start: '40px',
          duration: this.duration
        }
      };
      this.fullscreenAnimation = {
        value: '',
        params: {
          start: '100vh',
          duration: this.duration
        }
      };
      close$.subscribe(() => {
        this.close();
      });
    }
    get size() {
      return this.context.size;
    }
    get header() {
      return this.context.header;
    }
    get slideInTop() {
      return this.size === 'fullscreen' || this.size === 'page' || this.isMobile ? this.fullscreenAnimation : this.animation;
    }
    close() {
      if (this.context.required) {
        this.context.$implicit.error(REQUIRED_ERROR);
      } else {
        this.context.$implicit.complete();
      }
    }
  };
  TuiDialogComponent.ɵfac = function TuiDialogComponent_Factory(t) {
    return new (t || TuiDialogComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_ANIMATIONS_DURATION */.dx), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL), core_js_["ɵɵdirectiveInject"](tinkoff_ng_polymorpheus/* POLYMORPHEUS_CONTEXT */.yf), core_js_["ɵɵdirectiveInject"](TUI_DIALOG_CLOSE_STREAM), core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_CLOSE_WORD */.U0));
  };
  TuiDialogComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDialogComponent,
    selectors: [["tui-dialog"]],
    hostVars: 5,
    hostBindings: function TuiDialogComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵattribute"]("data-size", ctx.size);
        core_js_["ɵɵsyntheticHostProperty"]("@tuiSlideInTop", ctx.slideInTop)("@tuiFadeIn", ctx.slideInTop);
        core_js_["ɵɵclassProp"]("_centered", ctx.header);
      }
    },
    features: [core_js_["ɵɵProvidersFeature"](TUI_DIALOG_PROVIDERS)],
    decls: 6,
    vars: 6,
    consts: [["polymorpheus-outlet", "", "class", "t-header", 3, "content", "context", 4, "ngIf"], [1, "t-content"], [1, "t-heading", 3, "id", "textContent"], ["polymorpheus-outlet", "", 3, "context", "content"], ["class", "t-wrapper", 4, "ngIf"], ["polymorpheus-outlet", "", 1, "t-header", 3, "content", "context"], [1, "t-buttons"], ["tuiButton", "", "size", "m", 3, "click"], [1, "t-wrapper"], ["tuiIconButton", "", "tuiPreventDefault", "mousedown", "automation-id", "tui-dialog__close", "size", "s", "appearance", "", "icon", "tuiIconCloseLarge", "shape", "rounded", 1, "t-close", 3, "title", "click"]],
    template: function TuiDialogComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵtemplate"](0, TuiDialogComponent_header_0_Template, 1, 2, "header", 0);
        core_js_["ɵɵelementStart"](1, "div", 1);
        core_js_["ɵɵelement"](2, "h2", 2);
        core_js_["ɵɵelementStart"](3, "section", 3);
        core_js_["ɵɵtemplate"](4, TuiDialogComponent_ng_template_4_Template, 4, 2, "ng-template");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](5, TuiDialogComponent_div_5_Template, 3, 3, "div", 4);
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngIf", ctx.header);
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵproperty"]("id", ctx.context.id)("textContent", ctx.context.label);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("context", ctx.context)("content", ctx.context.content);
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵproperty"]("ngIf", ctx.context.closeable);
      }
    },
    directives: [common_js_.NgIf, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, taiga_ui_core_components_button/* TuiButtonComponent */.v0, TuiPreventDefaultDirective],
    pipes: [common_js_.AsyncPipe],
    styles: ["[_nghost-%COMP%]{position:relative;display:flex;font:var(--tui-font-text-m);flex-direction:column;box-sizing:border-box;margin:auto;border-radius:1rem;border:2.5rem solid transparent}[_nghost-%COMP%]:after{position:absolute;top:0;left:0;width:100%;height:100%;box-shadow:0 1.125rem 1.875rem rgba(0,0,0,.48);content:'';border-radius:inherit;pointer-events:none}[data-size=auto][_nghost-%COMP%]{width:auto}[data-size='s'][_nghost-%COMP%]{width:30rem}[data-size='s'][_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{padding:1.5rem}[data-size='s'][_nghost-%COMP%]   .t-heading[_ngcontent-%COMP%]{margin-bottom:.5rem;font:var(--tui-font-heading-5)}[data-size='m'][_nghost-%COMP%]{width:42.5rem}[data-size='m'][_nghost-%COMP%]   .t-heading[_ngcontent-%COMP%]{margin-bottom:.75rem;font:var(--tui-font-heading-4)}[data-size='l'][_nghost-%COMP%]{width:55rem}[data-size='l'][_nghost-%COMP%]   .t-heading[_ngcontent-%COMP%]{margin-bottom:1rem}[data-size=fullscreen][_nghost-%COMP%], [data-size=page][_nghost-%COMP%]{width:100%;min-height:100%;border-radius:0;border:none;background:var(--tui-elevation-01);box-shadow:0 4rem var(--tui-base-01)}[data-size=fullscreen][_nghost-%COMP%]   .t-content[_ngcontent-%COMP%], [data-size=page][_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{padding:3rem calc(50vw - (45rem / 2))}[data-size=fullscreen][_nghost-%COMP%]   .t-heading[_ngcontent-%COMP%], [data-size=page][_nghost-%COMP%]   .t-heading[_ngcontent-%COMP%]{margin-bottom:1rem}[data-size=page][_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{padding:0}._centered[_nghost-%COMP%]{text-align:center}[_nghost-%COMP%]   tui-root._mobile[data-size][_nghost-%COMP%], tui-root._mobile   [data-size][_nghost-%COMP%]{min-width:100%;width:100%;max-width:100%;border-radius:0;border:none;margin:auto 0 0}[_nghost-%COMP%]   tui-root._mobile[data-size][_nghost-%COMP%]   .t-content[_ngcontent-%COMP%], tui-root._mobile   [data-size][_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{padding:1.5rem}[_nghost-%COMP%]   tui-root._mobile[data-size][_nghost-%COMP%]   .t-heading[_ngcontent-%COMP%], tui-root._mobile   [data-size][_nghost-%COMP%]   .t-heading[_ngcontent-%COMP%]{margin-bottom:.5rem;font:var(--tui-font-heading-5)}.t-heading[_ngcontent-%COMP%]{margin:0;word-wrap:break-word;font:var(--tui-font-heading-3)}.t-heading[_ngcontent-%COMP%]:empty{display:none}.t-header[_ngcontent-%COMP%]{display:flex;border-top-left-radius:inherit;border-top-right-radius:inherit;overflow:hidden}[data-size=fullscreen][_nghost-%COMP%]   tui-root._mobile[_nghost-%COMP%]   .t-header[_ngcontent-%COMP%], tui-root._mobile   [_nghost-%COMP%]   .t-header[_ngcontent-%COMP%]{flex:1}.t-content[_ngcontent-%COMP%]{border-radius:inherit;padding:2rem;background:var(--tui-base-01)}.t-content[_ngcontent-%COMP%]:not(:first-child){border-top-left-radius:0;border-top-right-radius:0}.t-wrapper[_ngcontent-%COMP%]{position:-webkit-sticky;position:sticky;top:0;order:-1}.t-close[_ngcontent-%COMP%]{transition-property:background;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;position:fixed;top:1.5rem;right:1.5rem;color:var(--tui-base-01);background:rgba(104,104,104,.96)}.t-close[_ngcontent-%COMP%]:hover{background:rgba(159,159,159,.86)}[_nghost-%COMP%]:not([data-size=fullscreen])   .t-close[_ngcontent-%COMP%]{animation:tuiFadeIn var(--tui-duration)}[_nghost-%COMP%]:not([data-size=fullscreen]).ng-animating   .t-close[_ngcontent-%COMP%]{display:none}tui-root._mobile[_nghost-%COMP%]   .t-close[_ngcontent-%COMP%], tui-root._mobile   [_nghost-%COMP%]   .t-close[_ngcontent-%COMP%]{position:absolute;top:0;right:0;background:0 0;color:var(--tui-base-06)}tui-root._mobile[_nghost-%COMP%]   .t-close[_ngcontent-%COMP%]:hover, tui-root._mobile   [_nghost-%COMP%]   .t-close[_ngcontent-%COMP%]:hover{color:var(--tui-base-07)}.t-buttons[_ngcontent-%COMP%]{margin-top:1.25rem;text-align:right}"],
    data: {
      animation: [tuiSlideInTop, tuiFadeIn]
    },
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('attr.data-size')], TuiDialogComponent.prototype, "size", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._centered')], TuiDialogComponent.prototype, "header", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('@tuiSlideInTop'), (0,core_js_.HostBinding)('@tuiFadeIn')], TuiDialogComponent.prototype, "slideInTop", null);
  TuiDialogComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_ANIMATIONS_DURATION */.dx)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(tinkoff_ng_polymorpheus/* POLYMORPHEUS_CONTEXT */.yf)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TUI_DIALOG_CLOSE_STREAM)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_CLOSE_WORD */.U0))], TuiDialogComponent);
  return TuiDialogComponent;
})();
const DIALOG = new tinkoff_ng_polymorpheus/* PolymorpheusComponent */.Al(TuiDialogComponent);
const DEFAULT_OPTIONS = {
  size: `m`,
  required: false,
  closeable: true,
  dismissible: true,
  label: ``,
  header: ``
};
let TuiDialogService = /*#__PURE__*/(() => {
  let TuiDialogService = class TuiDialogService extends taiga_ui_cdk_abstract/* AbstractTuiDialogService */.d5 {
    constructor() {
      super(...arguments);
      this.component = DIALOG;
      this.defaultOptions = DEFAULT_OPTIONS;
    }
  };
  TuiDialogService.ɵfac = /*@__PURE__*/function () {
    let ɵTuiDialogService_BaseFactory;
    return function TuiDialogService_Factory(t) {
      return (ɵTuiDialogService_BaseFactory || (ɵTuiDialogService_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiDialogService)))(t || TuiDialogService);
    };
  }();
  TuiDialogService.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function TuiDialogService_Factory() {
      return new TuiDialogService((0,core_js_["ɵɵinject"])(taiga_ui_cdk_services/* TuiIdService */.ll));
    },
    token: TuiDialogService,
    providedIn: "root"
  });
  return TuiDialogService;
})();
let TuiDialogDirective = /*#__PURE__*/(() => {
  let TuiDialogDirective = class TuiDialogDirective extends taiga_ui_cdk_abstract/* AbstractTuiDialogDirective */.LF {};
  TuiDialogDirective.ɵfac = /*@__PURE__*/function () {
    let ɵTuiDialogDirective_BaseFactory;
    return function TuiDialogDirective_Factory(t) {
      return (ɵTuiDialogDirective_BaseFactory || (ɵTuiDialogDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiDialogDirective)))(t || TuiDialogDirective);
    };
  }();
  TuiDialogDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiDialogDirective,
    selectors: [["ng-template", "tuiDialog", ""]],
    inputs: {
      options: ["tuiDialogOptions", "options"],
      open: ["tuiDialog", "open"]
    },
    outputs: {
      openChange: "tuiDialogChange"
    },
    features: [core_js_["ɵɵProvidersFeature"]([{
      provide: taiga_ui_cdk_abstract/* AbstractTuiDialogService */.d5,
      useExisting: TuiDialogService
    }]), core_js_["ɵɵInheritDefinitionFeature"]]
  });
  return TuiDialogDirective;
})();
let TuiDialogModule = /*#__PURE__*/(() => {
  let TuiDialogModule = class TuiDialogModule {};
  TuiDialogModule.ɵfac = function TuiDialogModule_Factory(t) {
    return new (t || TuiDialogModule)();
  };
  TuiDialogModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDialogModule
  });
  TuiDialogModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    providers: [{
      provide: taiga_ui_cdk_tokens/* TUI_DIALOGS */.qY,
      useExisting: TuiDialogService,
      multi: true
    }],
    imports: [[tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_button/* TuiButtonModule */.fN, common_js_.CommonModule, TuiPreventDefaultModule]]
  });
  return TuiDialogModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDialogModule, {
    declarations: function () {
      return [TuiDialogComponent, TuiDialogDirective];
    },
    imports: function () {
      return [tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_button/* TuiButtonModule */.fN, common_js_.CommonModule, TuiPreventDefaultModule];
    },
    exports: function () {
      return [TuiDialogComponent, TuiDialogDirective];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-dialog.js.map
;// CONCATENATED MODULE: ./node_modules/@angular/cdk/fesm2015/clipboard.js





/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A pending copy-to-clipboard operation.
 *
 * The implementation of copying text to the clipboard modifies the DOM and
 * forces a relayout. This relayout can take too long if the string is large,
 * causing the execCommand('copy') to happen too long after the user clicked.
 * This results in the browser refusing to copy. This object lets the
 * relayout happen in a separate tick from copying by providing a copy function
 * that can be called later.
 *
 * Destroy must be called when no longer in use, regardless of whether `copy` is
 * called.
 */

class PendingCopy {
  constructor(text, _document) {
    this._document = _document;
    const textarea = this._textarea = this._document.createElement('textarea');
    const styles = textarea.style;
    // Hide the element for display and accessibility. Set a fixed position so the page layout
    // isn't affected. We use `fixed` with `top: 0`, because focus is moved into the textarea
    // for a split second and if it's off-screen, some browsers will attempt to scroll it into view.
    styles.position = 'fixed';
    styles.top = styles.opacity = '0';
    styles.left = '-999em';
    textarea.setAttribute('aria-hidden', 'true');
    textarea.value = text;
    this._document.body.appendChild(textarea);
  }
  /** Finishes copying the text. */
  copy() {
    const textarea = this._textarea;
    let successful = false;
    try {
      // Older browsers could throw if copy is not supported.
      if (textarea) {
        const currentFocus = this._document.activeElement;
        textarea.select();
        textarea.setSelectionRange(0, textarea.value.length);
        successful = this._document.execCommand('copy');
        if (currentFocus) {
          currentFocus.focus();
        }
      }
    } catch (_a) {
      // Discard error.
      // Initial setting of {@code successful} will represent failure here.
    }
    return successful;
  }
  /** Cleans up DOM changes used to perform the copy operation. */
  destroy() {
    const textarea = this._textarea;
    if (textarea) {
      if (textarea.parentNode) {
        textarea.parentNode.removeChild(textarea);
      }
      this._textarea = undefined;
    }
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A service for copying text to the clipboard.
 */
let Clipboard = /*#__PURE__*/(() => {
  class Clipboard {
    constructor(document) {
      this._document = document;
    }
    /**
     * Copies the provided text into the user's clipboard.
     *
     * @param text The string to copy.
     * @returns Whether the operation was successful.
     */
    copy(text) {
      const pendingCopy = this.beginCopy(text);
      const successful = pendingCopy.copy();
      pendingCopy.destroy();
      return successful;
    }
    /**
     * Prepares a string to be copied later. This is useful for large strings
     * which take too long to successfully render and be copied in the same tick.
     *
     * The caller must call `destroy` on the returned `PendingCopy`.
     *
     * @param text The string to copy.
     * @returns the pending copy operation.
     */
    beginCopy(text) {
      return new PendingCopy(text, this._document);
    }
  }
  Clipboard.ɵfac = function Clipboard_Factory(t) {
    return new (t || Clipboard)(core_js_["ɵɵinject"](common_js_.DOCUMENT));
  };
  Clipboard.ɵprov = core_js_["ɵɵdefineInjectable"]({
    factory: function Clipboard_Factory() {
      return new Clipboard(core_js_["ɵɵinject"](common_js_.DOCUMENT));
    },
    token: Clipboard,
    providedIn: "root"
  });
  return Clipboard;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/** Injection token that can be used to provide the default options to `CdkCopyToClipboard`. */
const CDK_COPY_TO_CLIPBOARD_CONFIG = /*#__PURE__*/new core_js_.InjectionToken('CDK_COPY_TO_CLIPBOARD_CONFIG');
/**
 * @deprecated Use `CDK_COPY_TO_CLIPBOARD_CONFIG` instead.
 * @breaking-change 13.0.0
 */
const CKD_COPY_TO_CLIPBOARD_CONFIG = CDK_COPY_TO_CLIPBOARD_CONFIG;
/**
 * Provides behavior for a button that when clicked copies content into user's
 * clipboard.
 */
let CdkCopyToClipboard = /*#__PURE__*/(() => {
  class CdkCopyToClipboard {
    constructor(_clipboard, _ngZone, config) {
      this._clipboard = _clipboard;
      this._ngZone = _ngZone;
      /** Content to be copied. */
      this.text = '';
      /**
       * How many times to attempt to copy the text. This may be necessary for longer text, because
       * the browser needs time to fill an intermediate textarea element and copy the content.
       */
      this.attempts = 1;
      /**
       * Emits when some text is copied to the clipboard. The
       * emitted value indicates whether copying was successful.
       */
      this.copied = new core_js_.EventEmitter();
      /** Copies that are currently being attempted. */
      this._pending = new Set();
      if (config && config.attempts != null) {
        this.attempts = config.attempts;
      }
    }
    /** Copies the current text to the clipboard. */
    copy(attempts = this.attempts) {
      if (attempts > 1) {
        let remainingAttempts = attempts;
        const pending = this._clipboard.beginCopy(this.text);
        this._pending.add(pending);
        const attempt = () => {
          const successful = pending.copy();
          if (!successful && --remainingAttempts && !this._destroyed) {
            // We use 1 for the timeout since it's more predictable when flushing in unit tests.
            this._currentTimeout = this._ngZone.runOutsideAngular(() => setTimeout(attempt, 1));
          } else {
            this._currentTimeout = null;
            this._pending.delete(pending);
            pending.destroy();
            this.copied.emit(successful);
          }
        };
        attempt();
      } else {
        this.copied.emit(this._clipboard.copy(this.text));
      }
    }
    ngOnDestroy() {
      if (this._currentTimeout) {
        clearTimeout(this._currentTimeout);
      }
      this._pending.forEach(copy => copy.destroy());
      this._pending.clear();
      this._destroyed = true;
    }
  }
  CdkCopyToClipboard.ɵfac = function CdkCopyToClipboard_Factory(t) {
    return new (t || CdkCopyToClipboard)(core_js_["ɵɵdirectiveInject"](Clipboard), core_js_["ɵɵdirectiveInject"](core_js_.NgZone), core_js_["ɵɵdirectiveInject"](CKD_COPY_TO_CLIPBOARD_CONFIG, 8));
  };
  CdkCopyToClipboard.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: CdkCopyToClipboard,
    selectors: [["", "cdkCopyToClipboard", ""]],
    hostBindings: function CdkCopyToClipboard_HostBindings(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵlistener"]("click", function CdkCopyToClipboard_click_HostBindingHandler() {
          return ctx.copy();
        });
      }
    },
    inputs: {
      text: ["cdkCopyToClipboard", "text"],
      attempts: ["cdkCopyToClipboardAttempts", "attempts"]
    },
    outputs: {
      copied: "cdkCopyToClipboardCopied"
    }
  });
  return CdkCopyToClipboard;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
let ClipboardModule = /*#__PURE__*/(() => {
  class ClipboardModule {}
  ClipboardModule.ɵfac = function ClipboardModule_Factory(t) {
    return new (t || ClipboardModule)();
  };
  ClipboardModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: ClipboardModule
  });
  ClipboardModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return ClipboardModule;
})();
/*#__PURE__*/(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
/*#__PURE__*/(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](ClipboardModule, {
    declarations: [CdkCopyToClipboard],
    exports: [CdkCopyToClipboard]
  });
})();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=clipboard.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/i18n/fesm2015/taiga-ui-i18n-tokens.js


// @note: cannot be transferred to a shared file
// ReferenceError: Cannot access 'TUI_LANGUAGE_LOADER' before initialization
const taiga_ui_i18n_tokens_TUI_LANGUAGE_LOADER = new core_js_.InjectionToken(`Webpack chunk loader for Taiga UI libraries i18n`);
const TUI_LANGUAGE_STORAGE_KEY = new core_js_.InjectionToken(`Default key for search value in storage`, {
  factory: () => `tuiLanguage`
});

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-i18n-tokens.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/from.js + 6 modules
var observable_from = __webpack_require__(4402);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/i18n/fesm2015/taiga-ui-i18n-switch.js








function tuiAsyncLoadLanguage(language, loader, fallback) {
  return language && loader ? tuiLoadLanguage(language, loader) : (0,observable_of.of)(fallback);
}
function tuiLoadLanguage(language, loader) {
  return (0,observable_from/* from */.D)(normalizeCommonJSImport(loader(language))).pipe((0,operators_map/* map */.U)(module => module === null || module === void 0 ? void 0 : module[`TUI_${language.toUpperCase()}_LANGUAGE`]));
}
// CommonJS `module.exports` is wrapped as `default` in ESModule.
function normalizeCommonJSImport(importPromise) {
  return (0,tslib_es6/* __awaiter */.mG)(this, void 0, void 0, function* () {
    return importPromise.then(m => m.default || m);
  });
}

// @dynamic
let TuiLanguageSwitcher = /*#__PURE__*/(() => {
  let TuiLanguageSwitcher = class TuiLanguageSwitcher extends internal_BehaviorSubject/* BehaviorSubject */.X {
    constructor(fallback, key, storage, loader) {
      super(tuiAsyncLoadLanguage(storage.getItem(key), loader, fallback));
      this.fallback = fallback;
      this.key = key;
      this.storage = storage;
      this.loader = loader;
    }
    get language() {
      return this.storage.getItem(this.key) || this.fallback.name;
    }
    setLanguage(language) {
      this.storage.setItem(this.key, language);
      this.next(tuiAsyncLoadLanguage(language, this.loader, this.fallback));
    }
    clear() {
      this.storage.removeItem(this.key);
      this.next((0,observable_of.of)(this.fallback));
    }
  };
  TuiLanguageSwitcher.ɵfac = function TuiLanguageSwitcher_Factory(t) {
    return new (t || TuiLanguageSwitcher)(core_js_["ɵɵinject"](taiga_ui_i18n_tools/* TUI_DEFAULT_LANGUAGE */.ty), core_js_["ɵɵinject"](TUI_LANGUAGE_STORAGE_KEY), core_js_["ɵɵinject"](ng_web_apis_common/* LOCAL_STORAGE */.H3), core_js_["ɵɵinject"](taiga_ui_i18n_tokens_TUI_LANGUAGE_LOADER, 8));
  };
  TuiLanguageSwitcher.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function TuiLanguageSwitcher_Factory() {
      return new TuiLanguageSwitcher((0,core_js_["ɵɵinject"])(taiga_ui_i18n_tools/* TUI_DEFAULT_LANGUAGE */.ty), (0,core_js_["ɵɵinject"])(TUI_LANGUAGE_STORAGE_KEY), (0,core_js_["ɵɵinject"])(ng_web_apis_common/* LOCAL_STORAGE */.H3), (0,core_js_["ɵɵinject"])(taiga_ui_i18n_tokens_TUI_LANGUAGE_LOADER, 8));
    },
    token: TuiLanguageSwitcher,
    providedIn: "root"
  });
  TuiLanguageSwitcher = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_i18n_tools/* TUI_DEFAULT_LANGUAGE */.ty)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_LANGUAGE_STORAGE_KEY)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(ng_web_apis_common/* LOCAL_STORAGE */.H3)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(taiga_ui_i18n_tokens_TUI_LANGUAGE_LOADER))], TuiLanguageSwitcher);
  return TuiLanguageSwitcher;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
function tuiLanguageSwitcher(loader) {
  return [{
    provide: TUI_LANGUAGE_LOADER,
    useFactory: () => loader
  }, {
    provide: TUI_LANGUAGE,
    useExisting: TuiLanguageSwitcher
  }];
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-i18n-switch.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-mobile/fesm2015/taiga-ui-addon-mobile-directives-sidebar.js








const taiga_ui_addon_mobile_directives_sidebar_c0 = ["tuiSidebar", ""];
let TuiSidebarDirective = /*#__PURE__*/(() => {
  let TuiSidebarDirective = class TuiSidebarDirective extends tinkoff_ng_polymorpheus/* PolymorpheusTemplate */.GL {
    constructor(content, injector, componentFactoryResolver, portalService, changeDetectorRef) {
      super(content, changeDetectorRef);
      this.content = content;
      this.injector = injector;
      this.componentFactoryResolver = componentFactoryResolver;
      this.portalService = portalService;
      this.sidebarRef = null;
      this.direction = 'left';
      this.autoWidth = false;
    }
    set tuiSidebar(open) {
      if (open) {
        this.show();
      } else {
        this.hide();
      }
    }
    ngOnDestroy() {
      this.hide();
    }
    show() {
      if (this.sidebarRef !== null) {
        return;
      }
      const componentFactory = this.componentFactoryResolver.resolveComponentFactory(TuiSidebarComponent);
      this.sidebarRef = this.portalService.add(componentFactory, this.injector);
      this.sidebarRef.changeDetectorRef.detectChanges();
    }
    hide() {
      if (this.sidebarRef === null) {
        return;
      }
      this.portalService.remove(this.sidebarRef);
      this.sidebarRef = null;
    }
  };
  TuiSidebarDirective.ɵfac = function TuiSidebarDirective_Factory(t) {
    return new (t || TuiSidebarDirective)(core_js_["ɵɵdirectiveInject"](core_js_.TemplateRef), core_js_["ɵɵdirectiveInject"](core_js_.Injector), core_js_["ɵɵdirectiveInject"](core_js_.ComponentFactoryResolver), core_js_["ɵɵdirectiveInject"](TuiPortalService), core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef));
  };
  TuiSidebarDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiSidebarDirective,
    selectors: [["", "tuiSidebar", ""]],
    inputs: {
      direction: ["tuiSidebarDirection", "direction"],
      autoWidth: ["tuiSidebarAutoWidth", "autoWidth"],
      tuiSidebar: "tuiSidebar"
    },
    features: [core_js_["ɵɵInheritDefinitionFeature"]]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiSidebarDirection')], TuiSidebarDirective.prototype, "direction", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)('tuiSidebarAutoWidth')], TuiSidebarDirective.prototype, "autoWidth", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiSidebarDirective.prototype, "tuiSidebar", null);
  TuiSidebarDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.TemplateRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.Injector)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.ComponentFactoryResolver)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(TuiPortalService)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(core_js_.ChangeDetectorRef))], TuiSidebarDirective);

  // @dynamic
  return TuiSidebarDirective;
})();
let TuiSidebarComponent = /*#__PURE__*/(() => {
  let TuiSidebarComponent = class TuiSidebarComponent {
    constructor(options, directive) {
      this.options = options;
      this.directive = directive;
      this.left = Object.assign({
        value: 'left'
      }, this.options);
      this.right = Object.assign({
        value: 'right'
      }, this.options);
    }
    get animation() {
      return this.direction === 'left' ? this.left : this.right;
    }
    get directionHostClass() {
      return `t-${this.directive.direction}`;
    }
    get direction() {
      return this.directive.direction;
    }
    get content() {
      return this.directive.content;
    }
    get autoWidth() {
      return this.directive.autoWidth;
    }
    ngDoCheck() {
      this.directive.check();
    }
  };
  TuiSidebarComponent.ɵfac = function TuiSidebarComponent_Factory(t) {
    return new (t || TuiSidebarComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw), core_js_["ɵɵdirectiveInject"](TuiSidebarDirective));
  };
  TuiSidebarComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiSidebarComponent,
    selectors: [["aside", "tuiSidebar", ""]],
    hostVars: 3,
    hostBindings: function TuiSidebarComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵsyntheticHostProperty"]("@tuiSlideIn", ctx.animation);
        core_js_["ɵɵclassMap"](ctx.directionHostClass);
      }
    },
    attrs: taiga_ui_addon_mobile_directives_sidebar_c0,
    decls: 1,
    vars: 3,
    consts: [["polymorpheus-outlet", "", "tuiActiveZone", "", 1, "t-wrapper", 3, "content"]],
    template: function TuiSidebarComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵelement"](0, "div", 0);
      }
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("t-wrapper_auto-width", ctx.autoWidth);
        core_js_["ɵɵproperty"]("content", ctx.content);
      }
    },
    directives: [tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, TuiActiveZoneDirective],
    styles: ["[_nghost-%COMP%]{position:fixed;top:0;left:0;width:100%;height:100%;display:flex}[_nghost-%COMP%]:after, [_nghost-%COMP%]:before{position:absolute;top:0;left:0;width:100%;content:'';height:100%;background:rgba(0,0,0,.38);animation:tuiFadeIn var(--tui-duration)}[_nghost-%COMP%]:before{left:-100%;width:200%}[_nghost-%COMP%]:after{left:100%}.ng-animating[_nghost-%COMP%]:after, .ng-animating[_nghost-%COMP%]:before{opacity:0;transition:opacity var(--tui-duration)}.t-right[_nghost-%COMP%]{justify-content:flex-end}.t-left[_nghost-%COMP%]{justify-content:flex-start}.t-wrapper[_ngcontent-%COMP%]{position:relative;display:flex;flex-direction:column;background:var(--tui-base-01);box-shadow:0 10rem var(--tui-base-01);width:17.25rem}.t-wrapper_auto-width[_ngcontent-%COMP%]{width:auto}"],
    data: {
      animation: [tuiSlideIn]
    },
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('@tuiSlideIn')], TuiSidebarComponent.prototype, "animation", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class')], TuiSidebarComponent.prototype, "directionHostClass", null);
  TuiSidebarComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_core_tokens/* TUI_ANIMATION_OPTIONS */.Pw)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TuiSidebarDirective))], TuiSidebarComponent);
  return TuiSidebarComponent;
})();
let TuiSidebarModule = /*#__PURE__*/(() => {
  let TuiSidebarModule = class TuiSidebarModule {};
  TuiSidebarModule.ɵfac = function TuiSidebarModule_Factory(t) {
    return new (t || TuiSidebarModule)();
  };
  TuiSidebarModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiSidebarModule
  });
  TuiSidebarModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[TuiActiveZoneModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq]]
  });
  return TuiSidebarModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiSidebarModule, {
    declarations: function () {
      return [TuiSidebarDirective, TuiSidebarComponent];
    },
    imports: function () {
      return [TuiActiveZoneModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq];
    },
    exports: function () {
      return [TuiSidebarDirective];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-addon-mobile-directives-sidebar.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/addon-doc/fesm2015/taiga-ui-addon-doc.js




















/**
 * @deprecated: use {@link tuiRawLoad} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention














function TuiDocCodeComponent_p_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "p", 2);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", ctx_r0.filename, "\n");
  }
}
function TuiDocCodeComponent_pre_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "pre", 3);
    core_js_["ɵɵelement"](1, "code", 4);
    core_js_["ɵɵtext"](2, "\n");
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const content_r2 = ctx.$implicit;
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("lineNumbers", true)("highlight", content_r2);
  }
}
function TuiDocCopyComponent_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "button", 1);
    core_js_["ɵɵlistener"]("click", function TuiDocCopyComponent_button_0_Template_button_click_0_listener() {
      core_js_["ɵɵrestoreView"](_r3);
      const ctx_r2 = core_js_["ɵɵnextContext"]();
      return ctx_r2.onClick();
    });
    core_js_["ɵɵelementStart"](1, "span", 2);
    core_js_["ɵɵpipe"](2, "async");
    core_js_["ɵɵelementStart"](3, "span", 3);
    core_js_["ɵɵprojection"](4);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵtext"](5);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const texts_r1 = ctx.ngIf;
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("title", texts_r1[0]);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵclassProp"]("t-content_moved", core_js_["ɵɵpipeBind1"](2, 5, ctx_r0.copied$));
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵattribute"]("data-text", texts_r1[0]);
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵtextInterpolate1"](" ", texts_r1[1], " ");
  }
}
const taiga_ui_addon_doc_c0 = ["*"];
const taiga_ui_addon_doc_c1 = ["content"];
const taiga_ui_addon_doc_c2 = ["wrapper"];
const taiga_ui_addon_doc_c3 = ["resizerText"];
function TuiDocDemoComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵtext"](0);
    core_js_["ɵɵelementStart"](1, "a", 13);
    core_js_["ɵɵelementStart"](2, "code");
    core_js_["ɵɵtext"](3, "tuiMode");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵtextInterpolate1"](" ", ctx_r1.texts[0], " ");
  }
}
function TuiDocDemoComponent_ng_container_3_tui_data_list_wrapper_3_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-data-list-wrapper", 16);
  }
  if (rf & 2) {
    const ctx_r9 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵproperty"]("items", ctx_r9.items);
  }
}
function TuiDocDemoComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵelementStart"](1, "tui-select", 14);
    core_js_["ɵɵtext"](2, " tuiMode ");
    core_js_["ɵɵtemplate"](3, TuiDocDemoComponent_ng_container_3_tui_data_list_wrapper_3_Template, 1, 1, "tui-data-list-wrapper", 15);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    const _r0 = core_js_["ɵɵreference"](2);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("tuiTextfieldCleaner", true)("tuiHintContent", _r0)("formControl", ctx_r2.modeControl);
  }
}
function TuiDocDemoComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵtext"](0, " tuiMode: ");
    core_js_["ɵɵelement"](1, "tui-tooltip", 17);
    core_js_["ɵɵelementStart"](2, "div", 18);
    core_js_["ɵɵelementStart"](3, "tui-radio-block", 19);
    core_js_["ɵɵtext"](4, " null ");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementStart"](5, "tui-radio-block", 20);
    core_js_["ɵɵtext"](6, " onDark ");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementStart"](7, "tui-radio-block", 21);
    core_js_["ɵɵtext"](8, " onLight ");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r4 = core_js_["ɵɵnextContext"]();
    const _r0 = core_js_["ɵɵreference"](2);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("content", _r0);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("collapsed", true);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("item", null)("hideRadio", true)("formControl", ctx_r4.modeControl);
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵproperty"]("hideRadio", true)("formControl", ctx_r4.modeControl);
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵproperty"]("hideRadio", true)("formControl", ctx_r4.modeControl);
  }
}
function TuiDocDemoComponent_form_12_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-svg", 29);
  }
  if (rf & 2) {
    const ctx_r11 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵclassProp"]("t-icon_rotated", ctx_r11.expanded);
  }
}
function TuiDocDemoComponent_form_12_ng_template_8_tui_data_list_wrapper_6_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-data-list-wrapper", 16);
  }
  if (rf & 2) {
    const ctx_r13 = core_js_["ɵɵnextContext"](3);
    core_js_["ɵɵproperty"]("items", ctx_r13.updateOnVariants);
  }
}
const taiga_ui_addon_doc_c4 = function () {
  return {
    standalone: true
  };
};
function TuiDocDemoComponent_form_12_ng_template_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r15 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "pre", 30);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵpipe"](2, "json");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementStart"](3, "div", 31);
    core_js_["ɵɵelementStart"](4, "tui-select", 32);
    core_js_["ɵɵlistener"]("ngModelChange", function TuiDocDemoComponent_form_12_ng_template_8_Template_tui_select_ngModelChange_4_listener($event) {
      core_js_["ɵɵrestoreView"](_r15);
      const ctx_r14 = core_js_["ɵɵnextContext"](2);
      return ctx_r14.updateOnChange($event);
    });
    core_js_["ɵɵtext"](5, " updateOn ");
    core_js_["ɵɵtemplate"](6, TuiDocDemoComponent_form_12_ng_template_8_tui_data_list_wrapper_6_Template, 1, 1, "tui-data-list-wrapper", 15);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementStart"](7, "button", 33);
    core_js_["ɵɵtext"](8, " Reset ");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementStart"](9, "button", 34);
    core_js_["ɵɵtext"](10, " Submit ");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r12 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"]("Form data: ", core_js_["ɵɵpipeBind1"](2, 3, ctx_r12.testForm.value), "");
    core_js_["ɵɵadvance"](3);
    core_js_["ɵɵproperty"]("ngModel", ctx_r12.updateOn)("ngModelOptions", core_js_["ɵɵpureFunction0"](5, taiga_ui_addon_doc_c4));
  }
}
function TuiDocDemoComponent_form_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "form", 22);
    core_js_["ɵɵelementStart"](1, "div", 23);
    core_js_["ɵɵelementContainer"](2, 24);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementStart"](3, "button", 25);
    core_js_["ɵɵlistener"]("click", function TuiDocDemoComponent_form_12_Template_button_click_3_listener() {
      core_js_["ɵɵrestoreView"](_r17);
      const ctx_r16 = core_js_["ɵɵnextContext"]();
      return ctx_r16.toggleDetails();
    });
    core_js_["ɵɵtext"](4);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵtemplate"](5, TuiDocDemoComponent_form_12_ng_template_5_Template, 1, 2, "ng-template", null, 26, core_js_["ɵɵtemplateRefExtractor"]);
    core_js_["ɵɵelementStart"](7, "tui-expand", 27);
    core_js_["ɵɵtemplate"](8, TuiDocDemoComponent_form_12_ng_template_8_Template, 11, 6, "ng-template", 28);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const _r10 = core_js_["ɵɵreference"](6);
    const ctx_r7 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("formGroup", ctx_r7.testForm);
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵproperty"]("ngTemplateOutlet", ctx_r7.template);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("iconRight", _r10);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", ctx_r7.texts[2], " ");
    core_js_["ɵɵadvance"](3);
    core_js_["ɵɵproperty"]("expanded", ctx_r7.expanded);
  }
}
function TuiDocDocumentationComponent_h1_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "h1", 7);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", ctx_r0.heading, "\n");
  }
}
function TuiDocDocumentationComponent_th_8_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "th", 8);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", ctx_r1.texts[3], " ");
  }
}
function TuiDocDocumentationComponent_tr_9_tui_badge_4_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-badge", 18);
  }
}
function TuiDocDocumentationComponent_tr_9_span_5_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "span", 19);
    core_js_["ɵɵtext"](1, " deprecated ");
    core_js_["ɵɵelementEnd"]();
  }
}
function TuiDocDocumentationComponent_tr_9_tui_tooltip_10_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵtext"](0);
    core_js_["ɵɵelementStart"](1, "a", 22);
    core_js_["ɵɵelementStart"](2, "code");
    core_js_["ɵɵtext"](3, "ng-polymorpheus");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r9 = core_js_["ɵɵnextContext"](3);
    core_js_["ɵɵtextInterpolate1"](" ", ctx_r9.texts[4], " ");
  }
}
function TuiDocDocumentationComponent_tr_9_tui_tooltip_10_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "tui-tooltip", 20);
    core_js_["ɵɵtemplate"](1, TuiDocDocumentationComponent_tr_9_tui_tooltip_10_ng_template_1_Template, 4, 1, "ng-template", null, 21, core_js_["ɵɵtemplateRefExtractor"]);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const _r8 = core_js_["ɵɵreference"](2);
    const propertyConnector_r3 = core_js_["ɵɵnextContext"]().$implicit;
    core_js_["ɵɵproperty"]("describeId", propertyConnector_r3.attrName)("content", _r8);
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_tui_select_1_tui_data_list_wrapper_3_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-data-list-wrapper", 31);
  }
  if (rf & 2) {
    core_js_["ɵɵnextContext"](2);
    const _r15 = core_js_["ɵɵreference"](3);
    const propertyConnector_r3 = core_js_["ɵɵnextContext"](2).$implicit;
    core_js_["ɵɵproperty"]("items", propertyConnector_r3.documentationPropertyValues)("itemContent", _r15);
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_tui_select_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r23 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "tui-select", 28);
    core_js_["ɵɵlistener"]("ngModelChange", function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_tui_select_1_Template_tui_select_ngModelChange_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r23);
      const propertyConnector_r3 = core_js_["ɵɵnextContext"](3).$implicit;
      return propertyConnector_r3.onValueChange($event);
    });
    core_js_["ɵɵelementStart"](1, "code", 29);
    core_js_["ɵɵtext"](2, "null");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵtemplate"](3, TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_tui_select_1_tui_data_list_wrapper_3_Template, 1, 2, "tui-data-list-wrapper", 30);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    core_js_["ɵɵnextContext"]();
    const _r15 = core_js_["ɵɵreference"](3);
    const propertyConnector_r3 = core_js_["ɵɵnextContext"](2).$implicit;
    const ctx_r14 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("tuiTextfieldCleaner", ctx_r14.showCleaner(propertyConnector_r3.documentationPropertyType))("tuiTextfieldLabelOutside", true)("nativeId", propertyConnector_r3.attrName)("valueContent", _r15)("ngModel", propertyConnector_r3.documentationPropertyValue);
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "code");
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const data_r25 = ctx.$implicit;
    const ctx_r16 = core_js_["ɵɵnextContext"](4);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate"](ctx_r16.inspectAny(data_r25));
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_tui_toggle_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r33 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "tui-toggle", 38);
    core_js_["ɵɵlistener"]("ngModelChange", function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_tui_toggle_1_Template_tui_toggle_ngModelChange_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r33);
      const propertyConnector_r3 = core_js_["ɵɵnextContext"](4).$implicit;
      return propertyConnector_r3.onValueChange($event);
    });
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const propertyConnector_r3 = core_js_["ɵɵnextContext"](4).$implicit;
    core_js_["ɵɵproperty"]("nativeId", propertyConnector_r3.attrName)("showIcons", true)("ngModel", propertyConnector_r3.documentationPropertyValue);
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_tui_primitive_textfield_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r37 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "tui-primitive-textfield", 39);
    core_js_["ɵɵlistener"]("valueChange", function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_tui_primitive_textfield_2_Template_tui_primitive_textfield_valueChange_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r37);
      const propertyConnector_r3 = core_js_["ɵɵnextContext"](4).$implicit;
      return propertyConnector_r3.onValueChange($event);
    });
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const propertyConnector_r3 = core_js_["ɵɵnextContext"](4).$implicit;
    core_js_["ɵɵproperty"]("nativeId", propertyConnector_r3.attrName)("tuiTextfieldLabelOutside", true)("tuiTextfieldCleaner", true)("value", propertyConnector_r3.documentationPropertyValue || "");
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r41 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "div", 40);
    core_js_["ɵɵelementStart"](1, "tui-primitive-textfield", 41);
    core_js_["ɵɵlistener"]("valueChange", function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_div_3_Template_tui_primitive_textfield_valueChange_1_listener($event) {
      core_js_["ɵɵrestoreView"](_r41);
      const propertyConnector_r3 = core_js_["ɵɵnextContext"](4).$implicit;
      const ctx_r39 = core_js_["ɵɵnextContext"]();
      return ctx_r39.onColorChange(propertyConnector_r3, $event);
    });
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementStart"](2, "tui-input-count", 42);
    core_js_["ɵɵlistener"]("ngModelChange", function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_div_3_Template_tui_input_count_ngModelChange_2_listener($event) {
      core_js_["ɵɵrestoreView"](_r41);
      const propertyConnector_r3 = core_js_["ɵɵnextContext"](4).$implicit;
      const ctx_r42 = core_js_["ɵɵnextContext"]();
      return ctx_r42.onOpacityChange(propertyConnector_r3, $event);
    });
    core_js_["ɵɵtext"](3, " Opacity ");
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const propertyConnector_r3 = core_js_["ɵɵnextContext"](4).$implicit;
    const ctx_r28 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("tuiTextfieldLabelOutside", true)("tuiInputOpacity", ctx_r28.getOpacity(propertyConnector_r3.documentationPropertyValue))("value", ctx_r28.getColor(propertyConnector_r3.documentationPropertyValue));
    core_js_["ɵɵattribute"]("id", propertyConnector_r3.attrName);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("max", 100)("ngModel", ctx_r28.getOpacity(propertyConnector_r3.documentationPropertyValue));
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_tui_input_count_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r47 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "tui-input-count", 43);
    core_js_["ɵɵlistener"]("ngModelChange", function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_tui_input_count_4_Template_tui_input_count_ngModelChange_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r47);
      const propertyConnector_r3 = core_js_["ɵɵnextContext"](4).$implicit;
      return propertyConnector_r3.onValueChange($event);
    });
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const propertyConnector_r3 = core_js_["ɵɵnextContext"](4).$implicit;
    core_js_["ɵɵproperty"]("nativeId", propertyConnector_r3.attrName)("tuiTextfieldLabelOutside", true)("ngModel", propertyConnector_r3.documentationPropertyValue);
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_ng_container_5_tui_primitive_textfield_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r52 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "tui-primitive-textfield", 39);
    core_js_["ɵɵlistener"]("valueChange", function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_ng_container_5_tui_primitive_textfield_1_Template_tui_primitive_textfield_valueChange_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r52);
      const propertyConnector_r3 = core_js_["ɵɵnextContext"](5).$implicit;
      return propertyConnector_r3.onValueChange($event);
    });
    core_js_["ɵɵtext"](1, " Default content ");
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const propertyConnector_r3 = core_js_["ɵɵnextContext"](5).$implicit;
    core_js_["ɵɵproperty"]("nativeId", propertyConnector_r3.attrName)("tuiTextfieldLabelOutside", true)("tuiTextfieldCleaner", true)("value", propertyConnector_r3.documentationPropertyValue.toString());
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_ng_container_5_tui_primitive_textfield_1_Template, 2, 4, "tui-primitive-textfield", 44);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const propertyConnector_r3 = core_js_["ɵɵnextContext"](4).$implicit;
    const ctx_r30 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", ctx_r30.isPrimitivePolymorpheusContent(propertyConnector_r3.documentationPropertyValue));
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0, 32);
    core_js_["ɵɵtemplate"](1, TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_tui_toggle_1_Template, 1, 3, "tui-toggle", 33);
    core_js_["ɵɵtemplate"](2, TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_tui_primitive_textfield_2_Template, 1, 4, "tui-primitive-textfield", 34);
    core_js_["ɵɵtemplate"](3, TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_div_3_Template, 4, 6, "div", 35);
    core_js_["ɵɵtemplate"](4, TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_tui_input_count_4_Template, 1, 3, "tui-input-count", 36);
    core_js_["ɵɵtemplate"](5, TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_ng_container_5_Template, 2, 1, "ng-container", 37);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const propertyConnector_r3 = core_js_["ɵɵnextContext"](3).$implicit;
    core_js_["ɵɵproperty"]("ngSwitch", propertyConnector_r3.documentationPropertyType);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngSwitchCase", "boolean");
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngSwitchCase", "string");
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngSwitchCase", "color");
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngSwitchCase", "number");
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngSwitchCase", "PolymorpheusContent");
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_tui_select_1_Template, 4, 5, "tui-select", 25);
    core_js_["ɵɵtemplate"](2, TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_2_Template, 2, 1, "ng-template", null, 26, core_js_["ɵɵtemplateRefExtractor"]);
    core_js_["ɵɵtemplate"](4, TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_ng_template_4_Template, 6, 6, "ng-template", null, 27, core_js_["ɵɵtemplateRefExtractor"]);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const _r17 = core_js_["ɵɵreference"](5);
    const propertyConnector_r3 = core_js_["ɵɵnextContext"](2).$implicit;
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", propertyConnector_r3.hasItems)("ngIfElse", _r17);
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "tui-notification", 45);
    core_js_["ɵɵpipe"](1, "async");
    core_js_["ɵɵtext"](2, " Emit! ");
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const propertyConnector_r3 = core_js_["ɵɵnextContext"](2).$implicit;
    core_js_["ɵɵproperty"]("@emitEvent", core_js_["ɵɵpipeBind1"](1, 1, propertyConnector_r3.emits$));
  }
}
function TuiDocDocumentationComponent_tr_9_td_11_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "td", 10);
    core_js_["ɵɵtemplate"](1, TuiDocDocumentationComponent_tr_9_td_11_ng_container_1_Template, 6, 2, "ng-container", 23);
    core_js_["ɵɵtemplate"](2, TuiDocDocumentationComponent_tr_9_td_11_ng_template_2_Template, 3, 3, "ng-template", null, 24, core_js_["ɵɵtemplateRefExtractor"]);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const _r12 = core_js_["ɵɵreference"](3);
    const propertyConnector_r3 = core_js_["ɵɵnextContext"]().$implicit;
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", propertyConnector_r3.shouldShowValues)("ngIfElse", _r12);
  }
}
function TuiDocDocumentationComponent_tr_9_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "tr", 9);
    core_js_["ɵɵelementStart"](1, "td", 10);
    core_js_["ɵɵelementStart"](2, "div", 11);
    core_js_["ɵɵtext"](3);
    core_js_["ɵɵtemplate"](4, TuiDocDocumentationComponent_tr_9_tui_badge_4_Template, 1, 0, "tui-badge", 12);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵtemplate"](5, TuiDocDocumentationComponent_tr_9_span_5_Template, 2, 0, "span", 13);
    core_js_["ɵɵelementContainer"](6, 14);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementStart"](7, "td", 10);
    core_js_["ɵɵelementStart"](8, "span", 15);
    core_js_["ɵɵtext"](9);
    core_js_["ɵɵtemplate"](10, TuiDocDocumentationComponent_tr_9_tui_tooltip_10_Template, 3, 2, "tui-tooltip", 16);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵtemplate"](11, TuiDocDocumentationComponent_tr_9_td_11_Template, 4, 2, "td", 17);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const propertyConnector_r3 = ctx.$implicit;
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵclassProp"]("t-deprecated", propertyConnector_r3.documentationPropertyDeprecated);
    core_js_["ɵɵadvance"](3);
    core_js_["ɵɵtextInterpolate1"](" ", ctx_r2.stripOptional(propertyConnector_r3.attrName), " ");
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", ctx_r2.isOptional(propertyConnector_r3.attrName));
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", propertyConnector_r3.documentationPropertyDeprecated);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngTemplateOutlet", propertyConnector_r3.template);
    core_js_["ɵɵadvance"](3);
    core_js_["ɵɵtextInterpolate1"](" ", propertyConnector_r3.documentationPropertyType, " ");
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", ctx_r2.showContentTooltip(propertyConnector_r3.documentationPropertyType));
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", ctx_r2.showValues);
  }
}
function TuiDocExampleComponent_h3_0_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "button", 8);
    core_js_["ɵɵlistener"]("click", function TuiDocExampleComponent_h3_0_button_3_Template_button_click_0_listener() {
      core_js_["ɵɵrestoreView"](_r9);
      const ctx_r8 = core_js_["ɵɵnextContext"](2);
      return ctx_r8.copyExampleLink();
    });
    core_js_["ɵɵpipe"](1, "async");
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r7 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵproperty"]("title", core_js_["ɵɵpipeBind1"](1, 1, ctx_r7.copy$));
  }
}
function TuiDocExampleComponent_h3_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "h3", 5);
    core_js_["ɵɵelement"](1, "span", 6);
    core_js_["ɵɵpipe"](2, "tuiDocExampleCapitalize");
    core_js_["ɵɵtemplate"](3, TuiDocExampleComponent_h3_0_button_3_Template, 2, 3, "button", 7);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("content", core_js_["ɵɵpipeBind1"](2, 2, ctx_r0.heading));
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵproperty"]("ngIf", ctx_r0.id);
  }
}
function TuiDocExampleComponent_h4_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "h4", 9);
    core_js_["ɵɵpipe"](1, "tuiDocExampleCapitalize");
  }
  if (rf & 2) {
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("content", core_js_["ɵɵpipeBind1"](1, 1, ctx_r1.description));
  }
}
function TuiDocExampleComponent_div_2_ng_container_1_ng_container_3_button_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "button", 18);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const tab_r16 = core_js_["ɵɵnextContext"]().$implicit;
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", tab_r16, " ");
  }
}
function TuiDocExampleComponent_div_2_ng_container_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiDocExampleComponent_div_2_ng_container_1_ng_container_3_button_1_Template, 2, 1, "button", 17);
    core_js_["ɵɵelementContainerEnd"]();
  }
}
function TuiDocExampleComponent_div_2_ng_container_1_button_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r21 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "button", 19);
    core_js_["ɵɵlistener"]("click", function TuiDocExampleComponent_div_2_ng_container_1_button_4_Template_button_click_0_listener() {
      core_js_["ɵɵrestoreView"](_r21);
      const files_r10 = core_js_["ɵɵnextContext"](2).ngIf;
      const ctx_r19 = core_js_["ɵɵnextContext"]();
      return ctx_r19.edit(files_r10);
    });
    core_js_["ɵɵpipe"](1, "async");
    core_js_["ɵɵtext"](2);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r14 = core_js_["ɵɵnextContext"](3);
    core_js_["ɵɵproperty"]("showLoader", !!core_js_["ɵɵpipeBind1"](1, 2, ctx_r14.loading$));
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵtextInterpolate1"](" Edit on ", ctx_r14.codeEditor.name, " ");
  }
}
function TuiDocExampleComponent_div_2_ng_container_1_div_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0, 23);
  }
  if (rf & 2) {
    core_js_["ɵɵnextContext"](4);
    const _r3 = core_js_["ɵɵreference"](5);
    core_js_["ɵɵproperty"]("ngTemplateOutlet", _r3);
  }
}
const taiga_ui_addon_doc_c5 = function (a0) {
  return {
    $implicit: a0
  };
};
function TuiDocExampleComponent_div_2_ng_container_1_div_5_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0, 24);
  }
  if (rf & 2) {
    const tabs_r12 = core_js_["ɵɵnextContext"](2).ngIf;
    const files_r10 = core_js_["ɵɵnextContext"]().ngIf;
    const ctx_r26 = core_js_["ɵɵnextContext"]();
    const _r5 = core_js_["ɵɵreference"](7);
    core_js_["ɵɵproperty"]("ngTemplateOutlet", _r5)("ngTemplateOutletContext", core_js_["ɵɵpureFunction1"](2, taiga_ui_addon_doc_c5, files_r10[tabs_r12[ctx_r26.activeItemIndex]] || ""));
  }
}
function TuiDocExampleComponent_div_2_ng_container_1_div_5_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 20);
    core_js_["ɵɵtemplate"](1, TuiDocExampleComponent_div_2_ng_container_1_div_5_ng_container_1_Template, 1, 1, "ng-container", 21);
    core_js_["ɵɵtemplate"](2, TuiDocExampleComponent_div_2_ng_container_1_div_5_ng_template_2_Template, 1, 4, "ng-template", null, 22, core_js_["ɵɵtemplateRefExtractor"]);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const index_r23 = ctx.index;
    const _r25 = core_js_["ɵɵreference"](3);
    const ctx_r15 = core_js_["ɵɵnextContext"](3);
    core_js_["ɵɵclassProp"]("t-content_animated", !ctx_r15.isCypress)("t-content_visible", ctx_r15.activeItemIndex === index_r23);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", index_r23 === ctx_r15.defaultTabIndex)("ngIfElse", _r25);
  }
}
function TuiDocExampleComponent_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r30 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵelementStart"](1, "div", 12);
    core_js_["ɵɵelementStart"](2, "tui-tabs-with-more", 13);
    core_js_["ɵɵlistener"]("activeItemIndexChange", function TuiDocExampleComponent_div_2_ng_container_1_Template_tui_tabs_with_more_activeItemIndexChange_2_listener($event) {
      core_js_["ɵɵrestoreView"](_r30);
      const ctx_r29 = core_js_["ɵɵnextContext"](2);
      return ctx_r29.activeItemIndex = $event;
    });
    core_js_["ɵɵtemplate"](3, TuiDocExampleComponent_div_2_ng_container_1_ng_container_3_Template, 2, 0, "ng-container", 14);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵtemplate"](4, TuiDocExampleComponent_div_2_ng_container_1_button_4_Template, 3, 4, "button", 15);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵtemplate"](5, TuiDocExampleComponent_div_2_ng_container_1_div_5_Template, 4, 6, "div", 16);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const tabs_r12 = ctx.ngIf;
    const ctx_r11 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵproperty"]("activeItemIndex", ctx_r11.activeItemIndex);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", tabs_r12);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", ctx_r11.codeEditor);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", tabs_r12);
  }
}
function TuiDocExampleComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 10);
    core_js_["ɵɵtemplate"](1, TuiDocExampleComponent_div_2_ng_container_1_Template, 6, 4, "ng-container", 11);
    core_js_["ɵɵpipe"](2, "tuiDocExampleGetTabs");
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const files_r10 = ctx.ngIf;
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", core_js_["ɵɵpipeBind2"](2, 1, files_r10, ctx_r2.defaultTab));
  }
}
function TuiDocExampleComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 25);
    core_js_["ɵɵprojection"](1);
    core_js_["ɵɵelementEnd"]();
  }
}
function TuiDocExampleComponent_ng_template_6_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵelement"](1, "div", 29);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const action_r33 = ctx.$implicit;
    const code_r31 = core_js_["ɵɵnextContext"]().$implicit;
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("content", action_r33)("context", core_js_["ɵɵpureFunction1"](2, taiga_ui_addon_doc_c5, code_r31));
  }
}
function TuiDocExampleComponent_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "section", 26);
    core_js_["ɵɵtemplate"](1, TuiDocExampleComponent_ng_template_6_ng_container_1_Template, 2, 4, "ng-container", 14);
    core_js_["ɵɵelement"](2, "tui-doc-copy", 27);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelement"](3, "tui-doc-code", 28);
  }
  if (rf & 2) {
    const code_r31 = ctx.$implicit;
    const ctx_r6 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", ctx_r6.codeActions);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("cdkCopyToClipboard", code_r31);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("code", code_r31);
  }
}
function TuiLanguageSwitcherComponent_tui_data_list_2_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "button", 3);
    core_js_["ɵɵlistener"]("click", function TuiLanguageSwitcherComponent_tui_data_list_2_button_1_Template_button_click_0_listener() {
      const restoredCtx = core_js_["ɵɵrestoreView"](_r4);
      const name_r2 = restoredCtx.$implicit;
      const ctx_r3 = core_js_["ɵɵnextContext"](2);
      return ctx_r3.switcher.setLanguage(name_r2);
    });
    core_js_["ɵɵpipe"](1, "titlecase");
    core_js_["ɵɵelement"](2, "img", 4);
    core_js_["ɵɵpipe"](3, "tuiFlag");
    core_js_["ɵɵtext"](4);
    core_js_["ɵɵpipe"](5, "titlecase");
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const name_r2 = ctx.$implicit;
    const ctx_r1 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵproperty"]("value", core_js_["ɵɵpipeBind1"](1, 3, name_r2));
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵproperty"]("src", core_js_["ɵɵpipeBind1"](3, 5, ctx_r1.flags.get(name_r2)), core_js_["ɵɵsanitizeUrl"]);
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵtextInterpolate1"](" ", core_js_["ɵɵpipeBind1"](5, 7, name_r2), " ");
  }
}
function TuiLanguageSwitcherComponent_tui_data_list_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "tui-data-list");
    core_js_["ɵɵtemplate"](1, TuiLanguageSwitcherComponent_tui_data_list_2_button_1_Template, 6, 9, "button", 2);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", ctx_r0.names);
  }
}
function TuiDocMainComponent_tui_theme_night_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-theme-night");
  }
}
const _c6 = [[["tuiDocNavigation"]], [["tuiDocHeader"]], [["tuiOverContent"]], [["tuiOverDialogs"]], [["tuiOverAlerts"]], [["tuiOverNotifications"]], [["tuiOverPortals"]], [["tuiOverHints"]]];
const _c7 = ["tuiDocNavigation", "tuiDocHeader", "tuiOverContent", "tuiOverDialogs", "tuiOverAlerts", "tuiOverNotifications", "tuiOverPortals", "tuiOverHints"];
function TuiDocNavigationComponent_tui_hosted_dropdown_0_ng_template_3_tui_opt_group_1_a_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r15 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "a", 14);
    core_js_["ɵɵlistener"]("click", function TuiDocNavigationComponent_tui_hosted_dropdown_0_ng_template_3_tui_opt_group_1_a_1_Template_a_click_0_listener() {
      core_js_["ɵɵrestoreView"](_r15);
      const ctx_r14 = core_js_["ɵɵnextContext"](4);
      return ctx_r14.onClick();
    });
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const item_r13 = ctx.$implicit;
    core_js_["ɵɵproperty"]("routerLink", item_r13.route);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", item_r13.title, " ");
  }
}
function TuiDocNavigationComponent_tui_hosted_dropdown_0_ng_template_3_tui_opt_group_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "tui-opt-group", 12);
    core_js_["ɵɵtemplate"](1, TuiDocNavigationComponent_tui_hosted_dropdown_0_ng_template_3_tui_opt_group_1_a_1_Template, 2, 2, "a", 13);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const group_r10 = ctx.$implicit;
    const index_r11 = ctx.index;
    const ctx_r9 = core_js_["ɵɵnextContext"](3);
    core_js_["ɵɵproperty"]("label", ctx_r9.labels[index_r11] || "");
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", group_r10);
  }
}
function TuiDocNavigationComponent_tui_hosted_dropdown_0_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "tui-data-list");
    core_js_["ɵɵtemplate"](1, TuiDocNavigationComponent_tui_hosted_dropdown_0_ng_template_3_tui_opt_group_1_Template, 2, 2, "tui-opt-group", 11);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const filtered_r5 = core_js_["ɵɵnextContext"]().tuiLet;
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", filtered_r5);
  }
}
function TuiDocNavigationComponent_tui_hosted_dropdown_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "tui-hosted-dropdown", 8);
    core_js_["ɵɵlistener"]("openChange", function TuiDocNavigationComponent_tui_hosted_dropdown_0_Template_tui_hosted_dropdown_openChange_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r18);
      const ctx_r17 = core_js_["ɵɵnextContext"]();
      return ctx_r17.open = $event;
    });
    core_js_["ɵɵelementStart"](1, "tui-primitive-textfield", 9);
    core_js_["ɵɵlistener"]("valueChange", function TuiDocNavigationComponent_tui_hosted_dropdown_0_Template_tui_primitive_textfield_valueChange_1_listener($event) {
      core_js_["ɵɵrestoreView"](_r18);
      const ctx_r19 = core_js_["ɵɵnextContext"]();
      return ctx_r19.onSearchChange($event);
    });
    core_js_["ɵɵtext"](2);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵtemplate"](3, TuiDocNavigationComponent_tui_hosted_dropdown_0_ng_template_3_Template, 2, 1, "ng-template", null, 10, core_js_["ɵɵtemplateRefExtractor"]);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const _r6 = core_js_["ɵɵreference"](4);
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("autoFocus", !!ctx_r0.sidebar)("content", _r6)("canOpen", ctx_r0.canOpen)("open", ctx_r0.open);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("pseudoFocused", ctx_r0.open || null)("tuiTextfieldCleaner", true)("tuiTextfieldLabelOutside", true)("value", ctx_r0.search);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", ctx_r0.searchText, " ");
  }
}
const _c8 = function (a0, a1) {
  return {
    item: a0,
    index: a1
  };
};
function TuiDocNavigationComponent_tui_accordion_item_5_ng_template_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0, 19);
  }
  if (rf & 2) {
    const item_r24 = ctx.$implicit;
    const subIndex_r25 = ctx.index;
    const index_r21 = core_js_["ɵɵnextContext"](2).index;
    core_js_["ɵɵnextContext"]();
    const _r3 = core_js_["ɵɵreference"](9);
    core_js_["ɵɵproperty"]("ngTemplateOutlet", _r3)("ngTemplateOutletContext", core_js_["ɵɵpureFunction2"](2, _c8, item_r24, index_r21 * 100 + subIndex_r25));
  }
}
function TuiDocNavigationComponent_tui_accordion_item_5_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 18);
    core_js_["ɵɵtemplate"](1, TuiDocNavigationComponent_tui_accordion_item_5_ng_template_4_ng_container_1_Template, 1, 5, "ng-container", 6);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const index_r21 = core_js_["ɵɵnextContext"]().index;
    const ctx_r22 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", ctx_r22.items[index_r21]);
  }
}
function TuiDocNavigationComponent_tui_accordion_item_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r29 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "tui-accordion-item", 15);
    core_js_["ɵɵlistener"]("openChange", function TuiDocNavigationComponent_tui_accordion_item_5_Template_tui_accordion_item_openChange_0_listener($event) {
      const restoredCtx = core_js_["ɵɵrestoreView"](_r29);
      const index_r21 = restoredCtx.index;
      const ctx_r28 = core_js_["ɵɵnextContext"]();
      return !!(ctx_r28.openPagesArr[index_r21] = $event);
    });
    core_js_["ɵɵelementStart"](1, "span", 16);
    core_js_["ɵɵelementStart"](2, "strong");
    core_js_["ɵɵtext"](3);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵtemplate"](4, TuiDocNavigationComponent_tui_accordion_item_5_ng_template_4_Template, 2, 1, "ng-template", 17);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const label_r20 = ctx.$implicit;
    const index_r21 = ctx.index;
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("borders", null)("open", !!ctx_r1.openPagesArr[index_r21]);
    core_js_["ɵɵadvance"](3);
    core_js_["ɵɵtextInterpolate"](label_r20);
  }
}
function TuiDocNavigationComponent_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0, 19);
  }
  if (rf & 2) {
    const item_r30 = ctx.$implicit;
    const index_r31 = ctx.index;
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    const _r3 = core_js_["ɵɵreference"](9);
    core_js_["ɵɵproperty"]("ngTemplateOutlet", _r3)("ngTemplateOutletContext", core_js_["ɵɵpureFunction2"](2, _c8, item_r30, ctx_r2.items.length - 1 + index_r31));
  }
}
function TuiDocNavigationComponent_ng_template_8_a_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r38 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "a", 22);
    core_js_["ɵɵlistener"]("click", function TuiDocNavigationComponent_ng_template_8_a_0_Template_a_click_0_listener() {
      core_js_["ɵɵrestoreView"](_r38);
      const ctx_r37 = core_js_["ɵɵnextContext"](2);
      return ctx_r37.closeMenu();
    });
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const item_r32 = core_js_["ɵɵnextContext"]().item;
    const ctx_r34 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("routerLink", item_r32.route)("scrollIntoView", ctx_r34.isActive(item_r32.route));
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", item_r32.title, " ");
  }
}
function TuiDocNavigationComponent_ng_template_8_ng_template_1_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r44 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "button", 28);
    core_js_["ɵɵlistener"]("click", function TuiDocNavigationComponent_ng_template_8_ng_template_1_button_1_Template_button_click_0_listener() {
      core_js_["ɵɵrestoreView"](_r44);
      const index_r33 = core_js_["ɵɵnextContext"](2).index;
      const ctx_r42 = core_js_["ɵɵnextContext"]();
      return ctx_r42.onGroupClick(index_r33);
    });
    core_js_["ɵɵelement"](1, "tui-svg", 29);
    core_js_["ɵɵtext"](2);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r45 = core_js_["ɵɵnextContext"](2);
    const index_r33 = ctx_r45.index;
    const item_r32 = ctx_r45.item;
    const ctx_r40 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵclassProp"]("t-chevron_active", !!ctx_r40.openPagesGroupsArr[index_r33]);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", item_r32.title, " ");
  }
}
function TuiDocNavigationComponent_ng_template_8_ng_template_1_a_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r48 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "a", 30);
    core_js_["ɵɵlistener"]("click", function TuiDocNavigationComponent_ng_template_8_ng_template_1_a_4_Template_a_click_0_listener() {
      core_js_["ɵɵrestoreView"](_r48);
      const ctx_r47 = core_js_["ɵɵnextContext"](3);
      return ctx_r47.closeMenu();
    });
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const subPage_r46 = ctx.$implicit;
    const ctx_r41 = core_js_["ɵɵnextContext"](3);
    core_js_["ɵɵproperty"]("routerLink", subPage_r46.route)("scrollIntoView", ctx_r41.isActive(subPage_r46.route));
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", subPage_r46.title, " ");
  }
}
const _c9 = function () {
  return {
    exact: false
  };
};
function TuiDocNavigationComponent_ng_template_8_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 23);
    core_js_["ɵɵtemplate"](1, TuiDocNavigationComponent_ng_template_8_ng_template_1_button_1_Template, 3, 3, "button", 24);
    core_js_["ɵɵelementStart"](2, "tui-expand", 25);
    core_js_["ɵɵelementStart"](3, "div", 26);
    core_js_["ɵɵtemplate"](4, TuiDocNavigationComponent_ng_template_8_ng_template_1_a_4_Template, 2, 3, "a", 27);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r49 = core_js_["ɵɵnextContext"]();
    const item_r32 = ctx_r49.item;
    const index_r33 = ctx_r49.index;
    const ctx_r36 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("routerLinkActiveOptions", core_js_["ɵɵpureFunction0"](4, _c9));
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", item_r32.subPages);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("expanded", !!ctx_r36.openPagesGroupsArr[index_r33]);
    core_js_["ɵɵadvance"](2);
    core_js_["ɵɵproperty"]("ngForOf", item_r32.subPages);
  }
}
function TuiDocNavigationComponent_ng_template_8_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵtemplate"](0, TuiDocNavigationComponent_ng_template_8_a_0_Template, 2, 3, "a", 20);
    core_js_["ɵɵtemplate"](1, TuiDocNavigationComponent_ng_template_8_ng_template_1_Template, 5, 5, "ng-template", null, 21, core_js_["ɵɵtemplateRefExtractor"]);
  }
  if (rf & 2) {
    const item_r32 = ctx.item;
    const _r35 = core_js_["ɵɵreference"](2);
    core_js_["ɵɵproperty"]("ngIf", !item_r32.subPages)("ngIfElse", _r35);
  }
}
const _c10 = ["tuiDocHeader", ""];
function TuiDocHeaderComponent_tui_doc_navigation_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-doc-navigation", 3);
  }
}
function TuiDocHeaderComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "img", 4);
  }
  if (rf & 2) {
    const src_r2 = ctx.$implicit;
    core_js_["ɵɵproperty"]("src", src_r2, core_js_["ɵɵsanitizeUrl"]);
  }
}
function TuiDocPageComponent_tui_tag_3_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-tag", 9);
  }
}
function TuiDocPageComponent_tui_tag_4_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-tag", 10);
  }
  if (rf & 2) {
    const ctx_r1 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("value", ctx_r1.package)("autoColor", true);
  }
}
const _c11 = function () {
  return {
    exact: true
  };
};
function TuiDocPageComponent_tui_tabs_with_more_5_ng_container_1_ng_container_1_a_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "a", 15);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r13 = core_js_["ɵɵnextContext"](2);
    const tab_r6 = ctx_r13.$implicit;
    const index_r8 = ctx_r13.index;
    const ctx_r12 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵproperty"]("routerLinkActiveOptions", core_js_["ɵɵpureFunction0"](2, _c11));
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", tab_r6.pageTab || ctx_r12.defaultTabs[index_r8], " ");
  }
}
function TuiDocPageComponent_tui_tabs_with_more_5_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiDocPageComponent_tui_tabs_with_more_5_ng_container_1_ng_container_1_a_1_Template, 2, 3, "a", 14);
    core_js_["ɵɵelementContainerEnd"]();
  }
}
function TuiDocPageComponent_tui_tabs_with_more_5_ng_container_1_ng_template_2_a_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "a", 17);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r15 = core_js_["ɵɵnextContext"](2);
    const tab_r6 = ctx_r15.$implicit;
    const index_r8 = ctx_r15.index;
    const ctx_r14 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵproperty"]("routerLink", ctx_r14.getRouterLink(tab_r6.pageTab || ctx_r14.defaultTabs[index_r8]));
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", tab_r6.pageTab || ctx_r14.defaultTabs[index_r8], " ");
  }
}
function TuiDocPageComponent_tui_tabs_with_more_5_ng_container_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵtemplate"](0, TuiDocPageComponent_tui_tabs_with_more_5_ng_container_1_ng_template_2_a_0_Template, 2, 2, "a", 16);
  }
}
function TuiDocPageComponent_tui_tabs_with_more_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiDocPageComponent_tui_tabs_with_more_5_ng_container_1_ng_container_1_Template, 2, 0, "ng-container", 12);
    core_js_["ɵɵtemplate"](2, TuiDocPageComponent_tui_tabs_with_more_5_ng_container_1_ng_template_2_Template, 1, 0, "ng-template", null, 13, core_js_["ɵɵtemplateRefExtractor"]);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const first_r7 = ctx.first;
    const _r10 = core_js_["ɵɵreference"](3);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", first_r7)("ngIfElse", _r10);
  }
}
function TuiDocPageComponent_tui_tabs_with_more_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = core_js_["ɵɵgetCurrentView"]();
    core_js_["ɵɵelementStart"](0, "tui-tabs-with-more", 11);
    core_js_["ɵɵlistener"]("activeItemIndexChange", function TuiDocPageComponent_tui_tabs_with_more_5_Template_tui_tabs_with_more_activeItemIndexChange_0_listener($event) {
      core_js_["ɵɵrestoreView"](_r17);
      const ctx_r16 = core_js_["ɵɵnextContext"]();
      return ctx_r16.activeItemIndex = $event;
    });
    core_js_["ɵɵtemplate"](1, TuiDocPageComponent_tui_tabs_with_more_5_ng_container_1_Template, 4, 2, "ng-container", 8);
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r2 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("activeItemIndex", ctx_r2.activeItemIndex);
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngForOf", ctx_r2.tabConnectors);
  }
}
function TuiDocPageComponent_tui_doc_see_also_9_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "tui-doc-see-also", 18);
  }
  if (rf & 2) {
    const ctx_r3 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("seeAlso", ctx_r3.seeAlso);
  }
}
function TuiDocPageComponent_ng_container_10_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainer"](0, 20);
  }
  if (rf & 2) {
    const tab_r18 = core_js_["ɵɵnextContext"]().$implicit;
    core_js_["ɵɵproperty"]("ngTemplateOutlet", tab_r18.template);
  }
}
function TuiDocPageComponent_ng_container_10_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtemplate"](1, TuiDocPageComponent_ng_container_10_ng_container_1_Template, 1, 1, "ng-container", 19);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const index_r19 = ctx.index;
    const ctx_r4 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", index_r19 === ctx_r4.activeItemIndex);
  }
}
function TuiDocSeeAlsoComponent_ng_container_2_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵtext"](1);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate"](", ");
  }
}
function TuiDocSeeAlsoComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementContainerStart"](0);
    core_js_["ɵɵelementStart"](1, "a", 2);
    core_js_["ɵɵtext"](2);
    core_js_["ɵɵelementEnd"]();
    core_js_["ɵɵtemplate"](3, TuiDocSeeAlsoComponent_ng_container_2_ng_container_3_Template, 2, 1, "ng-container", 3);
    core_js_["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const last_r2 = ctx.last;
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("routerLink", ctx_r0.getRouterLink(item_r1));
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵtextInterpolate1"](" ", item_r1, " ");
    core_js_["ɵɵadvance"](1);
    core_js_["ɵɵproperty"]("ngIf", !last_r2);
  }
}
function TuiDocSourceCodeComponent_div_0_ng_template_1_a_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelement"](0, "a", 3);
  }
  if (rf & 2) {
    const link_r2 = core_js_["ɵɵnextContext"]().$implicit;
    const ctx_r3 = core_js_["ɵɵnextContext"](2);
    core_js_["ɵɵproperty"]("title", ctx_r3.text)("href", link_r2, core_js_["ɵɵsanitizeUrl"]);
  }
}
function TuiDocSourceCodeComponent_div_0_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵtemplate"](0, TuiDocSourceCodeComponent_div_0_ng_template_1_a_0_Template, 1, 2, "a", 2);
  }
  if (rf & 2) {
    const link_r2 = ctx.$implicit;
    core_js_["ɵɵproperty"]("ngIf", link_r2);
  }
}
function TuiDocSourceCodeComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    core_js_["ɵɵelementStart"](0, "div", 1);
    core_js_["ɵɵtemplate"](1, TuiDocSourceCodeComponent_div_0_ng_template_1_Template, 1, 1, "ng-template");
    core_js_["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = core_js_["ɵɵnextContext"]();
    core_js_["ɵɵproperty"]("content", ctx_r0.sourceCode)("context", ctx_r0.pathOptions);
  }
}
function rawLoad(content) {
  return (0,tslib_es6/* __awaiter */.mG)(this, void 0, void 0, function* () {
    return content instanceof Promise ? (yield content).default : content;
  });
}
const tuiRawLoad = (/* unused pure expression or super */ null && (rawLoad));

/**
 * @deprecated: use {@link tuiTryParseMarkdownCodeBlock} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function tryParseMarkdownCodeBlock(text = ``) {
  const tokens = new (markdown_it_default())().parse(text, {});
  const result = tokens.filter(({
    tag,
    type
  }) => tag === `code` && type === `fence`).map(({
    content
  }) => content);
  return result.length ? result : [text];
}
const tuiTryParseMarkdownCodeBlock = (/* unused pure expression or super */ null && (tryParseMarkdownCodeBlock));
let TuiDocCodeComponent = /*#__PURE__*/(() => {
  let TuiDocCodeComponent = class TuiDocCodeComponent {
    constructor() {
      this.rawLoader$$ = new BehaviorSubject('');
      this.filename = '';
      this.processor$ = this.rawLoader$$.pipe(switchMap(rawLoad), map(tryParseMarkdownCodeBlock));
    }
    set code(code) {
      this.rawLoader$$.next(code);
    }
    get hasFilename() {
      return !!this.filename;
    }
  };
  TuiDocCodeComponent.ɵfac = function TuiDocCodeComponent_Factory(t) {
    return new (t || TuiDocCodeComponent)();
  };
  TuiDocCodeComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDocCodeComponent,
    selectors: [["tui-doc-code"]],
    hostVars: 2,
    hostBindings: function TuiDocCodeComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("_has-filename", ctx.hasFilename);
      }
    },
    inputs: {
      filename: "filename",
      code: "code"
    },
    decls: 3,
    vars: 4,
    consts: [["class", "t-header", 4, "ngIf"], ["class", "t-code", 4, "ngFor", "ngForOf"], [1, "t-header"], [1, "t-code"], [3, "lineNumbers", "highlight"]],
    template: function TuiDocCodeComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵtemplate"](0, TuiDocCodeComponent_p_0_Template, 2, 1, "p", 0);
        core_js_["ɵɵtemplate"](1, TuiDocCodeComponent_pre_1_Template, 3, 2, "pre", 1);
        core_js_["ɵɵpipe"](2, "async");
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngIf", ctx.filename);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngForOf", core_js_["ɵɵpipeBind1"](2, 2, ctx.processor$));
      }
    },
    directives: [common_js_.NgIf, common_js_.NgForOf, Highlight],
    pipes: [common_js_.AsyncPipe],
    styles: ["[_nghost-%COMP%]{display:block}.t-header[_ngcontent-%COMP%]{font:var(--tui-font-text-s);font-weight:700}.t-code[_ngcontent-%COMP%]{margin:0}.t-code[_ngcontent-%COMP%] + .t-code[_ngcontent-%COMP%]{margin-top:1rem}.hljs[_ngcontent-%COMP%]:not(:empty){font:var(--tui-font-text-m);padding:1.5rem 2rem;font-family:monospace;background:var(--tui-clear-disabled);word-wrap:break-word;white-space:pre-wrap}@media all and (-webkit-min-device-pixel-ratio:0) and (min-resolution:0.001dpcm){.hljs[_ngcontent-%COMP%]:not(:empty)::-webkit-scrollbar, .hljs[_ngcontent-%COMP%]:not(:empty)::-webkit-scrollbar-thumb{width:1rem;height:1rem;border-radius:6.25rem;background-clip:padding-box;border:2.667rem solid transparent}.hljs[_ngcontent-%COMP%]:not(:empty)::-webkit-scrollbar{background-color:transparent}.hljs[_ngcontent-%COMP%]:not(:empty)::-webkit-scrollbar-thumb{background-color:var(--tui-clear-hover)}.hljs[_ngcontent-%COMP%]:not(:empty)::-webkit-scrollbar-thumb:hover{background-color:var(--tui-clear-active)}.hljs[_ngcontent-%COMP%]:not(:empty)::-webkit-scrollbar-thumb:active{background-color:var(--tui-text-03)}}._has-filename[_nghost-%COMP%]   .hljs[_ngcontent-%COMP%]:not(:empty){border-radius:.75rem}tui-root._mobile[_nghost-%COMP%]   .hljs[_ngcontent-%COMP%]:not(:empty), tui-root._mobile   [_nghost-%COMP%]   .hljs[_ngcontent-%COMP%]:not(:empty){padding:1rem}"]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocCodeComponent.prototype, "filename", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocCodeComponent.prototype, "code", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._has-filename')], TuiDocCodeComponent.prototype, "hasFilename", null);
  return TuiDocCodeComponent;
})();
let TuiDocCodeModule = /*#__PURE__*/(() => {
  let TuiDocCodeModule = class TuiDocCodeModule {};
  TuiDocCodeModule.ɵfac = function TuiDocCodeModule_Factory(t) {
    return new (t || TuiDocCodeModule)();
  };
  TuiDocCodeModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocCodeModule
  });
  TuiDocCodeModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, HighlightModule]]
  });
  return TuiDocCodeModule;
})();
const COPIED_TIMEOUT = 1500;
// @dynamic
let TuiDocCopyComponent = /*#__PURE__*/(() => {
  let TuiDocCopyComponent = class TuiDocCopyComponent {
    constructor(texts$) {
      this.texts$ = texts$;
      this.copy$ = new Subject();
    }
    get copied$() {
      return this.copy$.pipe(switchMapTo(timer(COPIED_TIMEOUT).pipe(mapTo(false), startWith(true))));
    }
    onClick() {
      this.copy$.next();
    }
  };
  TuiDocCopyComponent.ɵfac = function TuiDocCopyComponent_Factory(t) {
    return new (t || TuiDocCopyComponent)(core_js_["ɵɵdirectiveInject"](TUI_COPY_TEXTS));
  };
  TuiDocCopyComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDocCopyComponent,
    selectors: [["tui-doc-copy"]],
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])],
    ngContentSelectors: taiga_ui_addon_doc_c0,
    decls: 2,
    vars: 3,
    consts: [["tuiButton", "", "type", "button", "appearance", "", "size", "s", "class", "t-copy", 3, "title", "click", 4, "ngIf"], ["tuiButton", "", "type", "button", "appearance", "", "size", "s", 1, "t-copy", 3, "title", "click"], [1, "t-content"], [1, "t-initial"]],
    template: function TuiDocCopyComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵtemplate"](0, TuiDocCopyComponent_button_0_Template, 6, 7, "button", 0);
        core_js_["ɵɵpipe"](1, "async");
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngIf", core_js_["ɵɵpipeBind1"](1, 1, ctx.texts$));
      }
    },
    directives: [common_js_.NgIf, taiga_ui_core_components_button/* TuiButtonComponent */.v0],
    pipes: [common_js_.AsyncPipe],
    styles: ["[_nghost-%COMP%]{position:relative;display:inline-block;vertical-align:middle}.t-copy[_ngcontent-%COMP%]{transition-property:background;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;width:100%;color:var(--tui-text-01);background:var(--tui-base-01);overflow:hidden}.t-copy[_ngcontent-%COMP%]:hover{background:var(--tui-base-02)}.t-initial[_ngcontent-%COMP%]{white-space:nowrap}.t-initial[_ngcontent-%COMP%]:empty:before{content:attr(data-text)}.t-content[_ngcontent-%COMP%]{transition-property:transform;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;display:flex;flex-direction:column;transform:translateY(1rem);text-align:center;line-height:2rem}.t-content_moved[_ngcontent-%COMP%]{transform:translateY(-1rem)}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDocCopyComponent.prototype, "copied$", null);
  TuiDocCopyComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TUI_COPY_TEXTS))], TuiDocCopyComponent);
  return TuiDocCopyComponent;
})();
let TuiDocCopyModule = /*#__PURE__*/(() => {
  let TuiDocCopyModule = class TuiDocCopyModule {};
  TuiDocCopyModule.ɵfac = function TuiDocCopyModule_Factory(t) {
    return new (t || TuiDocCopyModule)();
  };
  TuiDocCopyModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocCopyModule
  });
  TuiDocCopyModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, taiga_ui_core_components_button/* TuiButtonModule */.fN]]
  });

  /**
   * TODO: think about reorganization in @taiga-ui/i18n way
   */
  /**
   * Works with a tuple
   * [@string tuiMode tooltip content, @string word 'background', @string 'form value']
   */
  return TuiDocCopyModule;
})();
const TUI_DOC_DEMO_TEXTS = new core_js_.InjectionToken(`tui-doc-demo i18n texts`, {
  factory: () => [`Read more more about modes: `, `Background`, `Form value`]
});
/**
 * Works with a tuple
 * [
 * @string word 'argument',
 * @string word 'type',
 * @string 'name and description',
 * @string word 'value'
 * @string message for tooltip about ng-polymorpheus
 * ]
 */
const TUI_DOC_DOCUMENTATION_TEXTS = new core_js_.InjectionToken(`tui-doc-documentation i18n texts`, {
  factory: () => [`Argument`, `Type`, `Name and description`, `Value`, `Learn about our dynamic templates from `]
});
/**
 * Works with a tuple
 * [
 * @string default tab name,
 * @string link to a sample copied message text,
 * @string link to a sample copied message label
 * ]
 */
const TUI_DOC_EXAMPLE_TEXTS = new core_js_.InjectionToken(`tui-doc-example i18n texts`, {
  factory: () => [`Preview`, `Link to a sample was successfully copied`, `Done`]
});
const TUI_DOC_MENU_TEXT = new core_js_.InjectionToken(`menu i18n text`, {
  factory: () => `Menu`
});
const TUI_DOC_SEARCH_TEXT = new core_js_.InjectionToken(`search i18n text`, {
  factory: () => `Search`
});
const TUI_DOC_SEE_ALSO_TEXT = new core_js_.InjectionToken(`tui-doc-see-also i18n text`, {
  factory: () => `See also`
});
const TUI_DOC_SOURCE_CODE_TEXT = new core_js_.InjectionToken(`tui-doc-source-code i18n text`, {
  factory: () => `Source code`
});
var TuiDocDemoComponent_1;
const MIN_COMPONENT_WIDTH = 104;
// @dynamic
let TuiDocDemoComponent = TuiDocDemoComponent_1 = class TuiDocDemoComponent {
  constructor(isMobile, destroy$, renderer, platformId, locationRef, urlSerializer, texts) {
    this.isMobile = isMobile;
    this.destroy$ = destroy$;
    this.renderer = renderer;
    this.texts = texts;
    this.initialX = 0;
    this.wrapperWidth = 0;
    this.control = null;
    this.template = null;
    this.updateOnVariants = ['change', 'blur', 'submit'];
    this.updateOn = 'change';
    this.expanded = false;
    this.opaque = true;
    this.modeControl = new fesm2015_forms.FormControl();
    this.mode = null;
    this.change$ = new Subject();
    this.items = ['onLight', 'onDark'];
    this.isBrowser = (0,common_js_.isPlatformBrowser)(platformId);
    const parsedMode = locationRef.path().match(/tuiMode=(onDark|onLight)/);
    if (parsedMode !== null && parsedMode.length > 0) {
      this.modeControl.setValue(parsedMode[1]);
    }
    this.modeControl.valueChanges.pipe(startWith(this.modeControl.value), takeUntil(this.destroy$)).subscribe(mode => {
      const urlTree = urlSerializer.parse(locationRef.path());
      urlTree.queryParams = Object.assign(Object.assign({}, urlTree.queryParams), {
        tuiMode: mode
      });
      locationRef.go(String(urlTree));
      this.mode = mode;
      this.change$.next();
    });
  }
  onResize() {
    this.setResizerTextContent();
  }
  ngOnInit() {
    this.createForm();
  }
  ngAfterViewInit() {
    this.setResizerTextContent();
  }
  setResizerTextContent() {
    if (!this.content || !this.resizerText) {
      return;
    }
    const paddingLeft = this.isBrowser ? getComputedStyle(this.content.nativeElement).paddingLeft : '0';
    const {
      offsetWidth
    } = this.content.nativeElement;
    this.resizerText.nativeElement.textContent = String(offsetWidth - parseInt(paddingLeft || '0', 10) * 2);
  }
  onDragStart(event) {
    event.preventDefault();
    this.initialX = event.clientX;
    this.wrapperWidth = this.wrapper ? this.wrapper.nativeElement.offsetWidth : 0;
  }
  onDragContinues(event) {
    const deltaX = this.initialX - event.clientX;
    this.resizeContent(deltaX);
    this.setResizerTextContent();
  }
  onDragEnd() {
    this.wrapperWidth = this.wrapper ? this.wrapper.nativeElement.offsetWidth : 0;
  }
  toggleDetails() {
    this.expanded = !this.expanded;
  }
  updateOnChange(updateOn) {
    this.updateOn = updateOn;
    this.createForm();
  }
  createForm() {
    const {
      control,
      updateOn
    } = this;
    if (!control) {
      return;
    }
    this.testForm = new fesm2015_forms.FormGroup({
      testValue: control
    }, {
      updateOn
    });
  }
  resizeContent(delta) {
    if (!this.wrapper) {
      return;
    }
    this.renderer.setStyle(this.wrapper.nativeElement, 'width', px(Math.max(this.wrapperWidth - delta, MIN_COMPONENT_WIDTH)));
  }
};
TuiDocDemoComponent.ɵfac = function TuiDocDemoComponent_Factory(t) {
  return new (t || TuiDocDemoComponent)(core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3), core_js_["ɵɵdirectiveInject"](core_js_.Renderer2), core_js_["ɵɵdirectiveInject"](core_js_.PLATFORM_ID), core_js_["ɵɵdirectiveInject"](common_js_.Location), core_js_["ɵɵdirectiveInject"](router_js_.UrlSerializer), core_js_["ɵɵdirectiveInject"](TUI_DOC_DEMO_TEXTS));
};
TuiDocDemoComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiDocDemoComponent,
  selectors: [["tui-doc-demo"]],
  contentQueries: function TuiDocDemoComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      core_js_["ɵɵcontentQuery"](dirIndex, core_js_.TemplateRef, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.template = _t.first);
    }
  },
  viewQuery: function TuiDocDemoComponent_Query(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵviewQuery"](taiga_ui_addon_doc_c1, 5);
      core_js_["ɵɵviewQuery"](taiga_ui_addon_doc_c2, 5);
      core_js_["ɵɵviewQuery"](taiga_ui_addon_doc_c3, 5);
    }
    if (rf & 2) {
      let _t;
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.content = _t.first);
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.wrapper = _t.first);
      core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.resizerText = _t.first);
    }
  },
  hostBindings: function TuiDocDemoComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵlistener"]("resize", function TuiDocDemoComponent_resize_HostBindingHandler() {
        return ctx.onResize();
      }, false, core_js_["ɵɵresolveWindow"]);
    }
  },
  inputs: {
    control: "control"
  },
  features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3, {
    provide: taiga_ui_core_directives_mode/* TuiModeDirective */.w,
    useExisting: (0,core_js_.forwardRef)(() => TuiDocDemoComponent_1)
  }])],
  ngContentSelectors: taiga_ui_addon_doc_c0,
  decls: 17,
  vars: 12,
  consts: [[1, "t-bg-toggle", 3, "tuiMode"], ["tooltip", ""], [4, "ngIf", "ngIfElse"], ["desktop", ""], ["size", "m", 1, "t-checkbox", 3, "ngModel", "ngModelChange"], [1, "t-wrapper"], ["wrapper", ""], ["id", "demoContent", 1, "t-content"], ["content", ""], ["class", "t-form", 3, "formGroup", 4, "ngIf"], ["tabindex", "-1", 1, "t-resizer", 3, "tuiDragStart", "tuiDragContinues", "tuiDragEnd"], [1, "t-resizer-text"], ["resizerText", ""], ["tuiLink", "", "tuiMode", "onDark", "routerLink", "/directives/mode"], ["tuiTextfieldSize", "s", 1, "t-mode", 3, "tuiTextfieldCleaner", "tuiHintContent", "formControl"], [3, "items", 4, "tuiDataList"], [3, "items"], ["describeId", "form", 3, "content"], ["tuiGroup", "", 1, "t-group", 3, "collapsed"], ["size", "s", "nativeId", "form", 1, "tui-group__auto-width-item", 3, "item", "hideRadio", "formControl"], ["item", "onDark", "size", "s", "nativeId", "form", 1, "tui-group__auto-width-item", 3, "hideRadio", "formControl"], ["item", "onLight", "size", "s", "nativeId", "form", 1, "tui-group__auto-width-item", 3, "hideRadio", "formControl"], [1, "t-form", 3, "formGroup"], [1, "t-input-wrapper"], [3, "ngTemplateOutlet"], ["tuiButton", "", "type", "button", "size", "s", 1, "t-button", 3, "iconRight", "click"], ["icon", ""], [1, "t-expand", 3, "expanded"], ["tuiExpandContent", ""], ["src", "tuiIconChevronDown", 1, "t-icon"], [1, "t-value"], ["tuiGroup", "", 1, "t-form-controls"], ["tuiTextfieldSize", "s", 1, "t-select", 3, "ngModel", "ngModelOptions", "ngModelChange"], ["tuiButton", "", "type", "reset", "size", "s", 1, "tui-group__auto-width-item"], ["tuiButton", "", "type", "submit", "size", "s", 1, "tui-group__auto-width-item"]],
  template: function TuiDocDemoComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"]();
      core_js_["ɵɵelementStart"](0, "div", 0);
      core_js_["ɵɵtemplate"](1, TuiDocDemoComponent_ng_template_1_Template, 4, 1, "ng-template", null, 1, core_js_["ɵɵtemplateRefExtractor"]);
      core_js_["ɵɵtemplate"](3, TuiDocDemoComponent_ng_container_3_Template, 4, 3, "ng-container", 2);
      core_js_["ɵɵtemplate"](4, TuiDocDemoComponent_ng_template_4_Template, 9, 9, "ng-template", null, 3, core_js_["ɵɵtemplateRefExtractor"]);
      core_js_["ɵɵelementStart"](6, "tui-checkbox-labeled", 4);
      core_js_["ɵɵlistener"]("ngModelChange", function TuiDocDemoComponent_Template_tui_checkbox_labeled_ngModelChange_6_listener($event) {
        return ctx.opaque = $event;
      });
      core_js_["ɵɵtext"](7);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementStart"](8, "div", 5, 6);
      core_js_["ɵɵelementStart"](10, "div", 7, 8);
      core_js_["ɵɵtemplate"](12, TuiDocDemoComponent_form_12_Template, 9, 5, "form", 9);
      core_js_["ɵɵprojection"](13);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementStart"](14, "button", 10);
      core_js_["ɵɵlistener"]("tuiDragStart", function TuiDocDemoComponent_Template_button_tuiDragStart_14_listener($event) {
        return ctx.onDragStart($event);
      })("tuiDragContinues", function TuiDocDemoComponent_Template_button_tuiDragContinues_14_listener($event) {
        return ctx.onDragContinues($event);
      })("tuiDragEnd", function TuiDocDemoComponent_Template_button_tuiDragEnd_14_listener() {
        return ctx.onDragEnd();
      });
      core_js_["ɵɵelement"](15, "span", 11, 12);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      const _r3 = core_js_["ɵɵreference"](5);
      core_js_["ɵɵproperty"]("tuiMode", null);
      core_js_["ɵɵadvance"](3);
      core_js_["ɵɵproperty"]("ngIf", ctx.isMobile)("ngIfElse", _r3);
      core_js_["ɵɵadvance"](3);
      core_js_["ɵɵproperty"]("ngModel", ctx.opaque);
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵtextInterpolate1"](" ", ctx.texts[1], " ");
      core_js_["ɵɵadvance"](1);
      core_js_["ɵɵclassProp"]("t-wrapper_dark", ctx.modeControl.value === "onDark")("t-wrapper_gray", ctx.modeControl.value === "onLight")("t-wrapper_transparent", !ctx.opaque);
      core_js_["ɵɵadvance"](4);
      core_js_["ɵɵproperty"]("ngIf", ctx.testForm);
    }
  },
  directives: [taiga_ui_core_directives_mode/* TuiModeDirective */.w, common_js_.NgIf, TuiCheckboxLabeledComponent, fesm2015_forms.NgControlStatus, fesm2015_forms.NgModel, TuiDragDirective, taiga_ui_core_components_link/* TuiLinkComponent */.V, router_js_.RouterLinkWithHref, TuiSelectComponent, TuiSelectDirective, TuiTextfieldSizeDirective, TuiTextfieldCleanerDirective, TuiHintControllerDirective, fesm2015_forms.FormControlDirective, TuiDataListDirective, TuiDataListWrapperComponent, TuiTooltipComponent, TuiGroupDirective, TuiRadioBlockComponent, fesm2015_forms["ɵNgNoValidate"], fesm2015_forms.NgControlStatusGroup, fesm2015_forms.FormGroupDirective, common_js_.NgTemplateOutlet, taiga_ui_core_components_button/* TuiButtonComponent */.v0, TuiExpandComponent, TuiExpandContentDirective, taiga_ui_core_components_svg/* TuiSvgComponent */.P],
  pipes: [common_js_.JsonPipe],
  styles: ["[_nghost-%COMP%]{position:relative;display:block;min-width:100%;margin:1.5rem 0}.t-bg-toggle[_ngcontent-%COMP%]{position:absolute;bottom:calc(100% + .75rem);display:flex;align-items:center;justify-content:flex-end;pointer-events:none;width:100%}.t-bg-toggle[_ngcontent-%COMP%] > *[_ngcontent-%COMP%]{pointer-events:auto}.t-wrapper[_ngcontent-%COMP%]{box-shadow:0 .5rem 1rem rgba(0,0,0,.16);display:flex;border:1px solid var(--tui-base-03);border-radius:var(--tui-radius-m);max-width:100%;min-height:6rem;width:100%;background-color:var(--tui-base-01);overflow:hidden}.t-wrapper.t-wrapper_transparent[_ngcontent-%COMP%]{background-image:linear-gradient(45deg,var(--tui-base-02) 25%,transparent 25%),linear-gradient(-45deg,var(--tui-base-02) 25%,transparent 25%),linear-gradient(45deg,transparent 75%,var(--tui-base-02) 75%),linear-gradient(-45deg,transparent 75%,var(--tui-base-02) 75%);background-size:1.25rem 1.25rem;background-position:0 0,0 .625rem,.625rem -.625rem,-.625rem 0}.t-wrapper.t-wrapper_dark[_ngcontent-%COMP%]{background-color:#454e58;color:var(--tui-base-01)}.t-wrapper.t-wrapper_gray[_ngcontent-%COMP%]{background-color:#e5e7ea}.t-wrapper.t-wrapper_dark.t-wrapper_transparent[_ngcontent-%COMP%]{background-image:linear-gradient(45deg,var(--tui-focus) 25%,transparent 25%),linear-gradient(-45deg,var(--tui-focus) 25%,transparent 25%),linear-gradient(45deg,transparent 75%,var(--tui-focus) 75%),linear-gradient(-45deg,transparent 75%,var(--tui-focus) 75%)}.t-wrapper.t-wrapper_gray.t-wrapper_transparent[_ngcontent-%COMP%]{background-image:linear-gradient(45deg,var(--tui-base-05) 25%,transparent 25%),linear-gradient(-45deg,var(--tui-base-05) 25%,transparent 25%),linear-gradient(45deg,transparent 75%,var(--tui-base-05) 75%),linear-gradient(-45deg,transparent 75%,var(--tui-base-05) 75%)}tui-root._mobile[_nghost-%COMP%]   .t-wrapper[_ngcontent-%COMP%], tui-root._mobile   [_nghost-%COMP%]   .t-wrapper[_ngcontent-%COMP%]{min-height:auto}.t-content[_ngcontent-%COMP%]{flex:1 1 0;min-width:0;padding:1.5rem;box-sizing:border-box;overflow:hidden}tui-root._mobile[_nghost-%COMP%]   .t-content[_ngcontent-%COMP%], tui-root._mobile   [_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{padding:1rem}.t-form[_ngcontent-%COMP%]{display:flex;flex-wrap:wrap;align-items:flex-start}.t-input-wrapper[_ngcontent-%COMP%]{width:100%;margin-bottom:.5rem}.t-expand[_ngcontent-%COMP%]{width:100%}.t-icon[_ngcontent-%COMP%]{transition-property:transform;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out}.t-icon_rotated[_ngcontent-%COMP%]{transform:rotate(180deg)}.t-value[_ngcontent-%COMP%]{flex:1;background:var(--tui-clear-inverse);padding:.75rem;border-radius:.25rem}.t-mode[_ngcontent-%COMP%]{width:12.5rem}.t-select[_ngcontent-%COMP%]{max-width:15rem}.t-resizer[_ngcontent-%COMP%]{-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:0;border:0;background:0 0;font-size:inherit;line-height:inherit;box-shadow:0 .5rem 1rem rgba(0,0,0,.16);position:relative;width:3.5rem;min-height:inherit;flex-shrink:0;border-left:1px solid var(--tui-base-03);cursor:col-resize;outline:0;background:var(--tui-base-01);color:var(--tui-text-01)}.t-resizer[_ngcontent-%COMP%]:after, .t-resizer[_ngcontent-%COMP%]:before{content:'';position:absolute;top:.75rem;left:50%;bottom:.75rem;width:1px;background:var(--tui-base-05)}.t-resizer[_ngcontent-%COMP%]:before{transform:translateX(.125rem)}.t-resizer[_ngcontent-%COMP%]:after{transform:translateX(-.1875rem)}tui-root._mobile[_nghost-%COMP%]   .t-resizer[_ngcontent-%COMP%], tui-root._mobile   [_nghost-%COMP%]   .t-resizer[_ngcontent-%COMP%]{display:none}.t-resizer-text[_ngcontent-%COMP%]{font:var(--tui-font-text-s);position:relative;z-index:1;padding:.75rem;background:var(--tui-base-01)}.wrapper_light[_ngcontent-%COMP%]   .t-resizer-text[_ngcontent-%COMP%]{background:#3e464e}.t-checkbox[_ngcontent-%COMP%], .t-group[_ngcontent-%COMP%]{margin-left:.75rem}.t-button[_ngcontent-%COMP%], .t-form-controls[_ngcontent-%COMP%]{margin-top:.75rem}@supports ((position:-webkit-sticky) or (position:sticky)){@media screen and (min-height:37.5rem){[_nghost-%COMP%]{position:-webkit-sticky;position:sticky;top:4.625rem;z-index:2}}}"],
  changeDetection: 0
});
TuiDocDemoComponent.ctorParameters = () => [{
  type: Boolean,
  decorators: [{
    type: core_js_.Inject,
    args: [taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL]
  }]
}, {
  type: taiga_ui_cdk_services/* TuiDestroyService */.a3,
  decorators: [{
    type: core_js_.Inject,
    args: [taiga_ui_cdk_services/* TuiDestroyService */.a3]
  }]
}, {
  type: core_js_.Renderer2,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.Renderer2]
  }]
}, {
  type: undefined,
  decorators: [{
    type: core_js_.Inject,
    args: [core_js_.PLATFORM_ID]
  }]
}, {
  type: common_js_.Location,
  decorators: [{
    type: core_js_.Inject,
    args: [common_js_.Location]
  }]
}, {
  type: router_js_.UrlSerializer,
  decorators: [{
    type: core_js_.Inject,
    args: [router_js_.UrlSerializer]
  }]
}, {
  type: Array,
  decorators: [{
    type: core_js_.Inject,
    args: [TUI_DOC_DEMO_TEXTS]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('content')], TuiDocDemoComponent.prototype, "content", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('wrapper')], TuiDocDemoComponent.prototype, "wrapper", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ViewChild)('resizerText')], TuiDocDemoComponent.prototype, "resizerText", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocDemoComponent.prototype, "control", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChild)(core_js_.TemplateRef)], TuiDocDemoComponent.prototype, "template", void 0);
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostListener)('window:resize')], TuiDocDemoComponent.prototype, "onResize", null);
TuiDocDemoComponent = TuiDocDemoComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_MOBILE */.fL)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.Renderer2)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(core_js_.PLATFORM_ID)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(common_js_.Location)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(router_js_.UrlSerializer)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(TUI_DOC_DEMO_TEXTS))], TuiDocDemoComponent);
let TuiDocDemoModule = /*#__PURE__*/(() => {
  let TuiDocDemoModule = class TuiDocDemoModule {};
  TuiDocDemoModule.ɵfac = function TuiDocDemoModule_Factory(t) {
    return new (t || TuiDocDemoModule)();
  };
  TuiDocDemoModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocDemoModule
  });
  TuiDocDemoModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, fesm2015_forms.ReactiveFormsModule, fesm2015_forms.FormsModule, router_js_.RouterModule, taiga_ui_core_components_link/* TuiLinkModule */.j, TuiDragModule, taiga_ui_core_components_button/* TuiButtonModule */.fN, TuiSelectModule, TuiExpandModule, TuiGroupModule, TuiTooltipModule, taiga_ui_core_directives_mode/* TuiModeModule */.z, TuiRadioBlockModule, TuiCheckboxLabeledModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiDataListWrapperModule, TuiDataListModule, TuiTextfieldControllerModule, TuiHintControllerModule]]
  });

  /**
   * TODO: duplicate, need fix it before v3
   * TODO: move another package for reuse between addon-editor and addon-doc
   * @deprecated: use {@link tuiRgbToHex} instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  return TuiDocDemoModule;
})();
function rgbToHex(r, g, b) {
  return `#${[r, g, b].map(x => x.toString(16).padStart(2, `0`)).join(``)}`;
}
const tuiRgbToHex = (/* unused pure expression or super */ null && (rgbToHex));
/**
 * @deprecated: use {@link tuiHexToRgb} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function hexToRgb(hex) {
  const matches = hex.replace(`#`, ``).split(``).map((char, _, array) => array.length === 3 ? char + char : char).join(``).match(/.{2}/g);
  return matches ? matches.map(x => Number.parseInt(x, 16)) : [0, 0, 0];
}
const tuiHexToRgb = (/* unused pure expression or super */ null && (hexToRgb));
function inspectArray(array, depth) {
  if (depth === 0) {
    return `[…]`;
  }
  let result = ``;
  let first = true;
  for (let index = 0; index < array.length; index++) {
    if (first) {
      first = false;
    } else {
      result += `, `;
    }
    result += index in array ? inspectAny(array[index], depth - 1) : `empty`;
  }
  return `[${result}]`;
}
function inspectObject(object, depth) {
  if (depth === 0) {
    return `{…}`;
  }
  let result = ``;
  let first = true;
  for (const key in object) {
    if (!object.hasOwnProperty(key)) {
      continue;
    }
    if (first) {
      first = false;
    } else {
      result += `, `;
    }
    result += `${key}: ${inspectAny(object[key], depth - 1)}`;
  }
  return `{${result}}`;
}
/**
 * @deprecated: use {@link tuiInspectAny} instead
 * Returns readable JS entity
 * @param data
 * @param depth
 * @return readable JS entity
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function inspectAny(data, depth) {
  if (data === null) {
    return `null`;
  }
  switch (typeof data) {
    case `string`:
      return `'${data}'`;
    case `undefined`:
    case `number`:
    case `boolean`:
    case `function`:
      return String(data);
  }
  if (data instanceof RegExp) {
    return String(data);
  }
  if (Array.isArray(data)) {
    return inspectArray(data, depth);
  }
  return inspectObject(data, depth);
}
const tuiInspectAny = (/* unused pure expression or super */ null && (inspectAny));

/**
 * @deprecated: use {@link tuiCoerceValue} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function coerceValue(value) {
  const prepared = String(value).trim();
  if (isEmptyParamValue(prepared)) {
    return null;
  }
  if (isBooleanParamValue(prepared)) {
    return String(prepared) === `true`;
  }
  if (isNumberParamValue(prepared)) {
    return Number(prepared);
  }
  const decodedValue = decodeURIComponent(prepared);
  try {
    return isPossibleArray(decodedValue) || isPossibleObject(decodedValue) ? JSON.parse(decodedValue) : decodedValue;
  } catch (_a) {
    return decodedValue;
  }
}
const tuiCoerceValue = (/* unused pure expression or super */ null && (coerceValue));
function isEmptyParamValue(value) {
  return [`undefined`, `null`, `NaN`, `Infinity`].includes(value);
}
function isBooleanParamValue(value) {
  return value === `true` || value === `false`;
}
function isNumberParamValue(value) {
  // TODO: investigate to disallow potentially catastrophic exponential-time regular expressions.
  // eslint-disable-next-line unicorn/no-unsafe-regex
  return /^-?[\d.]+(?:e-?\d+)?$/.test(value);
}
function isPossibleArray(value) {
  return value.startsWith(`[`) && value.endsWith(`]`);
}
function isPossibleObject(value) {
  return value.startsWith(`{`) && value.endsWith(`}`);
}
const SERIALIZED_SUFFIX = '$';
// @bad TODO: refactor output and value sync
let TuiDocDocumentationPropertyConnectorDirective = /*#__PURE__*/(() => {
  let TuiDocDocumentationPropertyConnectorDirective = class TuiDocDocumentationPropertyConnectorDirective {
    constructor(template, locationRef, activatedRoute, urlSerializer) {
      this.template = template;
      this.locationRef = locationRef;
      this.activatedRoute = activatedRoute;
      this.urlSerializer = urlSerializer;
      this.documentationPropertyName = '';
      this.documentationPropertyMode = null;
      this.documentationPropertyType = '';
      this.documentationPropertyDeprecated = false;
      this.documentationPropertyValues = null;
      this.documentationPropertyValueChange = new core_js_.EventEmitter();
      this.changed$ = new Subject();
      this.emits$ = new BehaviorSubject(1);
    }
    ngOnInit() {
      this.parseParams(this.activatedRoute.snapshot.queryParams);
    }
    get attrName() {
      switch (this.documentationPropertyMode) {
        case 'input':
          return `[${this.documentationPropertyName}]`;
        case 'output':
          return `(${this.documentationPropertyName})`;
        case 'input-output':
          return `[(${this.documentationPropertyName})]`;
        default:
          return this.documentationPropertyName;
      }
    }
    get hasItems() {
      return !!this.documentationPropertyValues;
    }
    get shouldShowValues() {
      return this.documentationPropertyMode !== 'output';
    }
    ngOnChanges() {
      this.changed$.next();
    }
    onValueChange(value) {
      this.documentationPropertyValue = value;
      this.documentationPropertyValueChange.emit(value);
      this.setQueryParam(value);
    }
    emitEvent(event) {
      // For more convenient debugging
      console.info(this.attrName, event);
      this.emits$.next(this.emits$.value + 1);
    }
    parseParams(params) {
      const propertyValue = params[this.documentationPropertyName];
      const propertyValueWithSuffix = params[`${this.documentationPropertyName}${SERIALIZED_SUFFIX}`];
      if (!propertyValue && !propertyValueWithSuffix) {
        return;
      }
      const value = !!propertyValueWithSuffix && this.documentationPropertyValues ? this.documentationPropertyValues[propertyValueWithSuffix] : coerceValue(propertyValue);
      this.onValueChange(value);
    }
    setQueryParam(value) {
      const tree = this.urlSerializer.parse(this.locationRef.path());
      const isValueAvailableByKey = value instanceof Object;
      const computedValue = isValueAvailableByKey && this.documentationPropertyValues ? this.documentationPropertyValues.indexOf(value) : value;
      const suffix = isValueAvailableByKey ? SERIALIZED_SUFFIX : '';
      const propName = this.documentationPropertyName + suffix;
      tree.queryParams = Object.assign(Object.assign({}, tree.queryParams), {
        [propName]: computedValue
      });
      this.locationRef.go(String(tree));
    }
  };
  TuiDocDocumentationPropertyConnectorDirective.ɵfac = function TuiDocDocumentationPropertyConnectorDirective_Factory(t) {
    return new (t || TuiDocDocumentationPropertyConnectorDirective)(core_js_["ɵɵdirectiveInject"](core_js_.TemplateRef), core_js_["ɵɵdirectiveInject"](common_js_.Location), core_js_["ɵɵdirectiveInject"](router_js_.ActivatedRoute), core_js_["ɵɵdirectiveInject"](router_js_.UrlSerializer));
  };
  TuiDocDocumentationPropertyConnectorDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiDocDocumentationPropertyConnectorDirective,
    selectors: [["ng-template", "documentationPropertyName", ""]],
    inputs: {
      documentationPropertyName: "documentationPropertyName",
      documentationPropertyMode: "documentationPropertyMode",
      documentationPropertyType: "documentationPropertyType",
      documentationPropertyDeprecated: "documentationPropertyDeprecated",
      documentationPropertyValues: "documentationPropertyValues",
      documentationPropertyValue: "documentationPropertyValue"
    },
    outputs: {
      documentationPropertyValueChange: "documentationPropertyValueChange"
    },
    exportAs: ["documentationProperty"],
    features: [core_js_["ɵɵNgOnChangesFeature"]]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocDocumentationPropertyConnectorDirective.prototype, "documentationPropertyName", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocDocumentationPropertyConnectorDirective.prototype, "documentationPropertyMode", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocDocumentationPropertyConnectorDirective.prototype, "documentationPropertyType", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocDocumentationPropertyConnectorDirective.prototype, "documentationPropertyValue", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocDocumentationPropertyConnectorDirective.prototype, "documentationPropertyDeprecated", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocDocumentationPropertyConnectorDirective.prototype, "documentationPropertyValues", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Output)()], TuiDocDocumentationPropertyConnectorDirective.prototype, "documentationPropertyValueChange", void 0);
  TuiDocDocumentationPropertyConnectorDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.TemplateRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(common_js_.Location)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(router_js_.ActivatedRoute)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(router_js_.UrlSerializer))], TuiDocDocumentationPropertyConnectorDirective);

  // @bad TODO subscribe propertiesConnectors changes
  // @bad TODO refactor to make more flexible
  // @dynamic
  return TuiDocDocumentationPropertyConnectorDirective;
})();
let TuiDocDocumentationComponent = /*#__PURE__*/(() => {
  let TuiDocDocumentationComponent = class TuiDocDocumentationComponent {
    constructor(changeDetectorRef, texts) {
      this.changeDetectorRef = changeDetectorRef;
      this.texts = texts;
      this.heading = '';
      this.showValues = true;
      this.isAPI = false;
      this.propertiesConnectors = taiga_ui_cdk_constants/* EMPTY_QUERY */.Mm;
      this.activeItemIndex = 0;
    }
    ngAfterContentInit() {
      (0,taiga_ui_cdk_observables/* itemsQueryListObservable */.Fp)(this.propertiesConnectors).pipe(switchMap(items => merge(...items.map(({
        changed$
      }) => changed$))), (0,taiga_ui_cdk_observables/* watch */.YP)(this.changeDetectorRef)).subscribe();
    }
    get type() {
      return this.isAPI ? this.texts[0] : this.texts[1];
    }
    getColor(color) {
      if (color.length === 4) {
        return color.split('').reduce((result, current) => [...result, current, current], []).join('').replace('#', '');
      }
      if (color.startsWith('#')) {
        return color;
      }
      if (color === 'transparent') {
        return '#000000';
      }
      const parsed = color.replace('rgb(', '').replace('rgba(', '').replace(')', '').replace(' ', '').split(',').map(v => Number.parseInt(v, 10));
      return rgbToHex(...parsed);
    }
    getOpacity(color) {
      if (color.startsWith('#') || color.startsWith('rgb(')) {
        return 100;
      }
      if (color === 'transparent') {
        return 0;
      }
      const lastComma = color.lastIndexOf(',');
      const parsed = color.slice(lastComma).replace(')', '').replace(' ', '').replace(',', '');
      return Math.round(Number.parseFloat(parsed) * 100);
    }
    onColorChange(connector, color) {
      const opacity = this.getOpacity(connector.documentationPropertyValue || '');
      if (opacity === 100) {
        connector.onValueChange(color);
        return;
      }
      const rgb = hexToRgb(color).join(', ');
      const result = `rgba(${rgb}, ${opacity / 100})`;
      connector.onValueChange(result);
    }
    onOpacityChange(connector, opacity) {
      const hex = this.getColor(connector.documentationPropertyValue || '');
      const rgb = hexToRgb(hex);
      const result = `rgba(${rgb}, ${opacity / 100})`;
      connector.onValueChange(result);
    }
    stripOptional(name) {
      return name.replace('?', '');
    }
    isOptional(name) {
      return name.includes('?');
    }
    isPrimitivePolymorpheusContent(value) {
      return typeof value === 'string' || typeof value === 'number';
    }
    showCleaner(type) {
      return type.includes('null');
    }
    showContentTooltip(type) {
      return type.includes('PolymorpheusContent');
    }
    inspectAny(data) {
      return inspectAny(data, 2);
    }
  };
  TuiDocDocumentationComponent.ɵfac = function TuiDocDocumentationComponent_Factory(t) {
    return new (t || TuiDocDocumentationComponent)(core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](TUI_DOC_DOCUMENTATION_TEXTS));
  };
  TuiDocDocumentationComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDocDocumentationComponent,
    selectors: [["tui-doc-documentation"]],
    contentQueries: function TuiDocDocumentationComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        core_js_["ɵɵcontentQuery"](dirIndex, TuiDocDocumentationPropertyConnectorDirective, 4);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.propertiesConnectors = _t);
      }
    },
    inputs: {
      heading: "heading",
      showValues: "showValues",
      isAPI: "isAPI"
    },
    ngContentSelectors: taiga_ui_addon_doc_c0,
    decls: 10,
    vars: 5,
    consts: [["class", "t-heading", 4, "ngIf"], [1, "t-table"], [1, "t-row", "t-row_header"], [1, "t-th", "t-cell", "t-cell_prop"], [1, "t-th"], ["class", "t-th t-cell t-cell_value", 4, "ngIf"], ["class", "t-row", 3, "t-deprecated", 4, "ngFor", "ngForOf"], [1, "t-heading"], [1, "t-th", "t-cell", "t-cell_value"], [1, "t-row"], [1, "t-cell"], ["automation-id", "tui-documentation__property-name", 1, "t-property"], ["size", "s", "value", "Optional", 4, "ngIf"], ["class", "t-deprecated-label", 4, "ngIf"], [3, "ngTemplateOutlet"], [1, "type"], [3, "describeId", "content", 4, "ngIf"], ["class", "t-cell", 4, "ngIf"], ["size", "s", "value", "Optional"], [1, "t-deprecated-label"], [3, "describeId", "content"], ["content", ""], ["tuiLink", "", "tuiMode", "onDark", "target", "_blank", "href", "https://github.com/tinkoff/ng-polymorpheus"], [4, "ngIf", "ngIfElse"], ["elseEmitter", ""], ["tuiTextfieldSize", "m", "tuiDropdownLimitWidth", "min", 3, "tuiTextfieldCleaner", "tuiTextfieldLabelOutside", "nativeId", "valueContent", "ngModel", "ngModelChange", 4, "ngIf", "ngIfElse"], ["selectContent", ""], ["noItems", ""], ["tuiTextfieldSize", "m", "tuiDropdownLimitWidth", "min", 3, "tuiTextfieldCleaner", "tuiTextfieldLabelOutside", "nativeId", "valueContent", "ngModel", "ngModelChange"], [1, "t-exception"], [3, "items", "itemContent", 4, "tuiDataList"], [3, "items", "itemContent"], [3, "ngSwitch"], ["size", "l", 3, "nativeId", "showIcons", "ngModel", "ngModelChange", 4, "ngSwitchCase"], ["tuiTextfieldSize", "m", 3, "nativeId", "tuiTextfieldLabelOutside", "tuiTextfieldCleaner", "value", "valueChange", 4, "ngSwitchCase"], ["tuiGroup", "", 4, "ngSwitchCase"], ["tuiTextfieldSize", "m", 3, "nativeId", "tuiTextfieldLabelOutside", "ngModel", "ngModelChange", 4, "ngSwitchCase"], [4, "ngSwitchCase"], ["size", "l", 3, "nativeId", "showIcons", "ngModel", "ngModelChange"], ["tuiTextfieldSize", "m", 3, "nativeId", "tuiTextfieldLabelOutside", "tuiTextfieldCleaner", "value", "valueChange"], ["tuiGroup", ""], ["tuiTextfieldType", "text", "tuiTextfieldSize", "m", 3, "tuiTextfieldLabelOutside", "tuiInputOpacity", "value", "valueChange"], ["tuiTextfieldSize", "m", 3, "max", "ngModel", "ngModelChange"], ["tuiTextfieldSize", "m", 3, "nativeId", "tuiTextfieldLabelOutside", "ngModel", "ngModelChange"], ["tuiTextfieldSize", "m", 3, "nativeId", "tuiTextfieldLabelOutside", "tuiTextfieldCleaner", "value", "valueChange", 4, "ngIf"], [1, "t-output"]],
    template: function TuiDocDocumentationComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵtemplate"](0, TuiDocDocumentationComponent_h1_0_Template, 2, 1, "h1", 0);
        core_js_["ɵɵprojection"](1);
        core_js_["ɵɵelementStart"](2, "table", 1);
        core_js_["ɵɵelementStart"](3, "tr", 2);
        core_js_["ɵɵelementStart"](4, "th", 3);
        core_js_["ɵɵtext"](5);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](6, "th", 4);
        core_js_["ɵɵtext"](7);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](8, TuiDocDocumentationComponent_th_8_Template, 2, 1, "th", 5);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](9, TuiDocDocumentationComponent_tr_9_Template, 12, 9, "tr", 6);
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngIf", ctx.heading);
        core_js_["ɵɵadvance"](5);
        core_js_["ɵɵtextInterpolate"](ctx.texts[2]);
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵtextInterpolate"](ctx.type);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.showValues && !ctx.isAPI);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngForOf", ctx.propertiesConnectors);
      }
    },
    directives: function () {
      return [common_js_.NgIf, common_js_.NgForOf, common_js_.NgTemplateOutlet, TuiBadgeComponent, TuiTooltipComponent, taiga_ui_core_components_link/* TuiLinkComponent */.V, taiga_ui_core_directives_mode/* TuiModeDirective */.w, TuiSelectComponent, TuiSelectDirective, TuiTextfieldSizeDirective, TuiDropdownControllerDirective, TuiTextfieldCleanerDirective, TuiTextfieldLabelOutsideDirective, fesm2015_forms.NgControlStatus, fesm2015_forms.NgModel, TuiDataListDirective, TuiDataListWrapperComponent, common_js_.NgSwitch, common_js_.NgSwitchCase, TuiToggleComponent, TuiPrimitiveTextfieldComponent, TuiPrimitiveTextfieldDirective, TuiGroupDirective, TuiTextfieldTypeDirective, TuiInputOpacityDirective, TuiInputCountComponent, TuiInputCountDirective, taiga_ui_core_components_notification/* TuiNotificationComponent */.Ls];
    },
    pipes: function () {
      return [common_js_.AsyncPipe];
    },
    styles: ["[_nghost-%COMP%]{display:block;min-width:100%}.t-table[_ngcontent-%COMP%]{width:100%;table-layout:fixed}.t-row[_ngcontent-%COMP%]:not(:last-child){border-bottom:1px solid var(--tui-base-03)}tui-root._mobile[_nghost-%COMP%]   .t-row[_ngcontent-%COMP%], tui-root._mobile   [_nghost-%COMP%]   .t-row[_ngcontent-%COMP%]{display:flex;flex-wrap:wrap}tui-root._mobile[_nghost-%COMP%]   .t-row_header[_ngcontent-%COMP%], tui-root._mobile   [_nghost-%COMP%]   .t-row_header[_ngcontent-%COMP%]{display:none}.t-cell[_ngcontent-%COMP%]{padding:1rem 1rem .875rem}.t-cell[_ngcontent-%COMP%]:first-child{padding-left:0}.t-cell[_ngcontent-%COMP%]:last-child{padding-right:0;text-align:right}.t-cell_prop[_ngcontent-%COMP%]{width:40%}.t-cell_value[_ngcontent-%COMP%]{max-width:20rem}tui-root._mobile[_nghost-%COMP%]   .t-cell_value[_ngcontent-%COMP%], tui-root._mobile   [_nghost-%COMP%]   .t-cell_value[_ngcontent-%COMP%]{width:9.375rem}tui-root._mobile[_nghost-%COMP%]   .t-cell[_ngcontent-%COMP%], tui-root._mobile   [_nghost-%COMP%]   .t-cell[_ngcontent-%COMP%]{width:100%;height:auto;padding:.5rem 0;text-align:left}.t-th[_ngcontent-%COMP%]{padding:.5rem 1rem;color:var(--tui-text-02);font-weight:400;text-align:left}.t-property[_ngcontent-%COMP%]{font:var(--tui-font-text-m);margin-bottom:.25rem;font-family:monospace;color:#8f75d1}tui-root._mobile[_nghost-%COMP%]   .t-property[_ngcontent-%COMP%], tui-root._mobile   [_nghost-%COMP%]   .t-property[_ngcontent-%COMP%]{padding:.5rem 0}.t-type[_ngcontent-%COMP%]{font-family:monospace}.t-deprecated[_ngcontent-%COMP%]{background-color:var(--tui-error-bg);box-shadow:-1rem 0 var(--tui-error-bg),1rem 0 var(--tui-error-bg)}.t-deprecated-label[_ngcontent-%COMP%]{margin-right:.125rem;color:var(--tui-error-fill)}.t-exception[_ngcontent-%COMP%]{display:block;width:-webkit-max-content;width:-moz-max-content;width:max-content}.t-output[_ngcontent-%COMP%]{text-align:left;opacity:0}.t-heading[_ngcontent-%COMP%]{font:var(--tui-font-heading-4)}"],
    data: {
      animation: [(0,animations/* trigger */.X$)('emitEvent', [(0,animations/* transition */.eR)(':increment', [(0,animations/* style */.oB)({
        opacity: 1
      }), (0,animations/* animate */.jt)('500ms ease-in')])])]
    },
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocDocumentationComponent.prototype, "heading", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocDocumentationComponent.prototype, "showValues", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocDocumentationComponent.prototype, "isAPI", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChildren)(TuiDocDocumentationPropertyConnectorDirective)], TuiDocDocumentationComponent.prototype, "propertiesConnectors", void 0);
  TuiDocDocumentationComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_DOC_DOCUMENTATION_TEXTS))], TuiDocDocumentationComponent);
  return TuiDocDocumentationComponent;
})();
let TuiInputOpacityDirective = /*#__PURE__*/(() => {
  let TuiInputOpacityDirective = class TuiInputOpacityDirective {
    constructor(renderer, tuiFocusableComponent) {
      this.renderer = renderer;
      this.tuiFocusableComponent = tuiFocusableComponent;
    }
    set tuiInputOpacity(opacity) {
      const {
        nativeFocusableElement
      } = this.tuiFocusableComponent;
      if (nativeFocusableElement) {
        this.renderer.setStyle(nativeFocusableElement, 'opacity', opacity / 100);
      }
    }
  };
  TuiInputOpacityDirective.ɵfac = function TuiInputOpacityDirective_Factory(t) {
    return new (t || TuiInputOpacityDirective)(core_js_["ɵɵdirectiveInject"](core_js_.Renderer2), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ));
  };
  TuiInputOpacityDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiInputOpacityDirective,
    selectors: [["", "tuiInputOpacity", ""]],
    inputs: {
      tuiInputOpacity: "tuiInputOpacity"
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiInputOpacityDirective.prototype, "tuiInputOpacity", null);
  TuiInputOpacityDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.Renderer2)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_FOCUSABLE_ITEM_ACCESSOR */.KZ))], TuiInputOpacityDirective);
  return TuiInputOpacityDirective;
})();
let TuiInputOpacityModule = /*#__PURE__*/(() => {
  let TuiInputOpacityModule = class TuiInputOpacityModule {};
  TuiInputOpacityModule.ɵfac = function TuiInputOpacityModule_Factory(t) {
    return new (t || TuiInputOpacityModule)();
  };
  TuiInputOpacityModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiInputOpacityModule
  });
  TuiInputOpacityModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiInputOpacityModule;
})();
let TuiDocDocumentationModule = /*#__PURE__*/(() => {
  let TuiDocDocumentationModule = class TuiDocDocumentationModule {};
  TuiDocDocumentationModule.ɵfac = function TuiDocDocumentationModule_Factory(t) {
    return new (t || TuiDocDocumentationModule)();
  };
  TuiDocDocumentationModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocDocumentationModule
  });
  TuiDocDocumentationModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, fesm2015_forms.FormsModule, router_js_.RouterModule, TuiBadgeModule, TuiSelectModule, TuiToggleModule, TuiTooltipModule, taiga_ui_core_components_link/* TuiLinkModule */.j, TuiInputCountModule, taiga_ui_core_directives_mode/* TuiModeModule */.z, TuiGroupModule, TuiInputOpacityModule, TuiPrimitiveTextfieldModule, TuiTextfieldControllerModule, TuiHintControllerModule, TuiDropdownControllerModule, TuiDataListModule, TuiDataListWrapperModule, taiga_ui_core_components_notification/* TuiNotificationModule */.Hi]]
  });
  return TuiDocDocumentationModule;
})();
const TUI_DOC_CODE_ACTIONS = new core_js_.InjectionToken(`Code actions for the opened tab with code example`, {
  factory: () => ``
});
const TUI_DOC_CODE_EDITOR = new core_js_.InjectionToken(`Contains service for opening online IDE e.g. Stackblitz`);
const TUI_DOC_EXAMPLE_CONTENT_PROCESSOR = new core_js_.InjectionToken(`Processes content in example`, {
  factory: () => identity
});

/**
 * @deprecated: use {@link tuiRawLoadRecord} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function rawLoadRecord(example) {
  return (0,tslib_es6/* __awaiter */.mG)(this, void 0, void 0, function* () {
    const processedContent = {};
    for (const [key, content] of Object.entries(example)) {
      if (content) {
        processedContent[key] = yield rawLoad(content);
      }
    }
    return processedContent;
  });
}
const tuiRawLoadRecord = (/* unused pure expression or super */ null && (rawLoadRecord));

// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
let TuiDocExampleComponent = /*#__PURE__*/(() => {
  let TuiDocExampleComponent = class TuiDocExampleComponent {
    constructor(id, clipboard, notifications, location, copyTexts$, texts, codeEditor, processContent, isCypress, codeActions, router, route, ngLocation) {
      this.id = id;
      this.clipboard = clipboard;
      this.notifications = notifications;
      this.location = location;
      this.copyTexts$ = copyTexts$;
      this.texts = texts;
      this.codeEditor = codeEditor;
      this.processContent = processContent;
      this.isCypress = isCypress;
      this.codeActions = codeActions;
      this.router = router;
      this.route = route;
      this.ngLocation = ngLocation;
      this.rawLoader$$ = new BehaviorSubject({});
      this.heading = '';
      this.description = '';
      this.componentName = this.location.pathname.slice(1);
      this.defaultTabIndex = 0;
      this.defaultTab = this.texts[this.defaultTabIndex];
      this.activeItemIndex = this.defaultTabIndex;
      this.copy$ = this.copyTexts$.pipe(map(([copy]) => copy));
      this.processor$ = this.rawLoader$$.pipe(switchMap(rawLoadRecord), map(value => this.processContent(value)));
      this.loading$ = new Subject();
    }
    set content(content) {
      this.rawLoader$$.next(content);
    }
    copyExampleLink() {
      const hashPosition = this.location.href.indexOf('#');
      const currentUrl = hashPosition > -1 ? this.location.href.slice(0, Math.max(0, hashPosition)) : this.location.href;
      const url = `${currentUrl}#${this.id}`;
      this.setFragmentWithoutRedirect(this.id);
      this.clipboard.copy(url);
      this.notifications.show(this.texts[1], {
        label: this.texts[2],
        status: "success" /* Success */
      }).subscribe();
    }
    edit(files) {
      var _a, _b;
      this.loading$.next(true);
      (_a = this.codeEditor) === null || _a === void 0 ? void 0 : _a.edit(this.componentName, (_b = this.id) !== null && _b !== void 0 ? _b : '', files).finally(() => this.loading$.next(false));
    }
    setFragmentWithoutRedirect(id) {
      const url = this.router.createUrlTree([], {
        relativeTo: this.route,
        fragment: id || ''
      }).toString();
      this.ngLocation.go(url);
    }
  };
  TuiDocExampleComponent.ɵfac = function TuiDocExampleComponent_Factory(t) {
    return new (t || TuiDocExampleComponent)(core_js_["ɵɵinjectAttribute"]('id'), core_js_["ɵɵdirectiveInject"](Clipboard), core_js_["ɵɵdirectiveInject"](TuiNotificationsService), core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* LOCATION */.Ct), core_js_["ɵɵdirectiveInject"](TUI_COPY_TEXTS), core_js_["ɵɵdirectiveInject"](TUI_DOC_EXAMPLE_TEXTS), core_js_["ɵɵdirectiveInject"](TUI_DOC_CODE_EDITOR, 8), core_js_["ɵɵdirectiveInject"](TUI_DOC_EXAMPLE_CONTENT_PROCESSOR), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_tokens/* TUI_IS_CYPRESS */.B4), core_js_["ɵɵdirectiveInject"](TUI_DOC_CODE_ACTIONS), core_js_["ɵɵdirectiveInject"](router_js_.Router), core_js_["ɵɵdirectiveInject"](router_js_.ActivatedRoute), core_js_["ɵɵdirectiveInject"](common_js_.Location));
  };
  TuiDocExampleComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDocExampleComponent,
    selectors: [["tui-doc-example"]],
    inputs: {
      heading: "heading",
      description: "description",
      componentName: "componentName",
      content: "content"
    },
    ngContentSelectors: taiga_ui_addon_doc_c0,
    decls: 8,
    vars: 5,
    consts: [["class", "t-title", 4, "ngIf"], ["polymorpheus-outlet", "", "class", "t-description", 3, "content", 4, "ngIf"], ["class", "t-example", 4, "ngIf"], ["preview", ""], ["codeSection", ""], [1, "t-title"], ["polymorpheus-outlet", "", 3, "content"], ["tuiIconButton", "", "type", "button", "size", "xs", "icon", "tuiIconLinkLarge", "appearance", "icon", "class", "t-link-icon", 3, "title", "click", 4, "ngIf"], ["tuiIconButton", "", "type", "button", "size", "xs", "icon", "tuiIconLinkLarge", "appearance", "icon", 1, "t-link-icon", 3, "title", "click"], ["polymorpheus-outlet", "", 1, "t-description", 3, "content"], [1, "t-example"], [4, "ngIf"], [1, "t-tabs-wrapper"], [1, "t-tabs", 3, "activeItemIndex", "activeItemIndexChange"], [4, "ngFor", "ngForOf"], ["tuiButton", "", "appearance", "flat", "size", "s", 3, "showLoader", "click", 4, "ngIf"], ["class", "t-content", 3, "t-content_animated", "t-content_visible", 4, "ngFor", "ngForOf"], ["tuiTab", "", 4, "tuiTab"], ["tuiTab", ""], ["tuiButton", "", "appearance", "flat", "size", "s", 3, "showLoader", "click"], [1, "t-content"], [3, "ngTemplateOutlet", 4, "ngIf", "ngIfElse"], ["anotherTab", ""], [3, "ngTemplateOutlet"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["automation-id", "tui-doc-example", 1, "t-demo"], [1, "t-code-actions"], [3, "cdkCopyToClipboard"], [3, "code"], ["polymorpheus-outlet", "", 3, "content", "context"]],
    template: function TuiDocExampleComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵtemplate"](0, TuiDocExampleComponent_h3_0_Template, 4, 4, "h3", 0);
        core_js_["ɵɵtemplate"](1, TuiDocExampleComponent_h4_1_Template, 2, 3, "h4", 1);
        core_js_["ɵɵtemplate"](2, TuiDocExampleComponent_div_2_Template, 3, 4, "div", 2);
        core_js_["ɵɵpipe"](3, "async");
        core_js_["ɵɵtemplate"](4, TuiDocExampleComponent_ng_template_4_Template, 2, 0, "ng-template", null, 3, core_js_["ɵɵtemplateRefExtractor"]);
        core_js_["ɵɵtemplate"](6, TuiDocExampleComponent_ng_template_6_Template, 4, 3, "ng-template", null, 4, core_js_["ɵɵtemplateRefExtractor"]);
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngIf", ctx.heading);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.description);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", core_js_["ɵɵpipeBind1"](3, 3, ctx.processor$));
      }
    },
    directives: function () {
      return [common_js_.NgIf, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, taiga_ui_core_components_button/* TuiButtonComponent */.v0, TuiTabsWithMoreComponent, common_js_.NgForOf, TuiTabDirective, TuiTabComponent, common_js_.NgTemplateOutlet, TuiDocCopyComponent, CdkCopyToClipboard, TuiDocCodeComponent];
    },
    pipes: function () {
      return [common_js_.AsyncPipe, TuiDocExampleCapitalizePipe, TuiDocExampleGetTabsPipe];
    },
    styles: ["[_nghost-%COMP%]{position:relative;display:block;padding-top:3.5rem;clear:right}[_nghost-%COMP%]   tui-root._mobile[_nghost-%COMP%], tui-root._mobile   [_nghost-%COMP%]{padding-top:2rem}.t-title[_ngcontent-%COMP%]{font:var(--tui-font-heading-5);margin:0 0 .5rem}tui-root._mobile[_nghost-%COMP%]   .t-title[_ngcontent-%COMP%], tui-root._mobile   [_nghost-%COMP%]   .t-title[_ngcontent-%COMP%]{font:var(--tui-font-heading-6)}.t-description[_ngcontent-%COMP%]{font:var(--tui-font-text-m);font-weight:400;margin:0}.t-example[_ngcontent-%COMP%]{position:relative;margin-top:1.5rem;border:1px solid var(--tui-base-03);border-radius:var(--tui-radius-m);box-shadow:0 .125rem .1875rem rgba(0,0,0,.1)}tui-root._mobile[_nghost-%COMP%]   .t-example[_ngcontent-%COMP%], tui-root._mobile   [_nghost-%COMP%]   .t-example[_ngcontent-%COMP%]{margin-top:.75rem}.t-tabs-wrapper[_ngcontent-%COMP%]{display:flex;padding:0 2rem;box-shadow:inset 0 -1px var(--tui-base-03);justify-content:space-between;align-items:center}tui-root._mobile[_nghost-%COMP%]   .t-tabs-wrapper[_ngcontent-%COMP%], tui-root._mobile   [_nghost-%COMP%]   .t-tabs-wrapper[_ngcontent-%COMP%]{padding:0 1rem}.t-tabs[_ngcontent-%COMP%]{flex-grow:1}.t-demo[_ngcontent-%COMP%]{padding:2rem;overflow-x:auto}@media all and (-webkit-min-device-pixel-ratio:0) and (min-resolution:0.001dpcm){.t-demo[_ngcontent-%COMP%]::-webkit-scrollbar, .t-demo[_ngcontent-%COMP%]::-webkit-scrollbar-thumb{width:1rem;height:1rem;border-radius:6.25rem;background-clip:padding-box;border:2.667rem solid transparent}.t-demo[_ngcontent-%COMP%]::-webkit-scrollbar{background-color:transparent}.t-demo[_ngcontent-%COMP%]::-webkit-scrollbar-thumb{background-color:var(--tui-clear-hover)}.t-demo[_ngcontent-%COMP%]::-webkit-scrollbar-thumb:hover{background-color:var(--tui-clear-active)}.t-demo[_ngcontent-%COMP%]::-webkit-scrollbar-thumb:active{background-color:var(--tui-text-03)}}tui-root._mobile[_nghost-%COMP%]   .t-demo[_ngcontent-%COMP%], tui-root._mobile   [_nghost-%COMP%]   .t-demo[_ngcontent-%COMP%]{padding:1rem}.t-code-actions[_ngcontent-%COMP%]{position:absolute;top:4.375rem;right:1rem;display:flex;justify-content:flex-end;align-items:center}.t-code-actions[_ngcontent-%COMP%] > *[_ngcontent-%COMP%]{margin-left:.5rem}.t-link-icon[_ngcontent-%COMP%]{margin-left:.3rem;vertical-align:baseline}.t-content[_ngcontent-%COMP%]{will-change:opacity;height:0;visibility:hidden;opacity:0}.t-content_animated[_ngcontent-%COMP%]{transition:opacity .3s ease-in-out}.t-content_visible[_ngcontent-%COMP%]{height:auto;visibility:visible;opacity:1}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocExampleComponent.prototype, "heading", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocExampleComponent.prototype, "description", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocExampleComponent.prototype, "content", null);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocExampleComponent.prototype, "componentName", void 0);
  TuiDocExampleComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Attribute)('id')), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(Clipboard)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(TuiNotificationsService)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(ng_web_apis_common/* LOCATION */.Ct)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(TUI_COPY_TEXTS)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(TUI_DOC_EXAMPLE_TEXTS)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(TUI_DOC_CODE_EDITOR)), (0,tslib_es6/* __param */.fM)(7, (0,core_js_.Inject)(TUI_DOC_EXAMPLE_CONTENT_PROCESSOR)), (0,tslib_es6/* __param */.fM)(8, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_IS_CYPRESS */.B4)), (0,tslib_es6/* __param */.fM)(9, (0,core_js_.Inject)(TUI_DOC_CODE_ACTIONS)), (0,tslib_es6/* __param */.fM)(10, (0,core_js_.Inject)(router_js_.Router)), (0,tslib_es6/* __param */.fM)(11, (0,core_js_.Inject)(router_js_.ActivatedRoute)), (0,tslib_es6/* __param */.fM)(12, (0,core_js_.Inject)(common_js_.Location))], TuiDocExampleComponent);
  return TuiDocExampleComponent;
})();
let TuiDocExampleCapitalizePipe = /*#__PURE__*/(() => {
  let TuiDocExampleCapitalizePipe = class TuiDocExampleCapitalizePipe {
    transform(content) {
      return typeof content === `string` ? capitalizeFirstLetter(content) : content;
    }
  };
  TuiDocExampleCapitalizePipe.ɵfac = function TuiDocExampleCapitalizePipe_Factory(t) {
    return new (t || TuiDocExampleCapitalizePipe)();
  };
  TuiDocExampleCapitalizePipe.ɵpipe = /*@__PURE__*/core_js_["ɵɵdefinePipe"]({
    name: "tuiDocExampleCapitalize",
    type: TuiDocExampleCapitalizePipe,
    pure: true
  });
  return TuiDocExampleCapitalizePipe;
})();
let TuiDocExampleGetTabsPipe = /*#__PURE__*/(() => {
  let TuiDocExampleGetTabsPipe = class TuiDocExampleGetTabsPipe {
    transform(content, defaultTab) {
      return [defaultTab, ...Object.keys(content)];
    }
  };
  TuiDocExampleGetTabsPipe.ɵfac = function TuiDocExampleGetTabsPipe_Factory(t) {
    return new (t || TuiDocExampleGetTabsPipe)();
  };
  TuiDocExampleGetTabsPipe.ɵpipe = /*@__PURE__*/core_js_["ɵɵdefinePipe"]({
    name: "tuiDocExampleGetTabs",
    type: TuiDocExampleGetTabsPipe,
    pure: true
  });
  return TuiDocExampleGetTabsPipe;
})();
let TuiDocExampleModule = /*#__PURE__*/(() => {
  let TuiDocExampleModule = class TuiDocExampleModule {};
  TuiDocExampleModule.ɵfac = function TuiDocExampleModule_Factory(t) {
    return new (t || TuiDocExampleModule)();
  };
  TuiDocExampleModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocExampleModule
  });
  TuiDocExampleModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, ClipboardModule, TuiTabsModule, taiga_ui_core_components_button/* TuiButtonModule */.fN, TuiDocCopyModule, TuiDocCodeModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq]]
  });
  return TuiDocExampleModule;
})();
let TuiLanguageSwitcherComponent = /*#__PURE__*/(() => {
  let TuiLanguageSwitcherComponent = class TuiLanguageSwitcherComponent {
    constructor(switcher) {
      this.switcher = switcher;
      this.language = new fesm2015_forms.FormControl(tuiCapitalizeFirstLetter(this.switcher.language));
      this.flags = new Map([['chinese', taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CN], ['dutch', taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.NL], ['english', taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GB], ['french', taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.FR], ['german', taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.DE], ['italian', taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.IT], ['polish', taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PL], ['portuguese', taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PT], ['russian', taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.RU], ['spanish', taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.ES], ['turkish', taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TR], ['ukrainian', taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.UA], ['vietnamese', taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.VN]]);
      this.names = Array.from(this.flags.keys());
    }
  };
  TuiLanguageSwitcherComponent.ɵfac = function TuiLanguageSwitcherComponent_Factory(t) {
    return new (t || TuiLanguageSwitcherComponent)(core_js_["ɵɵdirectiveInject"](TuiLanguageSwitcher));
  };
  TuiLanguageSwitcherComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiLanguageSwitcherComponent,
    selectors: [["tui-language-switcher"]],
    ngContentSelectors: taiga_ui_addon_doc_c0,
    decls: 3,
    vars: 1,
    consts: [[3, "formControl"], [4, "tuiDataList"], ["tuiOption", "", 3, "value", "click", 4, "ngFor", "ngForOf"], ["tuiOption", "", 3, "value", "click"], ["alt", "", 1, "t-flag", 3, "src"]],
    template: function TuiLanguageSwitcherComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵelementStart"](0, "tui-select", 0);
        core_js_["ɵɵprojection"](1);
        core_js_["ɵɵtemplate"](2, TuiLanguageSwitcherComponent_tui_data_list_2_Template, 2, 1, "tui-data-list", 1);
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("formControl", ctx.language);
      }
    },
    directives: [TuiSelectComponent, TuiSelectDirective, fesm2015_forms.NgControlStatus, fesm2015_forms.FormControlDirective, TuiDataListDirective, TuiDataListComponent, common_js_.NgForOf, TuiOptionComponent],
    pipes: [common_js_.TitleCasePipe, TuiFlagPipe],
    styles: [".t-flag[_ngcontent-%COMP%]{width:1.75rem;height:1.25rem;margin-right:.5rem}"],
    changeDetection: 0
  });
  TuiLanguageSwitcherComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TuiLanguageSwitcher))], TuiLanguageSwitcherComponent);
  return TuiLanguageSwitcherComponent;
})();
let TuiLanguageSwitcherModule = /*#__PURE__*/(() => {
  let TuiLanguageSwitcherModule = class TuiLanguageSwitcherModule {};
  TuiLanguageSwitcherModule.ɵfac = function TuiLanguageSwitcherModule_Factory(t) {
    return new (t || TuiLanguageSwitcherModule)();
  };
  TuiLanguageSwitcherModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiLanguageSwitcherModule
  });
  TuiLanguageSwitcherModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, TuiFlagPipeModule, TuiSelectModule, TuiDataListModule, fesm2015_forms.ReactiveFormsModule]]
  });
  return TuiLanguageSwitcherModule;
})();
var TuiDocMainComponent_1;
// @dynamic
let TuiDocMainComponent = TuiDocMainComponent_1 = class TuiDocMainComponent {
  constructor(storage, windowRef) {
    this.storage = storage;
    this.windowRef = windowRef;
    this.night = this.storage.getItem('night') === 'true' || this.storage.getItem('night') === null && this.windowRef.matchMedia('(prefers-color-scheme: dark)').matches;
    this.change$ = new Subject();
  }
  get mode() {
    return this.night ? 'onDark' : null;
  }
  onMode(night) {
    this.night = night;
    this.change$.next();
    this.storage.setItem('night', String(night));
  }
};
TuiDocMainComponent.ɵfac = function TuiDocMainComponent_Factory(t) {
  return new (t || TuiDocMainComponent)(core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* LOCAL_STORAGE */.H3), core_js_["ɵɵdirectiveInject"](ng_web_apis_common/* WINDOW */.m9));
};
TuiDocMainComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
  type: TuiDocMainComponent,
  selectors: [["tui-doc-main"]],
  hostVars: 1,
  hostBindings: function TuiDocMainComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      core_js_["ɵɵattribute"]("data-mode", ctx.mode);
    }
  },
  features: [core_js_["ɵɵProvidersFeature"]([{
    provide: taiga_ui_core_directives_mode/* TuiModeDirective */.w,
    useExisting: (0,core_js_.forwardRef)(() => TuiDocMainComponent_1)
  }, taiga_ui_cdk_services/* TuiSwipeService */.$D])],
  ngContentSelectors: _c7,
  decls: 24,
  vars: 2,
  consts: [[4, "ngIf"], [1, "tui-doc-page"], [1, "tui-doc-navigation"], [1, "tui-doc-content"], [1, "tui-doc-outlet"], ["tuiDocHeader", ""], [1, "night-mode"], [1, "tui-toggle", 3, "ngModel", "ngModelChange"], ["ngProjectAs", "tuiOverContent", 5, ["tuiOverContent"]], ["ngProjectAs", "tuiOverDialogs", 5, ["tuiOverDialogs"]], ["ngProjectAs", "tuiOverAlerts", 5, ["tuiOverAlerts"]], ["ngProjectAs", "tuiOverNotifications", 5, ["tuiOverNotifications"]], ["ngProjectAs", "tuiOverPortals", 5, ["tuiOverPortals"]], ["ngProjectAs", "tuiOverHints", 5, ["tuiOverHints"]]],
  template: function TuiDocMainComponent_Template(rf, ctx) {
    if (rf & 1) {
      core_js_["ɵɵprojectionDef"](_c6);
      core_js_["ɵɵtemplate"](0, TuiDocMainComponent_tui_theme_night_0_Template, 1, 0, "tui-theme-night", 0);
      core_js_["ɵɵelementStart"](1, "tui-root");
      core_js_["ɵɵelementStart"](2, "div", 1);
      core_js_["ɵɵelementStart"](3, "tui-doc-navigation", 2);
      core_js_["ɵɵprojection"](4);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementStart"](5, "div", 3);
      core_js_["ɵɵelement"](6, "router-outlet", 4);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementStart"](7, "header", 5);
      core_js_["ɵɵelementStart"](8, "label", 6);
      core_js_["ɵɵtext"](9, " Night mode ");
      core_js_["ɵɵelementStart"](10, "tui-toggle", 7);
      core_js_["ɵɵlistener"]("ngModelChange", function TuiDocMainComponent_Template_tui_toggle_ngModelChange_10_listener($event) {
        return ctx.onMode($event);
      });
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵprojection"](11, 1);
      core_js_["ɵɵelementEnd"]();
      core_js_["ɵɵelementContainerStart"](12, 8);
      core_js_["ɵɵprojection"](13, 2);
      core_js_["ɵɵelementContainerEnd"]();
      core_js_["ɵɵelementContainerStart"](14, 9);
      core_js_["ɵɵprojection"](15, 3);
      core_js_["ɵɵelementContainerEnd"]();
      core_js_["ɵɵelementContainerStart"](16, 10);
      core_js_["ɵɵprojection"](17, 4);
      core_js_["ɵɵelementContainerEnd"]();
      core_js_["ɵɵelementContainerStart"](18, 11);
      core_js_["ɵɵprojection"](19, 5);
      core_js_["ɵɵelementContainerEnd"]();
      core_js_["ɵɵelementContainerStart"](20, 12);
      core_js_["ɵɵprojection"](21, 6);
      core_js_["ɵɵelementContainerEnd"]();
      core_js_["ɵɵelementContainerStart"](22, 13);
      core_js_["ɵɵprojection"](23, 7);
      core_js_["ɵɵelementContainerEnd"]();
      core_js_["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      core_js_["ɵɵproperty"]("ngIf", ctx.night);
      core_js_["ɵɵadvance"](10);
      core_js_["ɵɵproperty"]("ngModel", ctx.night);
    }
  },
  directives: function () {
    return [common_js_.NgIf, TuiRootComponent, TuiDocNavigationComponent, router_js_.RouterOutlet, TuiDocHeaderComponent, TuiToggleComponent, fesm2015_forms.NgControlStatus, fesm2015_forms.NgModel, TuiThemeNightComponent];
  },
  styles: ["html{scroll-padding-top:4rem;height:auto}tui-root>tui-scroll-controls>.t-bar_vertical{top:4rem!important}@keyframes tuiShaking{from,to{transform:translate3d(0,0,0)}10%,30%,50%,70%,90%{transform:translate3d(-.3125rem,0,0)}20%,40%,60%,80%{transform:translate3d(.3125rem,0,0)}}body{background:var(--tui-base-01);height:auto}tui-doc-main{display:block}code:not(.hljs):not([class*=language-]):not(.exception){transition-property:background;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;background:var(--tui-base-02);color:var(--tui-text-02);vertical-align:middle;box-shadow:inset 0 -2px var(--tui-secondary);padding:.375rem .5rem;font-size:.875rem;border-radius:.5rem}a:focus code,button:focus code{background:var(--tui-base-01)}.tui-doc-page{position:relative;z-index:0;padding-top:4rem}tui-doc-navigation.tui-doc-navigation{position:fixed;top:4rem;bottom:0;width:16.25rem;border-right:1px solid var(--tui-base-03)}.tui-doc-content{margin-left:16.25rem}@media screen and (max-width:47.9625em){tui-doc-navigation.tui-doc-navigation{display:none}.tui-doc-content{margin-left:0}}.tui-doc-outlet+*{display:block}.tui-doc-animated-example{animation:1s .3s tuiShaking}label.night-mode{cursor:pointer}label.night-mode .tui-toggle{margin-left:.5rem}.hljs-tag{background:0 0}.hljs{display:block;overflow-x:auto;padding:.5em;color:var(--tui-text-01);background-color:var(--tui-clear-disabled)}.hljs.hljs-line-numbers{background:0 0}.hljs-subst,.hljs-title{font-weight:400;color:var(--tui-text-01)}.hljs-comment,.hljs-quote{color:var(--tui-text-03);font-style:italic}.hljs-meta{color:#e38162}.hljs-keyword,.hljs-literal,.hljs-name,.hljs-section,.hljs-selector-class,.hljs-selector-id,.hljs-selector-tag,.hljs-type{font-weight:700;color:var(--tui-link)}.hljs-attribute,.hljs-link,.hljs-number,.hljs-regexp{font-weight:700;color:var(--tui-support-06)}.hljs-link,.hljs-number,.hljs-regexp{font-weight:400}.hljs-string{color:var(--tui-positive);font-weight:700}.hljs-bullet,.hljs-formula,.hljs-symbol{color:var(--tui-text-01);background:var(--tui-base-02);font-style:italic}.hljs-doctag{text-decoration:underline}.hljs-template-variable,.hljs-variable{color:var(--tui-link-hover)}[data-mode=onDark] .hljs-template-variable,[data-mode=onDark] .hljs-variable{color:var(--tui-warning-fill)}.hljs-addition{background:var(--tui-success-bg)}.hljs-deletion{background:var(--tui-error-bg)}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs .hljs-line-numbers{padding:0}.hljs-ln-numbers{vertical-align:top;opacity:.3;text-align:right;padding-right:1em!important}"],
  encapsulation: 2
});
TuiDocMainComponent.ctorParameters = () => [{
  type: Storage,
  decorators: [{
    type: core_js_.Inject,
    args: [ng_web_apis_common/* LOCAL_STORAGE */.H3]
  }]
}, {
  type: Window,
  decorators: [{
    type: core_js_.Inject,
    args: [ng_web_apis_common/* WINDOW */.m9]
  }]
}];
(0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('attr.data-mode')], TuiDocMainComponent.prototype, "mode", null);
TuiDocMainComponent = TuiDocMainComponent_1 = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(ng_web_apis_common/* LOCAL_STORAGE */.H3)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(ng_web_apis_common/* WINDOW */.m9))], TuiDocMainComponent);
const TUI_DOC_PAGE_LOADED = new core_js_.InjectionToken(`[TUI_DOC_PAGE_LOADED] Stream that emits if loading of page is over (for example, to begin scrollIntoView)`, {
  factory: () => defer(() => timer(200).pipe(switchMapTo(of(true))))
});

/**
 * @deprecated: use {@link TuiScrollIntoViewLinkDirective}
 * TODO: remove in v3.0
 */
let ScrollIntoViewDirective =
/*#__PURE__*/
// eslint-disable-next-line @typescript-eslint/naming-convention
(() => {
  let ScrollIntoViewDirective = class ScrollIntoViewDirective {
    constructor(destroy$, {
      nativeElement
    }, readyToScroll$) {
      this.readyToScroll$ = readyToScroll$;
      this.scroll$ = new ReplaySubject(1);
      this.readyToScroll$.pipe(filter(Boolean), switchMapTo(this.scroll$), debounceTime(750), filter(shallWe => shallWe && !!(0,taiga_ui_cdk_utils_dom/* getElementObscurers */.hh)(nativeElement)), takeUntil(destroy$)).subscribe(() => {
        nativeElement.scrollIntoView();
      });
    }
    set scrollIntoView(shallWe) {
      this.scroll$.next(shallWe);
    }
  };
  ScrollIntoViewDirective.ɵfac = function ScrollIntoViewDirective_Factory(t) {
    return new (t || ScrollIntoViewDirective)(core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3), core_js_["ɵɵdirectiveInject"](core_js_.ElementRef), core_js_["ɵɵdirectiveInject"](TUI_DOC_PAGE_LOADED));
  };
  ScrollIntoViewDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: ScrollIntoViewDirective,
    selectors: [["", "scrollIntoView", ""]],
    inputs: {
      scrollIntoView: "scrollIntoView"
    },
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3])]
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], ScrollIntoViewDirective.prototype, "scrollIntoView", null);
  ScrollIntoViewDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(TUI_DOC_PAGE_LOADED))], ScrollIntoViewDirective);
  return ScrollIntoViewDirective;
})();
let TuiScrollIntoViewLinkDirective = /*#__PURE__*/(() => {
  let TuiScrollIntoViewLinkDirective = class TuiScrollIntoViewLinkDirective extends ScrollIntoViewDirective {};
  TuiScrollIntoViewLinkDirective.ɵfac = /*@__PURE__*/function () {
    let ɵTuiScrollIntoViewLinkDirective_BaseFactory;
    return function TuiScrollIntoViewLinkDirective_Factory(t) {
      return (ɵTuiScrollIntoViewLinkDirective_BaseFactory || (ɵTuiScrollIntoViewLinkDirective_BaseFactory = core_js_["ɵɵgetInheritedFactory"](TuiScrollIntoViewLinkDirective)))(t || TuiScrollIntoViewLinkDirective);
    };
  }();
  TuiScrollIntoViewLinkDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiScrollIntoViewLinkDirective,
    selectors: [["", "tuiScrollIntoViewLink", ""]],
    features: [core_js_["ɵɵProvidersFeature"]([taiga_ui_cdk_services/* TuiDestroyService */.a3]), core_js_["ɵɵInheritDefinitionFeature"]]
  });

  /**
   * @deprecated: use {@link TuiScrollIntoViewLinkModule}
   * TODO: remove in v3.0
   */
  return TuiScrollIntoViewLinkDirective;
})();
let ScrollIntoViewModule =
/*#__PURE__*/
// eslint-disable-next-line @typescript-eslint/naming-convention
(() => {
  let ScrollIntoViewModule = class ScrollIntoViewModule {};
  ScrollIntoViewModule.ɵfac = function ScrollIntoViewModule_Factory(t) {
    return new (t || ScrollIntoViewModule)();
  };
  ScrollIntoViewModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: ScrollIntoViewModule
  });
  ScrollIntoViewModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return ScrollIntoViewModule;
})();
let TuiScrollIntoViewLinkModule = /*#__PURE__*/(() => {
  let TuiScrollIntoViewLinkModule = class TuiScrollIntoViewLinkModule {};
  TuiScrollIntoViewLinkModule.ɵfac = function TuiScrollIntoViewLinkModule_Factory(t) {
    return new (t || TuiScrollIntoViewLinkModule)();
  };
  TuiScrollIntoViewLinkModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiScrollIntoViewLinkModule
  });
  TuiScrollIntoViewLinkModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return TuiScrollIntoViewLinkModule;
})();
const TUI_DOC_SCROLL_BEHAVIOR = new core_js_.InjectionToken(`[TUI_DOC_SCROLL_BEHAVIOR] Defines the transition animation for scroll`, {
  factory: () => `smooth`
});
const MAP = {
  а: `f`,
  б: `,`,
  в: `d`,
  г: `u`,
  д: `l`,
  е: `t`,
  ё: `\``,
  ж: `;`,
  з: `p`,
  и: `b`,
  й: `q`,
  к: `r`,
  л: `k`,
  м: `v`,
  н: `y`,
  о: `j`,
  п: `g`,
  р: `h`,
  с: `c`,
  т: `n`,
  у: `e`,
  ф: `a`,
  х: `[`,
  ц: `w`,
  ч: `x`,
  ш: `i`,
  щ: `o`,
  ъ: `]`,
  ы: `s`,
  ь: `m`,
  ю: `.`,
  я: `z`
};
/**
 * @deprecated: use {@link tuiTransliterateKeyboardLayout} instead
 * Translates text mistakenly typed in the Russian layout into English
 * @param string string with Russian layout characters
 * @return string with English layout characters
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function transliterateKeyboardLayout(string) {
  let newStr = ``;
  for (let i = 0; i < string.length; i++) {
    newStr += string.charAt(i) in MAP ? MAP[string.charAt(i)] : string.charAt(i);
  }
  return newStr;
}
const tuiTransliterateKeyboardLayout = (/* unused pure expression or super */ null && (transliterateKeyboardLayout));
const TUI_DOC_PAGES = new core_js_.InjectionToken(`Documentation pages`, {
  factory: () => []
});
const TUI_DOC_TITLE = new core_js_.InjectionToken(`Page title`, {
  factory: () => ``
});
const NAVIGATION_TITLE = new core_js_.InjectionToken(`Page title`);
const NAVIGATION_LABELS = new core_js_.InjectionToken(`Navigation sections labels for search`);
const NAVIGATION_ITEMS = new core_js_.InjectionToken(`Navigation pages`);
const NAVIGATION_PROVIDERS = [taiga_ui_cdk_services/* TuiDestroyService */.a3, {
  provide: NAVIGATION_TITLE,
  deps: [router_js_.Router, router_js_.ActivatedRoute, TUI_DOC_TITLE, taiga_ui_cdk_services/* TuiDestroyService */.a3],
  useFactory: titleProviderFactory
}, {
  provide: NAVIGATION_LABELS,
  deps: [TUI_DOC_PAGES],
  useFactory: labelsProviderFactory
}, {
  provide: NAVIGATION_ITEMS,
  deps: [TUI_DOC_PAGES],
  useFactory: itemsProviderFactory
}];
// eslint-disable-next-line @typescript-eslint/naming-convention
function titleProviderFactory(router, activatedRoute, titlePrefix, destroy$) {
  return router.events.pipe(filter(event => event instanceof router_js_.NavigationEnd), map(() => activatedRoute.firstChild), filter(taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN), mergeMap(({
    data
  }) => data), map(({
    title
  }) => titlePrefix + title), takeUntil(destroy$));
}
// eslint-disable-next-line @typescript-eslint/naming-convention
function labelsProviderFactory(pages) {
  return pages.map(({
    section
  }) => section).filter(taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN).filter((item, index, array) => array.indexOf(item) === index);
}
// eslint-disable-next-line @typescript-eslint/naming-convention
function itemsProviderFactory(pages) {
  const labels = labelsProviderFactory(pages);
  return [...labels.map(label => pages.filter(({
    section
  }) => section === label)), pages.filter(page => !page.section)];
}

// @dynamic
let TuiDocNavigationComponent = /*#__PURE__*/(() => {
  let TuiDocNavigationComponent = class TuiDocNavigationComponent {
    constructor(changeDetectorRef, titleService, title$, documentRef, mode, sidebar, labels, items, searchText, router, activatedRoute, destroy$, readyToScroll$, scrollBehavior) {
      this.documentRef = documentRef;
      this.mode = mode;
      this.sidebar = sidebar;
      this.labels = labels;
      this.items = items;
      this.searchText = searchText;
      this.router = router;
      this.activatedRoute = activatedRoute;
      this.destroy$ = destroy$;
      this.readyToScroll$ = readyToScroll$;
      this.scrollBehavior = scrollBehavior;
      this.menuOpen = false;
      this.search = '';
      this.open = false;
      this.openPagesArr = [];
      this.openPagesGroupsArr = [];
      this.active = '';
      this.mode$ = this.mode.change$.pipe(startWith(null), map(() => this.mode.mode || 'onLight'));
      // Angular can't navigate no anchor links
      // https://stackoverflow.com/questions/36101756/angular2-routing-with-hashtag-to-page-anchor
      title$.subscribe(title => {
        changeDetectorRef.markForCheck();
        titleService.setTitle(title);
        this.openActivePageGroup();
        this.handleAnchorLink(this.activatedRoute.snapshot.fragment);
      });
    }
    get canOpen() {
      return this.search.length > 2;
    }
    get filteredItems() {
      return this.filterItems(this.flattenSubPages(this.items), this.search);
    }
    get itemsWithoutSections() {
      return this.items[this.items.length - 1];
    }
    isActive(route) {
      return route === this.active;
    }
    onGroupClick(index) {
      this.openPagesGroupsArr[index] = !this.openPagesGroupsArr[index];
    }
    closeMenu() {
      this.menuOpen = false;
    }
    onSearchChange(search) {
      this.search = search;
      this.open = this.canOpen;
    }
    onClick() {
      this.open = false;
      this.menuOpen = false;
      this.search = '';
      this.openActivePageGroup();
    }
    filterItems(items, search) {
      return items.map(section => (0,taiga_ui_cdk_utils_miscellaneous/* uniqBy */.mN)(section.filter(({
        title,
        keywords = ''
      }) => {
        title = title.toLowerCase();
        search = search.toLowerCase();
        keywords = keywords.toLowerCase();
        return title.includes(search) || keywords.includes(search) || title.includes(transliterateKeyboardLayout(search)) || keywords.includes(transliterateKeyboardLayout(search)) || search.replace(/-/gi, '').includes(title);
      }), 'title'));
    }
    flattenSubPages(items) {
      return items.reduce((array, item) => [...array, item.reduce((pages, page) => 'subPages' in page ? [...pages, ...page.subPages] : [...pages, page], [])], []);
    }
    isActiveRoute(route) {
      return this.router.isActive(route, false);
    }
    handleAnchorLink(hash) {
      this.readyToScroll$.pipe(filter(Boolean), take(1), takeUntil(this.destroy$)).subscribe(() => this.navigateToAnchorLink(hash));
    }
    openActivePageGroup() {
      this.items.forEach((pages, pagesIndex) => {
        pages.forEach((page, pageIndex) => {
          if ('route' in page && this.isActiveRoute(page.route)) {
            this.openPagesArr[pagesIndex] = true;
            this.active = page.route;
          }
          if ('subPages' in page) {
            page.subPages.forEach(subPage => {
              if (this.isActiveRoute(subPage.route)) {
                this.openPagesArr[pagesIndex] = true;
                this.openPagesGroupsArr[pagesIndex * 100 + pageIndex] = true;
                this.active = subPage.route;
              }
            });
          }
        });
      });
    }
    navigateToAnchorLink(fragment) {
      const nodes = fragment ? this.documentRef.querySelectorAll(`#${fragment}`) : [];
      const element = nodes.length && nodes[nodes.length - 1];
      if (!element) {
        return;
      }
      element.classList.add('tui-doc-animated-example');
      element.scrollIntoView({
        block: 'start',
        inline: 'nearest',
        behavior: this.scrollBehavior
      });
    }
  };
  TuiDocNavigationComponent.ɵfac = function TuiDocNavigationComponent_Factory(t) {
    return new (t || TuiDocNavigationComponent)(core_js_["ɵɵdirectiveInject"](core_js_.ChangeDetectorRef), core_js_["ɵɵdirectiveInject"](platform_browser.Title), core_js_["ɵɵdirectiveInject"](NAVIGATION_TITLE), core_js_["ɵɵdirectiveInject"](common_js_.DOCUMENT), core_js_["ɵɵdirectiveInject"](taiga_ui_core_directives_mode/* TuiModeDirective */.w), core_js_["ɵɵdirectiveInject"](TuiSidebarDirective, 8), core_js_["ɵɵdirectiveInject"](NAVIGATION_LABELS), core_js_["ɵɵdirectiveInject"](NAVIGATION_ITEMS), core_js_["ɵɵdirectiveInject"](TUI_DOC_SEARCH_TEXT), core_js_["ɵɵdirectiveInject"](router_js_.Router), core_js_["ɵɵdirectiveInject"](router_js_.ActivatedRoute), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiDestroyService */.a3), core_js_["ɵɵdirectiveInject"](TUI_DOC_PAGE_LOADED), core_js_["ɵɵdirectiveInject"](TUI_DOC_SCROLL_BEHAVIOR));
  };
  TuiDocNavigationComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDocNavigationComponent,
    selectors: [["tui-doc-navigation"]],
    hostVars: 2,
    hostBindings: function TuiDocNavigationComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        core_js_["ɵɵclassProp"]("_open", ctx.menuOpen);
      }
    },
    features: [core_js_["ɵɵProvidersFeature"](NAVIGATION_PROVIDERS)],
    ngContentSelectors: taiga_ui_addon_doc_c0,
    decls: 11,
    vars: 8,
    consts: [["tuiAutoFocus", "", "tuiDropdownLimitWidth", "fixed", "class", "t-input", 3, "autoFocus", "content", "canOpen", "open", "openChange", 4, "tuiLet"], [1, "t-navigation"], [1, "t-scrollbar", 3, "tuiMode"], [3, "closeOthers", "rounded"], ["size", "s", 3, "borders", "open", "openChange", 4, "ngFor", "ngForOf"], [1, "t-items-container"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngFor", "ngForOf"], ["pages", ""], ["tuiAutoFocus", "", "tuiDropdownLimitWidth", "fixed", 1, "t-input", 3, "autoFocus", "content", "canOpen", "open", "openChange"], ["iconAlign", "left", "tuiTextfieldSize", "m", "iconContent", "tuiIconSearch", 3, "pseudoFocused", "tuiTextfieldCleaner", "tuiTextfieldLabelOutside", "value", "valueChange"], ["dropdown", ""], [3, "label", 4, "ngFor", "ngForOf"], [3, "label"], ["tuiOption", "", 3, "routerLink", "click", 4, "ngFor", "ngForOf"], ["tuiOption", "", 3, "routerLink", "click"], ["size", "s", 3, "borders", "open", "openChange"], [1, "t-label"], ["tuiAccordionItemContent", ""], [1, "t-section"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["tuiLink", "", "routerLinkActive", "t-sublink_active", "class", "t-sublink", 3, "routerLink", "scrollIntoView", "click", 4, "ngIf", "ngIfElse"], ["subPages", ""], ["tuiLink", "", "routerLinkActive", "t-sublink_active", 1, "t-sublink", 3, "routerLink", "scrollIntoView", "click"], ["routerLinkActive", "", 1, "t-subsection", 3, "routerLinkActiveOptions"], ["tuiLink", "", "type", "button", "class", "t-sublink t-sublink_subsection", 3, "click", 4, "ngIf"], [1, "t-expand", 3, "expanded"], [1, "t-section", "t-section_bordered"], ["tuiLink", "", "routerLinkActive", "t-sublink_active", "class", "t-sublink t-sublink_small", 3, "routerLink", "scrollIntoView", "click", 4, "ngFor", "ngForOf"], ["tuiLink", "", "type", "button", 1, "t-sublink", "t-sublink_subsection", 3, "click"], ["src", "tuiIconChevronRight", 1, "t-chevron"], ["tuiLink", "", "routerLinkActive", "t-sublink_active", 1, "t-sublink", "t-sublink_small", 3, "routerLink", "scrollIntoView", "click"]],
    template: function TuiDocNavigationComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵtemplate"](0, TuiDocNavigationComponent_tui_hosted_dropdown_0_Template, 5, 9, "tui-hosted-dropdown", 0);
        core_js_["ɵɵelementStart"](1, "nav", 1);
        core_js_["ɵɵelementStart"](2, "tui-scrollbar", 2);
        core_js_["ɵɵpipe"](3, "async");
        core_js_["ɵɵelementStart"](4, "tui-accordion", 3);
        core_js_["ɵɵtemplate"](5, TuiDocNavigationComponent_tui_accordion_item_5_Template, 5, 3, "tui-accordion-item", 4);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](6, "div", 5);
        core_js_["ɵɵtemplate"](7, TuiDocNavigationComponent_ng_container_7_Template, 1, 5, "ng-container", 6);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](8, TuiDocNavigationComponent_ng_template_8_Template, 3, 2, "ng-template", null, 7, core_js_["ɵɵtemplateRefExtractor"]);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵprojection"](10);
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("tuiLet", ctx.filteredItems);
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵproperty"]("tuiMode", core_js_["ɵɵpipeBind1"](3, 6, ctx.mode$));
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵproperty"]("closeOthers", false)("rounded", false);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngForOf", ctx.labels);
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵproperty"]("ngForOf", ctx.itemsWithoutSections);
      }
    },
    directives: [taiga_ui_cdk_directives_let/* TuiLetDirective */.Ls, TuiScrollbarComponent, taiga_ui_core_directives_mode/* TuiModeDirective */.w, TuiAccordionComponent, common_js_.NgForOf, TuiHostedDropdownComponent, TuiAutoFocusDirective, TuiDropdownControllerDirective, TuiPrimitiveTextfieldComponent, TuiPrimitiveTextfieldDirective, TuiTextfieldSizeDirective, TuiTextfieldCleanerDirective, TuiTextfieldLabelOutsideDirective, TuiDataListComponent, TuiOptGroupDirective, TuiOptionComponent, router_js_.RouterLinkWithHref, TuiAccordionItemComponent, TuiAccordionItemContentDirective, common_js_.NgTemplateOutlet, common_js_.NgIf, taiga_ui_core_components_link/* TuiLinkComponent */.V, router_js_.RouterLinkActive, ScrollIntoViewDirective, TuiExpandComponent, taiga_ui_core_components_svg/* TuiSvgComponent */.P],
    pipes: [common_js_.AsyncPipe],
    styles: ["[_nghost-%COMP%]{z-index:1;display:flex;flex-direction:column;text-align:center;background:var(--tui-base-01)}.t-input[_ngcontent-%COMP%]{display:block;margin:1.25rem}.t-navigation[_ngcontent-%COMP%]{display:flex;max-height:100%;min-height:0;flex:1 1 0;text-align:left}.t-scrollbar[_ngcontent-%COMP%]{width:100%;scroll-behavior:smooth}.t-items-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;padding:0 1rem}.t-label[_ngcontent-%COMP%]{margin-left:.5rem}.t-expand[_ngcontent-%COMP%]{margin-left:.25rem}.t-section[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:flex-start;margin:-1rem 0 -.5rem}.t-section_bordered[_ngcontent-%COMP%]{margin:.5rem 0;border-left:1px solid var(--tui-base-03)}.t-subsection[_ngcontent-%COMP%]{margin-left:.5rem}.t-sublink[_ngcontent-%COMP%]{-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:1rem 0 0;border:0;background:0 0;font-size:inherit;line-height:inherit;font:var(--tui-font-text-m);margin-left:.5rem}.t-sublink_small[_ngcontent-%COMP%]{margin-left:1rem;line-height:1.5rem;padding-top:.5rem}.t-sublink_subsection[_ngcontent-%COMP%]{margin-left:0;line-height:1.6rem}.t-sublink_active[_ngcontent-%COMP%]{color:var(--tui-text-01)}.t-chevron[_ngcontent-%COMP%]{transition-property:transform;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;width:1rem;height:1rem;margin:-.25rem .25rem 0 -.1875rem}.t-chevron_active[_ngcontent-%COMP%]{transform:rotate(90deg)}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.HostBinding)('class._open')], TuiDocNavigationComponent.prototype, "menuOpen", void 0);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDocNavigationComponent.prototype, "filterItems", null);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDocNavigationComponent.prototype, "flattenSubPages", null);
  TuiDocNavigationComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(platform_browser.Title)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(NAVIGATION_TITLE)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(common_js_.DOCUMENT)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(taiga_ui_core_directives_mode/* TuiModeDirective */.w)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Optional)()), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(TuiSidebarDirective)), (0,tslib_es6/* __param */.fM)(6, (0,core_js_.Inject)(NAVIGATION_LABELS)), (0,tslib_es6/* __param */.fM)(7, (0,core_js_.Inject)(NAVIGATION_ITEMS)), (0,tslib_es6/* __param */.fM)(8, (0,core_js_.Inject)(TUI_DOC_SEARCH_TEXT)), (0,tslib_es6/* __param */.fM)(9, (0,core_js_.Inject)(router_js_.Router)), (0,tslib_es6/* __param */.fM)(10, (0,core_js_.Inject)(router_js_.ActivatedRoute)), (0,tslib_es6/* __param */.fM)(11, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiDestroyService */.a3)), (0,tslib_es6/* __param */.fM)(12, (0,core_js_.Inject)(TUI_DOC_PAGE_LOADED)), (0,tslib_es6/* __param */.fM)(13, (0,core_js_.Inject)(TUI_DOC_SCROLL_BEHAVIOR))], TuiDocNavigationComponent);
  return TuiDocNavigationComponent;
})();
let TuiDocNavigationModule = /*#__PURE__*/(() => {
  let TuiDocNavigationModule = class TuiDocNavigationModule {};
  TuiDocNavigationModule.ɵfac = function TuiDocNavigationModule_Factory(t) {
    return new (t || TuiDocNavigationModule)();
  };
  TuiDocNavigationModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocNavigationModule
  });
  TuiDocNavigationModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, fesm2015_forms.FormsModule, router_js_.RouterModule, ScrollIntoViewModule, TuiScrollIntoViewLinkModule, taiga_ui_core_components_button/* TuiButtonModule */.fN, TuiPrimitiveTextfieldModule, TuiTextfieldControllerModule, TuiActiveZoneModule, taiga_ui_cdk_directives_let/* TuiLetModule */.WD, taiga_ui_core_directives_mode/* TuiModeModule */.z, taiga_ui_core_components_link/* TuiLinkModule */.j, TuiExpandModule, TuiHostedDropdownModule, TuiDropdownControllerModule, TuiAccordionModule, TuiScrollbarModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiDataListModule, TuiAutoFocusModule]]
  });
  return TuiDocNavigationModule;
})();
const TUI_DOC_LOGO = new core_js_.InjectionToken(`Main logo`, {
  factory: () => ``
});
let TuiDocHeaderComponent = /*#__PURE__*/(() => {
  let TuiDocHeaderComponent = class TuiDocHeaderComponent {
    constructor(logo, menu, router, swipes$) {
      this.logo = logo;
      this.menu = menu;
      this.router = router;
      this.swipes$ = swipes$;
      this.stream$ = new Subject();
      this.open$ = merge(this.router.events.pipe(mapTo(false)), this.stream$, this.swipes$.pipe(filter(swipe => swipe.direction === 'left' || swipe.direction === 'right'), map(swipe => swipe.direction === 'right'))).pipe(startWith(false), distinctUntilChanged());
    }
    onClick() {
      this.stream$.next(true);
    }
    onActiveZone(active) {
      if (!active) {
        this.stream$.next(false);
      }
    }
  };
  TuiDocHeaderComponent.ɵfac = function TuiDocHeaderComponent_Factory(t) {
    return new (t || TuiDocHeaderComponent)(core_js_["ɵɵdirectiveInject"](TUI_DOC_LOGO), core_js_["ɵɵdirectiveInject"](TUI_DOC_MENU_TEXT), core_js_["ɵɵdirectiveInject"](router_js_.Router), core_js_["ɵɵdirectiveInject"](taiga_ui_cdk_services/* TuiSwipeService */.$D));
  };
  TuiDocHeaderComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDocHeaderComponent,
    selectors: [["header", "tuiDocHeader", ""]],
    attrs: _c10,
    ngContentSelectors: taiga_ui_addon_doc_c0,
    decls: 6,
    vars: 5,
    consts: [["tuiIconButton", "", "icon", "tuiIconMenuLarge", "appearance", "icon", 1, "t-menu", 3, "title", "click", "tuiActiveZoneChange"], ["class", "t-navigation", 4, "tuiSidebar"], ["polymorpheus-outlet", "", 1, "t-logo", 3, "content"], [1, "t-navigation"], ["alt", "Logo", 1, "t-img", 3, "src"]],
    template: function TuiDocHeaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵelementStart"](0, "button", 0);
        core_js_["ɵɵlistener"]("click", function TuiDocHeaderComponent_Template_button_click_0_listener() {
          return ctx.onClick();
        })("tuiActiveZoneChange", function TuiDocHeaderComponent_Template_button_tuiActiveZoneChange_0_listener($event) {
          return ctx.onActiveZone($event);
        });
        core_js_["ɵɵtemplate"](1, TuiDocHeaderComponent_tui_doc_navigation_1_Template, 1, 0, "tui-doc-navigation", 1);
        core_js_["ɵɵpipe"](2, "async");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](3, "div", 2);
        core_js_["ɵɵtemplate"](4, TuiDocHeaderComponent_ng_template_4_Template, 1, 1, "ng-template");
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵprojection"](5);
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("title", ctx.menu);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("tuiSidebar", !!core_js_["ɵɵpipeBind1"](2, 3, ctx.open$));
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵproperty"]("content", ctx.logo);
      }
    },
    directives: [taiga_ui_core_components_button/* TuiButtonComponent */.v0, TuiActiveZoneDirective, TuiSidebarDirective, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, TuiDocNavigationComponent],
    pipes: [common_js_.AsyncPipe],
    styles: ["[_nghost-%COMP%]{box-shadow:0 .125rem 1rem rgba(0,0,0,.08);position:fixed;top:0;left:0;right:0;z-index:1;display:flex;height:3.9375rem;align-items:center;padding:0 1.25rem;background:var(--tui-base-01);border-bottom:1px solid var(--tui-base-03)}.t-logo[_ngcontent-%COMP%]{margin-right:auto;font:var(--tui-font-heading-5)}.t-img[_ngcontent-%COMP%]{display:block}.t-menu[_ngcontent-%COMP%]{margin-left:-1.25rem}@media screen and (min-width:48em){.t-menu[_ngcontent-%COMP%]{display:none}}.t-navigation[_ngcontent-%COMP%]{min-height:100%}"],
    changeDetection: 0
  });
  TuiDocHeaderComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TUI_DOC_LOGO)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_DOC_MENU_TEXT)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(router_js_.Router)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(taiga_ui_cdk_services/* TuiSwipeService */.$D))], TuiDocHeaderComponent);
  return TuiDocHeaderComponent;
})();
let TuiDocHeaderModule = /*#__PURE__*/(() => {
  let TuiDocHeaderModule = class TuiDocHeaderModule {};
  TuiDocHeaderModule.ɵfac = function TuiDocHeaderModule_Factory(t) {
    return new (t || TuiDocHeaderModule)();
  };
  TuiDocHeaderModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocHeaderModule
  });
  TuiDocHeaderModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_button/* TuiButtonModule */.fN, TuiSidebarModule, TuiActiveZoneModule, TuiDocNavigationModule]]
  });
  return TuiDocHeaderModule;
})();
let TuiDocMainModule = /*#__PURE__*/(() => {
  let TuiDocMainModule = class TuiDocMainModule {};
  TuiDocMainModule.ɵfac = function TuiDocMainModule_Factory(t) {
    return new (t || TuiDocMainModule)();
  };
  TuiDocMainModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocMainModule
  });
  TuiDocMainModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, router_js_.RouterModule, fesm2015_forms.FormsModule, TuiToggleModule, TuiThemeNightModule, TuiDocHeaderModule, TuiRootModule, TuiDialogModule, TuiAlertModule, TuiDocNavigationModule]]
  });
  return TuiDocMainModule;
})();
const TUI_DOC_DEFAULT_TABS = new core_js_.InjectionToken(`Array of default tab names`, {
  factory: () => []
});
const TUI_DOC_SEE_ALSO = new core_js_.InjectionToken(`Array of arrays of related pages`, {
  factory: () => []
});
const PAGE_SEE_ALSO = new core_js_.InjectionToken(`Page see also`);
const PAGE_PROVIDERS = [{
  provide: PAGE_SEE_ALSO,
  deps: [core_js_.ElementRef, TUI_DOC_SEE_ALSO],
  useFactory: seeAlsoProviderFactory
}];
// eslint-disable-next-line @typescript-eslint/naming-convention
function seeAlsoProviderFactory({
  nativeElement
}, seeAlsoGroups) {
  const currentHeader = nativeElement.getAttribute(`header`);
  const groups = seeAlsoGroups.filter(group => group.includes(currentHeader)) || [];
  const seeAlsoSet = new Set(groups.join().split(`,`).filter(component => component && component !== currentHeader));
  return Array.from(seeAlsoSet);
}
let TuiDocPageTabConnectorDirective = /*#__PURE__*/(() => {
  let TuiDocPageTabConnectorDirective = class TuiDocPageTabConnectorDirective {
    constructor(template) {
      this.template = template;
    }
  };
  TuiDocPageTabConnectorDirective.ɵfac = function TuiDocPageTabConnectorDirective_Factory(t) {
    return new (t || TuiDocPageTabConnectorDirective)(core_js_["ɵɵdirectiveInject"](core_js_.TemplateRef));
  };
  TuiDocPageTabConnectorDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: TuiDocPageTabConnectorDirective,
    selectors: [["", "pageTab", ""]],
    inputs: {
      pageTab: "pageTab"
    }
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)(), (0,taiga_ui_cdk_decorators/* tuiDefaultProp */.TH)()], TuiDocPageTabConnectorDirective.prototype, "pageTab", void 0);
  TuiDocPageTabConnectorDirective = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.TemplateRef))], TuiDocPageTabConnectorDirective);

  // Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
  // @dynamic
  return TuiDocPageTabConnectorDirective;
})();
let TuiDocPageComponent = /*#__PURE__*/(() => {
  let TuiDocPageComponent = class TuiDocPageComponent {
    constructor(deprecated, defaultTabs, seeAlso) {
      this.deprecated = deprecated;
      this.defaultTabs = defaultTabs;
      this.seeAlso = seeAlso;
      this.header = '';
      this.package = '';
      this.type = '';
      this.path = '';
      this.tabConnectors = taiga_ui_cdk_constants/* EMPTY_QUERY */.Mm;
      this.activeItemIndex = NaN;
    }
    get showSeeAlso() {
      return !!this.seeAlso.length && this.activeItemIndex === 0;
    }
    getRouterLink(tab = '') {
      return `./${tab.replace(/ /g, '_')}`;
    }
  };
  TuiDocPageComponent.ɵfac = function TuiDocPageComponent_Factory(t) {
    return new (t || TuiDocPageComponent)(core_js_["ɵɵinjectAttribute"]('deprecated'), core_js_["ɵɵdirectiveInject"](TUI_DOC_DEFAULT_TABS), core_js_["ɵɵdirectiveInject"](PAGE_SEE_ALSO));
  };
  TuiDocPageComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDocPageComponent,
    selectors: [["tui-doc-page"]],
    contentQueries: function TuiDocPageComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        core_js_["ɵɵcontentQuery"](dirIndex, TuiDocPageTabConnectorDirective, 4);
      }
      if (rf & 2) {
        let _t;
        core_js_["ɵɵqueryRefresh"](_t = core_js_["ɵɵloadQuery"]()) && (ctx.tabConnectors = _t);
      }
    },
    inputs: {
      header: "header",
      package: "package",
      type: "type",
      path: "path"
    },
    features: [core_js_["ɵɵProvidersFeature"](PAGE_PROVIDERS)],
    ngContentSelectors: taiga_ui_addon_doc_c0,
    decls: 11,
    vars: 10,
    consts: [[1, "t-header"], [1, "t-title"], ["value", "deprecated", "status", "custom", "class", "t-tag t-tag_deprecated", 4, "ngIf"], ["status", "custom", "class", "t-tag t-tag_package", 3, "value", "autoColor", 4, "ngIf"], ["class", "t-tabs", 3, "activeItemIndex", "activeItemIndexChange", 4, "ngIf"], [1, "t-source-code", 3, "header", "package", "type", "path"], [1, "t-content"], ["class", "t-see-also", 3, "seeAlso", 4, "ngIf"], [4, "ngFor", "ngForOf"], ["value", "deprecated", "status", "custom", 1, "t-tag", "t-tag_deprecated"], ["status", "custom", 1, "t-tag", "t-tag_package", 3, "value", "autoColor"], [1, "t-tabs", 3, "activeItemIndex", "activeItemIndexChange"], [4, "ngIf", "ngIfElse"], ["dynamicTab", ""], ["tuiTab", "", "routerLink", "./", "routerLinkActive", "", 3, "routerLinkActiveOptions", 4, "tuiTab"], ["tuiTab", "", "routerLink", "./", "routerLinkActive", "", 3, "routerLinkActiveOptions"], ["tuiTab", "", "routerLinkActive", "", 3, "routerLink", 4, "tuiTab"], ["tuiTab", "", "routerLinkActive", "", 3, "routerLink"], [1, "t-see-also", 3, "seeAlso"], [3, "ngTemplateOutlet", 4, "ngIf"], [3, "ngTemplateOutlet"]],
    template: function TuiDocPageComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵprojectionDef"]();
        core_js_["ɵɵelementStart"](0, "header", 0);
        core_js_["ɵɵelementStart"](1, "h1", 1);
        core_js_["ɵɵtext"](2);
        core_js_["ɵɵtemplate"](3, TuiDocPageComponent_tui_tag_3_Template, 1, 0, "tui-tag", 2);
        core_js_["ɵɵtemplate"](4, TuiDocPageComponent_tui_tag_4_Template, 1, 2, "tui-tag", 3);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](5, TuiDocPageComponent_tui_tabs_with_more_5_Template, 2, 2, "tui-tabs-with-more", 4);
        core_js_["ɵɵelement"](6, "tui-doc-source-code", 5);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵelementStart"](7, "div", 6);
        core_js_["ɵɵprojection"](8);
        core_js_["ɵɵtemplate"](9, TuiDocPageComponent_tui_doc_see_also_9_Template, 1, 1, "tui-doc-see-also", 7);
        core_js_["ɵɵtemplate"](10, TuiDocPageComponent_ng_container_10_Template, 2, 1, "ng-container", 8);
        core_js_["ɵɵelementEnd"]();
      }
      if (rf & 2) {
        core_js_["ɵɵadvance"](2);
        core_js_["ɵɵtextInterpolate1"](" ", ctx.header, " ");
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.deprecated !== null);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.package);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngIf", ctx.tabConnectors.length);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("header", ctx.header)("package", ctx.package)("type", ctx.type)("path", ctx.path);
        core_js_["ɵɵadvance"](3);
        core_js_["ɵɵproperty"]("ngIf", ctx.showSeeAlso);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngForOf", ctx.tabConnectors);
      }
    },
    directives: function () {
      return [common_js_.NgIf, TuiDocSourceCodeComponent, common_js_.NgForOf, TuiTagComponent, TuiTabsWithMoreComponent, TuiTabDirective, TuiTabComponent, router_js_.RouterLinkWithHref, router_js_.RouterLinkActive, TuiDocSeeAlsoComponent, common_js_.NgTemplateOutlet];
    },
    styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;min-height:0;flex-basis:0;flex-grow:1}.t-header[_ngcontent-%COMP%]{display:flex;font:var(--tui-font-heading-3);flex-wrap:wrap;min-height:7.25rem;color:var(--tui-text-01);box-shadow:inset 0 -1px 0 0 var(--tui-base-03);padding:3.75rem 0 0;box-sizing:border-box;flex-shrink:0;margin:0 min(10vw,8.75rem)}tui-root._mobile[_nghost-%COMP%]   .t-header[_ngcontent-%COMP%], tui-root._mobile   [_nghost-%COMP%]   .t-header[_ngcontent-%COMP%]{font:var(--tui-font-heading-4);min-height:4.5rem;padding:1.25rem 1.25rem 0;margin:0}.t-title[_ngcontent-%COMP%]{min-width:100%;font-size:inherit;margin:0}.t-tag[_ngcontent-%COMP%]{vertical-align:middle;text-transform:uppercase;margin-right:.5rem}.t-tag_deprecated[_ngcontent-%COMP%]{background-color:var(--tui-error-fill)}.t-tag.t-tag_package[_ngcontent-%COMP%]{color:#000}.t-tabs[_ngcontent-%COMP%]{flex:1;margin:1.125rem .3125rem 0 0}tui-root._mobile[_nghost-%COMP%]   .t-tabs[_ngcontent-%COMP%], tui-root._mobile   [_nghost-%COMP%]   .t-tabs[_ngcontent-%COMP%]{margin-top:.25rem}.t-content[_ngcontent-%COMP%]{padding:2rem 0;margin:0 min(10vw,8.75rem)}tui-root._mobile[_nghost-%COMP%]   .t-content[_ngcontent-%COMP%], tui-root._mobile   [_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{padding:2rem 1.25rem;margin:0}.t-see-also[_ngcontent-%COMP%]{min-width:18.75rem;width:30%;float:right;margin-left:1.5rem}tui-root._mobile[_nghost-%COMP%]   .t-see-also[_ngcontent-%COMP%], tui-root._mobile   [_nghost-%COMP%]   .t-see-also[_ngcontent-%COMP%]{float:none;width:100%;margin:0 0 1.5rem}.t-source-code[_ngcontent-%COMP%]{align-self:flex-end;line-height:2.75rem}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocPageComponent.prototype, "header", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocPageComponent.prototype, "package", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocPageComponent.prototype, "type", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocPageComponent.prototype, "path", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.ContentChildren)(TuiDocPageTabConnectorDirective)], TuiDocPageComponent.prototype, "tabConnectors", void 0);
  TuiDocPageComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Attribute)('deprecated')), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_DOC_DEFAULT_TABS)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(PAGE_SEE_ALSO))], TuiDocPageComponent);

  // @dynamic
  return TuiDocPageComponent;
})();
let TuiDocSeeAlsoComponent = /*#__PURE__*/(() => {
  let TuiDocSeeAlsoComponent = class TuiDocSeeAlsoComponent {
    constructor(text, pages) {
      this.text = text;
      this.pages = pages;
      this.seeAlso = [];
    }
    getRouterLink(pageTitle) {
      for (let i = 0; i < this.pages.length; i++) {
        const page = this.pages.map(page => 'subPages' in page ? page.subPages : [page]).reduce((pages, subPages) => [...pages, ...subPages], []).find(page => page.title === pageTitle);
        if (page === null || page === void 0 ? void 0 : page.route) {
          return page.route;
        }
      }
      return '';
    }
  };
  TuiDocSeeAlsoComponent.ɵfac = function TuiDocSeeAlsoComponent_Factory(t) {
    return new (t || TuiDocSeeAlsoComponent)(core_js_["ɵɵdirectiveInject"](TUI_DOC_SEE_ALSO_TEXT), core_js_["ɵɵdirectiveInject"](TUI_DOC_PAGES));
  };
  TuiDocSeeAlsoComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDocSeeAlsoComponent,
    selectors: [["tui-doc-see-also"]],
    inputs: {
      seeAlso: "seeAlso"
    },
    decls: 3,
    vars: 2,
    consts: [[1, "t-header"], [4, "ngFor", "ngForOf"], ["tuiLink", "", 3, "routerLink"], [4, "ngIf"]],
    template: function TuiDocSeeAlsoComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵelementStart"](0, "h5", 0);
        core_js_["ɵɵtext"](1);
        core_js_["ɵɵelementEnd"]();
        core_js_["ɵɵtemplate"](2, TuiDocSeeAlsoComponent_ng_container_2_Template, 4, 3, "ng-container", 1);
      }
      if (rf & 2) {
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵtextInterpolate"](ctx.text);
        core_js_["ɵɵadvance"](1);
        core_js_["ɵɵproperty"]("ngForOf", ctx.seeAlso);
      }
    },
    directives: [common_js_.NgForOf, taiga_ui_core_components_link/* TuiLinkComponent */.V, router_js_.RouterLinkWithHref, common_js_.NgIf],
    styles: ["[_nghost-%COMP%]{display:block}.t-header[_ngcontent-%COMP%]{font-size:.6875rem;line-height:1rem;text-transform:uppercase;letter-spacing:.075em;color:var(--tui-text-02);margin:0 0 .5rem;white-space:nowrap}"],
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocSeeAlsoComponent.prototype, "seeAlso", void 0);
  TuiDocSeeAlsoComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TUI_DOC_SEE_ALSO_TEXT)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_DOC_PAGES))], TuiDocSeeAlsoComponent);
  return TuiDocSeeAlsoComponent;
})();
let TuiDocSeeAlsoModule = /*#__PURE__*/(() => {
  let TuiDocSeeAlsoModule = class TuiDocSeeAlsoModule {};
  TuiDocSeeAlsoModule.ɵfac = function TuiDocSeeAlsoModule_Factory(t) {
    return new (t || TuiDocSeeAlsoModule)();
  };
  TuiDocSeeAlsoModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocSeeAlsoModule
  });
  TuiDocSeeAlsoModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, router_js_.RouterModule, taiga_ui_core_components_link/* TuiLinkModule */.j]]
  });
  return TuiDocSeeAlsoModule;
})();
const TUI_DOC_SOURCE_CODE = new core_js_.InjectionToken(`Source code link`, {
  factory: () => ``
});
let TuiDocSourceCodeComponent = /*#__PURE__*/(() => {
  let TuiDocSourceCodeComponent = class TuiDocSourceCodeComponent {
    constructor(sourceCode, text) {
      this.sourceCode = sourceCode;
      this.text = text;
      this.header = '';
      this.package = '';
      this.type = '';
      this.path = '';
    }
    get pathOptions() {
      return this.getPathOptions(this.header, this.package, this.type, this.path);
    }
    getPathOptions(header, packageName, type, path) {
      return {
        header,
        package: packageName,
        type,
        path
      };
    }
  };
  TuiDocSourceCodeComponent.ɵfac = function TuiDocSourceCodeComponent_Factory(t) {
    return new (t || TuiDocSourceCodeComponent)(core_js_["ɵɵdirectiveInject"](TUI_DOC_SOURCE_CODE), core_js_["ɵɵdirectiveInject"](TUI_DOC_SOURCE_CODE_TEXT));
  };
  TuiDocSourceCodeComponent.ɵcmp = /*@__PURE__*/core_js_["ɵɵdefineComponent"]({
    type: TuiDocSourceCodeComponent,
    selectors: [["tui-doc-source-code"]],
    inputs: {
      header: "header",
      package: "package",
      type: "type",
      path: "path"
    },
    decls: 1,
    vars: 1,
    consts: [["polymorpheus-outlet", "", 3, "content", "context", 4, "ngIf"], ["polymorpheus-outlet", "", 3, "content", "context"], ["tuiIconButton", "", "type", "button", "icon", "tuiIconCodeLarge", "appearance", "icon", "target", "_blank", "size", "s", 3, "title", "href", 4, "ngIf"], ["tuiIconButton", "", "type", "button", "icon", "tuiIconCodeLarge", "appearance", "icon", "target", "_blank", "size", "s", 3, "title", "href"]],
    template: function TuiDocSourceCodeComponent_Template(rf, ctx) {
      if (rf & 1) {
        core_js_["ɵɵtemplate"](0, TuiDocSourceCodeComponent_div_0_Template, 2, 2, "div", 0);
      }
      if (rf & 2) {
        core_js_["ɵɵproperty"]("ngIf", !!ctx.sourceCode);
      }
    },
    directives: [common_js_.NgIf, tinkoff_ng_polymorpheus/* PolymorpheusOutletComponent */.r1, taiga_ui_core_components_button/* TuiButtonComponent */.v0],
    encapsulation: 2,
    changeDetection: 0
  });
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocSourceCodeComponent.prototype, "header", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocSourceCodeComponent.prototype, "package", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocSourceCodeComponent.prototype, "type", void 0);
  (0,tslib_es6/* __decorate */.gn)([(0,core_js_.Input)()], TuiDocSourceCodeComponent.prototype, "path", void 0);
  (0,tslib_es6/* __decorate */.gn)([taiga_ui_cdk_decorators/* tuiPure */.UM], TuiDocSourceCodeComponent.prototype, "getPathOptions", null);
  TuiDocSourceCodeComponent = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TUI_DOC_SOURCE_CODE)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(TUI_DOC_SOURCE_CODE_TEXT))], TuiDocSourceCodeComponent);
  return TuiDocSourceCodeComponent;
})();
let TuiDocSourceCodeModule = /*#__PURE__*/(() => {
  let TuiDocSourceCodeModule = class TuiDocSourceCodeModule {};
  TuiDocSourceCodeModule.ɵfac = function TuiDocSourceCodeModule_Factory(t) {
    return new (t || TuiDocSourceCodeModule)();
  };
  TuiDocSourceCodeModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocSourceCodeModule
  });
  TuiDocSourceCodeModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_button/* TuiButtonModule */.fN]]
  });
  return TuiDocSourceCodeModule;
})();
let TuiDocPageModule = /*#__PURE__*/(() => {
  let TuiDocPageModule = class TuiDocPageModule {};
  TuiDocPageModule.ɵfac = function TuiDocPageModule_Factory(t) {
    return new (t || TuiDocPageModule)();
  };
  TuiDocPageModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiDocPageModule
  });
  TuiDocPageModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [[common_js_.CommonModule, router_js_.RouterModule, TuiDocSeeAlsoModule, TuiTabsModule, TuiTagModule, TuiDocSourceCodeModule]]
  });
  return TuiDocPageModule;
})();
const TUI_EXAMPLE_PRIMARY_FILE_NAME = {
  TS: `TypeScript`,
  LESS: `LESS`,
  HTML: `HTML`
};

// TODO: 3.0 remove in ivy compilation
const DEMO_TEXTS = [`Сделано с помощью директивы: `, `Фон`, `Детали формы`];
const DOC_TEXTS = [`Аргумент`, `Тип`, `Имя и описание`, `Значение`, `Для работы с динамическими шаблонами используется`];
const EXAMPLE_TEXTS = [`Превью`, `Ссылка на пример скопирована`, `Готово`];
const TUI_DOC_RUSSIAN = [{
  provide: TUI_DOC_DEMO_TEXTS,
  useValue: DEMO_TEXTS
}, {
  provide: TUI_DOC_DOCUMENTATION_TEXTS,
  useValue: DOC_TEXTS
}, {
  provide: TUI_DOC_EXAMPLE_TEXTS,
  useValue: EXAMPLE_TEXTS
}, {
  provide: TUI_DOC_MENU_TEXT,
  useValue: `Меню`
}, {
  provide: TUI_DOC_SEARCH_TEXT,
  useValue: `Поиск`
}, {
  provide: TUI_DOC_SEE_ALSO_TEXT,
  useValue: `Смотрите также`
}, {
  provide: TUI_DOC_SOURCE_CODE_TEXT,
  useValue: `Исходный код`
}];
let TuiAddonDocModule = /*#__PURE__*/(() => {
  let TuiAddonDocModule = class TuiAddonDocModule {};
  TuiAddonDocModule.ɵfac = function TuiAddonDocModule_Factory(t) {
    return new (t || TuiAddonDocModule)();
  };
  TuiAddonDocModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: TuiAddonDocModule
  });
  TuiAddonDocModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({
    imports: [TuiDocCodeModule, TuiDocDemoModule, TuiDocDocumentationModule, TuiDocPageModule, TuiDocExampleModule]
  });
  return TuiAddonDocModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocCodeModule, {
    declarations: function () {
      return [TuiDocCodeComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, HighlightModule];
    },
    exports: function () {
      return [TuiDocCodeComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocCopyModule, {
    declarations: function () {
      return [TuiDocCopyComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, taiga_ui_core_components_button/* TuiButtonModule */.fN];
    },
    exports: function () {
      return [TuiDocCopyComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocDemoModule, {
    declarations: function () {
      return [TuiDocDemoComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, fesm2015_forms.ReactiveFormsModule, fesm2015_forms.FormsModule, router_js_.RouterModule, taiga_ui_core_components_link/* TuiLinkModule */.j, TuiDragModule, taiga_ui_core_components_button/* TuiButtonModule */.fN, TuiSelectModule, TuiExpandModule, TuiGroupModule, TuiTooltipModule, taiga_ui_core_directives_mode/* TuiModeModule */.z, TuiRadioBlockModule, TuiCheckboxLabeledModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiDataListWrapperModule, TuiDataListModule, TuiTextfieldControllerModule, TuiHintControllerModule];
    },
    exports: function () {
      return [TuiDocDemoComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiInputOpacityModule, {
    declarations: [TuiInputOpacityDirective],
    exports: [TuiInputOpacityDirective]
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocDocumentationModule, {
    declarations: function () {
      return [TuiDocDocumentationComponent, TuiDocDocumentationPropertyConnectorDirective];
    },
    imports: function () {
      return [common_js_.CommonModule, fesm2015_forms.FormsModule, router_js_.RouterModule, TuiBadgeModule, TuiSelectModule, TuiToggleModule, TuiTooltipModule, taiga_ui_core_components_link/* TuiLinkModule */.j, TuiInputCountModule, taiga_ui_core_directives_mode/* TuiModeModule */.z, TuiGroupModule, TuiInputOpacityModule, TuiPrimitiveTextfieldModule, TuiTextfieldControllerModule, TuiHintControllerModule, TuiDropdownControllerModule, TuiDataListModule, TuiDataListWrapperModule, taiga_ui_core_components_notification/* TuiNotificationModule */.Hi];
    },
    exports: function () {
      return [TuiDocDocumentationComponent, TuiDocDocumentationPropertyConnectorDirective];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocExampleModule, {
    declarations: function () {
      return [TuiDocExampleComponent, TuiDocExampleGetTabsPipe, TuiDocExampleCapitalizePipe];
    },
    imports: function () {
      return [common_js_.CommonModule, ClipboardModule, TuiTabsModule, taiga_ui_core_components_button/* TuiButtonModule */.fN, TuiDocCopyModule, TuiDocCodeModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq];
    },
    exports: function () {
      return [TuiDocExampleComponent, TuiDocExampleGetTabsPipe, TuiDocExampleCapitalizePipe];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiLanguageSwitcherModule, {
    declarations: function () {
      return [TuiLanguageSwitcherComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, TuiFlagPipeModule, TuiSelectModule, TuiDataListModule, fesm2015_forms.ReactiveFormsModule];
    },
    exports: function () {
      return [TuiLanguageSwitcherComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](ScrollIntoViewModule, {
    declarations: [ScrollIntoViewDirective],
    exports: [ScrollIntoViewDirective]
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiScrollIntoViewLinkModule, {
    declarations: [TuiScrollIntoViewLinkDirective],
    exports: [TuiScrollIntoViewLinkDirective]
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocNavigationModule, {
    declarations: function () {
      return [TuiDocNavigationComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, fesm2015_forms.FormsModule, router_js_.RouterModule, ScrollIntoViewModule, TuiScrollIntoViewLinkModule, taiga_ui_core_components_button/* TuiButtonModule */.fN, TuiPrimitiveTextfieldModule, TuiTextfieldControllerModule, TuiActiveZoneModule, taiga_ui_cdk_directives_let/* TuiLetModule */.WD, taiga_ui_core_directives_mode/* TuiModeModule */.z, taiga_ui_core_components_link/* TuiLinkModule */.j, TuiExpandModule, TuiHostedDropdownModule, TuiDropdownControllerModule, TuiAccordionModule, TuiScrollbarModule, taiga_ui_core_components_svg/* TuiSvgModule */.E, TuiDataListModule, TuiAutoFocusModule];
    },
    exports: function () {
      return [TuiDocNavigationComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocHeaderModule, {
    declarations: function () {
      return [TuiDocHeaderComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_button/* TuiButtonModule */.fN, TuiSidebarModule, TuiActiveZoneModule, TuiDocNavigationModule];
    },
    exports: function () {
      return [TuiDocHeaderComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocMainModule, {
    declarations: function () {
      return [TuiDocMainComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, router_js_.RouterModule, fesm2015_forms.FormsModule, TuiToggleModule, TuiThemeNightModule, TuiDocHeaderModule, TuiRootModule, TuiDialogModule, TuiAlertModule, TuiDocNavigationModule];
    },
    exports: function () {
      return [TuiDocMainComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocSeeAlsoModule, {
    declarations: function () {
      return [TuiDocSeeAlsoComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, router_js_.RouterModule, taiga_ui_core_components_link/* TuiLinkModule */.j];
    },
    exports: function () {
      return [TuiDocSeeAlsoComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocSourceCodeModule, {
    declarations: function () {
      return [TuiDocSourceCodeComponent];
    },
    imports: function () {
      return [common_js_.CommonModule, tinkoff_ng_polymorpheus/* PolymorpheusModule */.wq, taiga_ui_core_components_button/* TuiButtonModule */.fN];
    },
    exports: function () {
      return [TuiDocSourceCodeComponent];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiDocPageModule, {
    declarations: function () {
      return [TuiDocPageComponent, TuiDocPageTabConnectorDirective];
    },
    imports: function () {
      return [common_js_.CommonModule, router_js_.RouterModule, TuiDocSeeAlsoModule, TuiTabsModule, TuiTagModule, TuiDocSourceCodeModule];
    },
    exports: function () {
      return [TuiDocPageComponent, TuiDocPageTabConnectorDirective];
    }
  });
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](TuiAddonDocModule, {
    exports: [TuiDocCodeModule, TuiDocDemoModule, TuiDocDocumentationModule, TuiDocPageModule, TuiDocExampleModule]
  });
})();

/**
 * @deprecated: use {@link tuiGenerateRoutes} instead
 * Generates typical page routing structure
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function generateRoutes(type) {
  return [{
    path: ``,
    component: type,
    children: [{
      path: `:tab`,
      component: type
    }]
  }];
}
const tuiGenerateRoutes = (/* unused pure expression or super */ null && (generateRoutes));

/**
 * Public API Surface of @taiga-ui/addon-doc
 */

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-addon-doc.js.map

/***/ }),

/***/ 6480:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Er: () => (/* binding */ AbstractTuiPortalHostComponent),
/* harmony export */   F9: () => (/* binding */ AbstractTuiNullableControl),
/* harmony export */   GM: () => (/* binding */ AbstractTuiThemeSwitcher),
/* harmony export */   LF: () => (/* binding */ AbstractTuiDialogDirective),
/* harmony export */   M$: () => (/* binding */ AbstractTuiControl),
/* harmony export */   N9: () => (/* binding */ AbstractTuiPortalService),
/* harmony export */   Xn: () => (/* binding */ AbstractTuiInteractive),
/* harmony export */   d5: () => (/* binding */ AbstractTuiDialogService),
/* harmony export */   td: () => (/* binding */ TuiController)
/* harmony export */ });
/* unused harmony exports AbstractTuiController, AbstractTuiMultipleControl */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7582);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(3738);
/* harmony import */ var _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8939);
/* harmony import */ var _taiga_ui_cdk_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3770);
/* harmony import */ var _taiga_ui_cdk_decorators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4358);
/* harmony import */ var _taiga_ui_cdk_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(1927);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9765);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(6682);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(8891);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(6215);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(9193);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1289);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(9761);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(8002);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(5435);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(7519);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(3190);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(6782);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(5829);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(6804);
/* harmony import */ var _tinkoff_ng_polymorpheus__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(9570);
/* harmony import */ var _taiga_ui_cdk_services__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(3503);
/* harmony import */ var _taiga_ui_cdk_exceptions__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(7788);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3008);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_1__);
















const _c0 = ["viewContainer"];
var AbstractTuiInteractive_1;
const TUI = `tui_interactive_`;
/**
 * The most basic class for interactive components
 */
let AbstractTuiInteractive = AbstractTuiInteractive_1 = class AbstractTuiInteractive {
  constructor() {
    this.pseudoHovered = null;
    this.pseudoPressed = null;
    this.pseudoFocused = null;
    /**
     * Determines if component is focusable with keyboard.
     */
    this.focusable = true;
    this.nativeId = ``;
    /**
     * Emits 'true' on focus and 'false' on blur.
     */
    this.focusedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    /** @deprecated use `tuiPressedChange` directive */
    this.pressedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    /** @deprecated use `tuiHoveredChange` directive */
    this.hoveredChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    this.focusVisibleChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    /** @deprecated use `tuiHoveredChange` directive */
    this.hovered = false;
    /** @deprecated use `tuiPressedChange` directive */
    this.pressed = false;
    this.focusVisible = false;
    this.autoIdString = `${TUI}${AbstractTuiInteractive_1.autoId++}${Date.now()}`;
  }
  get computedDisabled() {
    return this.disabled;
  }
  /** @deprecated */
  get computedHovered() {
    var _a;
    return !this.computedDisabled && ((_a = this.pseudoHovered) !== null && _a !== void 0 ? _a : this.hovered);
  }
  /** @deprecated */
  get computedPressed() {
    var _a;
    return !this.computedDisabled && ((_a = this.pseudoPressed) !== null && _a !== void 0 ? _a : this.pressed);
  }
  get computedFocusable() {
    return !this.computedDisabled && (this.focusable || this.focused);
  }
  get computedFocused() {
    var _a;
    return !this.computedDisabled && ((_a = this.pseudoFocused) !== null && _a !== void 0 ? _a : this.focused);
  }
  get computedFocusVisible() {
    var _a;
    return !this.computedDisabled && ((_a = this.pseudoFocused) !== null && _a !== void 0 ? _a : this.focusVisible);
  }
  // TODO: 3.0 Consider removing since native input is exposed
  get id() {
    return this.nativeId ? this.nativeId : this.autoIdString;
  }
  /** @deprecated */
  updateHovered(hovered) {
    if (this.hovered === hovered) {
      return;
    }
    this.hovered = hovered;
    this.hoveredChange.emit(hovered);
  }
  /** @deprecated */
  updatePressed(pressed) {
    if (this.pressed === pressed) {
      return;
    }
    this.pressed = pressed;
    this.pressedChange.emit(pressed);
  }
  updateFocused(focused) {
    this.focusedChange.emit(focused);
  }
  updateFocusVisible(focusVisible) {
    if (this.focusVisible === focusVisible) {
      return;
    }
    this.focusVisible = focusVisible;
    this.focusVisibleChange.emit(focusVisible);
  }
};
AbstractTuiInteractive.ɵfac = function AbstractTuiInteractive_Factory(t) {
  return new (t || AbstractTuiInteractive)();
};
AbstractTuiInteractive.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
  type: AbstractTuiInteractive,
  hostVars: 10,
  hostBindings: function AbstractTuiInteractive_HostBindings(rf, ctx) {
    if (rf & 2) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("_disabled", ctx.computedDisabled)("_hovered", ctx.computedHovered)("_pressed", ctx.computedPressed)("_focused", ctx.computedFocused)("_focus-visible", ctx.computedFocusVisible);
    }
  },
  inputs: {
    pseudoHovered: "pseudoHovered",
    pseudoPressed: "pseudoPressed",
    pseudoFocused: "pseudoFocused",
    focusable: "focusable",
    nativeId: "nativeId"
  },
  outputs: {
    focusedChange: "focusedChange",
    pressedChange: "pressedChange",
    hoveredChange: "hoveredChange",
    focusVisibleChange: "focusVisibleChange"
  }
});
AbstractTuiInteractive.autoId = 0;
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk_decorators__WEBPACK_IMPORTED_MODULE_3__/* .tuiDefaultProp */ .TH)()], AbstractTuiInteractive.prototype, "pseudoHovered", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk_decorators__WEBPACK_IMPORTED_MODULE_3__/* .tuiDefaultProp */ .TH)()], AbstractTuiInteractive.prototype, "pseudoPressed", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk_decorators__WEBPACK_IMPORTED_MODULE_3__/* .tuiDefaultProp */ .TH)()], AbstractTuiInteractive.prototype, "pseudoFocused", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk_decorators__WEBPACK_IMPORTED_MODULE_3__/* .tuiDefaultProp */ .TH)()], AbstractTuiInteractive.prototype, "focusable", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk_decorators__WEBPACK_IMPORTED_MODULE_3__/* .tuiDefaultProp */ .TH)()], AbstractTuiInteractive.prototype, "nativeId", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Output)()], AbstractTuiInteractive.prototype, "focusedChange", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Output)()], AbstractTuiInteractive.prototype, "pressedChange", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Output)()], AbstractTuiInteractive.prototype, "hoveredChange", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Output)()], AbstractTuiInteractive.prototype, "focusVisibleChange", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)(`class._disabled`)], AbstractTuiInteractive.prototype, "computedDisabled", null);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)(`class._hovered`)], AbstractTuiInteractive.prototype, "computedHovered", null);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)(`class._pressed`)], AbstractTuiInteractive.prototype, "computedPressed", null);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)(`class._focused`)], AbstractTuiInteractive.prototype, "computedFocused", null);
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)(`class._focus-visible`)], AbstractTuiInteractive.prototype, "computedFocusVisible", null);

/**
 * Basic ControlValueAccessor class to build form components upon
 */
let AbstractTuiControl = /*#__PURE__*/(() => {
  let AbstractTuiControl = class AbstractTuiControl extends AbstractTuiInteractive {
    constructor(ngControl, changeDetectorRef, valueTransformer) {
      super();
      this.ngControl = ngControl;
      this.changeDetectorRef = changeDetectorRef;
      this.valueTransformer = valueTransformer;
      this.refresh$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__/* .Subject */ .xQ();
      this.onTouched = _taiga_ui_cdk_constants__WEBPACK_IMPORTED_MODULE_5__/* .EMPTY_FUNCTION */ .iD;
      this.onChange = _taiga_ui_cdk_constants__WEBPACK_IMPORTED_MODULE_5__/* .EMPTY_FUNCTION */ .iD;
      this.fallbackValue = this.getFallbackValue();
      this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__/* .Subject */ .xQ();
      this.readOnly = false;
      this.pseudoInvalid = null;
      if (this.ngControl === null) {
        _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_6__/* .tuiAssert */ .zU.assert(false, `NgControl not injected in ${this.constructor.name}!\n`, `Use [(ngModel)] or [formControl] or formControlName for correct work.`);
      } else {
        this.ngControl.valueAccessor = this;
      }
    }
    get computedInvalid() {
      return this.interactive && (this.pseudoInvalid !== null ? this.pseudoInvalid : this.touched && this.invalid);
    }
    get value() {
      var _a;
      return (_a = this.previousInternalValue) !== null && _a !== void 0 ? _a : this.fallbackValue;
    }
    get safeCurrentValue() {
      var _a;
      return (_a = this.rawValue) !== null && _a !== void 0 ? _a : this.fallbackValue;
    }
    get invalid() {
      return this.safeNgControlData(({
        invalid
      }) => invalid, false);
    }
    get valid() {
      return this.safeNgControlData(({
        valid
      }) => valid, false);
    }
    get touched() {
      return this.safeNgControlData(({
        touched
      }) => touched, false);
    }
    get disabled() {
      return this.safeNgControlData(({
        disabled
      }) => disabled, false);
    }
    get interactive() {
      return !this.readOnly && !this.computedDisabled;
    }
    get control() {
      return this.safeNgControlData(({
        control
      }) => control, null);
    }
    get computedName() {
      var _a, _b;
      return (_b = (_a = this.controlName) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : null;
    }
    get controlName() {
      var _a, _b, _c;
      return (_c = (_b = (_a = this.ngControl) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.toString()) !== null && _c !== void 0 ? _c : null;
    }
    get rawValue() {
      const {
        ngControl
      } = this;
      if (ngControl === null) {
        return undefined;
      }
      const controlValue = ngControl instanceof _angular_forms__WEBPACK_IMPORTED_MODULE_7__.NgModel && this.previousInternalValue === undefined ? ngControl.viewModel : ngControl.value;
      return this.fromControlValue(controlValue);
    }
    ngOnInit() {
      this.refresh$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__/* .delay */ .g)(0), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__/* .startWith */ .O)(null), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__/* .map */ .U)(() => {
        var _a;
        return (_a = this.ngControl) === null || _a === void 0 ? void 0 : _a.control;
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_11__/* .filter */ .h)(_taiga_ui_cdk_utils__WEBPACK_IMPORTED_MODULE_12__/* .tuiIsPresent */ .Pc), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_13__/* .distinctUntilChanged */ .x)(), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_14__/* .switchMap */ .w)(control => (0,rxjs__WEBPACK_IMPORTED_MODULE_15__/* .merge */ .T)(control.valueChanges, control.statusChanges)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_16__/* .takeUntil */ .R)(this.destroy$)).subscribe(() => {
        this.refreshLocalValue(this.safeCurrentValue);
      });
    }
    ngOnDestroy() {
      this.destroy$.next();
      this.destroy$.complete();
    }
    checkControlUpdate() {
      this.changeDetectorRef.markForCheck();
    }
    registerOnChange(onChange) {
      this.onChange = componentValue => {
        onChange(this.toControlValue(componentValue));
      };
      this.refresh$.next();
    }
    registerOnTouched(onTouched) {
      this.onTouched = onTouched;
    }
    setDisabledState() {
      this.checkControlUpdate();
    }
    writeValue(value) {
      const controlValue = this.ngControl instanceof _angular_forms__WEBPACK_IMPORTED_MODULE_7__.NgModel && this.previousInternalValue === undefined ? this.ngControl.model : value;
      this.refreshLocalValue(this.fromControlValue(controlValue));
    }
    updateFocused(focused) {
      if (!focused) {
        this.controlMarkAsTouched();
      }
      super.updateFocused(focused);
    }
    updateValue(value) {
      if (this.disabled || this.valueIdenticalComparator(this.value, value)) {
        return;
      }
      this.previousInternalValue = value;
      this.controlSetValue(value);
    }
    valueIdenticalComparator(oldValue, newValue) {
      return oldValue === newValue;
    }
    safeNgControlData(extractor, defaultFieldValue) {
      var _a;
      return (_a = this.ngControl && extractor(this.ngControl)) !== null && _a !== void 0 ? _a : defaultFieldValue;
    }
    controlMarkAsTouched() {
      this.onTouched();
      this.checkControlUpdate();
    }
    controlSetValue(value) {
      this.onChange(value);
      this.checkControlUpdate();
    }
    refreshLocalValue(value) {
      this.previousInternalValue = value;
      this.checkControlUpdate();
    }
    fromControlValue(controlValue) {
      return this.valueTransformer ? this.valueTransformer.fromControlValue(controlValue) : controlValue;
    }
    toControlValue(componentValue) {
      return this.valueTransformer ? this.valueTransformer.toControlValue(componentValue) : componentValue;
    }
  };
  AbstractTuiControl.ɵfac = function AbstractTuiControl_Factory(t) {
    return new (t || AbstractTuiControl)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_forms__WEBPACK_IMPORTED_MODULE_7__.NgControl), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](undefined));
  };
  AbstractTuiControl.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
    type: AbstractTuiControl,
    hostVars: 4,
    hostBindings: function AbstractTuiControl_HostBindings(rf, ctx) {
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("_readonly", ctx.readOnly)("_invalid", ctx.computedInvalid);
      }
    },
    inputs: {
      readOnly: "readOnly",
      pseudoInvalid: "pseudoInvalid"
    },
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]]
  });
  (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)(`class._readonly`), (0,_taiga_ui_cdk_decorators__WEBPACK_IMPORTED_MODULE_3__/* .tuiDefaultProp */ .TH)()], AbstractTuiControl.prototype, "readOnly", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk_decorators__WEBPACK_IMPORTED_MODULE_3__/* .tuiDefaultProp */ .TH)()], AbstractTuiControl.prototype, "pseudoInvalid", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)(`class._invalid`)], AbstractTuiControl.prototype, "computedInvalid", null);

  /**
   * @deprecated
   * TODO: 3.0 replace with {@link AbstractTuiController}
   */
  return AbstractTuiControl;
})();
let TuiController = /*#__PURE__*/(() => {
  class TuiController {
    constructor() {
      this.change$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__/* .Subject */ .xQ();
    }
    ngOnChanges() {
      this.change$.next();
    }
  }
  TuiController.ɵfac = function TuiController_Factory(t) {
    return new (t || TuiController)();
  };
  TuiController.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
    type: TuiController,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
  });
  return TuiController;
})();
class AbstractTuiController extends (/* unused pure expression or super */ null && (TuiController)) {}
let AbstractTuiDialogService = /*#__PURE__*/(() => {
  let AbstractTuiDialogService = class AbstractTuiDialogService extends rxjs__WEBPACK_IMPORTED_MODULE_17__/* .Observable */ .y {
    constructor(idService) {
      super(observer => this.dialogs$.subscribe(observer));
      this.idService = idService;
      this.dialogs$ = new rxjs__WEBPACK_IMPORTED_MODULE_18__/* .BehaviorSubject */ .X([]);
    }
    open(content, options = {}) {
      return new rxjs__WEBPACK_IMPORTED_MODULE_17__/* .Observable */ .y(observer => {
        const completeWith = result => {
          observer.next(result);
          observer.complete();
        };
        const dialog = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), options), {
          content,
          completeWith,
          $implicit: observer,
          component: this.component,
          createdAt: Date.now(),
          id: this.idService.generate()
        });
        this.dialogs$.next([...this.dialogs$.value, dialog]);
        return () => {
          this.dialogs$.next(this.dialogs$.value.filter(item => item !== dialog));
        };
      });
    }
  };
  AbstractTuiDialogService.ɵfac = function AbstractTuiDialogService_Factory(t) {
    return new (t || AbstractTuiDialogService)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_taiga_ui_cdk_services__WEBPACK_IMPORTED_MODULE_19__/* .TuiIdService */ .ll));
  };
  AbstractTuiDialogService.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: AbstractTuiDialogService,
    factory: function (t) {
      return AbstractTuiDialogService.ɵfac(t);
    }
  });
  AbstractTuiDialogService = (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_cdk_services__WEBPACK_IMPORTED_MODULE_19__/* .TuiIdService */ .ll))], AbstractTuiDialogService);
  return AbstractTuiDialogService;
})();
let AbstractTuiDialogDirective = /*#__PURE__*/(() => {
  let AbstractTuiDialogDirective = class AbstractTuiDialogDirective extends _tinkoff_ng_polymorpheus__WEBPACK_IMPORTED_MODULE_20__/* .PolymorpheusTemplate */ .GL {
    constructor(templateRef, changeDetectorRef, service) {
      super(templateRef, changeDetectorRef);
      this.service = service;
      this.open$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__/* .Subject */ .xQ();
      this.options = {};
      this.openChange = this.open$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_14__/* .switchMap */ .w)(open => open ? this.service.open(this, this.options).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_21__/* .ignoreElements */ .l)(), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__/* .endWith */ .l)(false)) : rxjs__WEBPACK_IMPORTED_MODULE_23__/* .EMPTY */ .E));
    }
    set open(open) {
      this.open$.next(open);
    }
  };
  AbstractTuiDialogDirective.ɵfac = function AbstractTuiDialogDirective_Factory(t) {
    return new (t || AbstractTuiDialogDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](AbstractTuiDialogService));
  };
  AbstractTuiDialogDirective.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
    type: AbstractTuiDialogDirective,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]]
  });
  AbstractTuiDialogDirective = (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef)), (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__param */ .fM)(1, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef)), (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__param */ .fM)(2, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(AbstractTuiDialogService))], AbstractTuiDialogDirective);
  return AbstractTuiDialogDirective;
})();
let AbstractTuiMultipleControl = /*#__PURE__*/(/* unused pure expression or super */ null && ((() => {
  let AbstractTuiMultipleControl = class AbstractTuiMultipleControl extends AbstractTuiControl {
    clear() {
      this.updateValue([]);
    }
    getFallbackValue() {
      return [];
    }
  };
  AbstractTuiMultipleControl.ɵfac = /*@__PURE__*/function () {
    let ɵAbstractTuiMultipleControl_BaseFactory;
    return function AbstractTuiMultipleControl_Factory(t) {
      return (ɵAbstractTuiMultipleControl_BaseFactory || (ɵAbstractTuiMultipleControl_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AbstractTuiMultipleControl)))(t || AbstractTuiMultipleControl);
    };
  }();
  AbstractTuiMultipleControl.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({
    type: AbstractTuiMultipleControl,
    features: [ɵngcc0.ɵɵInheritDefinitionFeature]
  });
  return AbstractTuiMultipleControl;
})()));
let AbstractTuiNullableControl = /*#__PURE__*/(() => {
  let AbstractTuiNullableControl = class AbstractTuiNullableControl extends AbstractTuiControl {
    getFallbackValue() {
      return null;
    }
  };
  AbstractTuiNullableControl.ɵfac = /*@__PURE__*/function () {
    let ɵAbstractTuiNullableControl_BaseFactory;
    return function AbstractTuiNullableControl_Factory(t) {
      return (ɵAbstractTuiNullableControl_BaseFactory || (ɵAbstractTuiNullableControl_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](AbstractTuiNullableControl)))(t || AbstractTuiNullableControl);
    };
  }();
  AbstractTuiNullableControl.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
    type: AbstractTuiNullableControl,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]]
  });

  /**
   * Abstract service for displaying portals
   */
  return AbstractTuiNullableControl;
})();
let AbstractTuiPortalService = /*#__PURE__*/(() => {
  let AbstractTuiPortalService = class AbstractTuiPortalService {
    get safeHost() {
      if (!this.host) {
        throw new _taiga_ui_cdk_exceptions__WEBPACK_IMPORTED_MODULE_24__/* .TuiNoHostException */ .ZB();
      }
      return this.host;
    }
    attach(host) {
      this.host = host;
    }
    add(componentFactory, injector) {
      return this.safeHost.addComponentChild(componentFactory, injector);
    }
    remove({
      hostView
    }) {
      hostView.destroy();
    }
    addTemplate(templateRef, context) {
      return this.safeHost.addTemplateChild(templateRef, context);
    }
    removeTemplate(viewRef) {
      viewRef.destroy();
    }
  };
  AbstractTuiPortalService.ɵfac = function AbstractTuiPortalService_Factory(t) {
    return new (t || AbstractTuiPortalService)();
  };
  AbstractTuiPortalService.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: AbstractTuiPortalService,
    factory: function (t) {
      return AbstractTuiPortalService.ɵfac(t);
    }
  });
  return AbstractTuiPortalService;
})();
var AbstractTuiPortalHostComponent_1;
/**
 * Abstract class for host element for dynamically created portals.
 */
let AbstractTuiPortalHostComponent = AbstractTuiPortalHostComponent_1 = class AbstractTuiPortalHostComponent {
  constructor(elementRef, portalService) {
    this.elementRef = elementRef;
    portalService.attach(this);
  }
  get clientRect() {
    return this.elementRef.nativeElement.getBoundingClientRect();
  }
  addComponentChild(componentFactory, injector) {
    return this.viewContainerRef.createComponent(componentFactory, undefined, _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector.create({
      parent: injector,
      providers: [{
        provide: AbstractTuiPortalHostComponent_1,
        useValue: this
      }]
    }));
  }
  addTemplateChild(templateRef, context) {
    return this.viewContainerRef.createEmbeddedView(templateRef, context);
  }
};
AbstractTuiPortalHostComponent.ɵfac = function AbstractTuiPortalHostComponent_Factory(t) {
  return new (t || AbstractTuiPortalHostComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](AbstractTuiPortalService));
};
AbstractTuiPortalHostComponent.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
  type: AbstractTuiPortalHostComponent,
  viewQuery: function AbstractTuiPortalHostComponent_Query(rf, ctx) {
    if (rf & 1) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_c0, 5, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef);
    }
    if (rf & 2) {
      let _t;
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.viewContainerRef = _t.first);
    }
  }
});
AbstractTuiPortalHostComponent.ctorParameters = () => [{
  type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef]
  }]
}, {
  type: AbstractTuiPortalService,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [AbstractTuiPortalService]
  }]
}];
(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewChild)(`viewContainer`, {
  read: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef
})], AbstractTuiPortalHostComponent.prototype, "viewContainerRef", void 0);
AbstractTuiPortalHostComponent = AbstractTuiPortalHostComponent_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef)), (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__param */ .fM)(1, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(AbstractTuiPortalService))], AbstractTuiPortalHostComponent);
var AbstractTuiThemeSwitcher_1;
/**
 * Use this abstract class to create your own toggleable themes.
 * A component extending this class must have CSS variables definitions
 * and have ViewEncapsulation set to NONE. A boolean input allows to
 * switch theme on or off.
 * @dynamic
 */
let AbstractTuiThemeSwitcher = AbstractTuiThemeSwitcher_1 = class AbstractTuiThemeSwitcher {
  constructor(documentRef) {
    this.documentRef = documentRef;
    if (this.style !== null) {
      this.addTheme();
      return;
    }
    const styles = this.documentRef.head.querySelectorAll(`style`);
    this.constructor.style = styles[styles.length - 1];
  }
  get style() {
    return this.constructor.style;
  }
  ngOnDestroy() {
    this.removeTheme();
  }
  addTheme() {
    if (this.style) {
      this.documentRef.head.appendChild(this.style);
    }
  }
  removeTheme() {
    if (this.style && this.documentRef.head.contains(this.style)) {
      this.documentRef.head.removeChild(this.style);
    }
  }
};
AbstractTuiThemeSwitcher.ɵfac = function AbstractTuiThemeSwitcher_Factory(t) {
  return new (t || AbstractTuiThemeSwitcher)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT));
};
AbstractTuiThemeSwitcher.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
  type: AbstractTuiThemeSwitcher
});
AbstractTuiThemeSwitcher.style = null;
AbstractTuiThemeSwitcher.ctorParameters = () => [{
  type: Document,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT]
  }]
}];
AbstractTuiThemeSwitcher = AbstractTuiThemeSwitcher_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT))], AbstractTuiThemeSwitcher);
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-abstract.js.map

/***/ }),

/***/ 8939:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HU: () => (/* binding */ tuiAssertIsHTMLElement),
/* harmony export */   zU: () => (/* binding */ tuiAssert)
/* harmony export */ });
/* unused harmony export TuiValidationError */
/* harmony import */ var _taiga_ui_cdk_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3770);

const tuiAssert = {
  enabled: false,
  get assert() {
    return this.enabled ? Function.prototype.bind.call(console.assert, console) : _taiga_ui_cdk_constants__WEBPACK_IMPORTED_MODULE_0__/* .EMPTY_FUNCTION */ .iD;
  }
};
// TODO: replace `HTMLElement` to `Element` in v3.0
// TS 3.8 Argument of type Argument of type 'TuiNativeFocusableElement | HTMLElement' is not assignable to parameter of type 'HTMLElement'.
function tuiAssertIsHTMLElement(node) {
  var _a, _b;
  const defaultView = (_b = (_a = node) === null || _a === void 0 ? void 0 : _a.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView;
  const isElement = !!defaultView && (node instanceof defaultView.Element || node instanceof defaultView.HTMLDocument);
  tuiAssert.assert(isElement, `Node is not an Element`);
}
class TuiValidationError {
  constructor(message, context = {}) {
    this.message = message;
    this.context = context;
  }
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-classes.js.map

/***/ }),

/***/ 3770:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F: () => (/* binding */ CHAR_EN_DASH),
/* harmony export */   Iy: () => (/* binding */ ALWAYS_FALSE_HANDLER),
/* harmony export */   Jy: () => (/* binding */ EMPTY_CLIENT_RECT),
/* harmony export */   Kx: () => (/* binding */ TUI_PARENT_ANIMATION),
/* harmony export */   LZ: () => (/* binding */ EMPTY_ARRAY),
/* harmony export */   Lw: () => (/* binding */ svgNodeFilter),
/* harmony export */   Mm: () => (/* binding */ EMPTY_QUERY),
/* harmony export */   Yg: () => (/* binding */ POLLING_TIME),
/* harmony export */   bg: () => (/* binding */ TUI_DEFAULT_IDENTITY_MATCHER),
/* harmony export */   f$: () => (/* binding */ CHAR_NO_BREAK_SPACE),
/* harmony export */   fv: () => (/* binding */ CHAR_HYPHEN),
/* harmony export */   iD: () => (/* binding */ EMPTY_FUNCTION),
/* harmony export */   kU: () => (/* binding */ CHAR_PLUS),
/* harmony export */   yZ: () => (/* binding */ TUI_DEFAULT_STRINGIFY)
/* harmony export */ });
/* unused harmony exports ALWAYS_TRUE_HANDLER, CHAR_BULLET, CHAR_CURRENCY_SIGN, CHAR_ELLIPSIS, CHAR_EM_DASH, CHAR_LAQUO, CHAR_MINUS, CHAR_RAQUO, CHAR_ZERO_WIDTH_SPACE, CHROMIUM_EDGE_START_VERSION, EMPTY_VALIDATOR, TUI_DEFAULT_MATCHER, TUI_STRICT_MATCHER, TUI_VERSION */
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6083);



/**
 * Handler that always returns `false`.
 */
const ALWAYS_FALSE_HANDLER = () => false;

/**
 * Handler that always returns `true`.
 */
const ALWAYS_TRUE_HANDLER = () => true;
const CHROMIUM_EDGE_START_VERSION = 79;

/**
 * For type safety when using @ContentChildren and @ViewChildren
 *
 * NOTE: Be careful subscribing to 'changes'
 */
const EMPTY_QUERY = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.QueryList();
const EMPTY_ARRAY = [];
const EMPTY_FUNCTION = () => {};
/** @deprecated use Validators.nullValidator */
const EMPTY_VALIDATOR = () => null;
const EMPTY_CLIENT_RECT = {
  bottom: 0,
  height: 0,
  left: 0,
  right: 0,
  top: 0,
  width: 0
};

/**
 * Default method to turn arbitrary object into string
 */
const TUI_DEFAULT_STRINGIFY = item => String(item);

/**
 * Default handler for matching stringified version of an item and a search query
 * @param item arbitrary element to match with a string
 * @param search search query
 * @param stringify handler to turn item into a string
 */
const TUI_DEFAULT_MATCHER = (item, search, stringify = TUI_DEFAULT_STRINGIFY) => stringify(item).toLowerCase().includes(search.toLowerCase());
/**
 * Default handler for strict matching stringified version of an item and a search query
 * @param item arbitrary element to match with a string
 * @param search search query
 * @param stringify handler to turn item into a string
 */
const TUI_STRICT_MATCHER = (item, search, stringify = TUI_DEFAULT_STRINGIFY) => stringify(item).toLowerCase() === search.toLowerCase();
/**
 * Default handler to match equality of two elements
 * ATTENTION: considers two empty arrays equal
 *
 * @param item1 first element
 * @param item2 second element
 */
const TUI_DEFAULT_IDENTITY_MATCHER = (item1, item2) => item1 === item2 || bothEmpty(item1, item2);
function bothEmpty(item1, item2) {
  return Array.isArray(item1) && Array.isArray(item2) && !item1.length && !item2.length;
}
const TUI_PARENT_ANIMATION = (0,_angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .trigger */ .X$)(`tuiParentAnimation`, [(0,_angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .transition */ .eR)(`* => void`, [(0,_angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .style */ .oB)({
  overflow: `hidden`
}), (0,_angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .query */ .IO)(`:scope > *`, [(0,_angular_animations__WEBPACK_IMPORTED_MODULE_1__/* .animateChild */ .pV)()], {
  optional: true
})])]);
const POLLING_TIME = 1000 / 15;

// Filtering SVGElements for TreeWalker
// Filter must be a function in IE, other modern browsers are compliant to this format
const svgNodeFilter = node => `ownerSVGElement` in node ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;

/**
 * {@link https://unicode-table.com/en/00A0/ Non-breaking space}.
 */
const CHAR_NO_BREAK_SPACE = `\u00A0`;
/**
 * {@link https://unicode-table.com/en/2013/ EN dash}
 * is used to indicate a range of numbers or a span of time.
 * @example 2006–2022
 * ___
 * Don't confuse with {@link CHAR_EM_DASH} or {@link CHAR_HYPHEN}!
 */
const CHAR_EN_DASH = `\u2013`;
/**
 * {@link https://unicode-table.com/en/2014/ EM dash}
 * is used to mark a break in a sentence.
 * @example Taiga UI — powerful set of open source components for Angular
 * ___
 * Don't confuse with {@link CHAR_EN_DASH} or {@link CHAR_HYPHEN}!
 */
const CHAR_EM_DASH = (/* unused pure expression or super */ null && (`\u2014`));
/**
 * {@link https://unicode-table.com/en/00AB/ Left-Pointing Double Angle Quotation Mark}
 */
const CHAR_LAQUO = (/* unused pure expression or super */ null && (`\u00AB`));
/**
 * {@link https://unicode-table.com/en/00BB/ Right-Pointing Double Angle Quotation Mark}
 */
const CHAR_RAQUO = (/* unused pure expression or super */ null && (`\u00BB`));
/**
 * {@link https://unicode-table.com/en/002D/ Hyphen (minus sign)}
 * is used to combine words.
 * @example well-behaved
 * ___
 * Don't confuse with {@link CHAR_EN_DASH} or {@link CHAR_EM_DASH}!
 */
const CHAR_HYPHEN = `\u002D`;
/**
 * {@link https://unicode-table.com/en/2212/ Minus}
 * is used as math operator symbol or before negative digits.
 * ---
 * Can be used as `&minus;`. Don't confuse with {@link CHAR_HYPHEN}
 */
const CHAR_MINUS = (/* unused pure expression or super */ null && (`\u2212`));
/**
 * {@link https://unicode-table.com/en/002B/ Plus}
 */
const CHAR_PLUS = `\u002B`;
/**
 * {@link https://unicode-table.com/en/2022/ Bullet}.
 */
const CHAR_BULLET = (/* unused pure expression or super */ null && (`\u2022`));
/**
 * {@link https://unicode-table.com/en/2026/ Suspension points}.
 */
const CHAR_ELLIPSIS = (/* unused pure expression or super */ null && (`\u2026`));
/**
 * {@link https://unicode-table.com/en/00A4/ Suspension points}.
 */
const CHAR_CURRENCY_SIGN = (/* unused pure expression or super */ null && (`\u00A4`));
/**
 * {@link https://unicode-table.com/en/200b/ Suspension points}.
 */
const CHAR_ZERO_WIDTH_SPACE = (/* unused pure expression or super */ null && (`\u200B`));
const TUI_VERSION = (/* unused pure expression or super */ null && (`2.99.0`));

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-constants.js.map

/***/ }),

/***/ 4358:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NH: () => (/* binding */ tuiRequiredSetter),
/* harmony export */   TH: () => (/* binding */ tuiDefaultProp),
/* harmony export */   UM: () => (/* binding */ tuiPure)
/* harmony export */ });
/* harmony import */ var _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8939);
/* harmony import */ var _taiga_ui_cdk_exceptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7788);



/**
 * Decorator for checking input values for undefined. You can also pass
 * optional assertion to check input against.
 *
 * CAUTION: This decorator overwrites other getters and setters.
 */
function tuiDefaultProp(assertion, ...args) {
  return (target, key) => {
    const {
      name
    } = target.constructor;
    const errorGetDefaultMessage = errorGetDefault(key, name);
    const errorSetDefaultMessage = errorSetDefault(key, name);
    Object.defineProperty(target, key, {
      configurable: true,
      get() {
        _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .zU.assert(false, errorGetDefaultMessage);
        return undefined;
      },
      set(initialValue) {
        const isValid = initialValue !== undefined;
        const errorMessage = errorSetDefaultInitial(key, name);
        let currentValue = initialValue;
        _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .zU.assert(isValid, errorMessage);
        if (isValid && assertion) {
          _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .zU.assert(assertion.call(this, initialValue), `${String(key)} in ${name} received:`, initialValue, ...args);
        }
        Object.defineProperty(this, key, {
          configurable: true,
          get() {
            return currentValue;
          },
          set(value) {
            const isValid = value !== undefined;
            const backupValue = initialValue;
            _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .zU.assert(isValid, errorSetDefaultMessage, String(backupValue));
            if (isValid && assertion) {
              _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .zU.assert(assertion.call(this, value), `${String(key)} in ${name} received:`, value, ...args);
            }
            currentValue = isValid ? value : backupValue;
          }
        });
      }
    });
  };
}
function errorGetDefault(key, component) {
  return `Default value for ${String(key)} was not provided in ${component}, error in Taiga UI Angular Kit`;
}
function errorSetDefault(key, component) {
  return `Undefined was passed as ${String(key)} to ${component}, which is invalid input, using default value:`;
}
function errorSetDefaultInitial(key, component) {
  return `Undefined was passed as default value for ${String(key)} to ${component}, error in Taiga UI Angular Kit`;
}

/**
 * Implements lazy initialization for getter or memoization of a function call similar to pure {@link: Pipe}.
 * Replaces getter with its calculated value upon first call or keeps track of last call arguments and returned
 * value for function, skipping calculation when arguments are strictly the same.
 *
 * @throws error if used not on getter or function
 *
 * CAUTION: `this` is not available inside such functions/getters, they must be pure.
 */
function tuiPure(_target, propertyKey, {
  get,
  enumerable,
  value
}) {
  if (get) {
    return {
      configurable: true,
      enumerable,
      get() {
        const value = get.call(this);
        Object.defineProperty(this, propertyKey, {
          enumerable,
          value
        });
        return value;
      }
    };
  }
  if (typeof value !== `function`) {
    throw new _taiga_ui_cdk_exceptions__WEBPACK_IMPORTED_MODULE_1__/* .TuiPureException */ .jw();
  }
  const original = value;
  return {
    configurable: true,
    enumerable,
    get() {
      let previousArgs = [];
      let originalFnWasCalledLeastAtOnce = false;
      let pureValue;
      const patched = (...args) => {
        const isPure = originalFnWasCalledLeastAtOnce && previousArgs.length === args.length && args.every((arg, index) => arg === previousArgs[index]);
        if (isPure) {
          return pureValue;
        }
        previousArgs = args;
        pureValue = original.apply(this, args);
        originalFnWasCalledLeastAtOnce = true;
        return pureValue;
      };
      Object.defineProperty(this, propertyKey, {
        configurable: true,
        value: patched
      });
      return patched;
    }
  };
}

/**
 * Decorator for checking input setter values against a custom assertion which
 * takes value passed to input setter and component instance as arguments.
 * It specifically checks for undefined values and prevents calls to the
 * original setter in this case.
 */
function tuiRequiredSetter(assertion, ...args) {
  return (target, key, {
    configurable,
    enumerable,
    get,
    set
  }) => {
    const {
      name
    } = target.constructor;
    return {
      configurable,
      enumerable,
      get,
      set(value) {
        if (value !== undefined && assertion) {
          _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .zU.assert(assertion.call(this, value), `${String(key)} in ${name} received:`, value, ...args);
        }
        if (!set || value === undefined) {
          _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .zU.assert(value !== undefined, errorSet(key, name));
          return;
        }
        set.call(this, value);
      }
    };
  };
}
function errorSet(key, component) {
  return `Undefined was passed as ${String(key)} to ${component}, setter will not be called`;
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-decorators.js.map

/***/ }),

/***/ 2668:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ls: () => (/* binding */ TuiLetDirective),
/* harmony export */   WD: () => (/* binding */ TuiLetModule)
/* harmony export */ });
/* unused harmony export TuiLetContext */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7582);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);



/**
 * @internal
 */

class TuiLetContext {
  constructor(internalDirectiveInstance) {
    this.internalDirectiveInstance = internalDirectiveInstance;
  }
  get $implicit() {
    return this.internalDirectiveInstance.tuiLet;
  }
  get tuiLet() {
    return this.internalDirectiveInstance.tuiLet;
  }
}

/**
 * Works like *ngIf but does not have a condition — use it to declare
 * the result of pipes calculation (i.e. async pipe)
 */
let TuiLetDirective = /*#__PURE__*/(() => {
  let TuiLetDirective = class TuiLetDirective {
    constructor(viewContainer, templateRef) {
      viewContainer.createEmbeddedView(templateRef, new TuiLetContext(this));
    }
    /**
     * Asserts the correct type of the context for the template that `TuiLet` will render.
     *
     * The presence of this method is a signal to the Ivy template type-check compiler that the
     * `TuiLet` structural directive renders its template with a specific context type.
     */
    static ngTemplateContextGuard(_dir, _ctx) {
      return true;
    }
  };
  TuiLetDirective.ɵfac = function TuiLetDirective_Factory(t) {
    return new (t || TuiLetDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef));
  };
  TuiLetDirective.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
    type: TuiLetDirective,
    selectors: [["", "tuiLet", ""]],
    inputs: {
      tuiLet: "tuiLet"
    }
  });
  (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)()], TuiLetDirective.prototype, "tuiLet", void 0);
  TuiLetDirective = (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef)), (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__param */ .fM)(1, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef))], TuiLetDirective);
  return TuiLetDirective;
})();
let TuiLetModule = /*#__PURE__*/(() => {
  let TuiLetModule = class TuiLetModule {};
  TuiLetModule.ɵfac = function TuiLetModule_Factory(t) {
    return new (t || TuiLetModule)();
  };
  TuiLetModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
    type: TuiLetModule
  });
  TuiLetModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({});
  return TuiLetModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](TuiLetModule, {
    declarations: [TuiLetDirective],
    exports: [TuiLetDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-directives-let.js.map

/***/ }),

/***/ 7788:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZB: () => (/* binding */ TuiNoHostException),
/* harmony export */   aq: () => (/* binding */ TuiOwnerDocumentException),
/* harmony export */   gW: () => (/* binding */ TuiXmlParsingException),
/* harmony export */   jw: () => (/* binding */ TuiPureException)
/* harmony export */ });
/* unused harmony exports InvalidDayException, InvalidMonthException, InvalidYearException, TuiComputedDocumentException, TuiDocumentSelectionException, TuiInvalidDayException, TuiInvalidMonthException, TuiInvalidYearException, TuiTableSortKeyException, TuiTsParserException, TuiValueChangesException, TuiValuePresentException */
class TuiComputedDocumentException extends (/* unused pure expression or super */ null && (Error)) {
  constructor() {
    super(`Only use computedDocument after load event`);
  }
}
class TuiDocumentSelectionException extends (/* unused pure expression or super */ null && (Error)) {
  constructor() {
    super(`Failed to get document selection`);
  }
}

/**
 * @deprecated: use {@link TuiInvalidDayException}
 * TODO: remove in v3.0
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
class InvalidDayException extends (/* unused pure expression or super */ null && (Error)) {
  constructor(day) {
    super(`Invalid day: ${day}`);
  }
}
class TuiInvalidDayException extends (/* unused pure expression or super */ null && (InvalidDayException)) {}

/**
 * @deprecated: use {@link TuiInvalidMonthException}
 * TODO: remove in v3.0
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
class InvalidMonthException extends (/* unused pure expression or super */ null && (Error)) {
  constructor(month) {
    super(`Invalid month: ${month}`);
  }
}
class TuiInvalidMonthException extends (/* unused pure expression or super */ null && (InvalidMonthException)) {}

/**
 * @deprecated: use {@link TuiInvalidYearException}
 * TODO: remove in v3.0
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
class InvalidYearException extends (/* unused pure expression or super */ null && (Error)) {
  constructor(year) {
    super(`Invalid year: ${year}`);
  }
}
class TuiInvalidYearException extends (/* unused pure expression or super */ null && (InvalidYearException)) {}
class TuiNoHostException extends Error {
  constructor() {
    super(`Portals cannot be used without TuiPortalHostComponent`);
  }
}
class TuiOwnerDocumentException extends Error {
  constructor() {
    super(`Element does not have ownerDocument`);
  }
}
class TuiPureException extends Error {
  constructor() {
    super(`tuiPure can only be used with functions or getters`);
  }
}
class TuiTableSortKeyException extends (/* unused pure expression or super */ null && (Error)) {
  constructor() {
    super(`Trying to sort with no key`);
  }
}
class TuiTsParserException extends (/* unused pure expression or super */ null && (Error)) {
  constructor() {
    super(`TsFileParser: 1 component/module per ts-file`);
  }
}
class TuiValueChangesException extends (/* unused pure expression or super */ null && (Error)) {
  constructor() {
    super(`Control does not have valueChanges`);
  }
}
class TuiValuePresentException extends (/* unused pure expression or super */ null && (Error)) {
  constructor() {
    super(`Value must present`);
  }
}
class TuiXmlParsingException extends Error {
  constructor() {
    super(`Error parsing XML string`);
  }
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-exceptions.js.map

/***/ }),

/***/ 4197:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AA: () => (/* binding */ dragAndDropFrom),
  So: () => (/* binding */ focusVisibleObservable),
  Fp: () => (/* binding */ itemsQueryListObservable),
  _d: () => (/* binding */ pressedObservable),
  PF: () => (/* binding */ preventDefault),
  UW: () => (/* binding */ stopPropagation),
  fw: () => (/* binding */ tuiIsObserved),
  mp: () => (/* binding */ tuiPreventDefault),
  pt: () => (/* binding */ tuiScrollFrom),
  vm: () => (/* binding */ tuiStopPropagation),
  mL: () => (/* binding */ tuiTypedFromEvent),
  Yr: () => (/* binding */ tuiZoneOptimized),
  fL: () => (/* binding */ tuiZonefree),
  eh: () => (/* binding */ typedFromEvent),
  YP: () => (/* binding */ watch)
});

// UNUSED EXPORTS: TuiDragStage, TuiDragState, mouseDragFinishFrom, mustBePresent, tuiDragAndDropFrom, tuiFocusVisibleObservable, tuiIsAlive, tuiItemsQueryListObservable, tuiMouseDragFinishFrom, tuiMustBePresent, tuiPressedObservable, tuiReplayedValueChangesFrom, tuiWatch, tuiZonefull

// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-exceptions.js
var taiga_ui_cdk_exceptions = __webpack_require__(7788);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-miscellaneous.js
var taiga_ui_cdk_utils_miscellaneous = __webpack_require__(1927);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/fromEvent.js
var fromEvent = __webpack_require__(2759);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/merge.js
var merge = __webpack_require__(6682);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/concat.js + 1 modules
var concat = __webpack_require__(8071);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/pipe.js
var pipe = __webpack_require__(4022);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/timer.js + 1 modules
var timer = __webpack_require__(8634);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Observable.js + 2 modules
var internal_Observable = __webpack_require__(8891);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/take.js
var take = __webpack_require__(5257);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js
var operators_map = __webpack_require__(8002);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/endWith.js
var endWith = __webpack_require__(6804);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/takeWhile.js
var takeWhile = __webpack_require__(409);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscriber.js
var Subscriber = __webpack_require__(7393);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/empty.js
var empty = __webpack_require__(9193);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/repeat.js


function repeat(count = -1) {
  return source => {
    if (count === 0) {
      return (0,empty/* empty */.c)();
    } else if (count < 0) {
      return source.lift(new RepeatOperator(-1, source));
    } else {
      return source.lift(new RepeatOperator(count - 1, source));
    }
  };
}
class RepeatOperator {
  constructor(count, source) {
    this.count = count;
    this.source = source;
  }
  call(subscriber, source) {
    return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
  }
}
class RepeatSubscriber extends Subscriber/* Subscriber */.L {
  constructor(destination, count, source) {
    super(destination);
    this.count = count;
    this.source = source;
  }
  complete() {
    if (!this.isStopped) {
      const {
        source,
        count
      } = this;
      if (count === 0) {
        return super.complete();
      } else if (count > -1) {
        this.count = count - 1;
      }
      source.subscribe(this._unsubscribeAndRecycle());
    }
  }
}
//# sourceMappingURL=repeat.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/switchMapTo.js
var switchMapTo = __webpack_require__(9499);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/mapTo.js
var mapTo = __webpack_require__(6736);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/startWith.js
var operators_startWith = __webpack_require__(9761);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js
var distinctUntilChanged = __webpack_require__(7519);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/shareReplay.js
var shareReplay = __webpack_require__(7349);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/filter.js
var filter = __webpack_require__(5435);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/ignoreElements.js
var ignoreElements = __webpack_require__(5829);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/withLatestFrom.js
var withLatestFrom = __webpack_require__(7057);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/tap.js
var tap = __webpack_require__(8307);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-focus.js
var taiga_ui_cdk_utils_focus = __webpack_require__(7179);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-observables.js






/**
 * @deprecated: use {@link tuiTypedFromEvent} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function typedFromEvent(target, event, options = {}) {
  return (0,fromEvent/* fromEvent */.R)(target, event, options);
}
const tuiTypedFromEvent = typedFromEvent;

/**
 * @deprecated: use {@link tuiMouseDragFinishFrom} instead
 * Letting go of the mouse after it was pressed
 * @param target
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function mouseDragFinishFrom(target) {
  return (0,merge/* merge */.T)(typedFromEvent(target, `mouseup`), typedFromEvent(target, `dragend`));
}
const tuiMouseDragFinishFrom = (/* unused pure expression or super */ null && (mouseDragFinishFrom));
var TuiDragStage = /*#__PURE__*/(/* unused pure expression or super */ null && ((() => {
  (function (TuiDragStage) {
    TuiDragStage[TuiDragStage["Start"] = 0] = "Start";
    TuiDragStage[TuiDragStage["Continues"] = 1] = "Continues";
    TuiDragStage[TuiDragStage["End"] = 2] = "End";
  })(TuiDragStage || (TuiDragStage = {}));
  return TuiDragStage;
})()));
class TuiDragState {
  constructor(stage, event) {
    this.stage = stage;
    this.event = event;
  }
}
/**
 * @deprecated: use {@link tuiDragAndDropFrom} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function dragAndDropFrom(element) {
  const {
    ownerDocument
  } = element;
  if (!ownerDocument) {
    throw new taiga_ui_cdk_exceptions/* TuiOwnerDocumentException */.aq();
  }
  return (0,concat/* concat */.z)(typedFromEvent(element, `mousedown`).pipe((0,take/* take */.q)(1), (0,operators_map/* map */.U)(event => new TuiDragState(0 /* Start */, event))), (0,merge/* merge */.T)(typedFromEvent(ownerDocument, `mousemove`).pipe((0,operators_map/* map */.U)(event => new TuiDragState(1 /* Continues */, event))), mouseDragFinishFrom(ownerDocument).pipe((0,take/* take */.q)(1), (0,operators_map/* map */.U)(event => new TuiDragState(2 /* End */, event)), (0,endWith/* endWith */.l)(null))).pipe((0,takeWhile/* takeWhile */.o)(taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN))).pipe(repeat());
}
const tuiDragAndDropFrom = (/* unused pure expression or super */ null && (dragAndDropFrom));

/**
 * Operator to set lifespan after which current value is considered obsolete
 */
function tuiIsAlive(lifespan = 0) {
  return (0,pipe/* pipe */.z)((0,switchMapTo/* switchMapTo */.c)((0,timer/* timer */.H)(lifespan).pipe((0,mapTo/* mapTo */.h)(false), (0,operators_startWith/* startWith */.O)(true))), (0,distinctUntilChanged/* distinctUntilChanged */.x)());
}
let documentMouseUpIsAlive$;
let documentMouseDownIsAlive$;
/**
 * @deprecated: use {@link tuiFocusVisibleObservable} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function focusVisibleObservable(element) {
  const elementBlur$ = typedFromEvent(element, `blur`);
  const {
    ownerDocument
  } = element;
  if (!ownerDocument) {
    throw new taiga_ui_cdk_exceptions/* TuiOwnerDocumentException */.aq();
  }
  if (!documentMouseDownIsAlive$ || !documentMouseUpIsAlive$) {
    documentMouseUpIsAlive$ = typedFromEvent(ownerDocument, `mouseup`, {
      capture: true
    }).pipe(tuiIsAlive(), (0,operators_startWith/* startWith */.O)(false), (0,shareReplay/* shareReplay */.d)({
      bufferSize: 1,
      refCount: true
    }));
    documentMouseDownIsAlive$ = typedFromEvent(ownerDocument, `mousedown`, {
      capture: true
    }).pipe(tuiIsAlive(), (0,operators_startWith/* startWith */.O)(false), (0,shareReplay/* shareReplay */.d)({
      bufferSize: 1,
      refCount: true
    }));
  }
  return (0,merge/* merge */.T)(
  // focus events excluding ones that came right after mouse action
  (0,concat/* concat */.z)(typedFromEvent(element, `focus`).pipe((0,take/* take */.q)(1)),
  // filtering out blur events when element remains focused so that we ignore browser tab focus loss
  elementBlur$.pipe((0,filter/* filter */.h)(() => !(0,taiga_ui_cdk_utils_focus/* isNativeFocused */.zV)(element)), (0,take/* take */.q)(1), (0,ignoreElements/* ignoreElements */.l)())).pipe(repeat(), (0,withLatestFrom/* withLatestFrom */.M)(documentMouseDownIsAlive$, documentMouseUpIsAlive$, (_event, elementActual, documentActual) => elementActual || documentActual), (0,filter/* filter */.h)(isUserFocus => !isUserFocus))).pipe((0,switchMapTo/* switchMapTo */.c)(elementBlur$.pipe((0,mapTo/* mapTo */.h)(false), (0,take/* take */.q)(1), (0,operators_startWith/* startWith */.O)(true))), (0,distinctUntilChanged/* distinctUntilChanged */.x)());
}
const tuiFocusVisibleObservable = (/* unused pure expression or super */ null && (focusVisibleObservable));

/**
 * In RxJS 8 `observers` will be removed, this util is for future safety
 */
function tuiIsObserved(observable) {
  return observable.observed || !!observable.observers.length;
}

/**
 * @deprecated: use {@link tuiItemsQueryListObservable} instead
 * Converts changes observable of a QueryList to an Observable of arrays
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function itemsQueryListObservable(queryList) {
  return queryList.changes.pipe((0,operators_map/* map */.U)(() => (0,taiga_ui_cdk_utils_miscellaneous/* getOriginalArrayFromQueryList */.ct)(queryList)), (0,operators_startWith/* startWith */.O)((0,taiga_ui_cdk_utils_miscellaneous/* getOriginalArrayFromQueryList */.ct)(queryList)));
}
const tuiItemsQueryListObservable = (/* unused pure expression or super */ null && (itemsQueryListObservable));

/**
 * @deprecated: use {@link tuiMustBePresent} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function mustBePresent() {
  return map(value => {
    if (!isPresent(value)) {
      throw new TuiValuePresentException();
    }
    return value;
  });
}
const tuiMustBePresent = (/* unused pure expression or super */ null && (mustBePresent));

/**
 * @deprecated: use {@link tuiPressedObservable} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function pressedObservable(element, {
  onlyTrusted
} = {
  onlyTrusted: true
}) {
  const {
    ownerDocument
  } = element;
  if (!ownerDocument) {
    throw new taiga_ui_cdk_exceptions/* TuiOwnerDocumentException */.aq();
  }
  return typedFromEvent(element, `mousedown`).pipe((0,filter/* filter */.h)(({
    isTrusted
  }) => isTrusted || !onlyTrusted), (0,switchMapTo/* switchMapTo */.c)(mouseDragFinishFrom(ownerDocument).pipe((0,mapTo/* mapTo */.h)(false), (0,take/* take */.q)(1), (0,operators_startWith/* startWith */.O)(true))));
}
const tuiPressedObservable = (/* unused pure expression or super */ null && (pressedObservable));

/**
 * @deprecated: use {@link tuiPreventDefault} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function preventDefault() {
  return (0,tap/* tap */.b)(event => event.preventDefault());
}
const tuiPreventDefault = preventDefault;

/**
 * Turns AbstractControl/Abstract-control-directive valueChanges into ReplaySubject(1)
 * TODO: 3.0 name should be shorter.
 */
function tuiReplayedValueChangesFrom(control) {
  return new Observable(subscriber => {
    if (!control.valueChanges) {
      throw new TuiValueChangesException();
    }
    control.valueChanges.pipe(startWith(control.value)).subscribe(subscriber);
  });
}

/**
 * Normalizes scroll event in case element is `html` (document.documentElement)
 */
function tuiScrollFrom(element) {
  var _a;
  return tuiTypedFromEvent(element === ((_a = element.ownerDocument) === null || _a === void 0 ? void 0 : _a.documentElement) ? element.ownerDocument : element, `scroll`);
}

/**
 * @deprecated: use {@link tuiStopPropagation} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function stopPropagation() {
  return (0,tap/* tap */.b)(e => {
    e.stopPropagation();
  });
}
const tuiStopPropagation = stopPropagation;

/**
 * @deprecated: use {@link tuiWatch} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function watch(changeDetectorRef) {
  return (0,tap/* tap */.b)(() => {
    changeDetectorRef.markForCheck();
  });
}
const tuiWatch = (/* unused pure expression or super */ null && (watch));
function tuiZonefull(ngZone) {
  return source => new internal_Observable/* Observable */.y(subscriber => source.subscribe({
    next: value => ngZone.run(() => subscriber.next(value)),
    error: error => ngZone.run(() => subscriber.error(error)),
    complete: () => ngZone.run(() => subscriber.complete())
  }));
}
function tuiZonefree(ngZone) {
  return source => new internal_Observable/* Observable */.y(subscriber => ngZone.runOutsideAngular(() => source.subscribe(subscriber)));
}
function tuiZoneOptimized(ngZone) {
  return (0,pipe/* pipe */.z)(tuiZonefree(ngZone), tuiZonefull(ngZone));
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-observables.js.map

/***/ }),

/***/ 3503:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  a3: () => (/* binding */ TuiDestroyService),
  gH: () => (/* binding */ TuiDirectiveStylesService),
  ku: () => (/* binding */ TuiFocusVisibleService),
  gs: () => (/* binding */ TuiHoveredService),
  ll: () => (/* binding */ TuiIdService),
  AQ: () => (/* binding */ TuiObscuredService),
  b0: () => (/* binding */ TuiParentsScrollService),
  tl: () => (/* binding */ TuiResizeService),
  Fr: () => (/* binding */ TuiStaticRequestService),
  $D: () => (/* binding */ TuiSwipeService)
});

// UNUSED EXPORTS: TuiPanService, TuiScrollService, TuiZoomService

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.mjs
var tslib_es6 = __webpack_require__(7582);
// EXTERNAL MODULE: consume shared module (default) @angular/core@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/core/fesm2015/core.js)
var core_js_ = __webpack_require__(8312);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/ReplaySubject.js + 4 modules
var ReplaySubject = __webpack_require__(2298);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Observable.js + 2 modules
var internal_Observable = __webpack_require__(8891);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/merge.js
var observable_merge = __webpack_require__(6682);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/defer.js
var observable_defer = __webpack_require__(1439);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/fromEvent.js
var fromEvent = __webpack_require__(2759);
// EXTERNAL MODULE: consume shared module (default) @angular/common@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/common/fesm2015/common.js)
var common_js_ = __webpack_require__(3008);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-tokens.js + 1 modules
var taiga_ui_cdk_tokens = __webpack_require__(3034);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-observables.js + 1 modules
var taiga_ui_cdk_observables = __webpack_require__(4197);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/takeUntil.js
var operators_takeUntil = __webpack_require__(6782);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/switchMap.js
var operators_switchMap = __webpack_require__(3190);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/filter.js
var operators_filter = __webpack_require__(5435);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/take.js
var take = __webpack_require__(5257);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/mapTo.js
var mapTo = __webpack_require__(6736);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/startWith.js
var startWith = __webpack_require__(9761);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js
var distinctUntilChanged = __webpack_require__(7519);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/delay.js + 1 modules
var delay = __webpack_require__(1289);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/throttleTime.js + 1 modules
var throttleTime = __webpack_require__(9426);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js
var operators_map = __webpack_require__(8002);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/catchError.js
var catchError = __webpack_require__(5304);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/debounceTime.js
var debounceTime = __webpack_require__(4395);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/shareReplay.js
var shareReplay = __webpack_require__(7349);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/pairwise.js
var operators_pairwise = __webpack_require__(9328);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-dom.js
var taiga_ui_cdk_utils_dom = __webpack_require__(5242);
// EXTERNAL MODULE: ./node_modules/@ng-web-apis/common/fesm2015/ng-web-apis-common.js
var ng_web_apis_common = __webpack_require__(2579);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-constants.js
var taiga_ui_cdk_constants = __webpack_require__(3770);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/share.js + 1 modules
var share = __webpack_require__(8819);
;// CONCATENATED MODULE: ./node_modules/@ng-web-apis/resize-observer/fesm2015/ng-web-apis-resize-observer.js





/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */


const RESIZE_OPTION_BOX_DEFAULT = 'content-box';
/** @type {?} */
const RESIZE_OPTION_BOX = new core_js_.InjectionToken('Box model to observe changes', {
  providedIn: 'root',
  factory: () => RESIZE_OPTION_BOX_DEFAULT
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const RESIZE_OBSERVER_SUPPORT = new core_js_.InjectionToken('Resize Observer API support', {
  providedIn: 'root',
  factory: () => !!(0,core_js_.inject)(ng_web_apis_common/* WINDOW */.m9).ResizeObserver
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @dynamic
let ResizeObserverService = /*#__PURE__*/(() => {
  class ResizeObserverService extends internal_Observable/* Observable */.y {
    /**
     * @param {?} __0
     * @param {?} ngZone
     * @param {?} support
     * @param {?} box
     */
    constructor({
      nativeElement
    }, ngZone, support, box) {
      /** @type {?} */
      let observer;
      super(subscriber => {
        if (!support) {
          subscriber.error('ResizeObserver is not supported in your browser');
          return;
        }
        observer = new ResizeObserver(entries => {
          ngZone.run(() => {
            subscriber.next(entries);
          });
        });
        observer.observe(nativeElement, {
          box
        });
        return () => {
          observer.disconnect();
        };
      });
      return this.pipe((0,share/* share */.B)());
    }
  }
  ResizeObserverService.ɵfac = function ResizeObserverService_Factory(t) {
    return new (t || ResizeObserverService)(core_js_["ɵɵinject"](core_js_.ElementRef), core_js_["ɵɵinject"](core_js_.NgZone), core_js_["ɵɵinject"](RESIZE_OBSERVER_SUPPORT), core_js_["ɵɵinject"](RESIZE_OPTION_BOX));
  };
  ResizeObserverService.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: ResizeObserverService,
    factory: ResizeObserverService.ɵfac
  });
  /** @nocollapse */
  return ResizeObserverService;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// TODO switch to Attribute once https://github.com/angular/angular/issues/36479 is fixed
/**
 * @param {?} __0
 * @return {?}
 */
function boxExtractor({
  nativeElement
}) {
  /** @type {?} */
  const attribute = /** @type {?} */nativeElement.getAttribute('waResizeBox');
  return boxFactory(attribute);
}
/**
 * @param {?} box
 * @return {?}
 */
function boxFactory(box) {
  return box || RESIZE_OPTION_BOX_DEFAULT;
}
// @dynamic
let ResizeObserverDirective = /*#__PURE__*/(() => {
  class ResizeObserverDirective {
    /**
     * @param {?} entries$
     * @param {?} _box
     */
    constructor(entries$, _box) {
      this.waResizeObserver = entries$;
    }
  }
  ResizeObserverDirective.ɵfac = function ResizeObserverDirective_Factory(t) {
    return new (t || ResizeObserverDirective)(core_js_["ɵɵdirectiveInject"](ResizeObserverService), core_js_["ɵɵinjectAttribute"]('waResizeBox'));
  };
  ResizeObserverDirective.ɵdir = /*@__PURE__*/core_js_["ɵɵdefineDirective"]({
    type: ResizeObserverDirective,
    selectors: [["", "waResizeObserver", ""]],
    outputs: {
      waResizeObserver: "waResizeObserver"
    },
    features: [core_js_["ɵɵProvidersFeature"]([ResizeObserverService, {
      provide: RESIZE_OPTION_BOX,
      deps: [core_js_.ElementRef],
      useFactory: boxExtractor
    }])]
  });
  /** @nocollapse */
  return ResizeObserverDirective;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
let ResizeObserverModule = /*#__PURE__*/(() => {
  class ResizeObserverModule {}
  ResizeObserverModule.ɵfac = function ResizeObserverModule_Factory(t) {
    return new (t || ResizeObserverModule)();
  };
  ResizeObserverModule.ɵmod = /*@__PURE__*/core_js_["ɵɵdefineNgModule"]({
    type: ResizeObserverModule
  });
  ResizeObserverModule.ɵinj = /*@__PURE__*/core_js_["ɵɵdefineInjector"]({});
  return ResizeObserverModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && core_js_["ɵɵsetNgModuleScope"](ResizeObserverModule, {
    declarations: [ResizeObserverDirective],
    exports: [ResizeObserverDirective]
  });
})();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */



//# sourceMappingURL=ng-web-apis-resize-observer.js.map
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-miscellaneous.js
var taiga_ui_cdk_utils_miscellaneous = __webpack_require__(1927);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-services.js
















/**
 * Observable abstraction over ngOnDestroy to use with takeUntil
 */


let TuiDestroyService = /*#__PURE__*/(() => {
  let TuiDestroyService = class TuiDestroyService extends ReplaySubject/* ReplaySubject */.t {
    constructor() {
      super(1);
    }
    ngOnDestroy() {
      this.next();
      this.complete();
    }
  };
  TuiDestroyService.ɵfac = function TuiDestroyService_Factory(t) {
    return new (t || TuiDestroyService)();
  };
  TuiDestroyService.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: TuiDestroyService,
    factory: function (t) {
      return TuiDestroyService.ɵfac(t);
    }
  });

  /**
   * Service to use styles with directives
   * @dynamic
   */
  return TuiDestroyService;
})();
let TuiDirectiveStylesService = /*#__PURE__*/(() => {
  let TuiDirectiveStylesService = class TuiDirectiveStylesService {
    constructor(resolver, injector, documentRef, renderer) {
      this.resolver = resolver;
      this.injector = injector;
      this.documentRef = documentRef;
      this.renderer = renderer;
      this.map = new Map();
    }
    addComponent(component) {
      if (!this.map.has(component)) {
        this.map.set(component, this.resolver.resolveComponentFactory(component).create(this.injector));
      }
    }
    /** @deprecated use components approach
     * TODO: delete in v3.0
     */
    addStyle(styles, attribute) {
      if (this.documentRef.head.querySelector(`style[${attribute}]`)) {
        return;
      }
      const style = this.renderer.createElement(`style`);
      this.renderer.setProperty(style, `textContent`, styles);
      this.renderer.setAttribute(style, attribute, ``);
      this.documentRef.head.appendChild(style);
    }
  };
  TuiDirectiveStylesService.ɵfac = function TuiDirectiveStylesService_Factory(t) {
    return new (t || TuiDirectiveStylesService)(core_js_["ɵɵinject"](core_js_.ComponentFactoryResolver), core_js_["ɵɵinject"](core_js_.INJECTOR), core_js_["ɵɵinject"](common_js_.DOCUMENT), core_js_["ɵɵinject"](taiga_ui_cdk_tokens/* TUI_DEFAULT_RENDERER */.HO));
  };
  TuiDirectiveStylesService.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function TuiDirectiveStylesService_Factory() {
      return new TuiDirectiveStylesService((0,core_js_["ɵɵinject"])(core_js_.ComponentFactoryResolver), (0,core_js_["ɵɵinject"])(core_js_.INJECTOR), (0,core_js_["ɵɵinject"])(common_js_.DOCUMENT), (0,core_js_["ɵɵinject"])(taiga_ui_cdk_tokens/* TUI_DEFAULT_RENDERER */.HO));
    },
    token: TuiDirectiveStylesService,
    providedIn: "root"
  });
  TuiDirectiveStylesService = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ComponentFactoryResolver)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.INJECTOR)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(common_js_.DOCUMENT)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_DEFAULT_RENDERER */.HO))], TuiDirectiveStylesService);

  /**
   * Service to imitate :focus-visible
   * (https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible)
   * in browsers that do not support it
   * @dynamic
   */
  return TuiDirectiveStylesService;
})();
let TuiFocusVisibleService = /*#__PURE__*/(() => {
  let TuiFocusVisibleService = class TuiFocusVisibleService extends internal_Observable/* Observable */.y {
    constructor({
      nativeElement
    }, changeDetectorRef, destroy$) {
      super(subscriber => this.focusVisible$.subscribe(subscriber));
      this.focusVisible$ = (0,taiga_ui_cdk_observables/* focusVisibleObservable */.So)(nativeElement).pipe((0,taiga_ui_cdk_observables/* watch */.YP)(changeDetectorRef), (0,operators_takeUntil/* takeUntil */.R)(destroy$));
    }
  };
  TuiFocusVisibleService.ɵfac = function TuiFocusVisibleService_Factory(t) {
    return new (t || TuiFocusVisibleService)(core_js_["ɵɵinject"](core_js_.ElementRef), core_js_["ɵɵinject"](core_js_.ChangeDetectorRef), core_js_["ɵɵinject"](TuiDestroyService));
  };
  TuiFocusVisibleService.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: TuiFocusVisibleService,
    factory: function (t) {
      return TuiFocusVisibleService.ɵfac(t);
    }
  });
  TuiFocusVisibleService = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ChangeDetectorRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(TuiDestroyService))], TuiFocusVisibleService);

  /** @deprecated TODO remove in v3.0 */
  // @dynamic
  return TuiFocusVisibleService;
})();
let TuiHoveredService = /*#__PURE__*/(() => {
  let TuiHoveredService = class TuiHoveredService {
    constructor(documentRef, ngZone) {
      this.ngZone = ngZone;
      this.documentEvents$ = (0,observable_merge/* merge */.T)((0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(documentRef, `mousemove`), (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(documentRef, `touchstart`, {
        capture: true
      }));
    }
    createHovered$(target, options = {
      passive: true
    }) {
      return (0,observable_merge/* merge */.T)((0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(target, `mouseenter`, options), (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(target, `touchstart`, options)).pipe((0,operators_switchMap/* switchMap */.w)(() => (0,observable_merge/* merge */.T)((0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(target, `mouseleave`, options), this.documentEvents$.pipe((0,operators_filter/* filter */.h)(event => !target.contains((0,taiga_ui_cdk_utils_dom/* getActualTarget */.Bq)(event))), (0,taiga_ui_cdk_observables/* tuiZoneOptimized */.Yr)(this.ngZone), (0,take/* take */.q)(1))).pipe((0,mapTo/* mapTo */.h)(false), (0,startWith/* startWith */.O)(true))), (0,distinctUntilChanged/* distinctUntilChanged */.x)());
    }
  };
  TuiHoveredService.ɵfac = function TuiHoveredService_Factory(t) {
    return new (t || TuiHoveredService)(core_js_["ɵɵinject"](common_js_.DOCUMENT), core_js_["ɵɵinject"](core_js_.NgZone));
  };
  TuiHoveredService.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function TuiHoveredService_Factory() {
      return new TuiHoveredService((0,core_js_["ɵɵinject"])(common_js_.DOCUMENT), (0,core_js_["ɵɵinject"])(core_js_.NgZone));
    },
    token: TuiHoveredService,
    providedIn: "root"
  });
  TuiHoveredService = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(common_js_.DOCUMENT)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.NgZone))], TuiHoveredService);
  return TuiHoveredService;
})();
var TuiIdService_1;
const TUI = `tui_`;
/**
 * Generates unique ids
 */
let TuiIdService = TuiIdService_1 = class TuiIdService {
  generate() {
    return `${TUI}${TuiIdService_1.autoId++}${Date.now()}`;
  }
};
TuiIdService.ɵfac = function TuiIdService_Factory(t) {
  return new (t || TuiIdService)();
};
TuiIdService.autoId = 0;
TuiIdService.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
  factory: function TuiIdService_Factory() {
    return new TuiIdService();
  },
  token: TuiIdService,
  providedIn: "root"
});

/**
 * Service that subscribes to scroll events of all parent elements
 */
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
let TuiParentsScrollService = /*#__PURE__*/(() => {
  let TuiParentsScrollService = class TuiParentsScrollService extends internal_Observable/* Observable */.y {
    constructor(elementRef, windowRef) {
      super(subscriber => this.callback$.subscribe(subscriber));
      this.callback$ = (0,observable_defer/* defer */.P)(() => {
        let {
          nativeElement
        } = elementRef;
        const eventTargets = [windowRef, nativeElement];
        while (nativeElement.parentElement) {
          nativeElement = nativeElement.parentElement;
          eventTargets.push(nativeElement);
        }
        return (0,observable_merge/* merge */.T)(...eventTargets.map(element => (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(element, `scroll`)));
      });
    }
  };
  TuiParentsScrollService.ɵfac = function TuiParentsScrollService_Factory(t) {
    return new (t || TuiParentsScrollService)(core_js_["ɵɵinject"](core_js_.ElementRef), core_js_["ɵɵinject"](ng_web_apis_common/* WINDOW */.m9));
  };
  TuiParentsScrollService.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: TuiParentsScrollService,
    factory: function (t) {
      return TuiParentsScrollService.ɵfac(t);
    }
  });
  TuiParentsScrollService = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(ng_web_apis_common/* WINDOW */.m9))], TuiParentsScrollService);

  // @bad TODO: Consider Intersection Observer with fallback to current implementation
  /**
   * Service that monitors element visibility by subscribing to scrolls
   * and polling with set interval, returns either null or an array
   * of elements that overlap given element edges
   */
  // Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
  // @dynamic
  return TuiParentsScrollService;
})();
let TuiObscuredService = /*#__PURE__*/(() => {
  let TuiObscuredService = class TuiObscuredService extends internal_Observable/* Observable */.y {
    constructor(parentsScroll$, {
      nativeElement
    }, ngZone, windowRef, destroy$, animationFrame$) {
      super(subscriber => this.obscured$.subscribe(subscriber));
      this.obscured$ = (0,observable_merge/* merge */.T)(
      // delay is added so it will not interfere with other listeners
      (0,observable_merge/* merge */.T)(parentsScroll$, (0,fromEvent/* fromEvent */.R)(windowRef, `resize`)).pipe((0,delay/* delay */.g)(0)), animationFrame$.pipe((0,throttleTime/* throttleTime */.p)(taiga_ui_cdk_constants/* POLLING_TIME */.Yg))).pipe((0,operators_map/* map */.U)(() => (0,taiga_ui_cdk_utils_dom/* getElementObscurers */.hh)(nativeElement)), (0,startWith/* startWith */.O)(null), (0,distinctUntilChanged/* distinctUntilChanged */.x)(), (0,taiga_ui_cdk_observables/* tuiZoneOptimized */.Yr)(ngZone), (0,operators_takeUntil/* takeUntil */.R)(destroy$));
    }
  };
  TuiObscuredService.ɵfac = function TuiObscuredService_Factory(t) {
    return new (t || TuiObscuredService)(core_js_["ɵɵinject"](TuiParentsScrollService, 2), core_js_["ɵɵinject"](core_js_.ElementRef), core_js_["ɵɵinject"](core_js_.NgZone), core_js_["ɵɵinject"](ng_web_apis_common/* WINDOW */.m9), core_js_["ɵɵinject"](TuiDestroyService), core_js_["ɵɵinject"](ng_web_apis_common/* ANIMATION_FRAME */.L1));
  };
  TuiObscuredService.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: TuiObscuredService,
    factory: function (t) {
      return TuiObscuredService.ɵfac(t);
    }
  });
  TuiObscuredService = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(TuiParentsScrollService)), (0,tslib_es6/* __param */.fM)(0, (0,core_js_.Self)()), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(core_js_.NgZone)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(ng_web_apis_common/* WINDOW */.m9)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(TuiDestroyService)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(ng_web_apis_common/* ANIMATION_FRAME */.L1))], TuiObscuredService);

  /**
   * @dynamic
   */
  return TuiObscuredService;
})();
let TuiPanService = /*#__PURE__*/(/* unused pure expression or super */ null && ((() => {
  let TuiPanService = class TuiPanService extends Observable {
    constructor({
      nativeElement
    }, documentRef) {
      super(subscriber => {
        merge(typedFromEvent(nativeElement, `touchstart`, {
          passive: true
        }), typedFromEvent(nativeElement, `mousedown`)).pipe(switchMapTo(merge(typedFromEvent(documentRef, `touchmove`, {
          passive: true
        }).pipe(filter(({
          touches
        }) => touches.length < 2), map(({
          touches
        }) => touches[0])), typedFromEvent(documentRef, `mousemove`))), pairwise(), map(([first, second]) => {
          const deltaX = second.clientX - first.clientX;
          const deltaY = second.clientY - first.clientY;
          return [deltaX, deltaY];
        }),
        // eslint-disable-next-line rxjs/no-unsafe-takeuntil
        takeUntil(merge(typedFromEvent(documentRef, `touchend`), typedFromEvent(documentRef, `mouseup`))), repeat()).subscribe(subscriber);
      });
    }
  };
  TuiPanService.ɵfac = function TuiPanService_Factory(t) {
    return new (t || TuiPanService)(ɵngcc0.ɵɵinject(ElementRef), ɵngcc0.ɵɵinject(DOCUMENT));
  };
  TuiPanService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({
    token: TuiPanService,
    factory: function (t) {
      return TuiPanService.ɵfac(t);
    }
  });
  TuiPanService = __decorate([__param(0, Inject(ElementRef)), __param(1, Inject(DOCUMENT))], TuiPanService);

  // @dynamic
  return TuiPanService;
})()));
let TuiResizeService = /*#__PURE__*/(() => {
  let TuiResizeService = class TuiResizeService extends ResizeObserverService {
    constructor(elementRef, ngZone, destroy$, support, box, animationFrame$) {
      super(elementRef, ngZone, support, box);
      return this.pipe((0,catchError/* catchError */.K)(() => animationFrame$.pipe((0,throttleTime/* throttleTime */.p)(taiga_ui_cdk_constants/* POLLING_TIME */.Yg), (0,operators_map/* map */.U)(() => `${elementRef.nativeElement.clientWidth} ${elementRef.nativeElement.clientHeight}`), (0,distinctUntilChanged/* distinctUntilChanged */.x)(), (0,mapTo/* mapTo */.h)(taiga_ui_cdk_constants/* EMPTY_ARRAY */.LZ))), (0,debounceTime/* debounceTime */.b)(0), (0,taiga_ui_cdk_observables/* tuiZonefree */.fL)(ngZone), (0,operators_takeUntil/* takeUntil */.R)(destroy$));
    }
  };
  TuiResizeService.ɵfac = function TuiResizeService_Factory(t) {
    return new (t || TuiResizeService)(core_js_["ɵɵinject"](core_js_.ElementRef), core_js_["ɵɵinject"](core_js_.NgZone), core_js_["ɵɵinject"](TuiDestroyService), core_js_["ɵɵinject"](RESIZE_OBSERVER_SUPPORT), core_js_["ɵɵinject"](RESIZE_OPTION_BOX), core_js_["ɵɵinject"](ng_web_apis_common/* ANIMATION_FRAME */.L1));
  };
  TuiResizeService.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: TuiResizeService,
    factory: function (t) {
      return TuiResizeService.ɵfac(t);
    }
  });
  TuiResizeService = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(core_js_.NgZone)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(TuiDestroyService)), (0,tslib_es6/* __param */.fM)(3, (0,core_js_.Inject)(RESIZE_OBSERVER_SUPPORT)), (0,tslib_es6/* __param */.fM)(4, (0,core_js_.Inject)(RESIZE_OPTION_BOX)), (0,tslib_es6/* __param */.fM)(5, (0,core_js_.Inject)(ng_web_apis_common/* ANIMATION_FRAME */.L1))], TuiResizeService);
  return TuiResizeService;
})();
const SCROLL_TIME = 300;
// @dynamic
let TuiScrollService = /*#__PURE__*/(/* unused pure expression or super */ null && ((() => {
  let TuiScrollService = class TuiScrollService {
    constructor(performanceRef, animationFrame$) {
      this.performanceRef = performanceRef;
      this.animationFrame$ = animationFrame$;
    }
    scroll$(elementOrWindow, scrollTop, scrollLeft = getX(elementOrWindow), duration = SCROLL_TIME) {
      tuiAssert.assert(duration >= 0, `Duration cannot be negative`);
      tuiAssert.assert(scrollTop >= 0, `scrollTop cannot be negative`);
      tuiAssert.assert(scrollLeft >= 0, `scrollLeft cannot be negative`);
      const initialTop = getY(elementOrWindow);
      const initialLeft = getX(elementOrWindow);
      const deltaTop = scrollTop - initialTop;
      const deltaLeft = scrollLeft - initialLeft;
      const observable = !duration ? of([scrollTop, scrollLeft]) : defer(() => of(this.performanceRef.now())).pipe(switchMap(start => this.animationFrame$.pipe(map(now => now - start))), map(elapsed => tuiEaseInOutQuad(tuiClamp(elapsed / duration, 0, 1))), map(percent => [initialTop + deltaTop * percent, initialLeft + deltaLeft * percent]), takeUntil(timer(duration)));
      return observable.pipe(tap(([scrollTop, scrollLeft]) => {
        var _a;
        (_a = elementOrWindow.scrollTo) === null || _a === void 0 ? void 0 : _a.call(elementOrWindow, scrollLeft, scrollTop);
      }));
    }
  };
  TuiScrollService.ɵfac = function TuiScrollService_Factory(t) {
    return new (t || TuiScrollService)(ɵngcc0.ɵɵinject(PERFORMANCE), ɵngcc0.ɵɵinject(ANIMATION_FRAME));
  };
  TuiScrollService.ɵprov = ɵɵdefineInjectable({
    factory: function TuiScrollService_Factory() {
      return new TuiScrollService(ɵɵinject(PERFORMANCE), ɵɵinject(ANIMATION_FRAME));
    },
    token: TuiScrollService,
    providedIn: "root"
  });
  TuiScrollService = __decorate([__param(0, Inject(PERFORMANCE)), __param(1, Inject(ANIMATION_FRAME))], TuiScrollService);
  return TuiScrollService;
})()));
function getX(elementOrWindow) {
  return `scrollX` in elementOrWindow ? elementOrWindow.scrollX : elementOrWindow.scrollLeft;
}
function getY(elementOrWindow) {
  return `scrollY` in elementOrWindow ? elementOrWindow.scrollY : elementOrWindow.scrollTop;
}
let TuiStaticRequestService = /*#__PURE__*/(() => {
  let TuiStaticRequestService = class TuiStaticRequestService {
    constructor() {
      this.cache = new Map();
    }
    request(url) {
      const cache = this.cache.get(url);
      if (cache) {
        return cache;
      }
      const observable = new internal_Observable/* Observable */.y(observer => {
        const xhr = new XMLHttpRequest();
        xhr.onreadystatechange = () => {
          if (xhr.readyState === 4) {
            const response = xhr.responseType ? xhr.response : xhr.responseText;
            if (xhr.status === 200) {
              observer.next(response);
              observer.complete();
            } else {
              observer.error(response);
            }
          }
        };
        xhr.open(`GET`, url);
        xhr.send();
        return () => {
          xhr.abort();
        };
      });
      const piped = observable.pipe((0,shareReplay/* shareReplay */.d)({
        bufferSize: 1,
        refCount: false
      }));
      this.cache.set(url, piped);
      return piped;
    }
  };
  TuiStaticRequestService.ɵfac = function TuiStaticRequestService_Factory(t) {
    return new (t || TuiStaticRequestService)();
  };
  TuiStaticRequestService.ɵprov = (0,core_js_["ɵɵdefineInjectable"])({
    factory: function TuiStaticRequestService_Factory() {
      return new TuiStaticRequestService();
    },
    token: TuiStaticRequestService,
    providedIn: "root"
  });

  /**
   * @dynamic
   */
  return TuiStaticRequestService;
})();
let TuiSwipeService = /*#__PURE__*/(() => {
  let TuiSwipeService = class TuiSwipeService extends internal_Observable/* Observable */.y {
    constructor({
      nativeElement
    }, {
      timeout,
      threshold
    }, documentRef) {
      super(subscriber => {
        (0,observable_merge/* merge */.T)((0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(nativeElement, `touchstart`, {
          passive: true
        }), (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(documentRef, `touchend`)).pipe((0,operators_pairwise/* pairwise */.G)(), (0,operators_filter/* filter */.h)(([first, second]) => !!first.touches.length && first.touches[0].identifier === second.changedTouches[0].identifier), (0,operators_map/* map */.U)(([start, end]) => {
          const startX = start.touches[0].clientX;
          const startY = start.touches[0].clientY;
          const endX = end.changedTouches[0].clientX;
          const endY = end.changedTouches[0].clientY;
          const distanceX = startX - endX;
          const distanceY = startY - endY;
          const duration = end.timeStamp - start.timeStamp;
          if ((Math.abs(distanceX) > threshold || Math.abs(distanceY) > threshold) && duration < timeout) {
            return {
              direction: (0,taiga_ui_cdk_utils_miscellaneous/* getSwipeDirection */.Yg)(distanceX, distanceY),
              events: [start, end]
            };
          }
          return null;
        }), (0,operators_filter/* filter */.h)(taiga_ui_cdk_utils_miscellaneous/* isPresent */.EN)).subscribe(subscriber);
      });
    }
  };
  TuiSwipeService.ɵfac = function TuiSwipeService_Factory(t) {
    return new (t || TuiSwipeService)(core_js_["ɵɵinject"](core_js_.ElementRef), core_js_["ɵɵinject"](taiga_ui_cdk_tokens/* TUI_SWIPE_OPTIONS */.s6), core_js_["ɵɵinject"](common_js_.DOCUMENT));
  };
  TuiSwipeService.ɵprov = /*@__PURE__*/core_js_["ɵɵdefineInjectable"]({
    token: TuiSwipeService,
    factory: function (t) {
      return TuiSwipeService.ɵfac(t);
    }
  });
  TuiSwipeService = (0,tslib_es6/* __decorate */.gn)([(0,tslib_es6/* __param */.fM)(0, (0,core_js_.Inject)(core_js_.ElementRef)), (0,tslib_es6/* __param */.fM)(1, (0,core_js_.Inject)(taiga_ui_cdk_tokens/* TUI_SWIPE_OPTIONS */.s6)), (0,tslib_es6/* __param */.fM)(2, (0,core_js_.Inject)(common_js_.DOCUMENT))], TuiSwipeService);
  return TuiSwipeService;
})();
const TOUCH_SENSITIVITY = 0.01;
// @dynamic
let TuiZoomService = /*#__PURE__*/(/* unused pure expression or super */ null && ((() => {
  let TuiZoomService = class TuiZoomService extends Observable {
    constructor({
      nativeElement
    }, {
      wheelSensitivity
    }) {
      super(subscriber => {
        merge(typedFromEvent(nativeElement, `touchstart`, {
          passive: true
        }).pipe(filter(({
          touches
        }) => touches.length > 1), switchMap(startEvent => typedFromEvent(nativeElement, `touchmove`, {
          passive: true
        }).pipe(preventDefault(), scan((prev, event) => {
          const distance = distanceBetweenTouches(event);
          return {
            event,
            distance,
            delta: (distance - prev.distance) * TOUCH_SENSITIVITY
          };
        }, {
          event: startEvent,
          distance: distanceBetweenTouches(startEvent),
          delta: 0
        }), map(({
          event,
          delta
        }) => {
          const clientX = (event.touches[0].clientX + event.touches[1].clientX) / 2;
          const clientY = (event.touches[0].clientY + event.touches[1].clientY) / 2;
          return {
            clientX,
            clientY,
            delta,
            event
          };
        }), takeUntil(typedFromEvent(nativeElement, `touchend`))))), typedFromEvent(nativeElement, `wheel`, {
          passive: false
        }).pipe(preventDefault(), map(wheel => ({
          clientX: wheel.clientX,
          clientY: wheel.clientY,
          delta: -wheel.deltaY * wheelSensitivity,
          event: wheel
        })))).subscribe(subscriber);
      });
    }
  };
  TuiZoomService.ɵfac = function TuiZoomService_Factory(t) {
    return new (t || TuiZoomService)(ɵngcc0.ɵɵinject(ElementRef), ɵngcc0.ɵɵinject(TUI_ZOOM_OPTIONS));
  };
  TuiZoomService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({
    token: TuiZoomService,
    factory: function (t) {
      return TuiZoomService.ɵfac(t);
    }
  });
  TuiZoomService = __decorate([__param(0, Inject(ElementRef)), __param(1, Inject(TUI_ZOOM_OPTIONS))], TuiZoomService);
  return TuiZoomService;
})()));
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-services.js.map

/***/ }),

/***/ 3034:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  wk: () => (/* binding */ TUI_ACTIVE_ELEMENT),
  bS: () => (/* binding */ TUI_ALERTS),
  HO: () => (/* binding */ TUI_DEFAULT_RENDERER),
  qY: () => (/* binding */ TUI_DIALOGS),
  KZ: () => (/* binding */ TUI_FOCUSABLE_ITEM_ACCESSOR),
  XG: () => (/* binding */ TUI_IS_ANDROID),
  B4: () => (/* binding */ TUI_IS_CYPRESS),
  FA: () => (/* binding */ TUI_IS_IOS),
  fL: () => (/* binding */ TUI_IS_MOBILE),
  hm: () => (/* binding */ TUI_SANITIZER),
  s6: () => (/* binding */ TUI_SWIPE_OPTIONS),
  wx: () => (/* binding */ TUI_TAKE_ONLY_TRUSTED_EVENTS)
});

// UNUSED EXPORTS: TUI_IS_APPLE, TUI_IS_CHROMIUM, TUI_IS_FIREFOX, TUI_IS_WEBKIT, TUI_REMOVED_ELEMENT, TUI_TOUCH_SUPPORTED, TUI_WINDOW_HEIGHT, TUI_ZOOM_OPTIONS

// EXTERNAL MODULE: consume shared module (default) @angular/common@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/common/fesm2015/common.js)
var common_js_ = __webpack_require__(3008);
// EXTERNAL MODULE: consume shared module (default) @angular/core@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/core/fesm2015/core.js)
var core_js_ = __webpack_require__(8312);
// EXTERNAL MODULE: ./node_modules/@ng-web-apis/common/fesm2015/ng-web-apis-common.js
var ng_web_apis_common = __webpack_require__(2579);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-observables.js + 1 modules
var taiga_ui_cdk_observables = __webpack_require__(4197);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-dom.js
var taiga_ui_cdk_utils_dom = __webpack_require__(5242);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-os.js
/**
 * @deprecated: use {@link tuiIsApplePlatform} instead
 * @description:
 * All Chrome / Chromium-based browsers will return MacIntel on macOS,
 * no matter what the hardware architecture is. See the source code here:
 * https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/core/frame/navigator_id.cc;l=64;drc=703d3c472cf27470dad21a3f2c8972aca3732cd6
 * But maybe in future years, it will be changed to MacM1
 *
 * Documentation:
 * https://developer.mozilla.org/en-US/docs/Web/API/Navigator/platform
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isApplePlatform(navigator) {
  return navigator.platform.indexOf(`Mac`) === 0 || navigator.platform === `iPhone`;
}
const tuiIsApplePlatform = (/* unused pure expression or super */ null && (isApplePlatform));
const IOS_REG_EXP = /ipad|iphone|ipod/;
/**
 * @deprecated: use {@link tuiIsIos} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isIos(navigator) {
  return IOS_REG_EXP.test(navigator.userAgent.toLowerCase()) || isApplePlatform(navigator) && navigator.maxTouchPoints > 1;
}
const tuiIsIos = (/* unused pure expression or super */ null && (isIos));
const SAFARI_REG_EXP = /^((?!chrome|android).)*safari/i;
/**
 * @deprecated: use {@link tuiIsApple} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isApple(navigator) {
  return isIos(navigator) || SAFARI_REG_EXP.test(navigator.userAgent.toLowerCase());
}
const tuiIsApple = (/* unused pure expression or super */ null && (isApple));

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-utils-os.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/BehaviorSubject.js
var BehaviorSubject = __webpack_require__(6215);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/timer.js + 1 modules
var timer = __webpack_require__(8634);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/merge.js
var merge = __webpack_require__(6682);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/of.js
var of = __webpack_require__(5917);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/switchMap.js
var switchMap = __webpack_require__(3190);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/mapTo.js
var mapTo = __webpack_require__(6736);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/startWith.js
var startWith = __webpack_require__(9761);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/share.js + 1 modules
var share = __webpack_require__(8819);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/takeUntil.js
var takeUntil = __webpack_require__(6782);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/repeatWhen.js
var repeatWhen = __webpack_require__(2361);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/withLatestFrom.js
var withLatestFrom = __webpack_require__(7057);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/filter.js
var filter = __webpack_require__(5435);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js
var map = __webpack_require__(8002);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/take.js
var take = __webpack_require__(5257);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js
var distinctUntilChanged = __webpack_require__(7519);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/shareReplay.js
var shareReplay = __webpack_require__(7349);
// EXTERNAL MODULE: ./node_modules/@angular/animations/fesm2015/browser.js
var browser = __webpack_require__(9221);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-tokens.js








const TUI_REMOVED_ELEMENT = new core_js_.InjectionToken(`Element currently being removed by AnimationEngine`, {
  factory: () => {
    var _a;
    const stub = {
      onRemovalComplete: () => {}
    };
    const element$ = new BehaviorSubject/* BehaviorSubject */.X(null);
    const engine = (_a = (0,core_js_.inject)(browser/* ɵAnimationEngine */.Th, core_js_.InjectFlags.Optional)) !== null && _a !== void 0 ? _a : stub;
    const {
      onRemovalComplete = stub.onRemovalComplete
    } = engine;
    engine.onRemovalComplete = (element, context) => {
      element$.next(element);
      onRemovalComplete(element, context);
    };
    return element$.pipe((0,switchMap/* switchMap */.w)(element => (0,timer/* timer */.H)(0).pipe((0,mapTo/* mapTo */.h)(null), (0,startWith/* startWith */.O)(element))), (0,share/* share */.B)());
  }
});
const TUI_ACTIVE_ELEMENT = new core_js_.InjectionToken(`Active element on the document for ActiveZone`, {
  factory: () => {
    const removedElement$ = (0,core_js_.inject)(TUI_REMOVED_ELEMENT);
    const windowRef = (0,core_js_.inject)(ng_web_apis_common/* WINDOW */.m9);
    const documentRef = (0,core_js_.inject)(common_js_.DOCUMENT);
    const focusout$ = (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(windowRef, `focusout`);
    const focusin$ = (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(windowRef, `focusin`);
    const blur$ = (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(windowRef, `blur`);
    const mousedown$ = (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(windowRef, `mousedown`);
    const mouseup$ = (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(windowRef, `mouseup`);
    return (0,merge/* merge */.T)(focusout$.pipe(
    // eslint-disable-next-line rxjs/no-unsafe-takeuntil
    (0,takeUntil/* takeUntil */.R)(mousedown$),
    // eslint-disable-next-line rxjs/no-ignored-notifier
    (0,repeatWhen/* repeatWhen */.a)(() => mouseup$), (0,withLatestFrom/* withLatestFrom */.M)(removedElement$), (0,filter/* filter */.h)(([event, removedElement]) => isValidFocusout((0,taiga_ui_cdk_utils_dom/* getActualTarget */.Bq)(event), removedElement)), (0,map/* map */.U)(([{
      relatedTarget
    }]) => relatedTarget)), blur$.pipe((0,map/* map */.U)(() => documentRef.activeElement), (0,filter/* filter */.h)(element => !!element && element.matches(`iframe`))), focusin$.pipe((0,switchMap/* switchMap */.w)(event => {
      const target = (0,taiga_ui_cdk_utils_dom/* getActualTarget */.Bq)(event);
      const root = (0,taiga_ui_cdk_utils_dom/* getDocumentOrShadowRoot */.sy)(target);
      return root === documentRef ? (0,of.of)(target) : shadowRootActiveElement(root).pipe((0,startWith/* startWith */.O)(target));
    })), mousedown$.pipe((0,switchMap/* switchMap */.w)(event => !documentRef.activeElement || documentRef.activeElement === documentRef.body ? (0,of.of)((0,taiga_ui_cdk_utils_dom/* getActualTarget */.Bq)(event)) : focusout$.pipe((0,take/* take */.q)(1), (0,mapTo/* mapTo */.h)((0,taiga_ui_cdk_utils_dom/* getActualTarget */.Bq)(event)), (0,takeUntil/* takeUntil */.R)((0,timer/* timer */.H)(0)))))).pipe((0,distinctUntilChanged/* distinctUntilChanged */.x)(), (0,share/* share */.B)());
  }
});
// Checks if focusout event should be considered leaving active zone
function isValidFocusout(target, removedElement = null) {
  return (
    // Not due to switching tabs/going to DevTools
    (0,taiga_ui_cdk_utils_dom/* getDocumentOrShadowRoot */.sy)(target).activeElement !== target &&
    // Not due to button/input becoming disabled
    !target.disabled &&
    // Not due to element being removed from DOM
    !(removedElement === null || removedElement === void 0 ? void 0 : removedElement.contains(target))
  );
}
function shadowRootActiveElement(root) {
  return (0,merge/* merge */.T)((0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(root, `focusin`).pipe((0,map/* map */.U)(({
    target
  }) => target)), (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(root, `focusout`).pipe((0,filter/* filter */.h)(({
    target,
    relatedTarget
  }) => !!relatedTarget && isValidFocusout(target)), (0,map/* map */.U)(({
    relatedTarget
  }) => relatedTarget)));
}
const TUI_ALERTS = new core_js_.InjectionToken(`A stream of alerts`, {
  factory: () => []
});

// https://github.com/angular/angular/issues/17824#issuecomment-353239017
const TUI_DEFAULT_RENDERER = new core_js_.InjectionToken(`A Renderer2 for global services`, {
  // @ts-ignore
  factory: () => (0,core_js_.inject)(core_js_.RendererFactory2).createRenderer(null, null)
});
const TUI_DIALOGS = new core_js_.InjectionToken(`A stream of dialogs`, {
  factory: () => []
});
const TUI_FOCUSABLE_ITEM_ACCESSOR = new core_js_.InjectionToken(`A component that can be focused`);
const TUI_IS_IOS = new core_js_.InjectionToken(`iOS browser detection`, {
  factory: () => isIos((0,core_js_.inject)(ng_web_apis_common/* NAVIGATOR */.s5))
});

// https://stackoverflow.com/a/11381730/2706426 http://detectmobilebrowsers.com/
const firstRegex = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/;
const secondRegex = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/;
const TUI_IS_MOBILE = new core_js_.InjectionToken(`Mobile browser detection`, {
  factory: () => firstRegex.test((0,core_js_.inject)(ng_web_apis_common/* USER_AGENT */.yZ).toLowerCase()) || secondRegex.test((0,core_js_.inject)(ng_web_apis_common/* USER_AGENT */.yZ).slice(0, 4).toLowerCase())
});
const TUI_IS_ANDROID = new core_js_.InjectionToken(`Mobile browser that is not iOS (technically includes Windows Phone, Blackberry etc.)`, {
  factory: () => (0,core_js_.inject)(TUI_IS_MOBILE) && !(0,core_js_.inject)(TUI_IS_IOS)
});
const TUI_IS_APPLE = new core_js_.InjectionToken(`Apple(safari/webkit) detection`, {
  factory: () => isApple((0,core_js_.inject)(ng_web_apis_common/* NAVIGATOR */.s5))
});
const TUI_IS_CHROMIUM = new core_js_.InjectionToken(`Chromium browser engine detection`, {
  factory: () => !!(0,core_js_.inject)(ng_web_apis_common/* WINDOW */.m9).chrome
});

/**
 * {@link https://docs.cypress.io/faq/questions/using-cypress-faq#Is-there-any-way-to-detect-if-my-app-is-running-under-Cypress Cypress docs}
 */
const TUI_IS_CYPRESS = new core_js_.InjectionToken(`Detect if app is running under Cypress`, {
  factory: () => !!(0,core_js_.inject)(ng_web_apis_common/* WINDOW */.m9).Cypress
});
const TUI_IS_FIREFOX = new core_js_.InjectionToken(`Firefox browser engine detection`, {
  factory: () => {
    var _a;
    return typeof ((_a = (0,core_js_.inject)(ng_web_apis_common/* WINDOW */.m9)) === null || _a === void 0 ? void 0 : _a.mozCancelFullScreen) !== `undefined`;
  }
});
const TUI_IS_WEBKIT = new core_js_.InjectionToken(`Webkit browser engine detection`, {
  factory: () => !!(0,core_js_.inject)(ng_web_apis_common/* WINDOW */.m9).webkitConvertPointFromNodeToPage
});

/* @deprecated export token from @taiga-ui/core package **/
const TUI_SANITIZER = new core_js_.InjectionToken(`A custom Sanitizer to sanitize source before inlining`);
const TUI_SWIPE_OPTIONS = new core_js_.InjectionToken(`Swipe options`, {
  factory: () => ({
    timeout: 500,
    threshold: 30
  })
});

/**
 * @description:
 * The isTrusted read-only property of the Event interface is a boolean value that is true
 * when the event was generated by a user action, and false when the event was created or
 * modified by a script or dispatched via EventTarget.dispatchEvent().
 */
const TUI_TAKE_ONLY_TRUSTED_EVENTS = new core_js_.InjectionToken(`This token need for override behavior the \`pressedObservable\` function`, {
  factory: () => true
});
const TUI_TOUCH_SUPPORTED = new core_js_.InjectionToken(`Touch support detection`, {
  factory: () => (0,core_js_.inject)(ng_web_apis_common/* WINDOW */.m9).matchMedia(`(any-pointer: coarse)`).matches
});
const TUI_WINDOW_HEIGHT = new core_js_.InjectionToken(`Window height accounting for disappearing address bar`, {
  factory: () => {
    const windowRef = (0,core_js_.inject)(ng_web_apis_common/* WINDOW */.m9);
    return (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(windowRef, `resize`).pipe((0,startWith/* startWith */.O)(null), (0,map/* map */.U)(() => windowRef.innerHeight), (0,shareReplay/* shareReplay */.d)({
      bufferSize: 1,
      refCount: true
    }));
  }
});
const TUI_ZOOM_OPTIONS = new core_js_.InjectionToken(`Zoom options`, {
  factory: () => ({
    wheelSensitivity: 0.01
  })
});

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-tokens.js.map

/***/ }),

/***/ 1213:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G6: () => (/* binding */ isSafari),
/* harmony export */   vU: () => (/* binding */ isFirefox),
/* harmony export */   w1: () => (/* binding */ isIE)
/* harmony export */ });
/* unused harmony exports isEdge, isEdgeOlderThan, tuiIsEdge, tuiIsEdgeOlderThan, tuiIsFirefox, tuiIsIE, tuiIsSafari */
/**
 * @deprecated: use {@link tuiIsEdge} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isEdge(userAgent) {
  return userAgent.toLowerCase().includes(`edge`);
}
const tuiIsEdge = (/* unused pure expression or super */ null && (isEdge));
const EDGE = (/* unused pure expression or super */ null && (`edge/`));
/**
 * @deprecated: use {@link tuiIsEdgeOlderThan} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isEdgeOlderThan(version, userAgent) {
  const currentVersion = parseInt(userAgent.slice(userAgent.toLowerCase().indexOf(EDGE) + EDGE.length), 10);
  return currentVersion < version;
}
const tuiIsEdgeOlderThan = (/* unused pure expression or super */ null && (isEdgeOlderThan));

/**
 * @deprecated: use {@link tuiIsFirefox} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isFirefox(userAgent) {
  return userAgent.toLowerCase().includes(`firefox`);
}
const tuiIsFirefox = (/* unused pure expression or super */ null && (isFirefox));

/**
 * @deprecated: use {@link tuiIsIE} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isIE(userAgent) {
  return userAgent.toLowerCase().includes(`trident`);
}
const tuiIsIE = (/* unused pure expression or super */ null && (isIE));

/**
 * @deprecated: use {@link tuiIsSafari} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isSafari({
  ownerDocument: documentRef
}) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const windowRef = documentRef === null || documentRef === void 0 ? void 0 : documentRef.defaultView;
  const isMacOsSafari = typeof windowRef.safari !== `undefined` && ((_b = (_a = windowRef.safari) === null || _a === void 0 ? void 0 : _a.pushNotification) === null || _b === void 0 ? void 0 : _b.toString()) === `[object SafariRemoteNotification]`;
  const isIosSafari = !!((_d = (_c = windowRef.navigator) === null || _c === void 0 ? void 0 : _c.vendor) === null || _d === void 0 ? void 0 : _d.includes(`Apple`)) && !((_f = (_e = windowRef.navigator) === null || _e === void 0 ? void 0 : _e.userAgent) === null || _f === void 0 ? void 0 : _f.includes(`CriOS`)) && !((_h = (_g = windowRef.navigator) === null || _g === void 0 ? void 0 : _g.userAgent) === null || _h === void 0 ? void 0 : _h.includes(`FxiOS`));
  return isMacOsSafari || isIosSafari;
}
const tuiIsSafari = (/* unused pure expression or super */ null && (isSafari));

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-utils-browser.js.map

/***/ }),

/***/ 5242:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bq: () => (/* binding */ getActualTarget),
/* harmony export */   PP: () => (/* binding */ tuiContainsOrAfter),
/* harmony export */   Xr: () => (/* binding */ isCurrentTarget),
/* harmony export */   eE: () => (/* binding */ canScroll),
/* harmony export */   hO: () => (/* binding */ tuiCustomEvent),
/* harmony export */   hh: () => (/* binding */ getElementObscurers),
/* harmony export */   pW: () => (/* binding */ getElementOffset),
/* harmony export */   rP: () => (/* binding */ getScrollParent),
/* harmony export */   sy: () => (/* binding */ getDocumentOrShadowRoot),
/* harmony export */   vV: () => (/* binding */ containsOrAfter),
/* harmony export */   ve: () => (/* binding */ tuiIsElement)
/* harmony export */ });
/* unused harmony exports getClipboardDataText, getClosestElement, isInsideIframe, isNodeIn, tuiCanScroll, tuiGetActualTarget, tuiGetClipboardDataText, tuiGetDocumentOrShadowRoot, tuiGetElementObscures, tuiGetElementOffset, tuiGetScrollParent, tuiGetSelectedText, tuiIsCurrentTarget, tuiIsFormFieldElement, tuiIsInsideIframe, tuiIsNodeIn, tuiPointToClientRect */
/* harmony import */ var _taiga_ui_cdk_utils_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5648);
/* harmony import */ var _taiga_ui_cdk_utils_miscellaneous__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1927);
/* harmony import */ var _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8939);




/**
 * @deprecated: use {@link tuiCanScroll} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function canScroll(element, rootElement, vertical, scrollEnd) {
  return vertical ? canScrollVertical(element, rootElement, scrollEnd) : canScrollHorizontal(element, rootElement, scrollEnd);
}
const tuiCanScroll = (/* unused pure expression or super */ null && (canScroll));
function canScrollVertical(element, rootElement, scrollEnd) {
  let currentElement = element;
  while (currentElement !== rootElement.parentElement) {
    if (Math.floor(currentElement.scrollTop) > 0 && !scrollEnd || Math.ceil(currentElement.scrollTop + currentElement.clientHeight) < currentElement.scrollHeight && scrollEnd) {
      return true;
    }
    if (currentElement.parentElement) {
      currentElement = currentElement.parentElement;
    } else {
      return false;
    }
  }
  return false;
}
function canScrollHorizontal(element, rootElement, scrollEnd) {
  let currentElement = element;
  while (currentElement !== rootElement.parentElement) {
    if (Math.floor(currentElement.scrollLeft) > 0 && !scrollEnd || Math.ceil(currentElement.scrollLeft + currentElement.clientWidth) < currentElement.scrollWidth && scrollEnd) {
      return true;
    }
    if (currentElement.parentElement) {
      currentElement = currentElement.parentElement;
    } else {
      return false;
    }
  }
  return false;
}

/**
 * @deprecated: use {@link tuiContainsOrAfter} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function containsOrAfter(current, node) {
  return current.contains(node) || !!(node.compareDocumentPosition(current) & Node.DOCUMENT_POSITION_PRECEDING);
}
const tuiContainsOrAfter = containsOrAfter;

/** @deprecated only needed for IE, remove in 3.0 */
function tuiCustomEvent(name, {
  bubbles = false,
  cancelable = false,
  detail = null
} = {}, documentRef) {
  if (typeof CustomEvent === `function`) {
    return new CustomEvent(name, {
      bubbles,
      cancelable,
      detail
    });
  }
  const customEvent = documentRef.createEvent(`CustomEvent`);
  customEvent.initCustomEvent(name, bubbles, cancelable, detail);
  return customEvent;
}

/**
 * @deprecated: use {@link tuiGetActualTarget} instead
 * Gets actual target from open Shadow DOM if event happened within it
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getActualTarget(event) {
  if (`composedPath` in event) {
    return event.composedPath()[0];
  }
  return event.target;
}
const tuiGetActualTarget = (/* unused pure expression or super */ null && (getActualTarget));
const DEFAULT_FORMAT = (/* unused pure expression or super */ null && (`text/plain`));
/**
 * @deprecated: use {@link tuiGetClipboardDataText} instead
 * Gets text from data of clipboardEvent, it also works in IE and Edge browsers
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getClipboardDataText(event, format = DEFAULT_FORMAT) {
  return `clipboardData` in event && event.clipboardData !== null ? event.clipboardData.getData(format) || event.clipboardData.getData(DEFAULT_FORMAT) : event.target.ownerDocument.defaultView.clipboardData.getData(`text`);
}
const tuiGetClipboardDataText = (/* unused pure expression or super */ null && (getClipboardDataText));

/**
 * @deprecated only needed for IE, remove in 3.0
 * Gets the closest element by selector i.e. {@link Element.closest}
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getClosestElement(element, selector) {
  const closest = Element.prototype.closest;
  if (closest) {
    return closest.call(element, selector);
  }
  const matchesSelector = Element.prototype.matches || Element.prototype.msMatchesSelector;
  do {
    if (matchesSelector.call(element, selector)) {
      return element;
    }
    element = element.parentElement;
  } while (element !== null);
  return null;
}

/**
 * @deprecated: use {@link tuiGetDocumentOrShadowRoot} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getDocumentOrShadowRoot(node) {
  return `getRootNode` in node && node.isConnected ? node.getRootNode() : node.ownerDocument;
}
const tuiGetDocumentOrShadowRoot = (/* unused pure expression or super */ null && (getDocumentOrShadowRoot));

/**
 * @deprecated: use {@link tuiGetElementObscures} instead
 * Returns array of Elements covering edges of given element or null if at least one edge middle point is visible
 *
 * CAUTION: Empty array means element if offscreen i.e. covered by no elements, rather than not covered
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getElementObscurers(element) {
  const {
    ownerDocument
  } = element;
  if (!(ownerDocument === null || ownerDocument === void 0 ? void 0 : ownerDocument.defaultView)) {
    return null;
  }
  const {
    innerWidth,
    innerHeight
  } = ownerDocument.defaultView;
  const documentRef = getDocumentOrShadowRoot(element);
  const rect = element.getBoundingClientRect();
  const left = (0,_taiga_ui_cdk_utils_math__WEBPACK_IMPORTED_MODULE_0__/* .clamp */ .uZ)(Math.round(rect.left) + 2, 0, innerWidth);
  const top = (0,_taiga_ui_cdk_utils_math__WEBPACK_IMPORTED_MODULE_0__/* .clamp */ .uZ)(Math.round(rect.top) + 2, 0, innerHeight);
  const right = (0,_taiga_ui_cdk_utils_math__WEBPACK_IMPORTED_MODULE_0__/* .clamp */ .uZ)(Math.round(rect.right) - 2, 0, innerWidth);
  const bottom = (0,_taiga_ui_cdk_utils_math__WEBPACK_IMPORTED_MODULE_0__/* .clamp */ .uZ)(Math.round(rect.bottom) - 2, 0, innerHeight);
  const horizontalMiddle = (0,_taiga_ui_cdk_utils_math__WEBPACK_IMPORTED_MODULE_0__/* .clamp */ .uZ)(Math.round(rect.left + rect.width / 2), 0, innerWidth);
  const verticalMiddle = (0,_taiga_ui_cdk_utils_math__WEBPACK_IMPORTED_MODULE_0__/* .clamp */ .uZ)(Math.round(rect.top + rect.height / 2), 0, innerHeight);
  const elements = [documentRef.elementFromPoint(horizontalMiddle, top), documentRef.elementFromPoint(horizontalMiddle, bottom), documentRef.elementFromPoint(left, verticalMiddle), documentRef.elementFromPoint(right, verticalMiddle)];
  const nonNull = elements.filter(_taiga_ui_cdk_utils_miscellaneous__WEBPACK_IMPORTED_MODULE_1__/* .isPresent */ .EN);
  if (!nonNull.length) {
    return nonNull;
  }
  const filtered = nonNull.filter(el => !element.contains(el));
  return filtered.length === 4 ? filtered : null;
}
const tuiGetElementObscures = (/* unused pure expression or super */ null && (getElementObscurers));

/**
 * @deprecated: use {@link tuiGetElementOffset} instead
 * Calculates offset for an element relative to it's parent several levels above
 *
 * @param host parent element
 * @param element
 * @return object with offsetTop and offsetLeft number properties
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getElementOffset(host, element) {
  _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_2__/* .tuiAssert */ .zU.assert(host.contains(element), `Host must contain element`);
  let {
    offsetTop,
    offsetLeft,
    offsetParent
  } = element;
  // TODO: iframe warning
  while (offsetParent && offsetParent instanceof HTMLElement && offsetParent !== host) {
    offsetTop += offsetParent.offsetTop;
    offsetLeft += offsetParent.offsetLeft;
    offsetParent = offsetParent.offsetParent;
  }
  return {
    offsetTop,
    offsetLeft
  };
}
const tuiGetElementOffset = (/* unused pure expression or super */ null && (getElementOffset));

/**
 * @deprecated: use {@link tuiGetScrollParent} instead
 * Finds the nearest parent with scroll in it
 *
 * @param element initial element
 * @param vertical flag for orientation of scroll
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getScrollParent(element, vertical = true) {
  if (element === null) {
    return null;
  }
  if (vertical && element.scrollHeight > element.clientHeight) {
    return element;
  }
  if (!vertical && element.scrollWidth > element.clientWidth) {
    return element;
  }
  return getScrollParent(element.parentElement, vertical);
}
const tuiGetScrollParent = (/* unused pure expression or super */ null && (getScrollParent));
function tuiIsFormFieldElement(element) {
  const textfield = element;
  return !!textfield && `value` in textfield && `selectionStart` in textfield && `selectionEnd` in textfield;
}

/**
 * @description:
 * cross browser way to get selected text
 *
 * History:
 * BUG - window.getSelection() fails when text selected in a form field
 * https://bugzilla.mozilla.org/show_bug.cgi?id=85686
 */
function tuiGetSelectedText({
  getSelection,
  document
}) {
  var _a;
  return tuiIsFormFieldElement(document.activeElement) ? document.activeElement.value.slice(document.activeElement.selectionStart || 0, document.activeElement.selectionEnd || 0) : ((_a = getSelection()) === null || _a === void 0 ? void 0 : _a.toString()) || null;
}

/**
 * @deprecated: use {@link tuiIsCurrentTarget} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isCurrentTarget({
  target,
  currentTarget
}) {
  return target === currentTarget;
}
const tuiIsCurrentTarget = (/* unused pure expression or super */ null && (isCurrentTarget));

// TODO: Refactor to use this check everywhere
function tuiIsElement(node) {
  return !!node && `nodeType` in node && node.nodeType === Node.ELEMENT_NODE;
}

/**
 * @deprecated: use {@link tuiIsInsideIframe} instead
 * Checks if an app is running inside <iframe /> tag
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isInsideIframe(windowRef) {
  return windowRef.parent !== windowRef;
}
const tuiIsInsideIframe = (/* unused pure expression or super */ null && (isInsideIframe));

/**
 * @deprecated: use {@link tuiIsNodeIn} instead
 * Checks if node is inside a specific selector
 *
 * @param node
 * @param selector
 * @return true if node is inside a particular selector
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isNodeIn(node, selector) {
  return node.nodeType === Node.TEXT_NODE ? !!node.parentElement && !!getClosestElement(node.parentElement, selector) : node.nodeType === Node.ELEMENT_NODE && !!getClosestElement(node, selector);
}
const tuiIsNodeIn = (/* unused pure expression or super */ null && (isNodeIn));
function tuiPointToClientRect(x = 0, y = 0) {
  return {
    left: x,
    right: x,
    top: y,
    bottom: y,
    width: 0,
    height: 0
  };
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-utils-dom.js.map

/***/ }),

/***/ 7179:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Gi: () => (/* binding */ setNativeMouseFocused),
/* harmony export */   KF: () => (/* binding */ isNativeFocusedIn),
/* harmony export */   NY: () => (/* binding */ setNativeFocused),
/* harmony export */   O9: () => (/* binding */ getClosestKeyboardFocusable),
/* harmony export */   PO: () => (/* binding */ blurNativeFocused),
/* harmony export */   Wb: () => (/* binding */ isNativeKeyboardFocusable),
/* harmony export */   dO: () => (/* binding */ getNativeFocused),
/* harmony export */   kA: () => (/* binding */ getClosestFocusable),
/* harmony export */   pr: () => (/* binding */ moveFocus),
/* harmony export */   zV: () => (/* binding */ isNativeFocused)
/* harmony export */ });
/* unused harmony exports isNativeMouseFocusable, tuiBlurNativeFocused, tuiGetClosestFocusable, tuiGetNativeFocused, tuiIsNativeFocused, tuiIsNativeFocusedIn, tuiIsNativeKeyboardFocusable, tuiIsNativeMouseFocusable, tuiMoveFocus, tuiSetNativeMouseFocused */
/* harmony import */ var _taiga_ui_cdk_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3770);


/**
 * @deprecated: use {@link tuiGetNativeFocused} instead
 * Returns current active element, including shadow dom
 *
 * @return element or null
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getNativeFocused(documentRef) {
  var _a;
  if (!((_a = documentRef.activeElement) === null || _a === void 0 ? void 0 : _a.shadowRoot)) {
    return documentRef.activeElement;
  }
  let element = documentRef.activeElement.shadowRoot.activeElement;
  while (element === null || element === void 0 ? void 0 : element.shadowRoot) {
    element = element.shadowRoot.activeElement;
  }
  return element;
}
const tuiGetNativeFocused = (/* unused pure expression or super */ null && (getNativeFocused));

/**
 * @deprecated: use native element.focus()
 * TODO: remove in v3.0
 * Focuses or blurs and element
 *
 * @param element native element
 * @param focused boolean focused state
 * @param preventScroll optional flag to prevent native scroll to the element
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function setNativeFocused(element, focused = true, preventScroll = false) {
  if (focused) {
    element.focus({
      preventScroll
    });
  } else {
    element.blur();
  }
}

/**
 * @deprecated: use {@link tuiBlurNativeFocused} instead
 * Finds and blurs current active element, including shadow DOM
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function blurNativeFocused(documentRef) {
  const activeElement = getNativeFocused(documentRef);
  // TODO: iframe warning
  if (activeElement instanceof HTMLElement) {
    setNativeFocused(activeElement, false);
  }
}
const tuiBlurNativeFocused = (/* unused pure expression or super */ null && (blurNativeFocused));

/**
 * @deprecated: use {@link tuiIsNativeKeyboardFocusable} instead
 * Checks for signs that element can be focused with keyboard. tabIndex above 0 is ignored to
 * only target natural focus order. Not checking the possibility of an element to
 * be focused, for example element can have display: none applied to it or any other
 * circumstances could prevent actual focus.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isNativeKeyboardFocusable(element) {
  if (element.hasAttribute(`disabled`) || element.getAttribute(`tabIndex`) === `-1`) {
    return false;
  }
  // TODO: iframe warning
  if (element instanceof HTMLElement && element.isContentEditable || element.getAttribute(`tabIndex`) === `0`) {
    return true;
  }
  switch (element.tagName) {
    case `BUTTON`:
    case `SELECT`:
    case `TEXTAREA`:
      return true;
    case `VIDEO`:
    case `AUDIO`:
      return element.hasAttribute(`controls`);
    case `INPUT`:
      return element.getAttribute(`type`) !== `hidden`;
    case `A`:
    case `LINK`:
      return element.hasAttribute(`href`);
    default:
      return false;
  }
}
const tuiIsNativeKeyboardFocusable = (/* unused pure expression or super */ null && (isNativeKeyboardFocusable));

/**
 * @deprecated: use {@link tuiIsNativeMouseFocusable} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isNativeMouseFocusable(element) {
  return !element.hasAttribute(`disabled`) && (element.getAttribute(`tabIndex`) === `-1` || isNativeKeyboardFocusable(element));
}
const tuiIsNativeMouseFocusable = (/* unused pure expression or super */ null && (isNativeMouseFocusable));

/**
 * @deprecated: use {@link tuiGetClosestFocusable} instead
 * Finds the closest element that can be focused with a keyboard or mouse in theory
 *
 * @param initial current HTML element
 * @param prev should it look backwards instead (find item that will be focused with Shift + Tab)
 * @param root top Node limiting the search area
 * @param keyboard determine if only keyboard focus is of interest
 *
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getClosestFocusable(initial, prev = false, root, keyboard = true) {
  if (!root.ownerDocument) {
    return null;
  }
  const check = keyboard ? isNativeKeyboardFocusable : isNativeMouseFocusable;
  // Deprecated but ony this overload works in IE
  // Filter must be a function in IE, other modern browsers are compliant to this format
  const treeWalker = root.ownerDocument.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, _taiga_ui_cdk_constants__WEBPACK_IMPORTED_MODULE_0__/* .svgNodeFilter */ .Lw, false);
  treeWalker.currentNode = initial;
  while (prev ? treeWalker.previousNode() : treeWalker.nextNode()) {
    // TODO: iframe warning
    if (treeWalker.currentNode instanceof HTMLElement) {
      initial = treeWalker.currentNode;
    }
    if (check(initial)) {
      return initial;
    }
  }
  return null;
}
/**
 * @deprecated: use {@link tuiGetClosestFocusable} instead
 */
const getClosestKeyboardFocusable = getClosestFocusable;
const tuiGetClosestFocusable = (/* unused pure expression or super */ null && (getClosestFocusable));

/**
 * @deprecated: use {@link tuiIsNativeFocused} instead
 * Checks if element is focused.
 *
 * Could return true even after blur since element remains focused if you switch away from a browser tab.
 *
 * @param node or null (as a common return value of DOM nodes walking)
 * @return true if focused
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isNativeFocused(node) {
  return !!node && !!node.ownerDocument && getNativeFocused(node.ownerDocument) === node;
}
const tuiIsNativeFocused = (/* unused pure expression or super */ null && (isNativeFocused));

/**
 * @deprecated: use {@link tuiIsNativeFocusedIn} instead
 * Checks if focused element is within given element.
 *
 * @param node
 * @return true if focused node is contained within element
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isNativeFocusedIn(node) {
  // !node.contains - check for IE11
  if (!node.ownerDocument || !node.contains) {
    return false;
  }
  const nativeFocused = getNativeFocused(node.ownerDocument);
  return nativeFocused !== null && node.contains(nativeFocused);
}
const tuiIsNativeFocusedIn = (/* unused pure expression or super */ null && (isNativeFocusedIn));

/**
 * @deprecated: use {@link tuiMoveFocus} instead
 * Utility method for moving focus in a list of elements
 *
 * @param currentIndex currently focused index
 * @param elements array of focusable elements
 * @param step a step to move focus by, typically -1 or 1
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function moveFocus(currentIndex, elements, step) {
  currentIndex += step;
  while (currentIndex >= 0 && currentIndex < elements.length) {
    setNativeFocused(elements[currentIndex]);
    if (isNativeFocused(elements[currentIndex])) {
      return;
    }
    currentIndex += step;
  }
}
const tuiMoveFocus = (/* unused pure expression or super */ null && (moveFocus));

/**
 * @deprecated: use {@link tuiSetNativeMouseFocused} instead
 * Focuses or blurs element with mouse action imitation (to spoof {@link TuiFocusVisibleService})
 *
 * @param element
 * @param focused desired focused state
 * @param preventScroll optionally prevent native browser scroll after focus
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function setNativeMouseFocused(element, focused = true, preventScroll = false) {
  if (!element.ownerDocument) {
    return;
  }
  if (typeof Event === `function`) {
    element.dispatchEvent(new Event(`mousedown`, {
      bubbles: true,
      cancelable: true
    }));
  } else {
    const event = element.ownerDocument.createEvent(`Event`);
    event.initEvent(`mousedown`, true, true);
    element.dispatchEvent(event);
  }
  setNativeFocused(element, focused, preventScroll);
}
const tuiSetNativeMouseFocused = (/* unused pure expression or super */ null && (setNativeMouseFocused));

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-utils-focus.js.map

/***/ }),

/***/ 5648:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Hq: () => (/* binding */ toInt),
/* harmony export */   Ki: () => (/* binding */ tuiClamp),
/* harmony export */   Z2: () => (/* binding */ inRange),
/* harmony export */   uZ: () => (/* binding */ clamp)
/* harmony export */ });
/* unused harmony exports ceil, floor, normalizeToIntNumber, quantize, round, sum, toRadians, tuiCeil, tuiFloor, tuiInRange, tuiNormalizeToIntNumber, tuiQuantize, tuiRound, tuiSum, tuiToInt, tuiToRadians */
/* harmony import */ var _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8939);


/**
 * @deprecated: use {@link tuiClamp} instead
 * Clamps a value between two inclusive limits
 *
 * @param value
 * @param min lower limit
 * @param max upper limit
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function clamp(value, min, max) {
  _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .zU.assert(!Number.isNaN(value));
  _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .zU.assert(!Number.isNaN(min));
  _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .zU.assert(!Number.isNaN(max));
  _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .zU.assert(max >= min);
  return Math.min(max, Math.max(min, value));
}
const tuiClamp = clamp;

/**
 * @deprecated: use {@link tuiInRange} instead
 * Checks if the value is in range
 *
 * @param value
 * @param fromInclude lower inclusive limit
 * @param toExclude upper exclusive limit
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function inRange(value, fromInclude, toExclude) {
  _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .zU.assert(!Number.isNaN(value));
  _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .zU.assert(!Number.isNaN(fromInclude));
  _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .zU.assert(!Number.isNaN(toExclude));
  _taiga_ui_cdk_classes__WEBPACK_IMPORTED_MODULE_0__/* .tuiAssert */ .zU.assert(fromInclude < toExclude);
  return value >= fromInclude && value < toExclude;
}
const tuiInRange = (/* unused pure expression or super */ null && (inRange));

/**
 * @deprecated: use {@link tuiNormalizeToIntNumber} instead
 * Normalizes any number to an integer within inclusive range
 *
 * @param value
 * @param min lower inclusive integer
 * @param max upper inclusive integer
 * @return an integer between min and max inclusive
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function normalizeToIntNumber(value, min, max) {
  tuiAssert.assert(Number.isInteger(min));
  tuiAssert.assert(Number.isInteger(max));
  tuiAssert.assert(min <= max);
  if (Number.isNaN(value) || value <= min) {
    return min;
  }
  if (value >= max) {
    return max;
  }
  return Math.round(value);
}
const tuiNormalizeToIntNumber = (/* unused pure expression or super */ null && (normalizeToIntNumber));

/**
 * @deprecated: use {@link tuiQuantize} instead
 * Rounds a number to the closest value in a fixed discrete series
 *
 * @param value
 * @param quantum series step
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function quantize(value, quantum) {
  tuiAssert.assert(Number.isFinite(value));
  tuiAssert.assert(Number.isFinite(quantum));
  tuiAssert.assert(quantum > 0);
  const remainder = value % quantum;
  return remainder < quantum / 2 ? value - remainder : value + quantum - remainder;
}
const tuiQuantize = (/* unused pure expression or super */ null && (quantize));
const MAX_PRECISION = 292;
/**
 * @deprecated: use {@link tuiRound} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function round(value, precision = 0) {
  return calculate(value, precision, Math.round);
}
/**
 * @deprecated: use {@link tuiCeil} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function ceil(value, precision = 0) {
  return calculate(value, precision, Math.ceil);
}
/**
 * @deprecated: use {@link tuiFloor} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function floor(value, precision = 0) {
  return calculate(value, precision, Math.floor);
}
const tuiRound = (/* unused pure expression or super */ null && (round));
const tuiCeil = (/* unused pure expression or super */ null && (ceil));
const tuiFloor = (/* unused pure expression or super */ null && (floor));
/**
 * Rounding number to the set precision
 *
 * @param value
 * @param precision number of digits in a float part
 * @param func rounding function (round, floor, ceil)
 */
function calculate(value, precision, func) {
  if (value === Infinity) {
    return value;
  }
  tuiAssert.assert(!Number.isNaN(value), `Value must be number`);
  tuiAssert.assert(Number.isInteger(precision), `Precision must be integer`);
  precision = Math.min(precision, MAX_PRECISION);
  const pair = `${value}e`.split(`e`);
  const tempValue = func(Number(`${pair[0]}e${Number(pair[1]) + precision}`));
  const processedPair = `${tempValue}e`.split(`e`);
  return Number(`${processedPair[0]}e${Number(processedPair[1]) - precision}`);
}

/**
 * @deprecated: use {@link tuiSum} instead
 * Calculates sum of any number of passed arguments
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function sum(...args) {
  return args.reduce((a, b) => a + b, 0);
}
const tuiSum = (/* unused pure expression or super */ null && (sum));

/**
 * @deprecated: use {@link tuiToInt} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function toInt(bool) {
  return bool ? 1 : 0;
}
const tuiToInt = (/* unused pure expression or super */ null && (toInt));

/**
 * @deprecated: use {@link tuiToRadians} instead
 * Converts angle in degrees to radians
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function toRadians(deg) {
  return deg * Math.PI / 180;
}
const tuiToRadians = (/* unused pure expression or super */ null && (toRadians));

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-utils-math.js.map

/***/ }),

/***/ 1927:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EN: () => (/* binding */ isPresent),
/* harmony export */   Pc: () => (/* binding */ tuiIsPresent),
/* harmony export */   Yg: () => (/* binding */ getSwipeDirection),
/* harmony export */   ct: () => (/* binding */ getOriginalArrayFromQueryList),
/* harmony export */   hj: () => (/* binding */ isNumber),
/* harmony export */   mN: () => (/* binding */ uniqBy),
/* harmony export */   rT: () => (/* binding */ isElementEditable)
/* harmony export */ });
/* unused harmony exports distanceBetweenTouches, easeInOutQuad, fallbackValue, flatLength, identity, markControlAsTouchedAndValidate, nullableSame, tuiDistanceBetweenTouches, tuiEaseInOutQuad, tuiFlatLength, tuiGetOriginalArrayFromQueryList, tuiGetSwipeDirection, tuiIsElementEditable, tuiIsNumber, tuiMarkControlAsTouchedAndValidate, tuiNullableSame, tuiUniqBy */



/**
 * @deprecated: use {@link tuiDistanceBetweenTouches} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function distanceBetweenTouches({
  touches
}) {
  return Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);
}
const tuiDistanceBetweenTouches = (/* unused pure expression or super */ null && (distanceBetweenTouches));

/**
 * @deprecated: use {@link tuiEaseInOutQuad} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function easeInOutQuad(t) {
  tuiAssert.assert(t >= 0 && t <= 1, `Input must be between 0 and 1 inclusive but received `, t);
  return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
}
const tuiEaseInOutQuad = (/* unused pure expression or super */ null && (easeInOutQuad));

/**
 * @deprecated: use {@link tuiIsPresent} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isPresent(value) {
  return value !== null && value !== undefined;
}
const tuiIsPresent = isPresent;

/**
 * @deprecated use nullish coalescing operator
 * If the value is null or undefined, returns default value
 * @param value
 * @param fallback alternative fallback
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function fallbackValue(value, fallback) {
  return isPresent(value) ? value : fallback;
}

/**
 * @deprecated: use {@link tuiFlatLength} instead
 * Flattens two-dimensional array and calculates resulting length
 *
 * @param array twi dimensional array
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function flatLength(array) {
  return array.reduce((count, section) => count + section.length, 0);
}
const tuiFlatLength = (/* unused pure expression or super */ null && (flatLength));

/**
 * @deprecated: use {@link tuiGetOriginalArrayFromQueryList} instead
 * Extracts original array from {@link QueryList} rather than
 * creating a copy like {@link QueryList.toArray} does.
 * @param queryList
 * @returns original array from {@link QueryList}.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getOriginalArrayFromQueryList(queryList) {
  let array = [];
  queryList.find((_item, _index, originalArray) => {
    array = originalArray;
    return true;
  });
  return array;
}
const tuiGetOriginalArrayFromQueryList = (/* unused pure expression or super */ null && (getOriginalArrayFromQueryList));

/**
 * @deprecated: use {@link tuiGetSwipeDirection} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getSwipeDirection(deltaX, deltaY) {
  if (Math.abs(deltaY) > Math.abs(deltaX)) {
    return deltaY > 0 ? `top` : `bottom`;
  }
  return deltaX > 0 ? `left` : `right`;
}
const tuiGetSwipeDirection = (/* unused pure expression or super */ null && (getSwipeDirection));

/**
 * @deprecated: use identity from rxjs
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function identity(item) {
  return item;
}

/**
 * @deprecated: use {@link tuiIsElementEditable} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isElementEditable(element) {
  // TODO: iframe warning
  return element instanceof HTMLInputElement && !element.readOnly || element instanceof HTMLTextAreaElement && !element.readOnly || element.isContentEditable;
}
const tuiIsElementEditable = (/* unused pure expression or super */ null && (isElementEditable));

/**
 * @deprecated: use {@link tuiIsNumber} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isNumber(value) {
  return typeof value === `number`;
}
const tuiIsNumber = (/* unused pure expression or super */ null && (isNumber));

/**
 * @deprecated: use {@link tuiMarkControlAsTouchedAndValidate} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function markControlAsTouchedAndValidate(control) {
  if (control instanceof FormArray) {
    control.controls.forEach(nestedControl => {
      markControlAsTouchedAndValidate(nestedControl);
    });
  }
  if (control instanceof FormGroup) {
    Object.values(control.controls).forEach(nestedControl => {
      markControlAsTouchedAndValidate(nestedControl);
    });
  }
  control.markAsTouched();
  control.updateValueAndValidity();
}
const tuiMarkControlAsTouchedAndValidate = (/* unused pure expression or super */ null && (markControlAsTouchedAndValidate));

/**
 * @deprecated: use {@link tuiNullableSame} instead
 * Checks identity for nullable elements.
 *
 * @param a element a
 * @param b element b
 * @param handler called if both elements are not null
 * @return true if either both are null or they pass identity handler
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function nullableSame(a, b, handler) {
  if (a === null) {
    return b === null;
  }
  if (b === null) {
    return false;
  }
  return handler(a, b);
}
const tuiNullableSame = (/* unused pure expression or super */ null && (nullableSame));

/**
 * @deprecated: use {@link tuiUniqBy} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function uniqBy(array, key) {
  return Array.from(array.reduce((map, item) => map.has(item[key]) ? map : map.set(item[key], item), new Map()).values());
}
const tuiUniqBy = (/* unused pure expression or super */ null && (uniqBy));

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-utils-miscellaneous.js.map

/***/ }),

/***/ 2628:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fN: () => (/* binding */ TuiButtonModule),
/* harmony export */   v0: () => (/* binding */ TuiButtonComponent)
/* harmony export */ });
/* unused harmony exports TUI_BUTTON_DEFAULT_OPTIONS, TUI_BUTTON_OPTIONS, tuiButtonOptionsProvider */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(7582);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6480);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(4197);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(7179);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(3503);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(3034);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(4358);
/* harmony import */ var _taiga_ui_core_directives__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(5452);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9193);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(8891);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9761);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8002);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7519);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(6782);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3008);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _taiga_ui_core_components_loader__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(719);
/* harmony import */ var _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(4789);
/* harmony import */ var _taiga_ui_core_directives_wrapper__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(1489);
/* harmony import */ var _tinkoff_ng_polymorpheus__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(9570);




















const _c0 = ["tuiButton", ""];
function TuiButtonComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainer"](0);
  }
}
function TuiButtonComponent_span_4_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "tui-svg", 7);
  }
  if (rf & 2) {
    const icon_r5 = ctx.$implicit;
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("src", icon_r5);
  }
}
function TuiButtonComponent_span_4_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "span", 6);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, TuiButtonComponent_span_4_ng_template_1_Template, 1, 1, "ng-template");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("content", ctx_r1.icon);
  }
}
function TuiButtonComponent_span_6_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "tui-svg", 7);
  }
  if (rf & 2) {
    const icon_r7 = ctx.$implicit;
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("src", icon_r7);
  }
}
function TuiButtonComponent_span_6_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "span", 8);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, TuiButtonComponent_span_6_ng_template_1_Template, 1, 1, "ng-template");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("content", ctx_r2.iconRight);
  }
}
function TuiButtonComponent_tui_loader_7_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "tui-loader", 9);
  }
  if (rf & 2) {
    const ctx_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("size", ctx_r3.loaderSize)("inheritColor", true);
  }
}
const _c1 = ["*"];
const TUI_BUTTON_DEFAULT_OPTIONS = {
  size: `l`,
  shape: null,
  appearance: "primary" /* Primary */
};

const TUI_BUTTON_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(`Default parameters for button component`, {
  factory: () => TUI_BUTTON_DEFAULT_OPTIONS
});
const tuiButtonOptionsProvider = options => ({
  provide: TUI_BUTTON_OPTIONS,
  useValue: Object.assign(Object.assign({}, TUI_BUTTON_DEFAULT_OPTIONS), options)
});
var TuiButtonComponent_1;
let TuiButtonComponent = TuiButtonComponent_1 = class TuiButtonComponent extends _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_2__/* .AbstractTuiInteractive */ .Xn {
  constructor(mode, elementRef, focusVisible$, hoveredService, destroy$, changeDetectorRef, takeOnlyTrustedEvents, options) {
    var _a;
    super();
    this.mode = mode;
    this.elementRef = elementRef;
    this.takeOnlyTrustedEvents = takeOnlyTrustedEvents;
    this.options = options;
    this.mode$ = ((_a = this.mode) === null || _a === void 0 ? void 0 : _a.change$) || rxjs__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY */ .E;
    this.appearance = null;
    this.disabled = false;
    this.icon = '';
    this.iconRight = '';
    this.shape = this.options.shape;
    this.showLoader = false;
    this.size = this.options.size;
    this.appearance$ = this.mode$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__/* .startWith */ .O)(null), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__/* .map */ .U)(() => this.computedAppearance), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__/* .distinctUntilChanged */ .x)());
    hoveredService.createHovered$(elementRef.nativeElement).pipe((0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__/* .watch */ .YP)(changeDetectorRef), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__/* .takeUntil */ .R)(destroy$)).subscribe(hovered => {
      this.updateHovered(hovered);
    });
    (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__/* .pressedObservable */ ._d)(elementRef.nativeElement, {
      onlyTrusted: this.takeOnlyTrustedEvents
    }).pipe((0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__/* .watch */ .YP)(changeDetectorRef), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__/* .takeUntil */ .R)(destroy$)).subscribe(pressed => {
      this.updatePressed(pressed);
    });
    focusVisible$.subscribe(focusVisible => {
      this.updateFocusVisible(focusVisible);
    });
  }
  get nativeFocusableElement() {
    return this.nativeDisabled ? null : this.elementRef.nativeElement;
  }
  get focused() {
    return !this.showLoader && (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_9__/* .isNativeFocused */ .zV)(this.elementRef.nativeElement);
  }
  get loaderSize() {
    return this.size === 'l' || this.size === 'xl' ? 'm' : 's';
  }
  get computedAppearance() {
    var _a;
    return (_a = this.appearance) !== null && _a !== void 0 ? _a : this.options.appearance || '';
  }
  get nativeDisabled() {
    return this.computedDisabled || this.showLoader ? '' : null;
  }
  get tabIndex() {
    return this.focusable ? 0 : -1;
  }
  onFocused(focused) {
    this.updateFocused(focused);
  }
};
TuiButtonComponent.ɵfac = function TuiButtonComponent_Factory(t) {
  return new (t || TuiButtonComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_taiga_ui_core_directives__WEBPACK_IMPORTED_MODULE_10__/* .TuiModeDirective */ .w, 8), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_11__/* .TuiFocusVisibleService */ .ku), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_11__/* .TuiHoveredService */ .gs), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_11__/* .TuiDestroyService */ .a3), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_12__/* .TUI_TAKE_ONLY_TRUSTED_EVENTS */ .wx), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](TUI_BUTTON_OPTIONS));
};
TuiButtonComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
  type: TuiButtonComponent,
  selectors: [["button", "tuiButton", ""], ["button", "tuiIconButton", ""], ["a", "tuiButton", ""], ["a", "tuiIconButton", ""]],
  hostVars: 7,
  hostBindings: function TuiButtonComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("focusin", function TuiButtonComponent_focusin_HostBindingHandler() {
        return ctx.onFocused(true);
      })("focusout", function TuiButtonComponent_focusout_HostBindingHandler() {
        return ctx.onFocused(false);
      });
    }
    if (rf & 2) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵhostProperty"]("tabIndex", ctx.tabIndex);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("data-shape", ctx.shape)("data-size", ctx.size)("data-appearance", ctx.computedAppearance)("disabled", ctx.nativeDisabled);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("_loading", ctx.showLoader);
    }
  },
  inputs: {
    appearance: "appearance",
    disabled: "disabled",
    icon: "icon",
    iconRight: "iconRight",
    shape: "shape",
    showLoader: "showLoader",
    size: "size"
  },
  features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
    provide: _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_12__/* .TUI_FOCUSABLE_ITEM_ACCESSOR */ .KZ,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => TuiButtonComponent_1)
  }, _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_11__/* .TuiDestroyService */ .a3, _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_11__/* .TuiFocusVisibleService */ .ku]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]],
  attrs: _c0,
  ngContentSelectors: _c1,
  decls: 8,
  vars: 11,
  consts: [[4, "ngIf"], [1, "t-wrapper", 3, "appearance", "hovered", "pressed", "disabled", "focused"], [1, "t-content"], ["polymorpheus-outlet", "", "class", "t-left", 3, "content", 4, "ngIf"], ["polymorpheus-outlet", "", "class", "t-right", 3, "content", 4, "ngIf"], ["class", "t-loader", 3, "size", "inheritColor", 4, "ngIf"], ["polymorpheus-outlet", "", 1, "t-left", 3, "content"], [1, "t-icon", 3, "src"], ["polymorpheus-outlet", "", 1, "t-right", 3, "content"], [1, "t-loader", 3, "size", "inheritColor"]],
  template: function TuiButtonComponent_Template(rf, ctx) {
    if (rf & 1) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, TuiButtonComponent_ng_container_0_Template, 1, 0, "ng-container", 0);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpipe"](1, "async");
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "tui-wrapper", 1);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](3, "span", 2);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](4, TuiButtonComponent_span_4_Template, 2, 1, "span", 3);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](5);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](6, TuiButtonComponent_span_6_Template, 2, 1, "span", 4);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](7, TuiButtonComponent_tui_loader_7_Template, 1, 2, "tui-loader", 5);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
    }
    if (rf & 2) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpipeBind1"](1, 9, ctx.appearance$));
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("appearance", ctx.computedAppearance)("hovered", ctx.computedHovered)("pressed", ctx.computedPressed)("disabled", ctx.computedDisabled)("focused", ctx.computedFocusVisible);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.icon);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.iconRight);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.showLoader);
    }
  },
  directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, _taiga_ui_core_directives_wrapper__WEBPACK_IMPORTED_MODULE_13__/* .TuiWrapperDirective */ .o, _tinkoff_ng_polymorpheus__WEBPACK_IMPORTED_MODULE_14__/* .PolymorpheusOutletComponent */ .r1, _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_15__/* .TuiSvgComponent */ .P, _taiga_ui_core_components_loader__WEBPACK_IMPORTED_MODULE_16__/* .TuiLoaderComponent */ .kM],
  pipes: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.AsyncPipe],
  styles: ["[_nghost-%COMP%]{-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:0;border:0;background:0 0;font-size:inherit;line-height:inherit;font:var(--tui-font-text-s);color:var(--tui-text-01);position:relative;display:inline-block;flex-shrink:0;vertical-align:top;border-radius:var(--tui-radius-m);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;text-decoration:none;outline:0;color:inherit}[disabled][_nghost-%COMP%]{pointer-events:none}[tuiIconButton][_nghost-%COMP%]   .t-left[_ngcontent-%COMP%], [tuiIconButton][_nghost-%COMP%]   .t-right[_ngcontent-%COMP%]{margin:0}[data-shape=rounded][_nghost-%COMP%]{border-radius:6.25rem}[data-size=xs][_nghost-%COMP%]{height:var(--tui-height-xs);font-weight:400}[data-size=xs][data-shape=square][_nghost-%COMP%], [data-size=xs][tuiIconButton][_nghost-%COMP%]{height:var(--tui-height-xs);width:var(--tui-height-xs)}[data-size='s'][_nghost-%COMP%]{height:var(--tui-height-s);font-weight:400}[data-size='s'][data-shape=square][_nghost-%COMP%], [data-size='s'][tuiIconButton][_nghost-%COMP%]{height:var(--tui-height-s);width:var(--tui-height-s)}[data-size='m'][_nghost-%COMP%]{height:var(--tui-height-m);font:var(--tui-font-text-m);font-weight:700}[data-size='m'][data-shape=square][_nghost-%COMP%], [data-size='m'][tuiIconButton][_nghost-%COMP%]{height:var(--tui-height-m);width:var(--tui-height-m)}[data-size='l'][_nghost-%COMP%]{height:var(--tui-height-l);font:var(--tui-font-text-m);font-weight:700}[data-size='l'][data-shape=square][_nghost-%COMP%], [data-size='l'][tuiIconButton][_nghost-%COMP%]{height:var(--tui-height-l);width:var(--tui-height-l)}[data-size=xl][_nghost-%COMP%]{height:3.75rem;font:var(--tui-font-text-m);font-weight:700}[data-size=xl][data-shape=square][_nghost-%COMP%], [data-size=xl][tuiIconButton][_nghost-%COMP%]{height:3.75rem;width:3.75rem}.t-loader[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%;cursor:default}.t-left[_ngcontent-%COMP%]{margin:0 .5rem 0 -.25rem}.t-right[_ngcontent-%COMP%]{margin:0 -.5rem 0 .25rem}.t-icon[_ngcontent-%COMP%]{display:block}[data-size='s'][_nghost-%COMP%]   .t-icon[_ngcontent-%COMP%], [data-size=xs][_nghost-%COMP%]   .t-icon[_ngcontent-%COMP%]{width:1rem;height:1rem}[tuiIconButton][_nghost-%COMP%]   .t-icon[_ngcontent-%COMP%], [tuiIconButton][_nghost-%COMP%]   .t-left[_ngcontent-%COMP%], [tuiIconButton][_nghost-%COMP%]   .t-right[_ngcontent-%COMP%]{display:flex;width:100%;height:100%;align-items:center;justify-content:center}.t-wrapper[_ngcontent-%COMP%]{position:relative;z-index:0;box-sizing:border-box;cursor:pointer}[data-size=xs][_nghost-%COMP%]   .t-wrapper[_ngcontent-%COMP%]{padding:0 .5rem}[data-size='s'][_nghost-%COMP%]   .t-wrapper[_ngcontent-%COMP%]{padding:0 .75rem}[data-size='m'][_nghost-%COMP%]   .t-wrapper[_ngcontent-%COMP%]{padding:0 1.5rem}[data-size='l'][_nghost-%COMP%]   .t-wrapper[_ngcontent-%COMP%]{padding:0 2.25rem}[data-size=xl][_nghost-%COMP%]   .t-wrapper[_ngcontent-%COMP%]{padding:0 2.5rem}[data-shape=square][_nghost-%COMP%]   .t-wrapper[_ngcontent-%COMP%], [tuiIconButton][_nghost-%COMP%]   .t-wrapper[_ngcontent-%COMP%]{padding:0}.t-content[_ngcontent-%COMP%]{display:flex;height:100%;align-items:center;justify-content:center;text-align:center}._loading[_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{opacity:0}"],
  changeDetection: 0
});
TuiButtonComponent.ctorParameters = () => [{
  type: _taiga_ui_core_directives__WEBPACK_IMPORTED_MODULE_10__/* .TuiModeDirective */ .w,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
  }, {
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [_taiga_ui_core_directives__WEBPACK_IMPORTED_MODULE_10__/* .TuiModeDirective */ .w]
  }]
}, {
  type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef]
  }]
}, {
  type: _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_11__/* .TuiFocusVisibleService */ .ku,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_11__/* .TuiFocusVisibleService */ .ku]
  }]
}, {
  type: _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_11__/* .TuiHoveredService */ .gs,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_11__/* .TuiHoveredService */ .gs]
  }]
}, {
  type: rxjs__WEBPACK_IMPORTED_MODULE_17__/* .Observable */ .y,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_11__/* .TuiDestroyService */ .a3]
  }]
}, {
  type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef]
  }]
}, {
  type: Boolean,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_12__/* .TUI_TAKE_ONLY_TRUSTED_EVENTS */ .wx]
  }]
}, {
  type: undefined,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [TUI_BUTTON_OPTIONS]
  }]
}];
(0,tslib__WEBPACK_IMPORTED_MODULE_18__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_19__/* .tuiDefaultProp */ .TH)()], TuiButtonComponent.prototype, "appearance", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_18__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_19__/* .tuiDefaultProp */ .TH)()], TuiButtonComponent.prototype, "disabled", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_18__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_19__/* .tuiDefaultProp */ .TH)()], TuiButtonComponent.prototype, "icon", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_18__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_19__/* .tuiDefaultProp */ .TH)()], TuiButtonComponent.prototype, "iconRight", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_18__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('attr.data-shape'), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_19__/* .tuiDefaultProp */ .TH)()], TuiButtonComponent.prototype, "shape", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_18__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._loading'), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_19__/* .tuiDefaultProp */ .TH)()], TuiButtonComponent.prototype, "showLoader", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_18__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('attr.data-size'), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_19__/* .tuiDefaultProp */ .TH)()], TuiButtonComponent.prototype, "size", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_18__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('attr.data-appearance')], TuiButtonComponent.prototype, "computedAppearance", null);
(0,tslib__WEBPACK_IMPORTED_MODULE_18__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('attr.disabled')], TuiButtonComponent.prototype, "nativeDisabled", null);
(0,tslib__WEBPACK_IMPORTED_MODULE_18__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('tabIndex')], TuiButtonComponent.prototype, "tabIndex", null);
(0,tslib__WEBPACK_IMPORTED_MODULE_18__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener)('focusin', ['true']), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener)('focusout', ['false'])], TuiButtonComponent.prototype, "onFocused", null);
TuiButtonComponent = TuiButtonComponent_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_18__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_18__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional)()), (0,tslib__WEBPACK_IMPORTED_MODULE_18__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_core_directives__WEBPACK_IMPORTED_MODULE_10__/* .TuiModeDirective */ .w)), (0,tslib__WEBPACK_IMPORTED_MODULE_18__/* .__param */ .fM)(1, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef)), (0,tslib__WEBPACK_IMPORTED_MODULE_18__/* .__param */ .fM)(2, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_11__/* .TuiFocusVisibleService */ .ku)), (0,tslib__WEBPACK_IMPORTED_MODULE_18__/* .__param */ .fM)(3, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_11__/* .TuiHoveredService */ .gs)), (0,tslib__WEBPACK_IMPORTED_MODULE_18__/* .__param */ .fM)(4, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_11__/* .TuiDestroyService */ .a3)), (0,tslib__WEBPACK_IMPORTED_MODULE_18__/* .__param */ .fM)(5, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef)), (0,tslib__WEBPACK_IMPORTED_MODULE_18__/* .__param */ .fM)(6, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_12__/* .TUI_TAKE_ONLY_TRUSTED_EVENTS */ .wx)), (0,tslib__WEBPACK_IMPORTED_MODULE_18__/* .__param */ .fM)(7, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(TUI_BUTTON_OPTIONS))], TuiButtonComponent);
let TuiButtonModule = /*#__PURE__*/(() => {
  let TuiButtonModule = class TuiButtonModule {};
  TuiButtonModule.ɵfac = function TuiButtonModule_Factory(t) {
    return new (t || TuiButtonModule)();
  };
  TuiButtonModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
    type: TuiButtonModule
  });
  TuiButtonModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
    imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule, _tinkoff_ng_polymorpheus__WEBPACK_IMPORTED_MODULE_14__/* .PolymorpheusModule */ .wq, _taiga_ui_core_directives_wrapper__WEBPACK_IMPORTED_MODULE_13__/* .TuiWrapperModule */ .W, _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_15__/* .TuiSvgModule */ .E, _taiga_ui_core_components_loader__WEBPACK_IMPORTED_MODULE_16__/* .TuiLoaderModule */ .dS]]
  });
  return TuiButtonModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](TuiButtonModule, {
    declarations: function () {
      return [TuiButtonComponent];
    },
    imports: function () {
      return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule, _tinkoff_ng_polymorpheus__WEBPACK_IMPORTED_MODULE_14__/* .PolymorpheusModule */ .wq, _taiga_ui_core_directives_wrapper__WEBPACK_IMPORTED_MODULE_13__/* .TuiWrapperModule */ .W, _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_15__/* .TuiSvgModule */ .E, _taiga_ui_core_components_loader__WEBPACK_IMPORTED_MODULE_16__/* .TuiLoaderModule */ .dS];
    },
    exports: function () {
      return [TuiButtonComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-button.js.map

/***/ }),

/***/ 2847:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   V: () => (/* binding */ TuiLinkComponent),
/* harmony export */   j: () => (/* binding */ TuiLinkModule)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(7582);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4197);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7179);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(3503);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(3034);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(4358);
/* harmony import */ var _taiga_ui_core_providers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(2130);
/* harmony import */ var _taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(865);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6682);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(8891);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6736);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3008);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(4789);














const _c0 = ["tuiLink", ""];
function TuiLinkComponent_tui_svg_0_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "tui-svg", 3);
  }
  if (rf & 2) {
    const ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("src", ctx_r0.icon || "");
  }
}
function TuiLinkComponent_tui_svg_3_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "tui-svg", 4);
  }
  if (rf & 2) {
    const ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("src", ctx_r1.icon || "");
  }
}
const _c1 = ["*"];
var TuiLinkComponent_1;
// @bad TODO: Think about extending Interactive
let TuiLinkComponent = TuiLinkComponent_1 = class TuiLinkComponent {
  constructor(elementRef, mode$, focusVisible$) {
    this.elementRef = elementRef;
    this.mode$ = mode$;
    this.pseudo = false;
    // TODO: 3.0 Remove `null`
    this.icon = null;
    this.iconAlign = 'right';
    this.iconRotated = false;
    this.mode = null;
    this.focusVisible = false;
    this.focusedChange = (0,rxjs__WEBPACK_IMPORTED_MODULE_2__/* .merge */ .T)((0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_3__/* .typedFromEvent */ .eh)(this.elementRef.nativeElement, 'focusin').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__/* .mapTo */ .h)(true)), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_3__/* .typedFromEvent */ .eh)(this.elementRef.nativeElement, 'focusout').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__/* .mapTo */ .h)(false)));
    focusVisible$.subscribe(visible => {
      this.focusVisible = visible;
    });
  }
  get nativeFocusableElement() {
    return this.elementRef.nativeElement;
  }
  get focused() {
    return (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_5__/* .isNativeFocused */ .zV)(this.nativeFocusableElement);
  }
  get hasIcon() {
    return this.icon !== null;
  }
  get iconAlignLeft() {
    return this.hasIcon && this.iconAlign === 'left';
  }
  get iconAlignRight() {
    return this.hasIcon && this.iconAlign === 'right';
  }
};
TuiLinkComponent.ɵfac = function TuiLinkComponent_Factory(t) {
  return new (t || TuiLinkComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_6__/* .TUI_MODE */ .Au), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__/* .TuiFocusVisibleService */ .ku));
};
TuiLinkComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
  type: TuiLinkComponent,
  selectors: [["a", "tuiLink", ""], ["button", "tuiLink", ""]],
  hostVars: 7,
  hostBindings: function TuiLinkComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("$.data-mode.attr", function TuiLinkComponent___data_mode_attr_HostBindingHandler() {
        return ctx.mode$;
      });
    }
    if (rf & 2) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("data-host-mode", ctx.mode);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("_pseudo", ctx.pseudo)("_icon-rotated", ctx.iconRotated)("_focus-visible", ctx.focusVisible);
    }
  },
  inputs: {
    pseudo: "pseudo",
    icon: "icon",
    iconAlign: "iconAlign",
    iconRotated: "iconRotated",
    mode: "mode"
  },
  exportAs: ["tuiLink"],
  features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
    provide: _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_8__/* .TUI_FOCUSABLE_ITEM_ACCESSOR */ .KZ,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => TuiLinkComponent_1)
  }, _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__/* .TuiFocusVisibleService */ .ku, _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__/* .TuiDestroyService */ .a3, _taiga_ui_core_providers__WEBPACK_IMPORTED_MODULE_9__/* .MODE_PROVIDER */ .CV])],
  attrs: _c0,
  ngContentSelectors: _c1,
  decls: 4,
  vars: 2,
  consts: [["class", "t-icon t-icon_left", 3, "src", 4, "ngIf"], [1, "t-content"], ["class", "t-icon t-icon_right", 3, "src", 4, "ngIf"], [1, "t-icon", "t-icon_left", 3, "src"], [1, "t-icon", "t-icon_right", 3, "src"]],
  template: function TuiLinkComponent_Template(rf, ctx) {
    if (rf & 1) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, TuiLinkComponent_tui_svg_0_Template, 1, 1, "tui-svg", 0);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "span", 1);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](2);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, TuiLinkComponent_tui_svg_3_Template, 1, 1, "tui-svg", 2);
    }
    if (rf & 2) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.iconAlignLeft);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](3);
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.iconAlignRight);
    }
  },
  directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_10__/* .TuiSvgComponent */ .P],
  styles: ["[_nghost-%COMP%]{-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:0;border:0;background:0 0;font-size:inherit;line-height:inherit;transition-property:color;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;color:var(--tui-link);text-decoration:none;text-align:left;text-transform:inherit;font-weight:inherit;cursor:pointer;outline:0}[_nghost-%COMP%]:hover{color:var(--tui-link-hover)}[_nghost-%COMP%]:disabled{opacity:var(--tui-disabled-opacity);cursor:default}[data-mode=onLight][_nghost-%COMP%]{color:var(--tui-text-02)}[data-mode=onLight]._active[_nghost-%COMP%], [data-mode=onLight][_nghost-%COMP%]:hover{color:var(--tui-text-01)}[data-mode=onLight]._pseudo[_nghost-%COMP%]{color:var(--tui-text-01)}[data-mode=onLight]._pseudo[_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{-webkit-text-decoration-color:rgba(0,0,0,.48);text-decoration-color:rgba(0,0,0,.48)}[data-mode=onLight]._pseudo._active[_nghost-%COMP%], [data-mode=onLight]._pseudo[_nghost-%COMP%]:hover{color:var(--tui-text-03)}[data-mode=onLight][data-host-mode=negative][_nghost-%COMP%]{color:var(--tui-negative-night)}[data-mode=onLight][data-host-mode=negative]._active[_nghost-%COMP%], [data-mode=onLight][data-host-mode=negative][_nghost-%COMP%]:active, [data-mode=onLight][data-host-mode=negative][_nghost-%COMP%]:hover{color:var(--tui-negative-night-hover)}[data-mode=onDark][_nghost-%COMP%]{color:var(--tui-text-03-night)}[data-mode=onDark]._active[_nghost-%COMP%], [data-mode=onDark][_nghost-%COMP%]:active, [data-mode=onDark][_nghost-%COMP%]:hover{color:var(--tui-text-01-night)}[data-mode=onDark]._pseudo[_nghost-%COMP%]{color:var(--tui-text-01-night)}[data-mode=onDark]._pseudo[_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{-webkit-text-decoration-color:rgba(255,255,255,.48);text-decoration-color:rgba(255,255,255,.48)}[data-mode=onDark]._pseudo._active[_nghost-%COMP%], [data-mode=onDark]._pseudo[_nghost-%COMP%]:active, [data-mode=onDark]._pseudo[_nghost-%COMP%]:hover{color:var(--tui-text-03-night)}[data-mode=onDark][data-host-mode=positive][_nghost-%COMP%]{color:var(--tui-positive-night)}[data-mode=onDark][data-host-mode=positive]._active[_nghost-%COMP%], [data-mode=onDark][data-host-mode=positive][_nghost-%COMP%]:active, [data-mode=onDark][data-host-mode=positive][_nghost-%COMP%]:hover{color:var(--tui-positive-night-hover)}[data-host-mode=negative][_nghost-%COMP%]{color:var(--tui-negative)}[data-host-mode=negative][_nghost-%COMP%]:hover{color:var(--tui-negative-hover)}[data-host-mode=negative]._pseudo[_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{-webkit-text-decoration-color:rgba(222,76,30,.48);text-decoration-color:rgba(222,76,30,.48)}[data-host-mode=positive][_nghost-%COMP%]{color:var(--tui-positive)}[data-host-mode=positive][_nghost-%COMP%]:hover{color:var(--tui-positive-hover)}[data-host-mode=positive]._pseudo[_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{-webkit-text-decoration-color:rgba(58,169,129,.48);text-decoration-color:rgba(58,169,129,.48)}._focus-visible[_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{background:var(--tui-selection)}[data-mode=onLight]._focus-visible[_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{background:var(--tui-clear);color:var(--tui-text-01)}[data-mode=onDark]._focus-visible[_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{background:var(--tui-clear-inverse);color:var(--tui-text-01-night)}[data-host-mode=positive]._focus-visible[_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{background:var(--tui-success-bg)}[data-host-mode=negative]._focus-visible[_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{background:var(--tui-error-bg)}._pseudo[_nghost-%COMP%]   .t-content[_ngcontent-%COMP%]{padding-bottom:.15em;-webkit-text-decoration:underline dashed rgba(51,111,238,.48);text-decoration:underline dashed rgba(51,111,238,.48);text-underline-offset:.2em;text-decoration-thickness:.7px}.t-icon[_ngcontent-%COMP%]{transition-property:transform;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;margin-top:-.125rem;opacity:.8}.t-icon_left[_ngcontent-%COMP%]{margin-right:.25rem}.t-icon_right[_ngcontent-%COMP%]{margin-left:.25rem}[_nghost-%COMP%]:hover   .t-icon[_ngcontent-%COMP%]{opacity:1}._icon-rotated[_nghost-%COMP%]   .t-icon[_ngcontent-%COMP%]{transform:rotate(180deg)}"],
  changeDetection: 0
});
TuiLinkComponent.ctorParameters = () => [{
  type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef]
  }]
}, {
  type: rxjs__WEBPACK_IMPORTED_MODULE_11__/* .Observable */ .y,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_6__/* .TUI_MODE */ .Au]
  }]
}, {
  type: _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__/* .TuiFocusVisibleService */ .ku,
  decorators: [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
    args: [_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__/* .TuiFocusVisibleService */ .ku]
  }]
}];
(0,tslib__WEBPACK_IMPORTED_MODULE_12__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._pseudo'), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_13__/* .tuiDefaultProp */ .TH)()], TuiLinkComponent.prototype, "pseudo", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_12__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_13__/* .tuiDefaultProp */ .TH)()], TuiLinkComponent.prototype, "icon", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_12__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_13__/* .tuiDefaultProp */ .TH)()], TuiLinkComponent.prototype, "iconAlign", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_12__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._icon-rotated'), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_13__/* .tuiDefaultProp */ .TH)()], TuiLinkComponent.prototype, "iconRotated", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_12__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('attr.data-host-mode'), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_13__/* .tuiDefaultProp */ .TH)()], TuiLinkComponent.prototype, "mode", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_12__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._focus-visible')], TuiLinkComponent.prototype, "focusVisible", void 0);
TuiLinkComponent = TuiLinkComponent_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_12__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_12__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef)), (0,tslib__WEBPACK_IMPORTED_MODULE_12__/* .__param */ .fM)(1, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_6__/* .TUI_MODE */ .Au)), (0,tslib__WEBPACK_IMPORTED_MODULE_12__/* .__param */ .fM)(2, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__/* .TuiFocusVisibleService */ .ku))], TuiLinkComponent);
let TuiLinkModule = /*#__PURE__*/(() => {
  let TuiLinkModule = class TuiLinkModule {};
  TuiLinkModule.ɵfac = function TuiLinkModule_Factory(t) {
    return new (t || TuiLinkModule)();
  };
  TuiLinkModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
    type: TuiLinkModule
  });
  TuiLinkModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
    imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule, _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_10__/* .TuiSvgModule */ .E]]
  });
  return TuiLinkModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](TuiLinkModule, {
    declarations: function () {
      return [TuiLinkComponent];
    },
    imports: function () {
      return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule, _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_10__/* .TuiSvgModule */ .E];
    },
    exports: function () {
      return [TuiLinkComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-link.js.map

/***/ }),

/***/ 719:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dS: () => (/* binding */ TuiLoaderModule),
/* harmony export */   kM: () => (/* binding */ TuiLoaderComponent)
/* harmony export */ });
/* unused harmony exports TUI_LOADER_DEFAULT_OPTIONS, TUI_LOADER_OPTIONS, tuiLoaderOptionsProvider */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7582);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3008);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1213);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7179);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3034);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(4358);
/* harmony import */ var _taiga_ui_core_utils_miscellaneous__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6640);
/* harmony import */ var _tinkoff_ng_polymorpheus__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9570);







/** Default values for the loader options. */



function TuiLoaderComponent_div_2_div_3_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnamespaceSVG"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnamespaceHTML"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](0, "div", 6);
  }
  if (rf & 2) {
    const ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵclassProp"]("t-text_horizontal", ctx_r1.isHorizontal);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("content", ctx_r1.textContent);
  }
}
function TuiLoaderComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementStart"](0, "div", 2);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnamespaceSVG"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementStart"](1, "svg", 3);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](2, "circle", 4);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](3, TuiLoaderComponent_div_2_div_3_Template, 1, 3, "div", 5);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵclassProp"]("t-loader_horizontal", ctx_r0.isHorizontal)("t-loader_inherit-color", ctx_r0.inheritColor);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("data-tui-element-size", ctx_r0.size);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](3);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngIf", ctx_r0.hasText);
  }
}
const _c0 = ["*"];
const TUI_LOADER_DEFAULT_OPTIONS = {
  size: `m`,
  inheritColor: false,
  overlay: false
};
const TUI_LOADER_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(`Default parameters for loader component`, {
  factory: () => TUI_LOADER_DEFAULT_OPTIONS
});
const tuiLoaderOptionsProvider = options => ({
  provide: TUI_LOADER_OPTIONS,
  useValue: Object.assign(Object.assign({}, TUI_LOADER_DEFAULT_OPTIONS), options)
});

// @dynamic
let TuiLoaderComponent = /*#__PURE__*/(() => {
  let TuiLoaderComponent = class TuiLoaderComponent {
    constructor(documentRef, elementRef, isIos, options) {
      this.documentRef = documentRef;
      this.elementRef = elementRef;
      this.isIos = isIos;
      this.options = options;
      this.size = this.options.size;
      this.inheritColor = this.options.inheritColor;
      this.overlay = this.options.overlay;
      // TODO: 3.0 Remove null
      this.textContent = null;
      this.loading = true;
      this.isApple = (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_2__/* .isSafari */ .G6)(this.elementRef.nativeElement) || this.isIos;
    }
    set showLoader(value) {
      // @bad TODO: https://github.com/angular/angular/issues/32083 think of a better way
      if (value && this.focused) {
        (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_3__/* .blurNativeFocused */ .PO)(this.documentRef);
      }
      this.loading = value;
    }
    get hasOverlay() {
      return this.overlay && this.loading;
    }
    get hasText() {
      return !!this.textContent;
    }
    get isHorizontal() {
      return !(0,_taiga_ui_core_utils_miscellaneous__WEBPACK_IMPORTED_MODULE_4__/* .sizeBigger */ .Bb)(this.size);
    }
    get focused() {
      return (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_3__/* .isNativeFocusedIn */ .KF)(this.elementRef.nativeElement);
    }
  };
  TuiLoaderComponent.ɵfac = function TuiLoaderComponent_Factory(t) {
    return new (t || TuiLoaderComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_5__/* .TUI_IS_IOS */ .FA), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](TUI_LOADER_OPTIONS));
  };
  TuiLoaderComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineComponent"]({
    type: TuiLoaderComponent,
    selectors: [["tui-loader"]],
    hostVars: 2,
    hostBindings: function TuiLoaderComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵclassProp"]("_loading", ctx.loading);
      }
    },
    inputs: {
      size: "size",
      inheritColor: "inheritColor",
      overlay: "overlay",
      textContent: "textContent",
      showLoader: "showLoader"
    },
    ngContentSelectors: _c0,
    decls: 3,
    vars: 6,
    consts: [[1, "t-content", 3, "disabled"], ["class", "t-loader", 3, "t-loader_horizontal", "t-loader_inherit-color", 4, "ngIf"], [1, "t-loader"], ["automation-id", "tui-loader__loader", "focusable", "false", "viewBox", "0 0 100 100", "xmlns", "http://www.w3.org/2000/svg", 1, "t-icon"], ["cx", "50", "cy", "50", "r", "50", "stroke-dasharray", "314", 1, "t-circle"], ["polymorpheus-outlet", "", "automation-id", "tui-loader__text", "class", "t-text", 3, "t-text_horizontal", "content", 4, "ngIf"], ["polymorpheus-outlet", "", "automation-id", "tui-loader__text", 1, "t-text", 3, "content"]],
    template: function TuiLoaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementStart"](0, "fieldset", 0);
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵprojection"](1);
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](2, TuiLoaderComponent_div_2_Template, 4, 6, "div", 1);
      }
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵclassProp"]("t-content_has-overlay", ctx.hasOverlay)("t-content_loading", ctx.loading);
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("disabled", ctx.loading && !ctx.isApple);
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](2);
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngIf", ctx.loading);
      }
    },
    directives: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.NgIf, _tinkoff_ng_polymorpheus__WEBPACK_IMPORTED_MODULE_6__/* .PolymorpheusOutletComponent */ .r1],
    styles: ["@keyframes tuiLoaderDashOffset{0%,100%{stroke-dashoffset:-66}50%{stroke-dashoffset:-314}}@keyframes tuiLoaderRotate{0%{transform:rotate(0)}50%{transform:rotate(1turn)}100%{transform:rotate(3turn)}}[_nghost-%COMP%]{position:relative;display:flex}._loading[_nghost-%COMP%]{overflow:hidden}.t-content[_ngcontent-%COMP%]{z-index:0;min-width:100%;height:100%;padding:0;margin:0;border:none}.t-content_has-overlay[_ngcontent-%COMP%]{opacity:.3}.t-content_loading[_ngcontent-%COMP%]{pointer-events:none}.t-loader[_ngcontent-%COMP%]{position:relative;left:-100%;display:flex;flex-direction:column;align-items:center;justify-content:center;min-width:100%;flex-shrink:0;align-self:center;color:var(--tui-text-01);stroke:var(--tui-primary);animation:tuiFadeIn var(--tui-duration)}.t-loader.t-loader_horizontal[_ngcontent-%COMP%]{flex-direction:row}.t-loader.t-loader_inherit-color[_ngcontent-%COMP%]{color:inherit;stroke:currentColor}.t-loader[data-tui-element-size=xs][_ngcontent-%COMP%]{font-size:.75rem;stroke-width:38}.t-loader[data-tui-element-size='s'][_ngcontent-%COMP%]{font-size:1rem;stroke-width:25}.t-loader[data-tui-element-size='m'][_ngcontent-%COMP%]{font-size:1.5rem;stroke-width:17}.t-loader[data-tui-element-size='l'][_ngcontent-%COMP%]{font-size:2.5rem;stroke-width:15}.t-loader[data-tui-element-size=xl][_ngcontent-%COMP%]{font-size:3.5rem;stroke-width:14}.t-loader[data-tui-element-size=xxl][_ngcontent-%COMP%]{font-size:5rem;stroke-width:10}.t-text[_ngcontent-%COMP%]{font:var(--tui-font-text-s);color:var(--tui-text-01);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;margin-top:1rem;color:inherit;max-width:100%;text-align:center;stroke-width:0}.t-text_horizontal[_ngcontent-%COMP%]{margin:0 0 0 1rem}.t-icon[_ngcontent-%COMP%]{display:block;min-width:1em;max-width:1em;min-height:1em;max-height:1em;margin:.25rem -.5em;border-radius:100%;overflow:hidden;transform:scale(1,-1);animation:3s linear infinite tuiLoaderRotate}.t-circle[_ngcontent-%COMP%]{fill:none;stroke:inherit;stroke-width:inherit;animation:3s linear infinite tuiLoaderDashOffset}"],
    changeDetection: 0
  });
  (0,tslib__WEBPACK_IMPORTED_MODULE_7__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_8__/* .tuiDefaultProp */ .TH)()], TuiLoaderComponent.prototype, "size", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_7__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_8__/* .tuiDefaultProp */ .TH)()], TuiLoaderComponent.prototype, "inheritColor", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_7__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_8__/* .tuiDefaultProp */ .TH)()], TuiLoaderComponent.prototype, "overlay", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_7__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_8__/* .tuiDefaultProp */ .TH)()], TuiLoaderComponent.prototype, "textContent", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_7__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_8__/* .tuiRequiredSetter */ .NH)()], TuiLoaderComponent.prototype, "showLoader", null);
  (0,tslib__WEBPACK_IMPORTED_MODULE_7__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.HostBinding)('class._loading')], TuiLoaderComponent.prototype, "loading", void 0);
  TuiLoaderComponent = (0,tslib__WEBPACK_IMPORTED_MODULE_7__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_7__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT)), (0,tslib__WEBPACK_IMPORTED_MODULE_7__/* .__param */ .fM)(1, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef)), (0,tslib__WEBPACK_IMPORTED_MODULE_7__/* .__param */ .fM)(2, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_5__/* .TUI_IS_IOS */ .FA)), (0,tslib__WEBPACK_IMPORTED_MODULE_7__/* .__param */ .fM)(3, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(TUI_LOADER_OPTIONS))], TuiLoaderComponent);
  return TuiLoaderComponent;
})();
let TuiLoaderModule = /*#__PURE__*/(() => {
  let TuiLoaderModule = class TuiLoaderModule {};
  TuiLoaderModule.ɵfac = function TuiLoaderModule_Factory(t) {
    return new (t || TuiLoaderModule)();
  };
  TuiLoaderModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
    type: TuiLoaderModule
  });
  TuiLoaderModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
    imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_0__.CommonModule, _tinkoff_ng_polymorpheus__WEBPACK_IMPORTED_MODULE_6__/* .PolymorpheusModule */ .wq]]
  });
  return TuiLoaderModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵsetNgModuleScope"](TuiLoaderModule, {
    declarations: function () {
      return [TuiLoaderComponent];
    },
    imports: function () {
      return [_angular_common__WEBPACK_IMPORTED_MODULE_0__.CommonModule, _tinkoff_ng_polymorpheus__WEBPACK_IMPORTED_MODULE_6__/* .PolymorpheusModule */ .wq];
    },
    exports: function () {
      return [TuiLoaderComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-loader.js.map

/***/ }),

/***/ 885:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Hi: () => (/* binding */ TuiNotificationModule),
/* harmony export */   Ls: () => (/* binding */ TuiNotificationComponent)
/* harmony export */ });
/* unused harmony export STATUS_ICON */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7582);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4197);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(4358);
/* harmony import */ var _taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(865);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3008);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _taiga_ui_core_components_button__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2628);
/* harmony import */ var _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4789);













function TuiNotificationComponent_tui_svg_0_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "tui-svg", 3);
  }
  if (rf & 2) {
    const ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("src", ctx_r0.icon);
  }
}
function TuiNotificationComponent_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "button", 4);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function TuiNotificationComponent_button_3_Template_button_click_0_listener() {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r3);
      const ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
      return ctx_r2.close.emit();
    });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpipe"](1, "async");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("title", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpipeBind1"](1, 1, ctx_r1.closeWord$));
  }
}
const _c0 = ["*"];
const STATUS_ICON = {
  info: 'tuiIconInfo',
  success: 'tuiIconCheckCircle',
  error: 'tuiIconCancel',
  warning: 'tuiIconAttention'
};
// @bad TODO: Think about moving to kit
let TuiNotificationComponent = /*#__PURE__*/(() => {
  let TuiNotificationComponent = class TuiNotificationComponent {
    constructor(closeWord$, options) {
      this.closeWord$ = closeWord$;
      this.options = options;
      this.hasIcon = this.options.hasIcon;
      this.status = this.options.status;
      this.close = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    }
    get icon() {
      return STATUS_ICON[this.status];
    }
    get hasClose() {
      return (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_2__/* .tuiIsObserved */ .fw)(this.close);
    }
  };
  TuiNotificationComponent.ɵfac = function TuiNotificationComponent_Factory(t) {
    return new (t || TuiNotificationComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_3__/* .TUI_CLOSE_WORD */ .U0), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_3__/* .TUI_NOTIFICATION_OPTIONS */ .Ln));
  };
  TuiNotificationComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: TuiNotificationComponent,
    selectors: [["tui-notification"]],
    hostVars: 5,
    hostBindings: function TuiNotificationComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("data-tui-host-status", ctx.status);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("_has-icon", ctx.hasIcon)("_has-close-button", ctx.hasClose);
      }
    },
    inputs: {
      hasIcon: "hasIcon",
      status: "status"
    },
    outputs: {
      close: "close"
    },
    ngContentSelectors: _c0,
    decls: 4,
    vars: 2,
    consts: [["automation-id", "tui-notification__icon", "class", "t-icon", 3, "src", 4, "ngIf"], [1, "t-content"], ["tuiIconButton", "", "type", "button", "automation-id", "tui-notification__close", "size", "xs", "icon", "tuiIconCloseLarge", "appearance", "icon", "class", "t-close", 3, "title", "click", 4, "ngIf"], ["automation-id", "tui-notification__icon", 1, "t-icon", 3, "src"], ["tuiIconButton", "", "type", "button", "automation-id", "tui-notification__close", "size", "xs", "icon", "tuiIconCloseLarge", "appearance", "icon", 1, "t-close", 3, "title", "click"]],
    template: function TuiNotificationComponent_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, TuiNotificationComponent_tui_svg_0_Template, 1, 1, "tui-svg", 0);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "div", 1);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](2);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, TuiNotificationComponent_button_3_Template, 2, 3, "button", 2);
      }
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.hasIcon);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](3);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.hasClose);
      }
    },
    directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_4__/* .TuiSvgComponent */ .P, _taiga_ui_core_components_button__WEBPACK_IMPORTED_MODULE_5__/* .TuiButtonComponent */ .v0],
    pipes: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.AsyncPipe],
    styles: ["[_nghost-%COMP%]{font:var(--tui-font-text-s);color:var(--tui-text-01);position:relative;display:block;padding:.8125rem 1rem .6875rem;border-radius:var(--tui-radius-m);background:#fff;background:var(--tui-base-01);box-sizing:border-box;overflow:hidden}[_nghost-%COMP%]:after{position:absolute;top:0;left:0;width:100%;height:100%;content:'';pointer-events:none}._has-close-button[_nghost-%COMP%]{padding-right:2rem}._has-icon[_nghost-%COMP%]{padding-left:2.75rem}[data-tui-host-status=info][_nghost-%COMP%]{color:var(--tui-info-fill)}[data-tui-host-status=info][_nghost-%COMP%]:after{background:var(--tui-info-bg)}[data-tui-host-status=success][_nghost-%COMP%]{color:var(--tui-success-fill)}[data-tui-host-status=success][_nghost-%COMP%]:after{background:var(--tui-success-bg)}[data-tui-host-status=error][_nghost-%COMP%]{color:var(--tui-error-fill)}[data-tui-host-status=error][_nghost-%COMP%]:after{background:var(--tui-error-bg)}[data-tui-host-status=warning][_nghost-%COMP%]{color:var(--tui-warning-fill)}[data-tui-host-status=warning][_nghost-%COMP%]:after{background:var(--tui-warning-bg)}.t-content[_ngcontent-%COMP%]{word-wrap:break-word;color:var(--tui-text-01)}.t-icon[_ngcontent-%COMP%]{position:absolute;top:0;left:1rem;display:flex;width:1rem;height:100%;max-height:3rem;align-items:center}.t-close[_ngcontent-%COMP%]{position:absolute;top:.625rem;right:.5rem}"],
    changeDetection: 0
  });
  (0,tslib__WEBPACK_IMPORTED_MODULE_6__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._has-icon'), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__/* .tuiDefaultProp */ .TH)()], TuiNotificationComponent.prototype, "hasIcon", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_6__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('attr.data-tui-host-status'), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__/* .tuiDefaultProp */ .TH)()], TuiNotificationComponent.prototype, "status", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_6__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Output)()], TuiNotificationComponent.prototype, "close", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_6__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._has-close-button')], TuiNotificationComponent.prototype, "hasClose", null);
  TuiNotificationComponent = (0,tslib__WEBPACK_IMPORTED_MODULE_6__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_6__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_3__/* .TUI_CLOSE_WORD */ .U0)), (0,tslib__WEBPACK_IMPORTED_MODULE_6__/* .__param */ .fM)(1, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_3__/* .TUI_NOTIFICATION_OPTIONS */ .Ln))], TuiNotificationComponent);
  return TuiNotificationComponent;
})();
let TuiNotificationModule = /*#__PURE__*/(() => {
  let TuiNotificationModule = class TuiNotificationModule {};
  TuiNotificationModule.ɵfac = function TuiNotificationModule_Factory(t) {
    return new (t || TuiNotificationModule)();
  };
  TuiNotificationModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
    type: TuiNotificationModule
  });
  TuiNotificationModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
    imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule, _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_4__/* .TuiSvgModule */ .E, _taiga_ui_core_components_button__WEBPACK_IMPORTED_MODULE_5__/* .TuiButtonModule */ .fN]]
  });
  return TuiNotificationModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](TuiNotificationModule, {
    declarations: function () {
      return [TuiNotificationComponent];
    },
    imports: function () {
      return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule, _taiga_ui_core_components_svg__WEBPACK_IMPORTED_MODULE_4__/* .TuiSvgModule */ .E, _taiga_ui_core_components_button__WEBPACK_IMPORTED_MODULE_5__/* .TuiButtonModule */ .fN];
    },
    exports: function () {
      return [TuiNotificationComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-notification.js.map

/***/ }),

/***/ 4789:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ TuiSvgModule),
/* harmony export */   P: () => (/* binding */ TuiSvgComponent)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(7582);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3008);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(1211);
/* harmony import */ var _ng_web_apis_common__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(2579);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1213);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(5242);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(8939);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(3503);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(4358);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(2668);
/* harmony import */ var _taiga_ui_core_constants__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(8269);
/* harmony import */ var _taiga_ui_core_services__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(7941);
/* harmony import */ var _taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(865);
/* harmony import */ var _taiga_ui_core_utils_miscellaneous__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(6640);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2298);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5917);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3190);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9761);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(5304);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(8002);

















function TuiSvgComponent_ng_container_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](0, "div", 3);
  }
  if (rf & 2) {
    const innerHTML_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]().tuiLet;
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("innerHTML", innerHTML_r1, _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵsanitizeHtml"]);
  }
}
function TuiSvgComponent_ng_container_0_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵgetCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnamespaceSVG"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementStart"](0, "svg", 4);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵlistener"]("error", function TuiSvgComponent_ng_container_0_ng_template_2_Template__svg_svg_error_0_listener() {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵrestoreView"](_r7);
      const ctx_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"](2);
      return ctx_r6.onError();
    });
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](1, "use");
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementEnd"]();
  }
  if (rf & 2) {
    const ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("href", ctx_r4.use, null, "xlink");
  }
}
function TuiSvgComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](1, TuiSvgComponent_ng_container_0_div_1_Template, 1, 1, "div", 1);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](2, TuiSvgComponent_ng_container_0_ng_template_2_Template, 2, 1, "ng-template", null, 2, _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplateRefExtractor"]);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const _r3 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵreference"](3);
    const ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngIf", ctx_r0.isInnerHTML)("ngIfElse", _r3);
  }
}
const UNDEFINED_NAMED_ICON = 'Attempted to use undefined named icon';
const MISSING_EXTERNAL_ICON = 'External icon is missing on the given URL';
const FAILED_EXTERNAL_ICON = 'Failed to load external SVG';
// TODO: Consider moving to CDK along with SvgService and SvgDefsHostComponent
// @dynamic
let TuiSvgComponent = /*#__PURE__*/(() => {
  let TuiSvgComponent = class TuiSvgComponent {
    constructor(documentRef, windowRef, iconsPath, tuiSanitizer, svgService, staticRequestService, sanitizer, elementRef, userAgent, srcProcessor, contentProcessor) {
      this.documentRef = documentRef;
      this.windowRef = windowRef;
      this.iconsPath = iconsPath;
      this.tuiSanitizer = tuiSanitizer;
      this.svgService = svgService;
      this.staticRequestService = staticRequestService;
      this.sanitizer = sanitizer;
      this.elementRef = elementRef;
      this.userAgent = userAgent;
      this.srcProcessor = srcProcessor;
      this.contentProcessor = contentProcessor;
      this.src$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__/* .ReplaySubject */ .t(1);
      this.isIE = (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_3__/* .isIE */ .w1)(this.userAgent);
      this.icon = '';
      this.innerHTML$ = this.src$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__/* .switchMap */ .w)(() => this.isExternal ? this.getExternalIcon(this.icon) : (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.of)(this.getSafeHtml(this.icon))), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__/* .startWith */ .O)(''));
    }
    set src(src) {
      this.icon = this.srcProcessor(src);
      this.src$.next();
    }
    get src() {
      return this.icon;
    }
    get use() {
      return this.icon.includes('.svg#') ? this.icon : this.resolveName(this.icon, this.iconsPath);
    }
    get isInnerHTML() {
      return this.isSrc || this.isExternal || this.isName && this.isShadowDOM;
    }
    get isShadowDOM() {
      return (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__/* .getDocumentOrShadowRoot */ .sy)(this.elementRef.nativeElement) !== this.documentRef;
    }
    get isUse() {
      return this.use.includes('.svg#');
    }
    get isExternal() {
      return this.isUrl || this.isIE && this.isUse || this.isCrossDomain;
    }
    get isUrl() {
      return this.icon.endsWith('.svg');
    }
    get isSrc() {
      return (0,_taiga_ui_core_utils_miscellaneous__WEBPACK_IMPORTED_MODULE_8__/* .isPresumedHTMLString */ .zL)(this.icon);
    }
    get isName() {
      return !this.isUrl && !this.isUse && !this.isSrc;
    }
    get isCrossDomain() {
      const {
        use,
        isUse,
        windowRef
      } = this;
      return isUse && use.startsWith('http') && !!windowRef.origin && !use.startsWith(windowRef.origin);
    }
    onError(message = MISSING_EXTERNAL_ICON) {
      const {
        icon
      } = this;
      const event = (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_7__/* .tuiCustomEvent */ .hO)(_taiga_ui_core_constants__WEBPACK_IMPORTED_MODULE_9__/* .TUI_ICON_ERROR */ .qT, {
        bubbles: true,
        detail: {
          message,
          icon
        }
      }, this.documentRef);
      _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_10__/* .tuiAssert */ .zU.assert(false, message, icon);
      this.elementRef.nativeElement.dispatchEvent(event);
    }
    resolveName(name, iconsPath) {
      return iconsPath(name);
    }
    getSafeHtml(src) {
      return this.isSrc ? this.sanitize(src) : this.process(src);
    }
    process(src) {
      const icon = this.svgService.getOriginal(src);
      if (this.isName && !icon && !!src) {
        this.onError(UNDEFINED_NAMED_ICON);
      }
      // Empty line for innerHTML when icon is shown through USE tag
      return !this.isShadowDOM || !this.isName ? '' : this.sanitize(icon || '');
    }
    sanitize(src) {
      src = this.contentProcessor(src);
      return this.tuiSanitizer ? this.sanitizer.bypassSecurityTrustHtml(this.tuiSanitizer.sanitize(_angular_core__WEBPACK_IMPORTED_MODULE_1__.SecurityContext.HTML, src) || '') : src;
    }
    getExternalIcon(src) {
      const url = src.includes('.svg') ? src : this.use;
      return this.staticRequestService.request(url).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_11__/* .catchError */ .K)(() => {
        this.onError(FAILED_EXTERNAL_ICON);
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.of)('');
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_12__/* .map */ .U)(response => this.sanitize(response.replace('<svg', '<svg focusable="false"'))));
    }
  };
  TuiSvgComponent.ɵfac = function TuiSvgComponent_Factory(t) {
    return new (t || TuiSvgComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_13__/* .WINDOW */ .m9), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_ICONS_PATH */ .ki), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_SANITIZER */ .hm, 8), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_taiga_ui_core_services__WEBPACK_IMPORTED_MODULE_15__/* .TuiSvgService */ .K5), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_16__/* .TuiStaticRequestService */ .Fr), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_platform_browser__WEBPACK_IMPORTED_MODULE_17__.DomSanitizer), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_13__/* .USER_AGENT */ .yZ), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_SVG_SRC_PROCESSOR */ .V5), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_SVG_CONTENT_PROCESSOR */ .u_));
  };
  TuiSvgComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineComponent"]({
    type: TuiSvgComponent,
    selectors: [["tui-svg"]],
    inputs: {
      src: "src"
    },
    decls: 2,
    vars: 3,
    consts: [[4, "tuiLet"], ["class", "t-src", 3, "innerHTML", 4, "ngIf", "ngIfElse"], ["useTemplate", ""], [1, "t-src", 3, "innerHTML"], ["version", "1.1", "xmlns", "http://www.w3.org/2000/svg", 0, "xmlns", "xlink", "http://www.w3.org/1999/xlink", "focusable", "false", "width", "100%", "height", "100%", 3, "error"]],
    template: function TuiSvgComponent_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](0, TuiSvgComponent_ng_container_0_Template, 4, 2, "ng-container", 0);
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵpipe"](1, "async");
      }
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("tuiLet", _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵpipeBind1"](1, 1, ctx.innerHTML$));
      }
    },
    directives: [_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_18__/* .TuiLetDirective */ .Ls, _angular_common__WEBPACK_IMPORTED_MODULE_0__.NgIf],
    pipes: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.AsyncPipe],
    styles: ["[_nghost-%COMP%]{display:inline-block;vertical-align:middle;flex-shrink:0;line-height:0;height:1.5rem;width:1.5rem;fill:currentColor;font-size:1rem}.t-src[_ngcontent-%COMP%]{display:flex;height:100%;align-items:center;justify-content:center}"],
    changeDetection: 0
  });
  (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_20__/* .tuiRequiredSetter */ .NH)()], TuiSvgComponent.prototype, "src", null);
  (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__decorate */ .gn)([_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_20__/* .tuiPure */ .UM], TuiSvgComponent.prototype, "resolveName", null);
  TuiSvgComponent = (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT)), (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(1, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_13__/* .WINDOW */ .m9)), (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(2, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_ICONS_PATH */ .ki)), (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(3, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional)()), (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(3, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_SANITIZER */ .hm)), (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(4, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_taiga_ui_core_services__WEBPACK_IMPORTED_MODULE_15__/* .TuiSvgService */ .K5)), (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(5, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_16__/* .TuiStaticRequestService */ .Fr)), (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(6, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_angular_platform_browser__WEBPACK_IMPORTED_MODULE_17__.DomSanitizer)), (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(7, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef)), (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(8, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_13__/* .USER_AGENT */ .yZ)), (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(9, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_SVG_SRC_PROCESSOR */ .V5)), (0,tslib__WEBPACK_IMPORTED_MODULE_19__/* .__param */ .fM)(10, (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject)(_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_SVG_CONTENT_PROCESSOR */ .u_))], TuiSvgComponent);
  return TuiSvgComponent;
})();
let TuiSvgModule = /*#__PURE__*/(() => {
  let TuiSvgModule = class TuiSvgModule {};
  TuiSvgModule.ɵfac = function TuiSvgModule_Factory(t) {
    return new (t || TuiSvgModule)();
  };
  TuiSvgModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
    type: TuiSvgModule
  });
  TuiSvgModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
    imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_0__.CommonModule, _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_18__/* .TuiLetModule */ .WD]]
  });
  return TuiSvgModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵsetNgModuleScope"](TuiSvgModule, {
    declarations: function () {
      return [TuiSvgComponent];
    },
    imports: function () {
      return [_angular_common__WEBPACK_IMPORTED_MODULE_0__.CommonModule, _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_18__/* .TuiLetModule */ .WD];
    },
    exports: function () {
      return [TuiSvgComponent];
    }
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-components-svg.js.map

/***/ }),

/***/ 8269:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Nq: () => (/* binding */ tuiEditingKeys),
/* harmony export */   P8: () => (/* binding */ TUI_EXPAND_LOADED),
/* harmony export */   R3: () => (/* binding */ TUI_NON_DIGITS_REGEXP),
/* harmony export */   UZ: () => (/* binding */ TUI_SCROLLABLE),
/* harmony export */   fe: () => (/* binding */ TUI_SCROLL_INTO_VIEW),
/* harmony export */   hW: () => (/* binding */ TUI_DIGIT_REGEXP),
/* harmony export */   jK: () => (/* binding */ DEFAULT_MARGIN),
/* harmony export */   oA: () => (/* binding */ DEFAULT_ICONS_PATH),
/* harmony export */   qT: () => (/* binding */ TUI_ICON_ERROR),
/* harmony export */   q_: () => (/* binding */ DEFAULT_MIN_HEIGHT),
/* harmony export */   s9: () => (/* binding */ TUI_LEADING_ZEROES_REGEXP),
/* harmony export */   v1: () => (/* binding */ MASK_CARET_TRAP),
/* harmony export */   yA: () => (/* binding */ DEFAULT_MAX_WIDTH),
/* harmony export */   ze: () => (/* binding */ DEFAULT_MAX_HEIGHT)
/* harmony export */ });
/* unused harmony exports MEDIA, TUI_DECIMAL_SYMBOLS, TUI_DEFAULT_MARKER_HANDLER, TUI_LAST_PUNCTUATION_MARK_REGEXP, TUI_LATIN_AND_NUMBERS_REGEXP, TUI_LATIN_REGEXP, TUI_MASK_SYMBOLS_REGEXP, TUI_NON_DIGIT_REGEXP, VERSION */

const DEFAULT_MARGIN = 4;
const DEFAULT_MIN_HEIGHT = 80;
const DEFAULT_MAX_HEIGHT = 400;
const DEFAULT_MAX_WIDTH = 600;
const TUI_DECIMAL_SYMBOLS = (/* unused pure expression or super */ null && ([`,`, `.`]));
const DEFAULT_ICONS_PATH = name => name.includes(`.svg#`) ? name : `#${name}`;
const TUI_DEFAULT_MARKER_HANDLER = () => EMPTY_ARRAY;
const tuiEditingKeys = [`Spacebar`, `Backspace`, `Delete`, `ArrowLeft`, `ArrowRight`, `Left`, `Right`, `End`, `Home`];

/**
 * An event indicating that async data for expand has finished loading.
 * Dispatch to finish loading states for {@link TuiExpandComponent}.
 */
const TUI_EXPAND_LOADED = `tui-expand-loaded`;
/**
 * An event for scrolling an element into view within {@link TuiScrollbarComponent}.
 */
const TUI_SCROLL_INTO_VIEW = `tui-scroll-into-view`;
/**
 * An event to notify {@link TuiScrollbarComponent} that
 * it should control a nested element.
 */
const TUI_SCROLLABLE = `tui-scrollable`;
/**
 * An event indicating and error during icon loading in {@link TuiSvgComponent}.
 */
const TUI_ICON_ERROR = `tui-icon-error`;
const MASK_CARET_TRAP = `[]`;

/**
 * Media constants are exact the same as css media breakpoints
 * @deprecated use TUI_MEDIA token
 */
const MEDIA = {
  mobile: 320,
  tablet: 600,
  desktopSmall: 1024,
  desktopLarge: 1280
};
const TUI_DIGIT_REGEXP = /\d/;
const TUI_NON_DIGIT_REGEXP = /\D/;
const TUI_NON_DIGITS_REGEXP = /\D+/g;
const TUI_LEADING_ZEROES_REGEXP = /^0+/;
const TUI_MASK_SYMBOLS_REGEXP = /[ \-_()]/g;
const TUI_LAST_PUNCTUATION_MARK_REGEXP = /[.,\\/#!$%\\^&\\*;:{}=\\-_`~()]$/;
const TUI_LATIN_REGEXP = /[A-z]/;
const TUI_LATIN_AND_NUMBERS_REGEXP = /[A-z|0-9]/;

/**
 * @deprecated: use {@link TUI_VERSION}
 * TODO: remove in v3.0
 */
const VERSION = (/* unused pure expression or super */ null && (TUI_VERSION));

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-constants.js.map

/***/ }),

/***/ 5452:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   w: () => (/* binding */ TuiModeDirective),
/* harmony export */   z: () => (/* binding */ TuiModeModule)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7582);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6480);




let TuiModeDirective = /*#__PURE__*/(() => {
  let TuiModeDirective = class TuiModeDirective extends _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_1__/* .TuiController */ .td {
    constructor() {
      super(...arguments);
      this.mode = null;
    }
  };
  TuiModeDirective.ɵfac = /*@__PURE__*/function () {
    let ɵTuiModeDirective_BaseFactory;
    return function TuiModeDirective_Factory(t) {
      return (ɵTuiModeDirective_BaseFactory || (ɵTuiModeDirective_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](TuiModeDirective)))(t || TuiModeDirective);
    };
  }();
  TuiModeDirective.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
    type: TuiModeDirective,
    selectors: [["", "tuiMode", ""]],
    inputs: {
      mode: ["tuiMode", "mode"]
    },
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]]
  });
  (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)('tuiMode')], TuiModeDirective.prototype, "mode", void 0);
  return TuiModeDirective;
})();
let TuiModeModule = /*#__PURE__*/(() => {
  let TuiModeModule = class TuiModeModule {};
  TuiModeModule.ɵfac = function TuiModeModule_Factory(t) {
    return new (t || TuiModeModule)();
  };
  TuiModeModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
    type: TuiModeModule
  });
  TuiModeModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({});
  return TuiModeModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](TuiModeModule, {
    declarations: [TuiModeDirective],
    exports: [TuiModeDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-directives-mode.js.map

/***/ }),

/***/ 1489:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   W: () => (/* binding */ TuiWrapperModule),
/* harmony export */   o: () => (/* binding */ TuiWrapperDirective)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7582);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _taiga_ui_core_providers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2130);
/* harmony import */ var _taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(865);






// TODO: 3.0 remove `tui-wrapper` mode


let TuiWrapperDirective = /*#__PURE__*/(() => {
  let TuiWrapperDirective = class TuiWrapperDirective {
    constructor(mode$) {
      this.mode$ = mode$;
      this.disabled = false;
      this.readOnly = false;
      // TODO: 3.0 Rename to `hover`
      this.hovered = null;
      // TODO: 3.0 Rename to `active`
      this.pressed = null;
      this.focused = false;
      this.invalid = false;
      this.appearance = '';
    }
    get computedInvalid() {
      return !this.disabled && !this.readOnly && this.invalid;
    }
    get computedFocused() {
      return this.focused && !this.disabled;
    }
    get interactiveState() {
      if (this.disabled) {
        return "disabled" /* Disabled */;
      }

      if (this.readOnly) {
        return "readonly" /* Readonly */;
      }

      if (this.pressed) {
        return "pressed" /* Pressed */;
      }

      if (this.hovered) {
        return "hovered" /* Hovered */;
      }

      return null;
    }
    get noHover() {
      return this.readOnly || this.hovered === false;
    }
    get noActive() {
      return this.readOnly || this.pressed === false;
    }
  };
  TuiWrapperDirective.ɵfac = function TuiWrapperDirective_Factory(t) {
    return new (t || TuiWrapperDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_1__/* .TUI_MODE */ .Au));
  };
  TuiWrapperDirective.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
    type: TuiWrapperDirective,
    selectors: [["tui-wrapper"], ["", "tuiWrapper", ""]],
    hostVars: 10,
    hostBindings: function TuiWrapperDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("$.data-mode.attr", function TuiWrapperDirective___data_mode_attr_HostBindingHandler() {
          return ctx.mode$;
        });
      }
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("data-appearance", ctx.appearance)("data-state", ctx.interactiveState);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("_invalid", ctx.computedInvalid)("_focused", ctx.computedFocused)("_no-hover", ctx.noHover)("_no-active", ctx.noActive);
      }
    },
    inputs: {
      disabled: "disabled",
      readOnly: "readOnly",
      hovered: "hovered",
      pressed: "pressed",
      focused: "focused",
      invalid: "invalid",
      appearance: "appearance"
    },
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([_taiga_ui_core_providers__WEBPACK_IMPORTED_MODULE_2__/* .MODE_PROVIDER */ .CV])]
  });
  (0,tslib__WEBPACK_IMPORTED_MODULE_3__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)()], TuiWrapperDirective.prototype, "disabled", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_3__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)()], TuiWrapperDirective.prototype, "readOnly", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_3__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)()], TuiWrapperDirective.prototype, "hovered", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_3__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)()], TuiWrapperDirective.prototype, "pressed", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_3__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)()], TuiWrapperDirective.prototype, "focused", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_3__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)()], TuiWrapperDirective.prototype, "invalid", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_3__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Input)(), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('attr.data-appearance')], TuiWrapperDirective.prototype, "appearance", void 0);
  (0,tslib__WEBPACK_IMPORTED_MODULE_3__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._invalid')], TuiWrapperDirective.prototype, "computedInvalid", null);
  (0,tslib__WEBPACK_IMPORTED_MODULE_3__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._focused')], TuiWrapperDirective.prototype, "computedFocused", null);
  (0,tslib__WEBPACK_IMPORTED_MODULE_3__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('attr.data-state')], TuiWrapperDirective.prototype, "interactiveState", null);
  (0,tslib__WEBPACK_IMPORTED_MODULE_3__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._no-hover')], TuiWrapperDirective.prototype, "noHover", null);
  (0,tslib__WEBPACK_IMPORTED_MODULE_3__/* .__decorate */ .gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding)('class._no-active')], TuiWrapperDirective.prototype, "noActive", null);
  TuiWrapperDirective = (0,tslib__WEBPACK_IMPORTED_MODULE_3__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_3__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_1__/* .TUI_MODE */ .Au))], TuiWrapperDirective);
  return TuiWrapperDirective;
})();
let TuiWrapperModule = /*#__PURE__*/(() => {
  let TuiWrapperModule = class TuiWrapperModule {};
  TuiWrapperModule.ɵfac = function TuiWrapperModule_Factory(t) {
    return new (t || TuiWrapperModule)();
  };
  TuiWrapperModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
    type: TuiWrapperModule
  });
  TuiWrapperModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({});
  return TuiWrapperModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](TuiWrapperModule, {
    declarations: [TuiWrapperDirective],
    exports: [TuiWrapperDirective]
  });
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-directives-wrapper.js.map

/***/ }),

/***/ 2130:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CV: () => (/* binding */ MODE_PROVIDER),
/* harmony export */   my: () => (/* binding */ watchedControllerFactory),
/* harmony export */   yI: () => (/* binding */ TUI_IS_MOBILE_RES_PROVIDER)
/* harmony export */ });
/* unused harmony exports isMobileResFactory, modeFactory, tuiIsMobileResFactory, tuiModeFactory, tuiWatchedControllerFactory */
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(865);
/* harmony import */ var _taiga_ui_core_directives_mode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5452);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5917);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9761);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8002);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6782);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4197);







/**
 * @deprecated: use {@link tuiIsMobileResFactory} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isMobileResFactory(mobile$, {
  nativeElement
}) {
  nativeElement[`$.class._mobile`] = mobile$;
  return mobile$;
}
const TUI_IS_MOBILE_RES_PROVIDER = {
  provide: _taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_1__/* .TUI_IS_MOBILE_RES */ .rL,
  deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_0__.SkipSelf(), _taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_1__/* .TUI_IS_MOBILE_RES */ .rL], _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef],
  useFactory: isMobileResFactory
};
const tuiIsMobileResFactory = (/* unused pure expression or super */ null && (isMobileResFactory));

/**
 * @deprecated: use {@link tuiModeFactory} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function modeFactory(mode, {
  nativeElement
}) {
  const mode$ = mode ? mode.change$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__/* .startWith */ .O)(null), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__/* .map */ .U)(() => mode.mode)) : (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.of)(null);
  nativeElement[`$.data-mode.attr`] = mode$;
  return mode$;
}
const MODE_PROVIDER = {
  provide: _taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_1__/* .TUI_MODE */ .Au,
  deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional(), _taiga_ui_core_directives_mode__WEBPACK_IMPORTED_MODULE_5__/* .TuiModeDirective */ .w], _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef],
  useFactory: modeFactory
};
const tuiModeFactory = (/* unused pure expression or super */ null && (modeFactory));

/**
 * @deprecated: use {@link tuiWatchedControllerFactory} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function watchedControllerFactory(controller, changeDetectorRef, destroy$) {
  controller.change$.pipe((0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__/* .watch */ .YP)(changeDetectorRef), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__/* .takeUntil */ .R)(destroy$)).subscribe();
  return controller;
}
const tuiWatchedControllerFactory = (/* unused pure expression or super */ null && (watchedControllerFactory));

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-providers.js.map

/***/ }),

/***/ 7941:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BN: () => (/* binding */ TuiHintService),
/* harmony export */   K5: () => (/* binding */ TuiSvgService),
/* harmony export */   Ok: () => (/* binding */ TuiRouterLinkActiveService)
/* harmony export */ });
/* unused harmony exports TuiFormatDateService, TuiNightThemeService */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(7582);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6215);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8891);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(9193);
/* harmony import */ var _ng_web_apis_common__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(2579);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8002);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7519);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6782);
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2541);
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_router__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4197);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(3503);
/* harmony import */ var _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(8939);
/* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(1211);
/* harmony import */ var _taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(865);
/* harmony import */ var _taiga_ui_core_utils_dom__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(7766);















let TuiFormatDateService = /*#__PURE__*/(/* unused pure expression or super */ null && ((() => {
  let TuiFormatDateService = class TuiFormatDateService {
    constructor(locale) {
      this.locale = locale;
    }
    format(timestamp) {
      return of(new Date(timestamp).toLocaleTimeString(this.locale, {
        hour: `numeric`,
        minute: `2-digit`
      }));
    }
  };
  TuiFormatDateService.ɵfac = function TuiFormatDateService_Factory(t) {
    return new (t || TuiFormatDateService)(ɵngcc0.ɵɵinject(LOCALE_ID));
  };
  TuiFormatDateService.ɵprov = ɵɵdefineInjectable({
    factory: function TuiFormatDateService_Factory() {
      return new TuiFormatDateService(ɵɵinject(LOCALE_ID));
    },
    token: TuiFormatDateService,
    providedIn: "root"
  });
  TuiFormatDateService = __decorate([__param(0, Inject(LOCALE_ID))], TuiFormatDateService);

  /**
   * Service for displaying hints/tooltips
   */
  return TuiFormatDateService;
})()));
let TuiHintService = /*#__PURE__*/(() => {
  let TuiHintService = class TuiHintService extends rxjs__WEBPACK_IMPORTED_MODULE_2__/* .BehaviorSubject */ .X {
    constructor() {
      super([]);
      /**
       * TODO:
       * We need the following logic for desribedBy
       * move it into another service that can register hints and
       * manage it using TuiHintService inside
       */
      this.directives = [];
    }
    add(directive) {
      this.next(this.value.concat(directive));
    }
    remove(directive) {
      if (this.value.includes(directive)) {
        this.next(this.value.filter(hint => hint !== directive));
      }
    }
    register(directive) {
      this.directives = [...this.directives, directive];
    }
    unregister(directive) {
      this.remove(directive);
      this.directives = this.directives.filter(dir => dir !== directive);
    }
    showHintForId(id) {
      const directive = this.findDirectiveWithHintId(id);
      if (directive) {
        this.add(directive);
      }
    }
    hideHintForId(id) {
      const directive = this.findDirectiveWithHintId(id);
      if (directive) {
        this.remove(directive);
      }
    }
    findDirectiveWithHintId(id) {
      return this.directives.find(directive => directive.tuiHintId === id);
    }
  };
  TuiHintService.ɵfac = function TuiHintService_Factory(t) {
    return new (t || TuiHintService)();
  };
  TuiHintService.ɵprov = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
    factory: function TuiHintService_Factory() {
      return new TuiHintService();
    },
    token: TuiHintService,
    providedIn: "root"
  });

  // @dynamic
  return TuiHintService;
})();
let TuiNightThemeService = /*#__PURE__*/(/* unused pure expression or super */ null && ((() => {
  let TuiNightThemeService = class TuiNightThemeService extends Observable {
    constructor(windowRef) {
      const media = windowRef.matchMedia(`(prefers-color-scheme: dark)`);
      const media$ = fromEvent(media, `change`).pipe(startWith(null), map(() => media.matches), share());
      super(subscriber => media$.subscribe(subscriber));
    }
  };
  TuiNightThemeService.ɵfac = function TuiNightThemeService_Factory(t) {
    return new (t || TuiNightThemeService)(ɵngcc0.ɵɵinject(WINDOW));
  };
  TuiNightThemeService.ɵprov = ɵɵdefineInjectable({
    factory: function TuiNightThemeService_Factory() {
      return new TuiNightThemeService(ɵɵinject(WINDOW));
    },
    token: TuiNightThemeService,
    providedIn: "root"
  });
  TuiNightThemeService = __decorate([__param(0, Inject(WINDOW))], TuiNightThemeService);
  return TuiNightThemeService;
})()));
let TuiRouterLinkActiveService = /*#__PURE__*/(() => {
  let TuiRouterLinkActiveService = class TuiRouterLinkActiveService extends rxjs__WEBPACK_IMPORTED_MODULE_3__/* .Observable */ .y {
    constructor(routerLinkActive, ngZone, animationFrame$, destroy$) {
      const stream$ = routerLinkActive ? animationFrame$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__/* .map */ .U)(() => routerLinkActive.isActive), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__/* .distinctUntilChanged */ .x)(), (0,_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_6__/* .tuiZoneOptimized */ .Yr)(ngZone), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__/* .takeUntil */ .R)(destroy$)) : rxjs__WEBPACK_IMPORTED_MODULE_8__/* .EMPTY */ .E;
      super(subscriber => stream$.subscribe(subscriber));
    }
  };
  TuiRouterLinkActiveService.ɵfac = function TuiRouterLinkActiveService_Factory(t) {
    return new (t || TuiRouterLinkActiveService)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_router__WEBPACK_IMPORTED_MODULE_1__.RouterLinkActive, 8), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_9__/* .ANIMATION_FRAME */ .L1), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_10__/* .TuiDestroyService */ .a3));
  };
  TuiRouterLinkActiveService.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
    token: TuiRouterLinkActiveService,
    factory: function (t) {
      return TuiRouterLinkActiveService.ɵfac(t);
    }
  });
  TuiRouterLinkActiveService = (0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional)()), (0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_angular_router__WEBPACK_IMPORTED_MODULE_1__.RouterLinkActive)), (0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__param */ .fM)(1, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone)), (0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__param */ .fM)(2, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_ng_web_apis_common__WEBPACK_IMPORTED_MODULE_9__/* .ANIMATION_FRAME */ .L1)), (0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__param */ .fM)(3, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_10__/* .TuiDestroyService */ .a3))], TuiRouterLinkActiveService);

  /**
   * Service for reusing SVGs without inlining each instance
   */
  // @dynamic
  return TuiRouterLinkActiveService;
})();
let TuiSvgService = /*#__PURE__*/(() => {
  let TuiSvgService = class TuiSvgService {
    constructor(tuiSanitizer, sanitizer, icons) {
      this.tuiSanitizer = tuiSanitizer;
      this.sanitizer = sanitizer;
      this.originals = {};
      this.items$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__/* .BehaviorSubject */ .X(new Map());
      this.define(icons);
    }
    define(icons) {
      const {
        value
      } = this.items$;
      Object.keys(icons).forEach(key => {
        this.defineIcon(key, icons[key], value);
      });
      this.items$.next(value);
    }
    getOriginal(name) {
      return this.originals[name] || null;
    }
    defineIcon(name, src, map) {
      if (map.has(name)) {
        return;
      }
      const parsed = this.parseSrc(name, src);
      if (!parsed) {
        _taiga_ui_cdk__WEBPACK_IMPORTED_MODULE_12__/* .tuiAssert */ .zU.assert(false, `Unable to parse given SVG src`);
        return;
      }
      map.set(name, parsed);
      this.originals = Object.assign(Object.assign({}, this.originals), {
        [name]: src
      });
    }
    parseSrc(name, src) {
      return this.sanitize((0,_taiga_ui_core_utils_dom__WEBPACK_IMPORTED_MODULE_13__/* .processIcon */ .c3)(src, name));
    }
    sanitize(src) {
      return this.sanitizer.bypassSecurityTrustHtml((this.tuiSanitizer ? this.tuiSanitizer.sanitize(_angular_core__WEBPACK_IMPORTED_MODULE_0__.SecurityContext.HTML, src) : this.sanitizer.sanitize(_angular_core__WEBPACK_IMPORTED_MODULE_0__.SecurityContext.HTML, src)) || ``);
    }
  };
  TuiSvgService.ɵfac = function TuiSvgService_Factory(t) {
    return new (t || TuiSvgService)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_SANITIZER */ .hm, 8), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_platform_browser__WEBPACK_IMPORTED_MODULE_15__.DomSanitizer), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_ICONS */ .It));
  };
  TuiSvgService.ɵprov = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
    factory: function TuiSvgService_Factory() {
      return new TuiSvgService((0,_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_SANITIZER */ .hm, 8), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_platform_browser__WEBPACK_IMPORTED_MODULE_15__.DomSanitizer), (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_ICONS */ .It));
    },
    token: TuiSvgService,
    providedIn: "root"
  });
  TuiSvgService = (0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__decorate */ .gn)([(0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional)()), (0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__param */ .fM)(0, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_SANITIZER */ .hm)), (0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__param */ .fM)(1, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_angular_platform_browser__WEBPACK_IMPORTED_MODULE_15__.DomSanitizer)), (0,tslib__WEBPACK_IMPORTED_MODULE_11__/* .__param */ .fM)(2, (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject)(_taiga_ui_core_tokens__WEBPACK_IMPORTED_MODULE_14__/* .TUI_ICONS */ .It))], TuiSvgService);
  return TuiSvgService;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-services.js.map

/***/ }),

/***/ 865:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  dx: () => (/* binding */ TUI_ANIMATIONS_DURATION),
  Pw: () => (/* binding */ TUI_ANIMATION_OPTIONS),
  uW: () => (/* binding */ TUI_ASSERT_ENABLED),
  U0: () => (/* binding */ TUI_CLOSE_WORD),
  Cc: () => (/* binding */ TUI_DATA_LIST_ACCESSOR),
  N1: () => (/* binding */ TUI_DATA_LIST_HOST),
  Jd: () => (/* binding */ TUI_DROPDOWN_DIRECTIVE),
  zP: () => (/* binding */ TUI_ELEMENT_REF),
  It: () => (/* binding */ TUI_ICONS),
  ki: () => (/* binding */ TUI_ICONS_PATH),
  rL: () => (/* binding */ TUI_IS_MOBILE_RES),
  J_: () => (/* binding */ TUI_MEDIA),
  Au: () => (/* binding */ TUI_MODE),
  $R: () => (/* binding */ TUI_MONTHS),
  PH: () => (/* binding */ TUI_NOTHING_FOUND_MESSAGE),
  Ln: () => (/* binding */ TUI_NOTIFICATION_OPTIONS),
  HO: () => (/* binding */ TUI_NUMBER_FORMAT),
  IQ: () => (/* binding */ TUI_OPTION_CONTENT),
  hm: () => (/* binding */ TUI_SANITIZER),
  $_: () => (/* binding */ TUI_SCROLL_REF),
  u_: () => (/* binding */ TUI_SVG_CONTENT_PROCESSOR),
  V5: () => (/* binding */ TUI_SVG_SRC_PROCESSOR),
  jt: () => (/* binding */ TUI_TEXTFIELD_APPEARANCE),
  S0: () => (/* binding */ TUI_TEXTFIELD_HOST),
  r2: () => (/* binding */ TUI_THEME),
  sE: () => (/* binding */ TUI_VALUE_ACCESSOR)
});

// UNUSED EXPORTS: TUI_DEFAULT_ERROR_MESSAGE, TUI_DOCUMENT_OR_SHADOW_ROOT, TUI_FIRST_DAY_OF_WEEK, TUI_ICONS_PLACE, TUI_NOTIFICATION_DEFAULT_OPTIONS, TUI_ORDERED_SHORT_WEEK_DAYS, TUI_SHORT_WEEK_DAYS, TUI_SPIN_TEXTS, convertToSundayFirstWeekFormat, tuiNotificationOptionsProvider

// EXTERNAL MODULE: consume shared module (default) @angular/core@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/core/fesm2015/core.js)
var core_js_ = __webpack_require__(8312);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/i18n/fesm2015/taiga-ui-i18n-tools.js + 2 modules
var taiga_ui_i18n_tools = __webpack_require__(8345);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-utils-miscellaneous.js
var taiga_ui_core_utils_miscellaneous = __webpack_require__(6640);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-utils-mobile.js
var taiga_ui_core_utils_mobile = __webpack_require__(9557);
// EXTERNAL MODULE: ./node_modules/@ng-web-apis/common/fesm2015/ng-web-apis-common.js
var ng_web_apis_common = __webpack_require__(2579);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-observables.js + 1 modules
var taiga_ui_cdk_observables = __webpack_require__(4197);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-constants.js
var taiga_ui_cdk_constants = __webpack_require__(3770);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-tokens.js + 1 modules
var taiga_ui_cdk_tokens = __webpack_require__(3034);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/share.js + 1 modules
var share = __webpack_require__(8819);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/startWith.js
var startWith = __webpack_require__(9761);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js
var map = __webpack_require__(8002);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js
var distinctUntilChanged = __webpack_require__(7519);
// EXTERNAL MODULE: consume shared module (default) @angular/common@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/common/fesm2015/common.js)
var common_js_ = __webpack_require__(3008);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-svg.js
/**
 * @deprecated: use {@link tuiSvgLinearGradientProcessor} instead
 * @description:
 * Any ‘linearGradient’ attributes which are defined on the referenced
 * element which are not defined on this element are inherited by this element.
 * If this element has no defined gradient stops, and the referenced element does
 * (possibly due to its own ‘xlink:href’ attribute), then this element inherits
 * the gradient stop from the referenced element. Inheritance can be indirect
 * to an arbitrary level; thus, if the referenced element inherits attribute
 * or gradient stops due to its own ‘xlink:href’ attribute, then the current
 * element can inherit those attributes or gradient stops.
 *
 * Documentation: https://www.w3.org/TR/SVG11/pservers.html
 *
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function svgLinearGradientProcessor(svg, salt) {
  const uniqueIds = extractLinearGradientIdsFromSvg(svg);
  return uniqueIds.reduce((processed, previousId) => processed.replace(new RegExp(previousId, `g`), `${previousId}_${salt || makeRandomSalt()}`), svg);
}
function makeRandomSalt() {
  return Math.floor(Math.random() * Date.now());
}
function extractLinearGradientIdsFromSvg(svg) {
  const matchedIdsWithPrefix = svg.match(/url\(#(\w\w+)/g) || [];
  return [...new Set(matchedIdsWithPrefix)].map(matched => matched.slice(5));
}
const tuiSvgLinearGradientProcessor = (/* unused pure expression or super */ null && (svgLinearGradientProcessor));

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-cdk-utils-svg.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/identity.js
var identity = __webpack_require__(4487);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-tokens.js









const TUI_ANIMATIONS_DURATION = new core_js_.InjectionToken(`Duration of all Taiga UI animations in ms`, {
  factory: () => 300
});
const TUI_ANIMATION_OPTIONS = new core_js_.InjectionToken(`Options for Taiga UI animations`, {
  factory: () => ({
    params: {
      duration: (0,core_js_.inject)(TUI_ANIMATIONS_DURATION)
    }
  })
});
const TUI_ASSERT_ENABLED = new core_js_.InjectionToken(`Flag to enable assertions across Taiga UI`, {
  factory: () => (0,core_js_.isDevMode)()
});
const TUI_DATA_LIST_ACCESSOR = new core_js_.InjectionToken(`Accessor for options`);
const TUI_DATA_LIST_HOST = new core_js_.InjectionToken(`DataList controller`);
const TUI_DOCUMENT_OR_SHADOW_ROOT = new core_js_.InjectionToken(`Document or ShadowRoot`);
const TUI_DROPDOWN_DIRECTIVE = new core_js_.InjectionToken(`Directive controlling TuiDropdownBoxComponent`);
const TUI_ELEMENT_REF = new core_js_.InjectionToken(`ElementRef when you cannot use @Input for single time injection`);
const TUI_FIRST_DAY_OF_WEEK = new core_js_.InjectionToken(`The first day of the week index`, {
  factory: () => 1 /* Monday */
});

const TUI_MONTHS = new core_js_.InjectionToken(`Localized months names`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`months`)
});
const TUI_CLOSE_WORD = new core_js_.InjectionToken(`i18n 'close' word`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`close`)
});
const TUI_NOTHING_FOUND_MESSAGE = new core_js_.InjectionToken(`i18n 'Nothing found' message`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`nothingFoundMessage`)
});
const TUI_DEFAULT_ERROR_MESSAGE = new core_js_.InjectionToken(`i18n of error message`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`defaultErrorMessage`)
});
const TUI_SPIN_TEXTS = new core_js_.InjectionToken(`spin i18n texts`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`spinTexts`)
});
const TUI_SHORT_WEEK_DAYS = new core_js_.InjectionToken(`calendars i18n texts`, {
  factory: (0,taiga_ui_i18n_tools/* extractI18n */.Ho)(`shortWeekDays`)
});
const TUI_ICONS_PLACE = new core_js_.InjectionToken(`Recommended paths to icons from documentation guide`, {
  factory: () => `assets/taiga-ui/icons`
});
const TUI_ICONS = new core_js_.InjectionToken(`A key/value dictionary of icon names and src to be defined with TuiSvgService`, {
  factory: () => ({})
});
const TUI_ICONS_PATH = new core_js_.InjectionToken(`A handler to retrieve USE id for icon by name`, {
  factory: () => (0,taiga_ui_core_utils_miscellaneous/* iconsPathFactory */.Dj)((0,core_js_.inject)(TUI_ICONS_PLACE))
});
const TUI_MEDIA = new core_js_.InjectionToken(`Token for media constant`, {
  factory: () => ({
    mobile: 768,
    desktopSmall: 1024,
    desktopLarge: 1280
  })
});
const TUI_IS_MOBILE_RES = new core_js_.InjectionToken(`Mobile resolution stream for private providers`, {
  factory: () => {
    const windowRef = (0,core_js_.inject)(ng_web_apis_common/* WINDOW */.m9);
    const media = (0,core_js_.inject)(TUI_MEDIA);
    return (0,taiga_ui_cdk_observables/* typedFromEvent */.eh)(windowRef, `resize`).pipe((0,share/* share */.B)(), (0,startWith/* startWith */.O)(null), (0,map/* map */.U)(() => (0,taiga_ui_core_utils_mobile/* tuiIsMobile */.J)(windowRef, media)), (0,distinctUntilChanged/* distinctUntilChanged */.x)(), (0,taiga_ui_cdk_observables/* tuiZoneOptimized */.Yr)((0,core_js_.inject)(core_js_.NgZone)));
  }
});
const TUI_MODE = new core_js_.InjectionToken(`Mode stream for private providers`);

/** Default values for the notification options. */
const TUI_NOTIFICATION_DEFAULT_OPTIONS = {
  autoClose: true,
  label: ``,
  status: "info" /* Info */,
  hasIcon: true,
  hasCloseButton: true,
  defaultAutoCloseTime: 3000
};
const TUI_NOTIFICATION_OPTIONS = new core_js_.InjectionToken(`Default parameters for notification alert component`, {
  factory: () => TUI_NOTIFICATION_DEFAULT_OPTIONS
});
function tuiNotificationOptionsProvider(options) {
  return {
    provide: TUI_NOTIFICATION_OPTIONS,
    useValue: Object.assign(Object.assign({}, TUI_NOTIFICATION_DEFAULT_OPTIONS), options)
  };
}
const TUI_NUMBER_FORMAT = new core_js_.InjectionToken(`Formatting configuration for displayed numbers`, {
  factory: () => ({
    decimalSeparator: `,`,
    thousandSeparator: taiga_ui_cdk_constants/* CHAR_NO_BREAK_SPACE */.f$,
    zeroPadding: true
  })
});
const TUI_OPTION_CONTENT = new core_js_.InjectionToken(`Content for tuiOption component`);

// TODO: 3.0 Remove export in ivy compilation
const convertToSundayFirstWeekFormat = weekDaysNames => {
  const sundayIndex = weekDaysNames.length - 1;
  return [weekDaysNames[sundayIndex], ...weekDaysNames.slice(0, sundayIndex)];
};
const TUI_ORDERED_SHORT_WEEK_DAYS = new core_js_.InjectionToken(`Ordered calendars i18n texts`, {
  factory: () => {
    const firstDayOfWeekIndex = (0,core_js_.inject)(TUI_FIRST_DAY_OF_WEEK);
    return (0,core_js_.inject)(TUI_SHORT_WEEK_DAYS).pipe((0,map/* map */.U)(convertToSundayFirstWeekFormat), (0,map/* map */.U)(weekDays => [...weekDays.slice(firstDayOfWeekIndex), ...weekDays.slice(0, firstDayOfWeekIndex)]));
  }
});
const TUI_SANITIZER = taiga_ui_cdk_tokens/* TUI_SANITIZER */.hm;

/**
 * Scrollable container
 */
const TUI_SCROLL_REF = new core_js_.InjectionToken(`[TUI_SCROLL_REF]`, {
  factory: () => new core_js_.ElementRef((0,core_js_.inject)(common_js_.DOCUMENT).documentElement)
});
const TUI_SVG_CONTENT_PROCESSOR = new core_js_.InjectionToken(`Transform function the contents of the loaded svg file`, {
  factory: () => svgLinearGradientProcessor
});
const TUI_SVG_SRC_PROCESSOR = new core_js_.InjectionToken(`Source path processor for svg`, {
  factory: () => identity/* identity */.y
});
const TUI_TEXTFIELD_APPEARANCE = new core_js_.InjectionToken(`Appearance for inputs`, {
  factory: () => "textfield" /* Textfield */
});

const TUI_TEXTFIELD_HOST = new core_js_.InjectionToken(`An interface to communicate with textfield based controls`);
const TUI_THEME = new core_js_.InjectionToken(`Theme name`, {
  factory: () => `Taiga`
});
const TUI_VALUE_ACCESSOR = new core_js_.InjectionToken(`Buffer token to pass NG_VALUE_ACCESSOR to a different Injector`);

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-tokens.js.map

/***/ }),

/***/ 7766:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c3: () => (/* binding */ processIcon),
/* harmony export */   ic: () => (/* binding */ tuiGetViewportWidth),
/* harmony export */   rn: () => (/* binding */ checkFixedPosition),
/* harmony export */   zP: () => (/* binding */ getScreenWidth)
/* harmony export */ });
/* unused harmony exports areCssVarsSupported, getSafeAreaSize, tuiAreCssVarsSupported, tuiCheckFixedPosition, tuiGetSafeAreaSize, tuiGetScreenWidth, tuiGetViewportHeight, tuiProcessIcon */


/**
 * @deprecated: use {@link tuiAreCssVarsSupported} instead
 * TODO: 3.0 remove this function
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function areCssVarsSupported(cssRef, userAgent) {
  return cssRef.supports(`(--a: 0)`) && !isEdgeOlderThan(17, userAgent);
}
const tuiAreCssVarsSupported = (/* unused pure expression or super */ null && (areCssVarsSupported));

/**
 * @deprecated: use {@link tuiCheckFixedPosition} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function checkFixedPosition(element) {
  if (!element || typeof getComputedStyle === `undefined`) {
    return false;
  }
  const style = getComputedStyle(element);
  return style.getPropertyValue(`position`) === `fixed` || checkFixedPosition(element.parentElement);
}
const tuiCheckFixedPosition = (/* unused pure expression or super */ null && (checkFixedPosition));

/**
 * @deprecated: use {@link tuiGetSafeAreaSize} instead
 * Calculates size of safe area on mobile devices (status bars)
 *
 * ATTENTION: Only use in browser environment
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getSafeAreaSize() {
  if (!CSS.supports(`padding-top: env(safe-area-inset-top)`)) {
    return 0;
  }
  const div = document.createElement(`div`);
  div.style.paddingTop = `env(safe-area-inset-top)`;
  document.body.appendChild(div);
  const safeAreaSize = parseInt(window.getComputedStyle(div).paddingTop, 10) || 0;
  document.body.removeChild(div);
  return safeAreaSize;
}
const tuiGetSafeAreaSize = (/* unused pure expression or super */ null && (getSafeAreaSize));

/**
 * @deprecated: use {@link tuiGetScreenWidth} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getScreenWidth(documentRef) {
  return Math.max(documentRef.documentElement.clientWidth, documentRef.defaultView ? documentRef.defaultView.innerWidth : 0);
}
const tuiGetScreenWidth = (/* unused pure expression or super */ null && (getScreenWidth));

/**
 * @description:
 * Cross-browser @media (height)
 *
 * 1. window.innerWidth
 * 1.1. gets CSS viewport @media (height) which include scrollbars
 * 1.2. initial-scale and zoom variations may cause mobile values to
 *      wrongly scale down to what PPK calls the visual
 *      viewport and be smaller than the @media values
 *  1.3. zoom may cause values to be 1px off due to native rounding
 *
 *  2. document.documentElement.clientHeight
 *  2.1. equals CSS viewport width minus scrollbar width
 *  2.2. matches @media (height) when there is no scrollbar
 *  2.3. available cross-browser
 *  2.4. inaccurate if doctype is missing
 */
function tuiGetViewportHeight({
  document,
  innerHeight
}) {
  return Math.max(document.documentElement.clientHeight || 0, innerHeight || 0);
}

/**
 * @description:
 * Cross-browser @media (width)
 *
 * 1. window.innerWidth
 * 1.1. gets CSS viewport @media (width) which include scrollbars
 * 1.2. initial-scale and zoom variations may cause mobile values to
 *      wrongly scale down to what PPK calls the visual
 *      viewport and be smaller than the @media values
 *  1.3. zoom may cause values to be 1px off due to native rounding
 *
 *  2. document.documentElement.clientWidth
 *  2.1. equals CSS viewport width minus scrollbar width
 *  2.2. matches @media (width) when there is no scrollbar
 *  2.3. available cross-browser
 *  2.4. inaccurate if doctype is missing
 */
function tuiGetViewportWidth({
  document,
  innerWidth
}) {
  return Math.max(document.documentElement.clientWidth || 0, innerWidth || 0);
}
const WIDTH_SEARCH = `width="`;
const HEIGHT_SEARCH = `height="`;
const START = `<svg`;
/**
 * @deprecated: use {@link tuiProcessIcon} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function processIcon(source, name) {
  if (source.includes(`id="${name}"`)) {
    return source;
  }
  const src = source.slice(Math.max(0, source.indexOf(START)));
  const attributes = src.slice(0, Math.max(0, src.indexOf(`>`)));
  if (!(attributes === null || attributes === void 0 ? void 0 : attributes.includes(WIDTH_SEARCH)) || !attributes.includes(HEIGHT_SEARCH)) {
    return `${src.replace(START, `<svg xmlns="http://www.w3.org/2000/svg"><g id="${name}" xmlns="http://www.w3.org/2000/svg"><svg`)}</g></svg>`;
  }
  const indexOfWidth = attributes.indexOf(WIDTH_SEARCH);
  const indexOfHeight = attributes.indexOf(HEIGHT_SEARCH);
  const widthOffset = indexOfWidth + WIDTH_SEARCH.length;
  const heightOffset = indexOfHeight + HEIGHT_SEARCH.length;
  const widthString = attributes.slice(widthOffset, attributes.indexOf(`"`, widthOffset));
  const heightString = attributes.slice(heightOffset, attributes.indexOf(`"`, heightOffset));
  if (!heightString || !widthString || widthString.includes(`%`) || heightString.includes(`%`) || widthString.includes(`em`) || heightString.includes(`em`)) {
    return src.replace(START, `<svg id="${name}"`);
  }
  const width = parseInt(widthString, 10);
  const height = parseInt(heightString, 10);
  return `<g id="${name}" xmlns="http://www.w3.org/2000/svg"><svg  x="50%" y="50%" width="${width / 16}em" height="${height / 16}em" overflow="visible" viewBox="0 0 ${width} ${height}"><svg x="${-width / 2}" y="${-height / 2}">${src}</svg></svg></g>`;
}
const tuiProcessIcon = (/* unused pure expression or super */ null && (processIcon));

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-utils-dom.js.map

/***/ }),

/***/ 6640:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bb: () => (/* binding */ sizeBigger),
/* harmony export */   Dj: () => (/* binding */ iconsPathFactory),
/* harmony export */   Rb: () => (/* binding */ isEditingKey),
/* harmony export */   ub: () => (/* binding */ getBorder),
/* harmony export */   zL: () => (/* binding */ isPresumedHTMLString)
/* harmony export */ });
/* unused harmony exports colorFallback, tuiGetBorder, tuiIconsPathFactory, tuiIsEditingKey, tuiIsPresumedHTMLString, tuiSizeBigger */
/* harmony import */ var _taiga_ui_core_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8269);


/**
 * @deprecated has been deleted in 3.0, please use CSS variables
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function colorFallback(color) {
  switch (color) {
    case `secondary`:
      return `var(--tui-info-fill)`;
    case `error`:
      return `var(--tui-error-fill)`;
    case `success`:
      return `var(--tui-success-fill)`;
    default:
      return `var(--tui-${color || `base-05`})`;
  }
}
const ITEM_SIZE = 1.5;
const CONTENT_SIZE = 2.5;
/**
 * @deprecated: use {@link tuiGetBorder} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getBorder(hasIcon, hasCleaner = false, hasTooltip = false, hasContent = false) {
  let border = 0;
  if (hasIcon) {
    border += ITEM_SIZE;
  }
  if (hasCleaner) {
    border += ITEM_SIZE;
  }
  if (hasTooltip) {
    border += ITEM_SIZE;
  }
  if (hasContent) {
    border += CONTENT_SIZE;
  }
  return border;
}
const tuiGetBorder = (/* unused pure expression or super */ null && (getBorder));

/**
 * @deprecated: use {@link tuiIconsPathFactory} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function iconsPathFactory(staticPath) {
  const base = staticPath[staticPath.length - 1] === `/` ? staticPath : `${staticPath}/`;
  return name => {
    if (name.startsWith(`tuiIcon`)) {
      return `${base}${name}.svg#${name}`;
    }
    return (0,_taiga_ui_core_constants__WEBPACK_IMPORTED_MODULE_0__/* .DEFAULT_ICONS_PATH */ .oA)(name);
  };
}
const tuiIconsPathFactory = (/* unused pure expression or super */ null && (iconsPathFactory));

/**
 * @deprecated: use {@link tuiIsEditingKey} instead
 * Check if pressed key is interactive in terms of input field
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isEditingKey(key) {
  return key.length === 1 || _taiga_ui_core_constants__WEBPACK_IMPORTED_MODULE_0__/* .tuiEditingKeys */ .Nq.includes(key);
}
const tuiIsEditingKey = (/* unused pure expression or super */ null && (isEditingKey));

/**
 * @deprecated: use {@link tuiIsPresumedHTMLString} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isPresumedHTMLString(candidate) {
  const trimmed = candidate.trim();
  return trimmed.startsWith(`<`) && trimmed.endsWith(`>`);
}
const tuiIsPresumedHTMLString = (/* unused pure expression or super */ null && (isPresumedHTMLString));
const SIZES = [`xs`, `s`, `m`, `l`, `xl`, `xxl`];
/**
 * @deprecated: use {@link tuiSizeBigger} instead
 * Compares size constants to determine if first size is bigger than the second
 *
 * @param size size that we need to compare
 * @param biggerThanSize size to compare with, 's' by default
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function sizeBigger(size, biggerThanSize = `s`) {
  return SIZES.indexOf(size) > SIZES.indexOf(biggerThanSize);
}
const tuiSizeBigger = (/* unused pure expression or super */ null && (sizeBigger));

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-utils-miscellaneous.js.map

/***/ }),

/***/ 9557:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J: () => (/* binding */ tuiIsMobile)
/* harmony export */ });
/* harmony import */ var _taiga_ui_core_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7766);

function tuiIsMobile(windowRef, {
  mobile
}) {
  return (0,_taiga_ui_core_utils_dom__WEBPACK_IMPORTED_MODULE_0__/* .tuiGetViewportWidth */ .ic)(windowRef) < mobile;
}

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-core-utils-mobile.js.map

/***/ }),

/***/ 1081:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   X: () => (/* binding */ TuiCountryIsoCode)
/* harmony export */ });
var TuiCountryIsoCode = /*#__PURE__*/(() => {
  (function (TuiCountryIsoCode) {
    TuiCountryIsoCode["AD"] = "AD";
    TuiCountryIsoCode["AE"] = "AE";
    TuiCountryIsoCode["AF"] = "AF";
    TuiCountryIsoCode["AG"] = "AG";
    TuiCountryIsoCode["AI"] = "AI";
    TuiCountryIsoCode["AL"] = "AL";
    TuiCountryIsoCode["AM"] = "AM";
    TuiCountryIsoCode["AO"] = "AO";
    TuiCountryIsoCode["AR"] = "AR";
    TuiCountryIsoCode["AT"] = "AT";
    TuiCountryIsoCode["AU"] = "AU";
    TuiCountryIsoCode["AW"] = "AW";
    TuiCountryIsoCode["AZ"] = "AZ";
    TuiCountryIsoCode["BA"] = "BA";
    TuiCountryIsoCode["BB"] = "BB";
    TuiCountryIsoCode["BD"] = "BD";
    TuiCountryIsoCode["BE"] = "BE";
    TuiCountryIsoCode["BF"] = "BF";
    TuiCountryIsoCode["BG"] = "BG";
    TuiCountryIsoCode["BH"] = "BH";
    TuiCountryIsoCode["BI"] = "BI";
    TuiCountryIsoCode["BJ"] = "BJ";
    TuiCountryIsoCode["BL"] = "BL";
    TuiCountryIsoCode["BM"] = "BM";
    TuiCountryIsoCode["BN"] = "BN";
    TuiCountryIsoCode["BO"] = "BO";
    TuiCountryIsoCode["BQ"] = "BQ";
    TuiCountryIsoCode["BR"] = "BR";
    TuiCountryIsoCode["BS"] = "BS";
    TuiCountryIsoCode["BT"] = "BT";
    TuiCountryIsoCode["BW"] = "BW";
    TuiCountryIsoCode["BY"] = "BY";
    TuiCountryIsoCode["BZ"] = "BZ";
    TuiCountryIsoCode["CD"] = "CD";
    TuiCountryIsoCode["CF"] = "CF";
    TuiCountryIsoCode["CG"] = "CG";
    TuiCountryIsoCode["CH"] = "CH";
    TuiCountryIsoCode["CI"] = "CI";
    TuiCountryIsoCode["CL"] = "CL";
    TuiCountryIsoCode["CM"] = "CM";
    TuiCountryIsoCode["CN"] = "CN";
    TuiCountryIsoCode["CO"] = "CO";
    TuiCountryIsoCode["CR"] = "CR";
    TuiCountryIsoCode["CU"] = "CU";
    TuiCountryIsoCode["CV"] = "CV";
    TuiCountryIsoCode["CW"] = "CW";
    TuiCountryIsoCode["CY"] = "CY";
    TuiCountryIsoCode["CZ"] = "CZ";
    TuiCountryIsoCode["DE"] = "DE";
    TuiCountryIsoCode["DJ"] = "DJ";
    TuiCountryIsoCode["DK"] = "DK";
    TuiCountryIsoCode["DM"] = "DM";
    TuiCountryIsoCode["DO"] = "DO";
    TuiCountryIsoCode["DZ"] = "DZ";
    TuiCountryIsoCode["EC"] = "EC";
    TuiCountryIsoCode["EE"] = "EE";
    TuiCountryIsoCode["EG"] = "EG";
    TuiCountryIsoCode["ER"] = "ER";
    TuiCountryIsoCode["ES"] = "ES";
    TuiCountryIsoCode["ET"] = "ET";
    TuiCountryIsoCode["FI"] = "FI";
    TuiCountryIsoCode["FJ"] = "FJ";
    TuiCountryIsoCode["FK"] = "FK";
    TuiCountryIsoCode["FM"] = "FM";
    TuiCountryIsoCode["FR"] = "FR";
    TuiCountryIsoCode["GA"] = "GA";
    TuiCountryIsoCode["GB"] = "GB";
    TuiCountryIsoCode["GD"] = "GD";
    TuiCountryIsoCode["GE"] = "GE";
    TuiCountryIsoCode["GF"] = "GF";
    TuiCountryIsoCode["GH"] = "GH";
    TuiCountryIsoCode["GI"] = "GI";
    TuiCountryIsoCode["GL"] = "GL";
    TuiCountryIsoCode["GM"] = "GM";
    TuiCountryIsoCode["GN"] = "GN";
    TuiCountryIsoCode["GP"] = "GP";
    TuiCountryIsoCode["GQ"] = "GQ";
    TuiCountryIsoCode["GR"] = "GR";
    TuiCountryIsoCode["GT"] = "GT";
    TuiCountryIsoCode["GW"] = "GW";
    TuiCountryIsoCode["GY"] = "GY";
    TuiCountryIsoCode["HK"] = "HK";
    TuiCountryIsoCode["HN"] = "HN";
    TuiCountryIsoCode["HR"] = "HR";
    TuiCountryIsoCode["HT"] = "HT";
    TuiCountryIsoCode["HU"] = "HU";
    TuiCountryIsoCode["ID"] = "ID";
    TuiCountryIsoCode["IE"] = "IE";
    TuiCountryIsoCode["IL"] = "IL";
    TuiCountryIsoCode["IN"] = "IN";
    TuiCountryIsoCode["IQ"] = "IQ";
    TuiCountryIsoCode["IR"] = "IR";
    TuiCountryIsoCode["IS"] = "IS";
    TuiCountryIsoCode["IT"] = "IT";
    TuiCountryIsoCode["JM"] = "JM";
    TuiCountryIsoCode["JO"] = "JO";
    TuiCountryIsoCode["JP"] = "JP";
    TuiCountryIsoCode["KE"] = "KE";
    TuiCountryIsoCode["KG"] = "KG";
    TuiCountryIsoCode["KH"] = "KH";
    TuiCountryIsoCode["KM"] = "KM";
    TuiCountryIsoCode["KN"] = "KN";
    TuiCountryIsoCode["KP"] = "KP";
    TuiCountryIsoCode["KR"] = "KR";
    TuiCountryIsoCode["KW"] = "KW";
    TuiCountryIsoCode["KY"] = "KY";
    TuiCountryIsoCode["KZ"] = "KZ";
    TuiCountryIsoCode["LA"] = "LA";
    TuiCountryIsoCode["LB"] = "LB";
    TuiCountryIsoCode["LC"] = "LC";
    TuiCountryIsoCode["LI"] = "LI";
    TuiCountryIsoCode["LK"] = "LK";
    TuiCountryIsoCode["LR"] = "LR";
    TuiCountryIsoCode["LS"] = "LS";
    TuiCountryIsoCode["LT"] = "LT";
    TuiCountryIsoCode["LU"] = "LU";
    TuiCountryIsoCode["LV"] = "LV";
    TuiCountryIsoCode["LY"] = "LY";
    TuiCountryIsoCode["MA"] = "MA";
    TuiCountryIsoCode["MC"] = "MC";
    TuiCountryIsoCode["MD"] = "MD";
    TuiCountryIsoCode["ME"] = "ME";
    TuiCountryIsoCode["MF"] = "MF";
    TuiCountryIsoCode["MG"] = "MG";
    TuiCountryIsoCode["MK"] = "MK";
    TuiCountryIsoCode["ML"] = "ML";
    TuiCountryIsoCode["MM"] = "MM";
    TuiCountryIsoCode["MN"] = "MN";
    TuiCountryIsoCode["MO"] = "MO";
    TuiCountryIsoCode["MQ"] = "MQ";
    TuiCountryIsoCode["MR"] = "MR";
    TuiCountryIsoCode["MS"] = "MS";
    TuiCountryIsoCode["MT"] = "MT";
    TuiCountryIsoCode["MU"] = "MU";
    TuiCountryIsoCode["MV"] = "MV";
    TuiCountryIsoCode["MW"] = "MW";
    TuiCountryIsoCode["MX"] = "MX";
    TuiCountryIsoCode["MY"] = "MY";
    TuiCountryIsoCode["MZ"] = "MZ";
    TuiCountryIsoCode["NA"] = "NA";
    TuiCountryIsoCode["NC"] = "NC";
    TuiCountryIsoCode["NE"] = "NE";
    TuiCountryIsoCode["NG"] = "NG";
    TuiCountryIsoCode["NI"] = "NI";
    TuiCountryIsoCode["NL"] = "NL";
    TuiCountryIsoCode["NO"] = "NO";
    TuiCountryIsoCode["NP"] = "NP";
    TuiCountryIsoCode["NZ"] = "NZ";
    TuiCountryIsoCode["OM"] = "OM";
    TuiCountryIsoCode["PA"] = "PA";
    TuiCountryIsoCode["PE"] = "PE";
    TuiCountryIsoCode["PF"] = "PF";
    TuiCountryIsoCode["PG"] = "PG";
    TuiCountryIsoCode["PH"] = "PH";
    TuiCountryIsoCode["PK"] = "PK";
    TuiCountryIsoCode["PL"] = "PL";
    TuiCountryIsoCode["PT"] = "PT";
    TuiCountryIsoCode["PW"] = "PW";
    TuiCountryIsoCode["PY"] = "PY";
    TuiCountryIsoCode["QA"] = "QA";
    TuiCountryIsoCode["RE"] = "RE";
    TuiCountryIsoCode["RO"] = "RO";
    TuiCountryIsoCode["RS"] = "RS";
    TuiCountryIsoCode["RU"] = "RU";
    TuiCountryIsoCode["RW"] = "RW";
    TuiCountryIsoCode["SA"] = "SA";
    TuiCountryIsoCode["SB"] = "SB";
    TuiCountryIsoCode["SC"] = "SC";
    TuiCountryIsoCode["SD"] = "SD";
    TuiCountryIsoCode["SE"] = "SE";
    TuiCountryIsoCode["SG"] = "SG";
    TuiCountryIsoCode["SH"] = "SH";
    TuiCountryIsoCode["SI"] = "SI";
    TuiCountryIsoCode["SK"] = "SK";
    TuiCountryIsoCode["SL"] = "SL";
    TuiCountryIsoCode["SM"] = "SM";
    TuiCountryIsoCode["SN"] = "SN";
    TuiCountryIsoCode["SO"] = "SO";
    TuiCountryIsoCode["SR"] = "SR";
    TuiCountryIsoCode["ST"] = "ST";
    TuiCountryIsoCode["SV"] = "SV";
    TuiCountryIsoCode["SX"] = "SX";
    TuiCountryIsoCode["SY"] = "SY";
    TuiCountryIsoCode["SZ"] = "SZ";
    TuiCountryIsoCode["TC"] = "TC";
    TuiCountryIsoCode["TD"] = "TD";
    TuiCountryIsoCode["TG"] = "TG";
    TuiCountryIsoCode["TH"] = "TH";
    TuiCountryIsoCode["TJ"] = "TJ";
    TuiCountryIsoCode["TL"] = "TL";
    TuiCountryIsoCode["TM"] = "TM";
    TuiCountryIsoCode["TN"] = "TN";
    TuiCountryIsoCode["TO"] = "TO";
    TuiCountryIsoCode["TR"] = "TR";
    TuiCountryIsoCode["TT"] = "TT";
    TuiCountryIsoCode["TW"] = "TW";
    TuiCountryIsoCode["TZ"] = "TZ";
    TuiCountryIsoCode["UA"] = "UA";
    TuiCountryIsoCode["UG"] = "UG";
    TuiCountryIsoCode["UY"] = "UY";
    TuiCountryIsoCode["UZ"] = "UZ";
    TuiCountryIsoCode["VC"] = "VC";
    TuiCountryIsoCode["VE"] = "VE";
    TuiCountryIsoCode["VG"] = "VG";
    TuiCountryIsoCode["VN"] = "VN";
    TuiCountryIsoCode["VU"] = "VU";
    TuiCountryIsoCode["WS"] = "WS";
    TuiCountryIsoCode["XK"] = "XK";
    TuiCountryIsoCode["YE"] = "YE";
    TuiCountryIsoCode["YT"] = "YT";
    TuiCountryIsoCode["ZA"] = "ZA";
    TuiCountryIsoCode["ZM"] = "ZM";
    TuiCountryIsoCode["ZW"] = "ZW";
    TuiCountryIsoCode["US"] = "US";
    TuiCountryIsoCode["CA"] = "CA";
  })(TuiCountryIsoCode || (TuiCountryIsoCode = {}));
  return TuiCountryIsoCode;
})();
/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-i18n-enums.js.map

/***/ }),

/***/ 8345:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ty: () => (/* binding */ TUI_DEFAULT_LANGUAGE),
  Ho: () => (/* binding */ extractI18n)
});

// UNUSED EXPORTS: TUI_LANGUAGE, tuiExtractI18n

// EXTERNAL MODULE: consume shared module (default) @angular/core@=12.2.17 (strict) (singleton) (fallback: ./node_modules/@angular/core/fesm2015/core.js)
var core_js_ = __webpack_require__(8312);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/of.js
var of = __webpack_require__(5917);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Observable.js + 2 modules
var Observable = __webpack_require__(8891);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/util/isObservable.js

function isObservable(obj) {
  return !!obj && (obj instanceof Observable/* Observable */.y || typeof obj.lift === 'function' && typeof obj.subscribe === 'function');
}
//# sourceMappingURL=isObservable.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/switchMap.js
var switchMap = __webpack_require__(3190);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js
var map = __webpack_require__(8002);
// EXTERNAL MODULE: ./node_modules/@taiga-ui/i18n/fesm2015/taiga-ui-i18n-enums.js
var taiga_ui_i18n_enums = __webpack_require__(1081);
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/i18n/fesm2015/taiga-ui-i18n-languages-english.js

const TUI_ENGLISH_LANGUAGE_ADDON_COMMERCE = {
  cardNumber: [`Number`, `Card number`],
  cardExpiry: [`Expires`, `Valid through`]
};
const TUI_ENGLISH_LANGUAGE_ADDON_EDITOR = {
  colorSelectorModeNames: [`Solid color`, `Gradient`],
  toolbarTools: {
    undo: `Undo`,
    redo: `Redo`,
    font: `Font`,
    fontStyle: `Font style`,
    fontSize: `Font size`,
    bold: `Bold`,
    italic: `Italic`,
    underline: `Underline`,
    strikeThrough: `Strike through`,
    justify: `Justify`,
    justifyLeft: `Justify left`,
    justifyCenter: `Justify center`,
    justifyRight: `Justify right`,
    justifyFull: `Justify full`,
    list: `List`,
    indent: `Indent`,
    outdent: `Outdent`,
    unorderedList: `Unordered list`,
    orderedList: `Ordered list`,
    quote: `Quote`,
    foreColor: `Color`,
    backColor: `Background color`,
    hiliteColor: `Highlight color`,
    clear: `Clear`,
    link: `Link`,
    attach: `Attach file`,
    tex: `Insert TeX`,
    code: `Code`,
    image: `Insert image`,
    insertHorizontalRule: `Insert horizontal rule`,
    superscript: `Superscript`,
    subscript: `Subscript`,
    insertTable: `Insert table`,
    insertGroup: `Insert group`,
    removeGroup: `Remove group`,
    insertAnchor: `Insert anchor`,
    mergeCells: `Merge cells`,
    splitCells: `Split cells`,
    rowsColumnsManaging: `Managing rows and columns`,
    cellColor: `Cell color`,
    setDetails: `Details`,
    removeDetails: `Remove details`
  },
  editorEditLink: {
    urlExample: `example.com`,
    anchorExample: `anchor`
  },
  editorTableCommands: [[`Insert column before`, `Insert column after`], [`Insert row before`, `Insert row after`], [`Delete column`, `Delete row`]],
  editorCodeOptions: [`Code in the text`, `Code in block`],
  editorFontOptions: {
    small: `Small`,
    large: `Large`,
    normal: `Normal`,
    title: `Title`,
    subtitle: `Subtitle`
  }
};
const TUI_ENGLISH_LANGUAGE_ADDON_PREVIEW = {
  previewTexts: {
    rotate: `Rotate`
  },
  zoomTexts: {
    zoomOut: `Zoom out`,
    zoomIn: `Zoom in`,
    reset: `Reset`
  }
};
const TUI_ENGLISH_LANGUAGE_ADDON_TABLE = {
  showHideText: `Show/Hide`,
  paginationTexts: {
    pages: `Pages`,
    linesPerPage: `Lines per page`,
    of: `of`
  }
};
const TUI_ENGLISH_LANGUAGE_COUNTRIES = {
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AD]: `Andorra`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AE]: `United Arab Emirates`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AF]: `Afghanistan`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AG]: `Antigua and Barbuda`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BL]: `Saint Barthélemy`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AI]: `Anguilla`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AL]: `Albania`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AM]: `Armenia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AO]: `Angola`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AR]: `Argentina`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AT]: `Austria`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AU]: `Australia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AW]: `Aruba`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.AZ]: `Azerbaijan`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BA]: `Bosnia and Herzegovina`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BB]: `Barbados`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BD]: `Bangladesh`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BE]: `Belgium`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BF]: `Burkina Faso`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BG]: `Bulgaria`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BH]: `Bahrain`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BI]: `Burundi`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BJ]: `Benin`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GF]: `Guyana`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BM]: `Bermuda`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BN]: `Brunei Darussalam`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BO]: `Bolivia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BQ]: `Bonaire, Sint Eustatius and Saba`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BR]: `Brazil`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BS]: `Bahamas`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BT]: `Bhutan`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BW]: `Botswana`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BY]: `Belarus`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.BZ]: `Belize`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CA]: `Canada`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CD]: `Dem. Rep. Congo (Kinshasa)`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CF]: `Central African Republic`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CG]: `Congo (Brazzaville)`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CH]: `Switzerland`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CI]: `Ivory Coast`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CL]: `Chile`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CM]: `Cameroon`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CN]: `China`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CO]: `Colombia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CR]: `Costa Rica`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CU]: `Cuba`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CV]: `Cape Verde`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CW]: `Curaçao`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CY]: `Cyprus`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.CZ]: `Czech Republic`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.DE]: `Germany`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.DJ]: `Djibouti`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.DK]: `Denmark`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.DM]: `Dominica`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.DO]: `Dominican Republic`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.DZ]: `Algeria`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.EC]: `Ecuador`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.EE]: `Estonia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.EG]: `Egypt`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.ER]: `Eritrea`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.ES]: `Spain`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.ET]: `Ethiopia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.FI]: `Finland`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.FJ]: `Fiji`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.FK]: `Falkland Islands`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.FM]: `F.S. of Micronesia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.FR]: `France`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GA]: `Gabon`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GB]: `United Kingdom`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GD]: `Grenada`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GE]: `Georgia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GP]: `Guadeloupe`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GH]: `Ghana`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GI]: `Gibraltar`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GL]: `Greenland`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GM]: `Gambia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GN]: `Guinea`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MF]: `Saint-Martin`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GQ]: `Equatorial Guinea`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GR]: `Greece`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GT]: `Guatemala`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GW]: `Guinea-Bissau`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.GY]: `Guyana`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.HK]: `Hong Kong`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.HN]: `Honduras`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.HR]: `Croatia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.HT]: `Haiti`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.HU]: `Hungary`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.ID]: `Indonesia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.IE]: `Ireland`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.IL]: `Israel`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.IN]: `India`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.IQ]: `Iraq`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.IR]: `Iran`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.IS]: `Iceland`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.IT]: `Italy`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.JM]: `Jamaica`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.JO]: `Jordan`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.JP]: `Japan`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.KE]: `Kenya`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.KG]: `Kyrgyzstan`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.KH]: `Cambodia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.KM]: `Comoros`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.KN]: `Saint Kitts and Nevis`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.KP]: `Korean PDR`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.KR]: `Rep. Korea`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.KW]: `Kuwait`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.KY]: `Cayman Islands`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.KZ]: `Kazakhstan`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LA]: `Laos`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LB]: `Lebanon`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LC]: `Saint Lucia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LI]: `Liechtenstein`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LK]: `Sri Lanka`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LR]: `Liberia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LS]: `Lesotho`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LT]: `Lithuania`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LU]: `Luxembourg`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LV]: `Latvia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.LY]: `Libya`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MA]: `Morocco`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MC]: `Monaco`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MD]: `Moldova`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.ME]: `Montenegro`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MQ]: `Martinique`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MG]: `Madagascar`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MK]: `Rep. of North Macedonia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.ML]: `Mali`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MM]: `Burma (Myanmar)`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MN]: `Mongolia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MO]: `Macau`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.RE]: `Réunion`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MR]: `Mauritania`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MS]: `Montserrat`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MT]: `Malta`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MU]: `Mauritius`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MV]: `Maldives`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MW]: `Malawi`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MX]: `Mexico`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MY]: `Malaysia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.MZ]: `Mozambique`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.NA]: `Namibia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.NC]: `New Caledonia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.NE]: `Niger`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.NG]: `Nigeria`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.NI]: `Nicaragua`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.NL]: `Netherlands`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.NO]: `Norway`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.NP]: `Nepal`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.NZ]: `New Zealand`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.OM]: `Oman`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PA]: `Panama`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PE]: `Peru`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PF]: `French Polynesia (Tahiti)`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PG]: `Papua New Guinea`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PH]: `Philippines`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PK]: `Pakistan`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PL]: `Poland`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PT]: `Portugal`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PW]: `Palau`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.PY]: `Paraguay`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.QA]: `Qatar`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.YT]: `Mayotte`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.RO]: `Romania`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.RS]: `Serbia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.RU]: `Russia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.RW]: `Rwanda`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SA]: `Saudi Arabia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SB]: `Solomon Islands`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SC]: `Seychelles`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SD]: `Sudan`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SE]: `Sweden`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SG]: `Singapore`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SH]: `Saint Helena`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SI]: `Slovenia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SK]: `Slovakia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SL]: `Sierra Leone`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SM]: `San Marino`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SN]: `Senegal`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SO]: `Somalia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SR]: `Suriname`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.ST]: `Sao Tome and Principe`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SV]: `El Salvador`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SX]: `Sint Maarten`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SY]: `Syrian Arab Republic`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.SZ]: `Swaziland`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TC]: `Turks and Caicos`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TD]: `Chad`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TG]: `Togo`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TH]: `Thailand`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TJ]: `Tajikistan`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TL]: `East Timor`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TM]: `Turkmenistan`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TN]: `Tunisia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TO]: `Tonga`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TR]: `Turkey`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TT]: `Trinidad and Tobago`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TW]: `Taiwan`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.TZ]: `Tanzania`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.UA]: `Ukraine`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.UG]: `Uganda`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.US]: `USA`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.UY]: `Uruguay`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.UZ]: `Uzbekistan`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.VC]: `Saint Vincent and the Grenadines`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.VE]: `Venezuela`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.VG]: `British Virgin Islands`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.VN]: `Vietnam`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.VU]: `Vanuatu`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.WS]: `Samoa`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.XK]: `Kosovo`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.YE]: `Yemen`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.ZA]: `South Africa`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.ZM]: `Zambia`,
  [taiga_ui_i18n_enums/* TuiCountryIsoCode */.X.ZW]: `Zimbabwe`
};
const TUI_ENGLISH_LANGUAGE_CORE = {
  months: [`January`, `February`, `March`, `April`, `May`, `June`, `July`, `August`, `September`, `October`, `November`, `December`],
  close: `Close`,
  nothingFoundMessage: `Nothing found`,
  defaultErrorMessage: `Value is invalid`,
  spinTexts: [`Previous`, `Next`],
  shortWeekDays: [`Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat`, `Sun`],
  countries: TUI_ENGLISH_LANGUAGE_COUNTRIES
};
const TUI_ENGLISH_LANGUAGE_KIT = {
  cancel: `Cancel`,
  done: `Done`,
  more: `More`,
  otherDate: `Other date...`,
  showAll: `Show all`,
  hide: `Hide`,
  mobileCalendarTexts: [`Choose day`, `Choose range`],
  range: [`from`, `to`],
  countTexts: [`Plus`, `Minus`],
  time: {
    'HH:MM': `HH:MM`,
    'HH:MM:SS': `HH:MM:SS`,
    'HH:MM:SS.MSS': `HH:MM:SS.MSS`
  },
  dateTexts: {
    DMY: `dd.mm.yyyy`,
    MDY: `mm.dd.yyyy`,
    YMD: `yyyy.mm.dd`
  },
  digitalInformationUnits: [`B`, `KiB`, `MiB`],
  passwordTexts: [`Show password`, `Hide password`],
  copyTexts: [`Copy`, `Copied`],
  shortCalendarMonths: [`Jan`, `Feb`, `Mar`, `Apr`, `May`, `Jun`, `Jul`, `Aug`, `Sep`, `Oct`, `Nov`, `Dec`],
  pagination: [`Previous page`, `Next page`],
  fileTexts: {
    loadingError: `Upload failed`,
    preview: `Preview`,
    remove: `Remove`
  },
  inputFileTexts: {
    defaultLabelSingle: `or drop\u00A0it\u00A0here`,
    defaultLabelMultiple: `or drop\u00A0them\u00A0here`,
    defaultLinkSingle: `Choose a file`,
    defaultLinkMultiple: `Choose files`,
    maxSizeRejectionReason: `File is too large `,
    formatRejectionReason: `Wrong file type`,
    drop: `Drop file here`,
    dropMultiple: `Drop files here`
  }
};
const TUI_ENGLISH_LANGUAGE = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
  name: `english`
}, TUI_ENGLISH_LANGUAGE_CORE), TUI_ENGLISH_LANGUAGE_KIT), TUI_ENGLISH_LANGUAGE_ADDON_TABLE), TUI_ENGLISH_LANGUAGE_ADDON_COMMERCE), TUI_ENGLISH_LANGUAGE_ADDON_EDITOR), TUI_ENGLISH_LANGUAGE_ADDON_PREVIEW);

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-i18n-languages-english.js.map
;// CONCATENATED MODULE: ./node_modules/@taiga-ui/i18n/fesm2015/taiga-ui-i18n-tools.js





// TODO: move to @taiga-ui/i18n/tokens in v3.0
const TUI_DEFAULT_LANGUAGE = new core_js_.InjectionToken(`Default Language for Taiga UI libraries i18n`, {
  factory: () => TUI_ENGLISH_LANGUAGE
});
// TODO: move to @taiga-ui/i18n/tokens in v3.0
const TUI_LANGUAGE = new core_js_.InjectionToken(`Language for Taiga UI libraries i18n`, {
  factory: () => (0,of.of)((0,core_js_.inject)(TUI_DEFAULT_LANGUAGE))
});

/**
 * @deprecated: use {@link tuiExtractI18n} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function extractI18n(key) {
  return () => (0,core_js_.inject)(TUI_LANGUAGE).pipe((0,switchMap/* switchMap */.w)(streamOrValue => isObservable(streamOrValue) ? streamOrValue : (0,of.of)(streamOrValue)), (0,map/* map */.U)(lang => lang[key]));
}
const tuiExtractI18n = (/* unused pure expression or super */ null && (extractI18n));

/**
 * Generated bundle index. Do not edit.
 */



//# sourceMappingURL=taiga-ui-i18n-tools.js.map

/***/ }),

/***/ 9570:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Al: () => (/* binding */ PolymorpheusComponent),
/* harmony export */   GL: () => (/* binding */ PolymorpheusTemplate),
/* harmony export */   r1: () => (/* binding */ PolymorpheusOutletComponent),
/* harmony export */   wq: () => (/* binding */ PolymorpheusModule),
/* harmony export */   yf: () => (/* binding */ POLYMORPHEUS_CONTEXT)
/* harmony export */ });
/* unused harmony export ɵa */
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8312);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3008);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_1__);



/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Use this token to access context within your components when
 * instantiating them through {\@link PolymorpheusOutletComponent}
 * @type {?}
 */


const _c0 = ["polymorpheus-outlet", ""];
function PolymorpheusOutletComponent_ng_container_0_ng_template_1_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainer"](0, 5);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpipe"](1, "injector");
  }
  if (rf & 2) {
    const ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngComponentOutlet", ctx_r4.content.component)("ngComponentOutletInjector", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpipeBind2"](1, 2, ctx_r4.content, ctx_r4.proxy));
  }
}
function PolymorpheusOutletComponent_ng_container_0_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, PolymorpheusOutletComponent_ng_container_0_ng_template_1_ng_container_0_Template, 2, 5, "ng-container", 4);
  }
  if (rf & 2) {
    const ctx_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r3.guard(ctx_r3.content));
  }
}
function PolymorpheusOutletComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0, 2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, PolymorpheusOutletComponent_ng_container_0_ng_template_1_Template, 1, 1, "ng-template", null, 3, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const _r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](2);
    const ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", ctx_r0.getTemplate(ctx_r0.content, _r2))("ngTemplateOutletContext", ctx_r0.context);
  }
}
function PolymorpheusOutletComponent_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const ctx_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx_r5.primitive);
  }
}
const _c1 = function (a0) {
  return {
    $implicit: a0
  };
};
function PolymorpheusOutletComponent_ng_container_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainer"](0, 2);
  }
  if (rf & 2) {
    const ctx_r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", ctx_r7.template)("ngTemplateOutletContext", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction1"](2, _c1, ctx_r7.primitive));
  }
}
function PolymorpheusOutletComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, PolymorpheusOutletComponent_ng_container_1_ng_container_1_Template, 2, 1, "ng-container", 6);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, PolymorpheusOutletComponent_ng_container_1_ng_template_2_Template, 1, 4, "ng-template", null, 7, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
  }
  if (rf & 2) {
    const _r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](3);
    const ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !ctx_r1.template)("ngIfElse", _r6);
  }
}
const POLYMORPHEUS_CONTEXT = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('Context from polymorpheus-outlet');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Wrapper class for a component that will be used as content for {\@link PolymorpheusOutletComponent}
 *
 * @param component — an Angular component to be dynamically created
 * @param injector — optional {\@link Injector} for lazy loaded module case
 * @template T, C
 */
class PolymorpheusComponent {
  /**
   * @param {?} component
   * @param {?=} injector
   */
  constructor(component, injector = null) {
    this.component = component;
    this.injector = injector;
  }
  /**
   * @param {?} injector
   * @param {?} context
   * @return {?}
   */
  createInjector(injector, context) {
    return _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector.create({
      parent: this.injector || injector,
      providers: [{
        provide: POLYMORPHEUS_CONTEXT,
        useValue: context
      }]
    });
  }
}
if (false) {}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * ng-template wrapper directive also stores {\@link ChangeDetectorRef} to properly handle change detection.
 * @template C
 */
let PolymorpheusTemplate = /*#__PURE__*/(() => {
  class PolymorpheusTemplate {
    /**
     * @param {?} template
     * @param {?} changeDetectorRef
     */
    constructor(template, changeDetectorRef) {
      this.template = template;
      this.changeDetectorRef = changeDetectorRef;
      this.polymorpheus = '';
    }
    /**
     * @return {?}
     */
    check() {
      this.changeDetectorRef.markForCheck();
    }
    /**
     * @template T
     * @param {?} _dir
     * @param {?} _ctx
     * @return {?}
     */
    static ngTemplateContextGuard(_dir, _ctx) {
      return true;
    }
  }
  PolymorpheusTemplate.ɵfac = function PolymorpheusTemplate_Factory(t) {
    return new (t || PolymorpheusTemplate)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef, 2), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef));
  };
  PolymorpheusTemplate.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
    type: PolymorpheusTemplate,
    selectors: [["ng-template", "polymorpheus", ""]],
    inputs: {
      polymorpheus: "polymorpheus"
    },
    exportAs: ["polymorpheus"]
  });
  /** @nocollapse */
  return PolymorpheusTemplate;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
if (false) {}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Outlet instantiating {\@link PolymorpheusContent} with given context
 * @template C
 */
let PolymorpheusOutletComponent = /*#__PURE__*/(() => {
  class PolymorpheusOutletComponent {
    constructor() {
      this.template = null;
      this.content = null;
    }
    /**
     * @return {?}
     */
    get primitive() {
      if (!this.content || this.isAdvanced(this.content)) {
        return '';
      }
      return typeof this.content === 'function' ? this.content(this.context) : this.content;
    }
    /**
     * @param {?} content
     * @return {?}
     */
    isAdvanced(content) {
      return isTemplate(content) || isComponent(content);
    }
    /**
     * @param {?} content
     * @param {?} componentTmp
     * @return {?}
     */
    getTemplate(content, componentTmp) {
      if (isComponent(content)) {
        return componentTmp;
      }
      return isDirective(content) ? content.template : content;
    }
    /**
     * @param {?} content
     * @return {?}
     */
    guard(content) {
      return isComponent(content);
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    ngOnChanges({
      content,
      context
    }) {
      if (context && this.proxy === undefined) {
        this.proxy = typeof this.context === 'object' && !Array.isArray(this.context) ? new Proxy(this.context, {
          get: (_, key) => this.context[/** @type {?} */key]
        }) : this.context;
      }
      // TODO: Keep an eye on private field, name can change
      /** @type {?} */
      const componentRef = /** @type {?} */!content && context && this.outlet && this.outlet['_componentRef'];
      if (componentRef) {
        componentRef.injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef).markForCheck();
      }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
      if (isDirective(this.content)) {
        this.content.check();
      }
    }
  }
  PolymorpheusOutletComponent.ɵfac = function PolymorpheusOutletComponent_Factory(t) {
    return new (t || PolymorpheusOutletComponent)();
  };
  PolymorpheusOutletComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: PolymorpheusOutletComponent,
    selectors: [["", "polymorpheus-outlet", ""]],
    contentQueries: function PolymorpheusOutletComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵcontentQuery"](dirIndex, _angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef, 5);
      }
      if (rf & 2) {
        let _t;
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.template = _t.first);
      }
    },
    viewQuery: function PolymorpheusOutletComponent_Query(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgComponentOutlet, 5);
      }
      if (rf & 2) {
        let _t;
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.outlet = _t.first);
      }
    },
    inputs: {
      content: "content",
      context: "context"
    },
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
    attrs: _c0,
    decls: 2,
    vars: 2,
    consts: [[3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["component", ""], [3, "ngComponentOutlet", "ngComponentOutletInjector", 4, "ngIf"], [3, "ngComponentOutlet", "ngComponentOutletInjector"], [4, "ngIf", "ngIfElse"], ["child", ""]],
    template: function PolymorpheusOutletComponent_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, PolymorpheusOutletComponent_ng_container_0_Template, 3, 2, "ng-container", 0);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, PolymorpheusOutletComponent_ng_container_1_Template, 4, 2, "ng-container", 1);
      }
      if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.isAdvanced(ctx.content));
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.primitive);
      }
    },
    directives: function () {
      return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgTemplateOutlet, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgComponentOutlet];
    },
    pipes: function () {
      return [InjectorPipe];
    },
    encapsulation: 2,
    changeDetection: 0
  });
  return PolymorpheusOutletComponent;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
if (false) {}
/**
 * @template C
 * @param {?} content
 * @return {?}
 */
function isDirective(content) {
  return content instanceof PolymorpheusTemplate;
}
/**
 * @template C
 * @param {?} content
 * @return {?}
 */
function isComponent(content) {
  return content instanceof PolymorpheusComponent;
}
/**
 * @template C
 * @param {?} content
 * @return {?}
 */
function isTemplate(content) {
  return isDirective(content) || content instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Internal use {\@link Pipe} to create {\@link Injector}
 * only when either content or context change
 * @template C
 */
let InjectorPipe = /*#__PURE__*/(() => {
  class InjectorPipe {
    /**
     * @param {?} injector
     */
    constructor(injector) {
      this.injector = injector;
    }
    /**
     * @param {?} content
     * @param {?} context
     * @return {?}
     */
    transform(content, context) {
      return content.createInjector(this.injector, context);
    }
  }
  InjectorPipe.ɵfac = function InjectorPipe_Factory(t) {
    return new (t || InjectorPipe)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector, 16));
  };
  InjectorPipe.ɵpipe = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefinePipe"]({
    name: "injector",
    type: InjectorPipe,
    pure: true
  });
  /** @nocollapse */
  return InjectorPipe;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
if (false) {}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
let PolymorpheusModule = /*#__PURE__*/(() => {
  class PolymorpheusModule {}
  PolymorpheusModule.ɵfac = function PolymorpheusModule_Factory(t) {
    return new (t || PolymorpheusModule)();
  };
  PolymorpheusModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
    type: PolymorpheusModule
  });
  PolymorpheusModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
    imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule]]
  });
  return PolymorpheusModule;
})();
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](PolymorpheusModule, {
    declarations: function () {
      return [PolymorpheusOutletComponent, PolymorpheusTemplate, InjectorPipe];
    },
    imports: function () {
      return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule];
    },
    exports: function () {
      return [PolymorpheusOutletComponent, PolymorpheusTemplate];
    }
  });
})();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */



//# sourceMappingURL=tinkoff-ng-polymorpheus.js.map

/***/ }),

/***/ 1120:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
var core_1 = __webpack_require__(8312);
var forms_1 = __webpack_require__(3738);
var platform_browser_1 = __webpack_require__(1211);
var textMaskCore_1 = __webpack_require__(2775);
var ɵngcc0 = __webpack_require__(8312);
var TextMaskConfig = /** @class */function () {
  function TextMaskConfig() {}
  return TextMaskConfig;
}();
__webpack_unused_export__ = TextMaskConfig;
exports.wR = {
  provide: forms_1.NG_VALUE_ACCESSOR,
  useExisting: core_1.forwardRef(function () {
    return MaskedInputDirective;
  }),
  multi: true
};
/**
 * We must check whether the agent is Android because composition events
 * behave differently between iOS and Android.
 */
function _isAndroid() {
  var userAgent = platform_browser_1.ɵgetDOM() ? platform_browser_1.ɵgetDOM().getUserAgent() : '';
  return /android (\d+)/.test(userAgent.toLowerCase());
}
var MaskedInputDirective = /** @class */function () {
  function MaskedInputDirective(_renderer, _elementRef, _compositionMode) {
    this._renderer = _renderer;
    this._elementRef = _elementRef;
    this._compositionMode = _compositionMode;
    this.textMaskConfig = {
      mask: [],
      guide: true,
      placeholderChar: '_',
      pipe: undefined,
      keepCharPositions: false
    };
    this.onChange = function (_) {};
    this.onTouched = function () {};
    /** Whether the user is creating a composition string (IME events). */
    this._composing = false;
    if (this._compositionMode == null) {
      this._compositionMode = !_isAndroid();
    }
  }
  MaskedInputDirective.prototype.ngOnChanges = function (changes) {
    this._setupMask(true);
    if (this.textMaskInputElement !== undefined) {
      this.textMaskInputElement.update(this.inputElement.value);
    }
  };
  MaskedInputDirective.prototype.writeValue = function (value) {
    this._setupMask();
    // set the initial value for cases where the mask is disabled
    var normalizedValue = value == null ? '' : value;
    this._renderer.setProperty(this.inputElement, 'value', normalizedValue);
    if (this.textMaskInputElement !== undefined) {
      this.textMaskInputElement.update(value);
    }
  };
  MaskedInputDirective.prototype.registerOnChange = function (fn) {
    this.onChange = fn;
  };
  MaskedInputDirective.prototype.registerOnTouched = function (fn) {
    this.onTouched = fn;
  };
  MaskedInputDirective.prototype.setDisabledState = function (isDisabled) {
    this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
  };
  MaskedInputDirective.prototype._handleInput = function (value) {
    if (!this._compositionMode || this._compositionMode && !this._composing) {
      this._setupMask();
      if (this.textMaskInputElement !== undefined) {
        this.textMaskInputElement.update(value);
        // get the updated value
        value = this.inputElement.value;
        this.onChange(value);
      }
    }
  };
  MaskedInputDirective.prototype._setupMask = function (create) {
    if (create === void 0) {
      create = false;
    }
    if (!this.inputElement) {
      if (this._elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {
        // `textMask` directive is used directly on an input element
        this.inputElement = this._elementRef.nativeElement;
      } else {
        // `textMask` directive is used on an abstracted input element, `md-input-container`, etc
        this.inputElement = this._elementRef.nativeElement.getElementsByTagName('INPUT')[0];
      }
    }
    if (this.inputElement && create) {
      this.textMaskInputElement = textMaskCore_1.createTextMaskInputElement(Object.assign({
        inputElement: this.inputElement
      }, this.textMaskConfig));
    }
  };
  MaskedInputDirective.prototype._compositionStart = function () {
    this._composing = true;
  };
  MaskedInputDirective.prototype._compositionEnd = function (value) {
    this._composing = false;
    this._compositionMode && this._handleInput(value);
  };
  /** @nocollapse */
  MaskedInputDirective.ctorParameters = function () {
    return [{
      type: core_1.Renderer2
    }, {
      type: core_1.ElementRef
    }, {
      type: undefined,
      decorators: [{
        type: core_1.Optional
      }, {
        type: core_1.Inject,
        args: [forms_1.COMPOSITION_BUFFER_MODE]
      }]
    }];
  };
  MaskedInputDirective.propDecorators = {
    'textMaskConfig': [{
      type: core_1.Input,
      args: ['textMask']
    }]
  };
  MaskedInputDirective.ɵfac = function MaskedInputDirective_Factory(t) {
    return new (t || MaskedInputDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(forms_1.COMPOSITION_BUFFER_MODE, 8));
  };
  MaskedInputDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({
    type: MaskedInputDirective,
    selectors: [["", "textMask", ""]],
    hostBindings: function MaskedInputDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵngcc0.ɵɵlistener("input", function MaskedInputDirective_input_HostBindingHandler($event) {
          return ctx._handleInput($event.target.value);
        })("blur", function MaskedInputDirective_blur_HostBindingHandler() {
          return ctx.onTouched();
        })("compositionstart", function MaskedInputDirective_compositionstart_HostBindingHandler() {
          return ctx._compositionStart();
        })("compositionend", function MaskedInputDirective_compositionend_HostBindingHandler($event) {
          return ctx._compositionEnd($event.target.value);
        });
      }
    },
    inputs: {
      textMaskConfig: ["textMask", "textMaskConfig"]
    },
    exportAs: ["textMask"],
    features: [ɵngcc0.ɵɵProvidersFeature([exports.wR]), ɵngcc0.ɵɵNgOnChangesFeature]
  });
  (function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
  })();
  return MaskedInputDirective;
}();
exports.hd = MaskedInputDirective;
var TextMaskModule = /** @class */function () {
  function TextMaskModule() {}
  /** @nocollapse */
  TextMaskModule.ctorParameters = function () {
    return [];
  };
  TextMaskModule.ɵfac = function TextMaskModule_Factory(t) {
    return new (t || TextMaskModule)();
  };
  TextMaskModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({
    type: TextMaskModule
  });
  TextMaskModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});
  (function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && void 0;
  })();
  (function () {
    (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TextMaskModule, {
      declarations: [MaskedInputDirective],
      exports: [MaskedInputDirective]
    });
  })();
  return TextMaskModule;
}();
exports.QA = TextMaskModule;
var textMaskCore_2 = __webpack_require__(2775);
__webpack_unused_export__ = textMaskCore_2.conformToMask;

//# sourceMappingURL=angular2TextMask.js.map

/***/ }),

/***/ 5622:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


////////////////////////////////////////////////////////////////////////////////
// Helpers

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function (source) {
    if (!source) {
      return;
    }
    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === '[object String]';
}
function isObject(obj) {
  return _class(obj) === '[object Object]';
}
function isRegExp(obj) {
  return _class(obj) === '[object RegExp]';
}
function isFunction(obj) {
  return _class(obj) === '[object Function]';
}
function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////

var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function (acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}
var defaultSchemas = {
  'http:': {
    validate: function (text, pos, self) {
      var tail = text.slice(pos);
      if (!self.re.http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.http = new RegExp('^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i');
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length;
      }
      return 0;
    }
  },
  'https:': 'http:',
  'ftp:': 'http:',
  '//': {
    validate: function (text, pos, self) {
      var tail = text.slice(pos);
      if (!self.re.no_http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.no_http = new RegExp('^' + self.re.src_auth +
        // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' + self.re.src_port + self.re.src_host_terminator + self.re.src_path, 'i');
      }
      if (self.re.no_http.test(tail)) {
        // should not be `://` & `///`, that protects from errors in protocol name
        if (pos >= 3 && text[pos - 3] === ':') {
          return 0;
        }
        if (pos >= 3 && text[pos - 3] === '/') {
          return 0;
        }
        return tail.match(self.re.no_http)[0].length;
      }
      return 0;
    }
  },
  'mailto:': {
    validate: function (text, pos, self) {
      var tail = text.slice(pos);
      if (!self.re.mailto) {
        self.re.mailto = new RegExp('^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i');
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length;
      }
      return 0;
    }
  }
};

/*eslint-disable max-len*/

// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';

// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');

/*eslint-enable max-len*/

////////////////////////////////////////////////////////////////////////////////

function resetScanCache(self) {
  self.__index__ = -1;
  self.__text_cache__ = '';
}
function createValidator(re) {
  return function (text, pos) {
    var tail = text.slice(pos);
    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}
function createNormalizer() {
  return function (match, self) {
    self.normalize(match);
  };
}

// Schemas compiler. Build regexps.
//
function compile(self) {
  // Load & clone RE patterns.
  var re = self.re = __webpack_require__(6249)(self.__opts__);

  // Define dynamic patterns
  var tlds = self.__tlds__.slice();
  self.onCompile();
  if (!self.__tlds_replaced__) {
    tlds.push(tlds_2ch_src_re);
  }
  tlds.push(re.src_xn);
  re.src_tlds = tlds.join('|');
  function untpl(tpl) {
    return tpl.replace('%TLDS%', re.src_tlds);
  }
  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), 'i');
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), 'i');
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');

  //
  // Compile each schema
  //

  var aliases = [];
  self.__compiled__ = {}; // Reset compiled data

  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }
  Object.keys(self.__schemas__).forEach(function (name) {
    var val = self.__schemas__[name];

    // skip disabled methods
    if (val === null) {
      return;
    }
    var compiled = {
      validate: null,
      link: null
    };
    self.__compiled__[name] = compiled;
    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }
      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }
      return;
    }
    if (isString(val)) {
      aliases.push(name);
      return;
    }
    schemaError(name, val);
  });

  //
  // Compile postponed aliases
  //

  aliases.forEach(function (alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      // Silently fail on missed schemas to avoid errons on disable.
      // schemaError(alias, self.__schemas__[alias]);
      return;
    }
    self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
  });

  //
  // Fake record for guessed links
  //
  self.__compiled__[''] = {
    validate: null,
    normalize: createNormalizer()
  };

  //
  // Build schema condition
  //
  var slist = Object.keys(self.__compiled__).filter(function (name) {
    // Filter disabled & fake schemas
    return name.length > 0 && self.__compiled__[name];
  }).map(escapeRE).join('|');
  // (?!_) cause 1.5x slowdown
  self.re.schema_test = RegExp('(^|(?!_)(?:[><\uff5c]|' + re.src_ZPCc + '))(' + slist + ')', 'i');
  self.re.schema_search = RegExp('(^|(?!_)(?:[><\uff5c]|' + re.src_ZPCc + '))(' + slist + ')', 'ig');
  self.re.pretest = RegExp('(' + self.re.schema_test.source + ')|(' + self.re.host_fuzzy_test.source + ')|@', 'i');

  //
  // Cleanup
  //

  resetScanCache(self);
}

/**
 * class Match
 *
 * Match result. Single element of array, returned by [[LinkifyIt#match]]
 **/
function Match(self, shift) {
  var start = self.__index__,
    end = self.__last_index__,
    text = self.__text_cache__.slice(start, end);

  /**
   * Match#schema -> String
   *
   * Prefix (protocol) for matched string.
   **/
  this.schema = self.__schema__.toLowerCase();
  /**
   * Match#index -> Number
   *
   * First position of matched string.
   **/
  this.index = start + shift;
  /**
   * Match#lastIndex -> Number
   *
   * Next position after matched string.
   **/
  this.lastIndex = end + shift;
  /**
   * Match#raw -> String
   *
   * Matched string.
   **/
  this.raw = text;
  /**
   * Match#text -> String
   *
   * Notmalized text of matched string.
   **/
  this.text = text;
  /**
   * Match#url -> String
   *
   * Normalized url of matched string.
   **/
  this.url = text;
}
function createMatch(self, shift) {
  var match = new Match(self, shift);
  self.__compiled__[match.schema].normalize(match, self);
  return match;
}

/**
 * class LinkifyIt
 **/

/**
 * new LinkifyIt(schemas, options)
 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Creates new linkifier instance with optional additional schemas.
 * Can be called without `new` keyword for convenience.
 *
 * By default understands:
 *
 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
 * - "fuzzy" links and emails (example.com, foo@bar.com).
 *
 * `schemas` is an object, where each key/value describes protocol/rule:
 *
 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
 *   for example). `linkify-it` makes shure that prefix is not preceeded with
 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
 * - __value__ - rule to check tail after link prefix
 *   - _String_ - just alias to existing rule
 *   - _Object_
 *     - _validate_ - validator function (should return matched length on success),
 *       or `RegExp`.
 *     - _normalize_ - optional function to normalize text & url of matched result
 *       (for example, for @twitter mentions).
 *
 * `options`:
 *
 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
 *   like version numbers. Default `false`.
 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
 *
 **/
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }
  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }
  this.__opts__ = assign({}, defaultOptions, options);

  // Cache last tested result. Used to skip repeating steps on next `match` call.
  this.__index__ = -1;
  this.__last_index__ = -1; // Next scan position
  this.__schema__ = '';
  this.__text_cache__ = '';
  this.__schemas__ = assign({}, defaultSchemas, schemas);
  this.__compiled__ = {};
  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;
  this.re = {};
  compile(this);
}

/** chainable
 * LinkifyIt#add(schema, definition)
 * - schema (String): rule name (fixed pattern prefix)
 * - definition (String|RegExp|Object): schema definition
 *
 * Add new rule definition. See constructor description for details.
 **/
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};

/** chainable
 * LinkifyIt#set(options)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Set recognition options for links without schema.
 **/
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};

/**
 * LinkifyIt#test(text) -> Boolean
 *
 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
 **/
LinkifyIt.prototype.test = function test(text) {
  // Reset scan cache
  this.__text_cache__ = text;
  this.__index__ = -1;
  if (!text.length) {
    return false;
  }
  var m, ml, me, len, shift, next, re, tld_pos, at_pos;

  // try to scan for link with schema - that's the most simple rule
  if (this.re.schema_test.test(text)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text)) !== null) {
      len = this.testSchemaAt(text, m[2], re.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }
  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
    // guess schemaless links
    tld_pos = text.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      // if tld is located after found link - no need to check fuzzy pattern
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
          shift = ml.index + ml[1].length;
          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = '';
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }
  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
    // guess schemaless emails
    at_pos = text.indexOf('@');
    if (at_pos >= 0) {
      // We can't skip this check, because this cases are possible:
      // 192.168.1.1@gmail.com, my.in@example.com
      if ((me = text.match(this.re.email_fuzzy)) !== null) {
        shift = me.index + me[1].length;
        next = me.index + me[0].length;
        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = 'mailto:';
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }
  return this.__index__ >= 0;
};

/**
 * LinkifyIt#pretest(text) -> Boolean
 *
 * Very quick check, that can give false positives. Returns true if link MAY BE
 * can exists. Can be used for speed optimization, when you need to check that
 * link NOT exists.
 **/
LinkifyIt.prototype.pretest = function pretest(text) {
  return this.re.pretest.test(text);
};

/**
 * LinkifyIt#testSchemaAt(text, name, position) -> Number
 * - text (String): text to scan
 * - name (String): rule (schema) name
 * - position (Number): text offset to check from
 *
 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
 * at given position. Returns length of found pattern (0 on fail).
 **/
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
  // If not supported schema check requested - terminate
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
};

/**
 * LinkifyIt#match(text) -> Array|null
 *
 * Returns array of found link descriptions or `null` on fail. We strongly
 * recommend to use [[LinkifyIt#test]] first, for best speed.
 *
 * ##### Result match description
 *
 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
 *   protocol-neutral  links.
 * - __index__ - offset of matched text
 * - __lastIndex__ - index of next char after mathch end
 * - __raw__ - matched text
 * - __text__ - normalized text
 * - __url__ - link, generated from matched text
 **/
LinkifyIt.prototype.match = function match(text) {
  var shift = 0,
    result = [];

  // Try to take previous element from cache, if .test() called before
  if (this.__index__ >= 0 && this.__text_cache__ === text) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }

  // Cut head if cache was used
  var tail = shift ? text.slice(shift) : text;

  // Scan string until end reached
  while (this.test(tail)) {
    result.push(createMatch(this, shift));
    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }
  if (result.length) {
    return result;
  }
  return null;
};

/** chainable
 * LinkifyIt#tlds(list [, keepOld]) -> this
 * - list (Array): list of tlds
 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
 *
 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
 * to avoid false positives. By default this algorythm used:
 *
 * - hostname with any 2-letter root zones are ok.
 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
 *   are ok.
 * - encoded (`xn--...`) root zones are ok.
 *
 * If list is replaced, then exact match for 2-chars root zones will be checked.
 **/
LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
  list = Array.isArray(list) ? list : [list];
  if (!keepOld) {
    this.__tlds__ = list.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }
  this.__tlds__ = this.__tlds__.concat(list).sort().filter(function (el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();
  compile(this);
  return this;
};

/**
 * LinkifyIt#normalize(match)
 *
 * Default normalizer (if schema does not define it's own).
 **/
LinkifyIt.prototype.normalize = function normalize(match) {
  // Do minimal possible changes by default. Need to collect feedback prior
  // to move forward https://github.com/markdown-it/linkify-it/issues/1

  if (!match.schema) {
    match.url = 'http://' + match.url;
  }
  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
    match.url = 'mailto:' + match.url;
  }
};

/**
 * LinkifyIt#onCompile()
 *
 * Override to modify basic RegExp-s.
 **/
LinkifyIt.prototype.onCompile = function onCompile() {};
module.exports = LinkifyIt;

/***/ }),

/***/ 6249:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = function (opts) {
  var re = {};

  // Use direct extract instead of `regenerate` to reduse browserified size
  re.src_Any = (__webpack_require__(3644).source);
  re.src_Cc = (__webpack_require__(9756).source);
  re.src_Z = (__webpack_require__(1905).source);
  re.src_P = (__webpack_require__(4897).source);

  // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join('|');

  // \p{\Z\Cc} (white spaces + control)
  re.src_ZCc = [re.src_Z, re.src_Cc].join('|');

  // Experimental. List of chars, completely prohibited in links
  // because can separate it from other part of text
  var text_separators = '[><\uff5c]';

  // All possible word characters (everything without punctuation, spaces & controls)
  // Defined via punctuation & spaces to save space
  // Should be something like \p{\L\N\S\M} (\w but without `_`)
  re.src_pseudo_letter = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';
  // The same as abothe but without [0-9]
  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';

  ////////////////////////////////////////////////////////////////////////////////

  re.src_ip4 = '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';

  // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.
  re.src_auth = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?';
  re.src_port = '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';
  re.src_host_terminator = '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';
  re.src_path = '(?:' + '[/?#]' + '(?:' + '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\]{}.,"\'?!\\-;]).|' + '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' + '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' + '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' + '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' + "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" + "\\'(?=" + re.src_pseudo_letter + '|[-]).|' +
  // allow `I'm_king` if no pair found
  '\\.{2,}[a-zA-Z0-9%/&]|' +
  // google has many dots in "google search" links (#66, #81).
  // github has ... in commit range links,
  // Restrict to
  // - english
  // - percent-encoded
  // - parts of file path
  // - params separator
  // until more examples found.
  '\\.(?!' + re.src_ZCc + '|[.]).|' + (opts && opts['---'] ? '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
  : '\\-+|') + ',(?!' + re.src_ZCc + ').|' +
  // allow `,,,` in paths
  ';(?!' + re.src_ZCc + ').|' +
  // allow `;` if not followed by space-like char
  '\\!+(?!' + re.src_ZCc + '|[!]).|' +
  // allow `!!!` in paths, but not at the end
  '\\?(?!' + re.src_ZCc + '|[?]).' + ')+' + '|\\/' + ')?';

  // Allow anything in markdown spec, forbid quote (") at the first position
  // because emails enclosed in quotes are far more common
  re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
  re.src_xn = 'xn--[a-z0-9\\-]{1,59}';

  // More to read about domain names
  // http://serverfault.com/questions/638260/

  re.src_domain_root =
  // Allow letters & digits (http://test1)
  '(?:' + re.src_xn + '|' + re.src_pseudo_letter + '{1,63}' + ')';
  re.src_domain = '(?:' + re.src_xn + '|' + '(?:' + re.src_pseudo_letter + ')' + '|' + '(?:' + re.src_pseudo_letter + '(?:-|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' + ')';
  re.src_host = '(?:' +
  // Don't need IP check, because digits are already allowed in normal domain names
  //   src_ip4 +
  // '|' +
  '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain /*_root*/ + ')' + ')';
  re.tpl_host_fuzzy = '(?:' + re.src_ip4 + '|' + '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' + ')';
  re.tpl_host_no_ip_fuzzy = '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';
  re.src_host_strict = re.src_host + re.src_host_terminator;
  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;

  ////////////////////////////////////////////////////////////////////////////////
  // Main rules

  // Rude test fuzzy links by host, for quick deny
  re.tpl_host_fuzzy_test = 'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';
  re.tpl_email_fuzzy = '(^|' + text_separators + '|"|\\(|' + re.src_ZCc + ')' + '(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';
  re.tpl_link_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uff5c]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uff5c])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';
  re.tpl_link_no_ip_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uff5c]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uff5c])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';
  return re;
};

/***/ }),

/***/ 4841:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(5096);

/***/ }),

/***/ 1087:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// HTML5 entities map: { name -> utf16string }
//


/*eslint quotes:0*/
module.exports = __webpack_require__(5485);

/***/ }),

/***/ 9204:
/***/ ((module) => {

"use strict";
// List of valid html blocks names, accorting to commonmark spec
// http://jgm.github.io/CommonMark/spec.html#html-blocks



module.exports = ['address', 'article', 'aside', 'base', 'basefont', 'blockquote', 'body', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dialog', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'iframe', 'legend', 'li', 'link', 'main', 'menu', 'menuitem', 'nav', 'noframes', 'ol', 'optgroup', 'option', 'p', 'param', 'section', 'source', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul'];

/***/ }),

/***/ 7110:
/***/ ((module) => {

"use strict";
// Regexps to match html elements



var attr_name = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
var unquoted = '[^"\'=<>`\\x00-\\x20]+';
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';
var attr_value = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';
var attribute = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';
var open_tag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';
var close_tag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var processing = '<[?][\\s\\S]*?[?]>';
var declaration = '<![A-Z]+\\s+[^>]*>';
var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';
var HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment + '|' + processing + '|' + declaration + '|' + cdata + ')');
var HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');
module.exports.n = HTML_TAG_RE;
module.exports.q = HTML_OPEN_CLOSE_TAG_RE;

/***/ }),

/***/ 7504:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Utilities
//


function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === '[object String]';
}
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function has(object, key) {
  return _hasOwnProperty.call(object, key);
}

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function (source) {
    if (!source) {
      return;
    }
    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be object');
    }
    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });
  return obj;
}

// Remove element from array and put another array at those position.
// Useful for some operations with tokens
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) {
    return false;
  }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) {
    return false;
  }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {
    return false;
  }
  // control codes
  if (c >= 0x00 && c <= 0x08) {
    return false;
  }
  if (c === 0x0B) {
    return false;
  }
  if (c >= 0x0E && c <= 0x1F) {
    return false;
  }
  if (c >= 0x7F && c <= 0x9F) {
    return false;
  }
  // out of range
  if (c > 0x10FFFF) {
    return false;
  }
  return true;
}
function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
      surrogate2 = 0xdc00 + (c & 0x3ff);
    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}
var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');
var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
var entities = __webpack_require__(1087);
function replaceEntityPattern(match, name) {
  var code = 0;
  if (has(entities, name)) {
    return entities[name];
  }
  if (name.charCodeAt(0) === 0x23 /* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }
  return match;
}

/*function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(ENTITY_RE, replaceEntityPattern);
}*/

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, '$1');
}
function unescapeAll(str) {
  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) {
    return str;
  }
  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match, entity);
  });
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};
function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}
function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

////////////////////////////////////////////////////////////////////////////////

var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////

function isSpace(code) {
  switch (code) {
    case 0x09:
    case 0x20:
      return true;
  }
  return false;
}

// Zs (unicode class) || [\t\f\v\r\n]
function isWhiteSpace(code) {
  if (code >= 0x2000 && code <= 0x200A) {
    return true;
  }
  switch (code) {
    case 0x09: // \t
    case 0x0A: // \n
    case 0x0B: // \v
    case 0x0C: // \f
    case 0x0D: // \r
    case 0x20:
    case 0xA0:
    case 0x1680:
    case 0x202F:
    case 0x205F:
    case 0x3000:
      return true;
  }
  return false;
}

////////////////////////////////////////////////////////////////////////////////

/*eslint-disable max-len*/
var UNICODE_PUNCT_RE = __webpack_require__(4897);

// Currently without astral characters support.
function isPunctChar(ch) {
  return UNICODE_PUNCT_RE.test(ch);
}

// Markdown ASCII punctuation characters.
//
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
//
// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
//
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 0x21 /* ! */:
    case 0x22 /* " */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x27 /* ' */:
    case 0x28 /* ( */:
    case 0x29 /* ) */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2C /* , */:
    case 0x2D /* - */:
    case 0x2E /* . */:
    case 0x2F /* / */:
    case 0x3A /* : */:
    case 0x3B /* ; */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x3F /* ? */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7C /* | */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

// Hepler to unify [reference labels].
//
function normalizeReference(str) {
  // Trim and collapse whitespace
  //
  str = str.trim().replace(/\s+/g, ' ');

  // In node v10 'ẞ'.toLowerCase() === 'Ṿ', which is presumed to be a bug
  // fixed in v12 (couldn't find any details).
  //
  // So treat this one as a special case
  // (remove this when node v10 is no longer supported).
  //
  if ('ẞ'.toLowerCase() === 'Ṿ') {
    str = str.replace(/ẞ/g, 'ß');
  }

  // .toLowerCase().toUpperCase() should get rid of all differences
  // between letter variants.
  //
  // Simple .toLowerCase() doesn't normalize 125 code points correctly,
  // and .toUpperCase doesn't normalize 6 of them (list of exceptions:
  // İ, ϴ, ẞ, Ω, K, Å - those are already uppercased, but have differently
  // uppercased versions).
  //
  // Here's an example showing how it happens. Lets take greek letter omega:
  // uppercase U+0398 (Θ), U+03f4 (ϴ) and lowercase U+03b8 (θ), U+03d1 (ϑ)
  //
  // Unicode entries:
  // 0398;GREEK CAPITAL LETTER THETA;Lu;0;L;;;;;N;;;;03B8;
  // 03B8;GREEK SMALL LETTER THETA;Ll;0;L;;;;;N;;;0398;;0398
  // 03D1;GREEK THETA SYMBOL;Ll;0;L;<compat> 03B8;;;;N;GREEK SMALL LETTER SCRIPT THETA;;0398;;0398
  // 03F4;GREEK CAPITAL THETA SYMBOL;Lu;0;L;<compat> 0398;;;;N;;;;03B8;
  //
  // Case-insensitive comparison should treat all of them as equivalent.
  //
  // But .toLowerCase() doesn't change ϑ (it's already lowercase),
  // and .toUpperCase() doesn't change ϴ (already uppercase).
  //
  // Applying first lower then upper case normalizes any character:
  // '\u0398\u03f4\u03b8\u03d1'.toLowerCase().toUpperCase() === '\u0398\u0398\u0398\u0398'
  //
  // Note: this is equivalent to unicode case folding; unicode normalization
  // is a different step that is not required here.
  //
  // Final result should be uppercased, because it's later stored in an object
  // (this avoid a conflict with Object.prototype members,
  // most notably, `__proto__`)
  //
  return str.toLowerCase().toUpperCase();
}

////////////////////////////////////////////////////////////////////////////////

// Re-export libraries commonly used in both markdown-it and its plugins,
// so plugins won't have to depend on them explicitly, which reduces their
// bundled size (e.g. a browser build).
//
exports.lib = {};
exports.lib.mdurl = __webpack_require__(4149);
exports.lib.ucmicro = __webpack_require__(8363);
exports.assign = assign;
exports.isString = isString;
exports.has = has;
exports.unescapeMd = unescapeMd;
exports.unescapeAll = unescapeAll;
exports.isValidEntityCode = isValidEntityCode;
exports.fromCodePoint = fromCodePoint;
// exports.replaceEntities     = replaceEntities;
exports.escapeHtml = escapeHtml;
exports.arrayReplaceAt = arrayReplaceAt;
exports.isSpace = isSpace;
exports.isWhiteSpace = isWhiteSpace;
exports.isMdAsciiPunct = isMdAsciiPunct;
exports.isPunctChar = isPunctChar;
exports.escapeRE = escapeRE;
exports.normalizeReference = normalizeReference;

/***/ }),

/***/ 2869:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Just a shortcut for bulk export


exports.parseLinkLabel = __webpack_require__(8666);
exports.parseLinkDestination = __webpack_require__(4349);
exports.parseLinkTitle = __webpack_require__(5874);

/***/ }),

/***/ 4349:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Parse link destination
//


var unescapeAll = (__webpack_require__(7504).unescapeAll);
module.exports = function parseLinkDestination(str, pos, max) {
  var code,
    level,
    lines = 0,
    start = pos,
    result = {
      ok: false,
      pos: 0,
      lines: 0,
      str: ''
    };
  if (str.charCodeAt(pos) === 0x3C /* < */) {
    pos++;
    while (pos < max) {
      code = str.charCodeAt(pos);
      if (code === 0x0A /* \n */) {
        return result;
      }
      if (code === 0x3C /* < */) {
        return result;
      }
      if (code === 0x3E /* > */) {
        result.pos = pos + 1;
        result.str = unescapeAll(str.slice(start + 1, pos));
        result.ok = true;
        return result;
      }
      if (code === 0x5C /* \ */ && pos + 1 < max) {
        pos += 2;
        continue;
      }
      pos++;
    }

    // no closing '>'
    return result;
  }

  // this should be ... } else { ... branch

  level = 0;
  while (pos < max) {
    code = str.charCodeAt(pos);
    if (code === 0x20) {
      break;
    }

    // ascii control characters
    if (code < 0x20 || code === 0x7F) {
      break;
    }
    if (code === 0x5C /* \ */ && pos + 1 < max) {
      if (str.charCodeAt(pos + 1) === 0x20) {
        break;
      }
      pos += 2;
      continue;
    }
    if (code === 0x28 /* ( */) {
      level++;
      if (level > 32) {
        return result;
      }
    }
    if (code === 0x29 /* ) */) {
      if (level === 0) {
        break;
      }
      level--;
    }
    pos++;
  }
  if (start === pos) {
    return result;
  }
  if (level !== 0) {
    return result;
  }
  result.str = unescapeAll(str.slice(start, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
};

/***/ }),

/***/ 8666:
/***/ ((module) => {

"use strict";
// Parse link label
//
// this function assumes that first character ("[") already matches;
// returns the end of the label
//


module.exports = function parseLinkLabel(state, start, disableNested) {
  var level,
    found,
    marker,
    prevPos,
    labelEnd = -1,
    max = state.posMax,
    oldPos = state.pos;
  state.pos = start + 1;
  level = 1;
  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 0x5D /* ] */) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }
    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 0x5B /* [ */) {
      if (prevPos === state.pos - 1) {
        // increase level if we find text `[`, which is not a part of any token
        level++;
      } else if (disableNested) {
        state.pos = oldPos;
        return -1;
      }
    }
  }
  if (found) {
    labelEnd = state.pos;
  }

  // restore old state
  state.pos = oldPos;
  return labelEnd;
};

/***/ }),

/***/ 5874:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Parse link title
//


var unescapeAll = (__webpack_require__(7504).unescapeAll);
module.exports = function parseLinkTitle(str, pos, max) {
  var code,
    marker,
    lines = 0,
    start = pos,
    result = {
      ok: false,
      pos: 0,
      lines: 0,
      str: ''
    };
  if (pos >= max) {
    return result;
  }
  marker = str.charCodeAt(pos);
  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) {
    return result;
  }
  pos++;

  // if opening marker is "(", switch it to closing marker ")"
  if (marker === 0x28) {
    marker = 0x29;
  }
  while (pos < max) {
    code = str.charCodeAt(pos);
    if (code === marker) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll(str.slice(start + 1, pos));
      result.ok = true;
      return result;
    } else if (code === 0x28 /* ( */ && marker === 0x29 /* ) */) {
      return result;
    } else if (code === 0x0A) {
      lines++;
    } else if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos++;
      if (str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }
    pos++;
  }
  return result;
};

/***/ }),

/***/ 5096:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Main parser class



var utils = __webpack_require__(7504);
var helpers = __webpack_require__(2869);
var Renderer = __webpack_require__(2282);
var ParserCore = __webpack_require__(5321);
var ParserBlock = __webpack_require__(1269);
var ParserInline = __webpack_require__(4189);
var LinkifyIt = __webpack_require__(5622);
var mdurl = __webpack_require__(4149);
var punycode = __webpack_require__(1911);
var config = {
  default: __webpack_require__(7044),
  zero: __webpack_require__(7970),
  commonmark: __webpack_require__(9611)
};

////////////////////////////////////////////////////////////////////////////////
//
// This validator can prohibit more than really needed to prevent XSS. It's a
// tradeoff to keep code simple and to be secure by default.
//
// If you need different setup - override validator method as you wish. Or
// replace it with dummy function and use external sanitizer.
//

var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
function validateLink(url) {
  // url should be normalized at this point, and existing entities are decoded
  var str = url.trim().toLowerCase();
  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
}

////////////////////////////////////////////////////////////////////////////////

var RECODE_HOSTNAME_FOR = ['http:', 'https:', 'mailto:'];
function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);
  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {/**/}
    }
  }
  return mdurl.encode(mdurl.format(parsed));
}
function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);
  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  // add '%' to exclude list because of https://github.com/markdown-it/markdown-it/issues/720
  return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + '%');
}

/**
 * class MarkdownIt
 *
 * Main parser/renderer class.
 *
 * ##### Usage
 *
 * ```javascript
 * // node.js, "classic" way:
 * var MarkdownIt = require('markdown-it'),
 *     md = new MarkdownIt();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // node.js, the same, but with sugar:
 * var md = require('markdown-it')();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // browser without AMD, added to "window" on script load
 * // Note, there are no dash.
 * var md = window.markdownit();
 * var result = md.render('# markdown-it rulezz!');
 * ```
 *
 * Single line rendering, without paragraph wrap:
 *
 * ```javascript
 * var md = require('markdown-it')();
 * var result = md.renderInline('__markdown-it__ rulezz!');
 * ```
 **/

/**
 * new MarkdownIt([presetName, options])
 * - presetName (String): optional, `commonmark` / `zero`
 * - options (Object)
 *
 * Creates parser instanse with given config. Can be called without `new`.
 *
 * ##### presetName
 *
 * MarkdownIt provides named presets as a convenience to quickly
 * enable/disable active syntax rules and options for common use cases.
 *
 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
 *   similar to GFM, used when no preset name given. Enables all available rules,
 *   but still without html, typographer & autolinker.
 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
 *   For example, when you need only `bold` and `italic` markup and nothing else.
 *
 * ##### options:
 *
 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
 *   That's not safe! You may need external sanitizer to protect output from XSS.
 *   It's better to extend features via plugins, instead of enabling HTML.
 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
 *   world you will need HTML output.
 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
 *   Can be useful for external highlighters.
 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
 *   quotes beautification (smartquotes).
 * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
 *   pairs, when typographer enabled and smartquotes on. For example, you can
 *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
 *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
 *   return empty string if the source was not changed and should be escaped
 *   externaly. If result starts with <pre... internal wrapper is skipped.
 *
 * ##### Example
 *
 * ```javascript
 * // commonmark mode
 * var md = require('markdown-it')('commonmark');
 *
 * // default mode
 * var md = require('markdown-it')();
 *
 * // enable everything
 * var md = require('markdown-it')({
 *   html: true,
 *   linkify: true,
 *   typographer: true
 * });
 * ```
 *
 * ##### Syntax highlighting
 *
 * ```js
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return hljs.highlight(str, { language: lang, ignoreIllegals: true }).value;
 *       } catch (__) {}
 *     }
 *
 *     return ''; // use external default escaping
 *   }
 * });
 * ```
 *
 * Or with full wrapper override (if you need assign class to `<pre>`):
 *
 * ```javascript
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * // Actual default values
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return '<pre class="hljs"><code>' +
 *                hljs.highlight(str, { language: lang, ignoreIllegals: true }).value +
 *                '</code></pre>';
 *       } catch (__) {}
 *     }
 *
 *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
 *   }
 * });
 * ```
 *
 **/
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }
  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = 'default';
    }
  }

  /**
   * MarkdownIt#inline -> ParserInline
   *
   * Instance of [[ParserInline]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.inline = new ParserInline();

  /**
   * MarkdownIt#block -> ParserBlock
   *
   * Instance of [[ParserBlock]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.block = new ParserBlock();

  /**
   * MarkdownIt#core -> Core
   *
   * Instance of [[Core]] chain executor. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.core = new ParserCore();

  /**
   * MarkdownIt#renderer -> Renderer
   *
   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
   * rules for new token types, generated by plugins.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * function myToken(tokens, idx, options, env, self) {
   *   //...
   *   return result;
   * };
   *
   * md.renderer.rules['my_token'] = myToken
   * ```
   *
   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
   **/
  this.renderer = new Renderer();

  /**
   * MarkdownIt#linkify -> LinkifyIt
   *
   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
   * rule.
   **/
  this.linkify = new LinkifyIt();

  /**
   * MarkdownIt#validateLink(url) -> Boolean
   *
   * Link validation function. CommonMark allows too much in links. By default
   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
   * except some embedded image types.
   *
   * You can change this behaviour:
   *
   * ```javascript
   * var md = require('markdown-it')();
   * // enable everything
   * md.validateLink = function () { return true; }
   * ```
   **/
  this.validateLink = validateLink;

  /**
   * MarkdownIt#normalizeLink(url) -> String
   *
   * Function used to encode link url to a machine-readable format,
   * which includes url-encoding, punycode, etc.
   **/
  this.normalizeLink = normalizeLink;

  /**
   * MarkdownIt#normalizeLinkText(url) -> String
   *
   * Function used to decode link url to a human-readable format`
   **/
  this.normalizeLinkText = normalizeLinkText;

  // Expose utils & helpers for easy acces from plugins

  /**
   * MarkdownIt#utils -> utils
   *
   * Assorted utility functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
   **/
  this.utils = utils;

  /**
   * MarkdownIt#helpers -> helpers
   *
   * Link components parser functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
   **/
  this.helpers = utils.assign({}, helpers);
  this.options = {};
  this.configure(presetName);
  if (options) {
    this.set(options);
  }
}

/** chainable
 * MarkdownIt.set(options)
 *
 * Set parser options (in the same format as in constructor). Probably, you
 * will never need it, but you can change options after constructor call.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .set({ html: true, breaks: true })
 *             .set({ typographer, true });
 * ```
 *
 * __Note:__ To achieve the best possible performance, don't modify a
 * `markdown-it` instance options on the fly. If you need multiple configurations
 * it's best to create multiple instances and initialize each with separate
 * config.
 **/
MarkdownIt.prototype.set = function (options) {
  utils.assign(this.options, options);
  return this;
};

/** chainable, internal
 * MarkdownIt.configure(presets)
 *
 * Batch load of all options and compenent settings. This is internal method,
 * and you probably will not need it. But if you will - see available presets
 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
 *
 * We strongly recommend to use presets instead of direct config loads. That
 * will give better compatibility with next versions.
 **/
MarkdownIt.prototype.configure = function (presets) {
  var self = this,
    presetName;
  if (utils.isString(presets)) {
    presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }
  if (!presets) {
    throw new Error('Wrong `markdown-it` preset, can\'t be empty');
  }
  if (presets.options) {
    self.set(presets.options);
  }
  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};

/** chainable
 * MarkdownIt.enable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to enable
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable list or rules. It will automatically find appropriate components,
 * containing rules with given names. If rule not found, and `ignoreInvalid`
 * not set - throws exception.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .enable(['sub', 'sup'])
 *             .disable('smartquotes');
 * ```
 **/
MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
  var result = [];
  if (!Array.isArray(list)) {
    list = [list];
  }
  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.enable(list, true));
  }, this);
  result = result.concat(this.inline.ruler2.enable(list, true));
  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
  }
  return this;
};

/** chainable
 * MarkdownIt.disable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * The same as [[MarkdownIt.enable]], but turn specified rules off.
 **/
MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
  var result = [];
  if (!Array.isArray(list)) {
    list = [list];
  }
  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.disable(list, true));
  }, this);
  result = result.concat(this.inline.ruler2.disable(list, true));
  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
  }
  return this;
};

/** chainable
 * MarkdownIt.use(plugin, params)
 *
 * Load specified plugin with given params into current parser instance.
 * It's just a sugar to call `plugin(md, params)` with curring.
 *
 * ##### Example
 *
 * ```javascript
 * var iterator = require('markdown-it-for-inline');
 * var md = require('markdown-it')()
 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
 *             });
 * ```
 **/
MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
  var args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};

/** internal
 * MarkdownIt.parse(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Parse input string and return list of block tokens (special token type
 * "inline" will contain list of inline tokens). You should not call this
 * method directly, until you write custom renderer (for example, to produce
 * AST).
 *
 * `env` is used to pass data between "distributed" rules and return additional
 * metadata like reference info, needed for the renderer. It also can be used to
 * inject data in specific cases. Usually, you will be ok to pass `{}`,
 * and then pass updated object to renderer.
 **/
MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== 'string') {
    throw new Error('Input data should be a String');
  }
  var state = new this.core.State(src, this, env);
  this.core.process(state);
  return state.tokens;
};

/**
 * MarkdownIt.render(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Render markdown string into html. It does all magic for you :).
 *
 * `env` can be used to inject additional metadata (`{}` by default).
 * But you will not need it with high probability. See also comment
 * in [[MarkdownIt.parse]].
 **/
MarkdownIt.prototype.render = function (src, env) {
  env = env || {};
  return this.renderer.render(this.parse(src, env), this.options, env);
};

/** internal
 * MarkdownIt.parseInline(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
 * block tokens list with the single `inline` element, containing parsed inline
 * tokens in `children` property. Also updates `env` object.
 **/
MarkdownIt.prototype.parseInline = function (src, env) {
  var state = new this.core.State(src, this, env);
  state.inlineMode = true;
  this.core.process(state);
  return state.tokens;
};

/**
 * MarkdownIt.renderInline(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
 * will NOT be wrapped into `<p>` tags.
 **/
MarkdownIt.prototype.renderInline = function (src, env) {
  env = env || {};
  return this.renderer.render(this.parseInline(src, env), this.options, env);
};
module.exports = MarkdownIt;

/***/ }),

/***/ 1269:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/** internal
 * class ParserBlock
 *
 * Block-level tokenizer.
 **/


var Ruler = __webpack_require__(7869);
var _rules = [
// First 2 params - rule name & source. Secondary array - list of rules,
// which can be terminated by this one.
['table', __webpack_require__(6961), ['paragraph', 'reference']], ['code', __webpack_require__(7636)], ['fence', __webpack_require__(785), ['paragraph', 'reference', 'blockquote', 'list']], ['blockquote', __webpack_require__(8264), ['paragraph', 'reference', 'blockquote', 'list']], ['hr', __webpack_require__(622), ['paragraph', 'reference', 'blockquote', 'list']], ['list', __webpack_require__(6483), ['paragraph', 'reference', 'blockquote']], ['reference', __webpack_require__(9194)], ['html_block', __webpack_require__(7607), ['paragraph', 'reference', 'blockquote']], ['heading', __webpack_require__(5492), ['paragraph', 'reference', 'blockquote']], ['lheading', __webpack_require__(6726)], ['paragraph', __webpack_require__(3794)]];

/**
 * new ParserBlock()
 **/
function ParserBlock() {
  /**
   * ParserBlock#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of block rules.
   **/
  this.ruler = new Ruler();
  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1], {
      alt: (_rules[i][2] || []).slice()
    });
  }
}

// Generate tokens for input range
//
ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var ok,
    i,
    rules = this.ruler.getRules(''),
    len = rules.length,
    line = startLine,
    hasEmptyLines = false,
    maxNesting = state.md.options.maxNesting;
  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists
    if (state.sCount[line] < state.blkIndent) {
      break;
    }

    // If nesting level exceeded - skip tail to the end. That's not ordinary
    // situation and we should not care about content.
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        break;
      }
    }

    // set state.tight if we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might "eat" one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }
    line = state.line;
    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};

/**
 * ParserBlock.parse(str, md, env, outTokens)
 *
 * Process input string and push block tokens into `outTokens`
 **/
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;
  if (!src) {
    return;
  }
  state = new this.State(src, md, env, outTokens);
  this.tokenize(state, state.line, state.lineMax);
};
ParserBlock.prototype.State = __webpack_require__(9031);
module.exports = ParserBlock;

/***/ }),

/***/ 5321:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/** internal
 * class Core
 *
 * Top-level rules executor. Glues block/inline parsers and does intermediate
 * transformations.
 **/


var Ruler = __webpack_require__(7869);
var _rules = [['normalize', __webpack_require__(4140)], ['block', __webpack_require__(5199)], ['inline', __webpack_require__(3286)], ['linkify', __webpack_require__(3490)], ['replacements', __webpack_require__(5131)], ['smartquotes', __webpack_require__(7185)]];

/**
 * new Core()
 **/
function Core() {
  /**
   * Core#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of core rules.
   **/
  this.ruler = new Ruler();
  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}

/**
 * Core.process(state)
 *
 * Executes core chain rules.
 **/
Core.prototype.process = function (state) {
  var i, l, rules;
  rules = this.ruler.getRules('');
  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};
Core.prototype.State = __webpack_require__(6546);
module.exports = Core;

/***/ }),

/***/ 4189:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/** internal
 * class ParserInline
 *
 * Tokenizes paragraph content.
 **/


var Ruler = __webpack_require__(7869);

////////////////////////////////////////////////////////////////////////////////
// Parser rules

var _rules = [['text', __webpack_require__(6242)], ['newline', __webpack_require__(8254)], ['escape', __webpack_require__(340)], ['backticks', __webpack_require__(8326)], ['strikethrough', (__webpack_require__(8032)/* .tokenize */ .w)], ['emphasis', (__webpack_require__(8023)/* .tokenize */ .w)], ['link', __webpack_require__(1786)], ['image', __webpack_require__(898)], ['autolink', __webpack_require__(6891)], ['html_inline', __webpack_require__(5061)], ['entity', __webpack_require__(8685)]];
var _rules2 = [['balance_pairs', __webpack_require__(4312)], ['strikethrough', (__webpack_require__(8032)/* .postProcess */ .g)], ['emphasis', (__webpack_require__(8023)/* .postProcess */ .g)], ['text_collapse', __webpack_require__(4013)]];

/**
 * new ParserInline()
 **/
function ParserInline() {
  var i;

  /**
   * ParserInline#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/
  this.ruler = new Ruler();
  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  /**
   * ParserInline#ruler2 -> Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/
  this.ruler2 = new Ruler();
  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}

// Skip single token by running all rules in validation mode;
// returns `true` if any rule reported success
//
ParserInline.prototype.skipToken = function (state) {
  var ok,
    i,
    pos = state.pos,
    rules = this.ruler.getRules(''),
    len = rules.length,
    maxNesting = state.md.options.maxNesting,
    cache = state.cache;
  if (typeof cache[pos] !== 'undefined') {
    state.pos = cache[pos];
    return;
  }
  if (state.level < maxNesting) {
    for (i = 0; i < len; i++) {
      // Increment state.level and decrement it later to limit recursion.
      // It's harmless to do here, because no tokens are created. But ideally,
      // we'd need a separate private state variable for this purpose.
      //
      state.level++;
      ok = rules[i](state, true);
      state.level--;
      if (ok) {
        break;
      }
    }
  } else {
    // Too much nesting, just skip until the end of the paragraph.
    //
    // NOTE: this will cause links to behave incorrectly in the following case,
    //       when an amount of `[` is exactly equal to `maxNesting + 1`:
    //
    //       [[[[[[[[[[[[[[[[[[[[[foo]()
    //
    // TODO: remove this workaround when CM standard will allow nested links
    //       (we can replace it by preventing links from being parsed in
    //       validation mode)
    //
    state.pos = state.posMax;
  }
  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};

// Generate tokens for input range
//
ParserInline.prototype.tokenize = function (state) {
  var ok,
    i,
    rules = this.ruler.getRules(''),
    len = rules.length,
    end = state.posMax,
    maxNesting = state.md.options.maxNesting;
  while (state.pos < end) {
    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true

    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) {
          break;
        }
      }
    }
    if (ok) {
      if (state.pos >= end) {
        break;
      }
      continue;
    }
    state.pending += state.src[state.pos++];
  }
  if (state.pending) {
    state.pushPending();
  }
};

/**
 * ParserInline.parse(str, md, env, outTokens)
 *
 * Process input string and push inline tokens into `outTokens`
 **/
ParserInline.prototype.parse = function (str, md, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md, env, outTokens);
  this.tokenize(state);
  rules = this.ruler2.getRules('');
  len = rules.length;
  for (i = 0; i < len; i++) {
    rules[i](state);
  }
};
ParserInline.prototype.State = __webpack_require__(9017);
module.exports = ParserInline;

/***/ }),

/***/ 9611:
/***/ ((module) => {

"use strict";
// Commonmark default options



module.exports = {
  options: {
    html: true,
    // Enable HTML tags in source
    xhtmlOut: true,
    // Use '/' to close single tags (<br />)
    breaks: false,
    // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-',
    // CSS language prefix for fenced blocks
    linkify: false,
    // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201c\u201d\u2018\u2019',
    /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {
    core: {
      rules: ['normalize', 'block', 'inline']
    },
    block: {
      rules: ['blockquote', 'code', 'fence', 'heading', 'hr', 'html_block', 'lheading', 'list', 'reference', 'paragraph']
    },
    inline: {
      rules: ['autolink', 'backticks', 'emphasis', 'entity', 'escape', 'html_inline', 'image', 'link', 'newline', 'text'],
      rules2: ['balance_pairs', 'emphasis', 'text_collapse']
    }
  }
};

/***/ }),

/***/ 7044:
/***/ ((module) => {

"use strict";
// markdown-it default options



module.exports = {
  options: {
    html: false,
    // Enable HTML tags in source
    xhtmlOut: false,
    // Use '/' to close single tags (<br />)
    breaks: false,
    // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-',
    // CSS language prefix for fenced blocks
    linkify: false,
    // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201c\u201d\u2018\u2019',
    /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 100 // Internal protection, recursion limit
  },

  components: {
    core: {},
    block: {},
    inline: {}
  }
};

/***/ }),

/***/ 7970:
/***/ ((module) => {

"use strict";
// "Zero" preset, with nothing enabled. Useful for manual configuring of simple
// modes. For example, to parse bold/italic only.



module.exports = {
  options: {
    html: false,
    // Enable HTML tags in source
    xhtmlOut: false,
    // Use '/' to close single tags (<br />)
    breaks: false,
    // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-',
    // CSS language prefix for fenced blocks
    linkify: false,
    // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201c\u201d\u2018\u2019',
    /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {
    core: {
      rules: ['normalize', 'block', 'inline']
    },
    block: {
      rules: ['paragraph']
    },
    inline: {
      rules: ['text'],
      rules2: ['balance_pairs', 'text_collapse']
    }
  }
};

/***/ }),

/***/ 2282:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * class Renderer
 *
 * Generates HTML from parsed token stream. Each instance has independent
 * copy of rules. Those can be rewritten with ease. Also, you can add new
 * rules if you create plugin and adds new token types.
 **/


var assign = (__webpack_require__(7504).assign);
var unescapeAll = (__webpack_require__(7504).unescapeAll);
var escapeHtml = (__webpack_require__(7504).escapeHtml);

////////////////////////////////////////////////////////////////////////////////

var default_rules = {};
default_rules.code_inline = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];
  return '<code' + slf.renderAttrs(token) + '>' + escapeHtml(tokens[idx].content) + '</code>';
};
default_rules.code_block = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];
  return '<pre' + slf.renderAttrs(token) + '><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\n';
};
default_rules.fence = function (tokens, idx, options, env, slf) {
  var token = tokens[idx],
    info = token.info ? unescapeAll(token.info).trim() : '',
    langName = '',
    langAttrs = '',
    highlighted,
    i,
    arr,
    tmpAttrs,
    tmpToken;
  if (info) {
    arr = info.split(/(\s+)/g);
    langName = arr[0];
    langAttrs = arr.slice(2).join('');
  }
  if (options.highlight) {
    highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }
  if (highlighted.indexOf('<pre') === 0) {
    return highlighted + '\n';
  }

  // If language exists, inject class gently, without modifying original token.
  // May be, one day we will add .deepClone() for token and simplify this part, but
  // now we prefer to keep things local.
  if (info) {
    i = token.attrIndex('class');
    tmpAttrs = token.attrs ? token.attrs.slice() : [];
    if (i < 0) {
      tmpAttrs.push(['class', options.langPrefix + langName]);
    } else {
      tmpAttrs[i] = tmpAttrs[i].slice();
      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
    }

    // Fake token just to render attributes
    tmpToken = {
      attrs: tmpAttrs
    };
    return '<pre><code' + slf.renderAttrs(tmpToken) + '>' + highlighted + '</code></pre>\n';
  }
  return '<pre><code' + slf.renderAttrs(token) + '>' + highlighted + '</code></pre>\n';
};
default_rules.image = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  // "alt" attr MUST be set, even if empty. Because it's mandatory and
  // should be placed on proper position for tests.
  //
  // Replace content with actual value

  token.attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children, options, env);
  return slf.renderToken(tokens, idx, options);
};
default_rules.hardbreak = function (tokens, idx, options /*, env */) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
default_rules.softbreak = function (tokens, idx, options /*, env */) {
  return options.breaks ? options.xhtmlOut ? '<br />\n' : '<br>\n' : '\n';
};
default_rules.text = function (tokens, idx /*, options, env */) {
  return escapeHtml(tokens[idx].content);
};
default_rules.html_block = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};
default_rules.html_inline = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};

/**
 * new Renderer()
 *
 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
 **/
function Renderer() {
  /**
   * Renderer#rules -> Object
   *
   * Contains render rules for tokens. Can be updated and extended.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.renderer.rules.strong_open  = function () { return '<b>'; };
   * md.renderer.rules.strong_close = function () { return '</b>'; };
   *
   * var result = md.renderInline(...);
   * ```
   *
   * Each rule is called as independent static function with fixed signature:
   *
   * ```javascript
   * function my_token_render(tokens, idx, options, env, renderer) {
   *   // ...
   *   return renderedHTML;
   * }
   * ```
   *
   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
   * for more details and examples.
   **/
  this.rules = assign({}, default_rules);
}

/**
 * Renderer.renderAttrs(token) -> String
 *
 * Render token attributes to string.
 **/
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  var i, l, result;
  if (!token.attrs) {
    return '';
  }
  result = '';
  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }
  return result;
};

/**
 * Renderer.renderToken(tokens, idx, options) -> String
 * - tokens (Array): list of tokens
 * - idx (Numbed): token index to render
 * - options (Object): params of parser instance
 *
 * Default token renderer. Can be overriden by custom function
 * in [[Renderer#rules]].
 **/
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  var nextToken,
    result = '',
    needLf = false,
    token = tokens[idx];

  // Tight list paragraphs
  if (token.hidden) {
    return '';
  }

  // Insert a newline between hidden paragraph and subsequent opening
  // block-level tag.
  //
  // For example, here we should insert a newline before blockquote:
  //  - a
  //    >
  //
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += '\n';
  }

  // Add token name, e.g. `<img`
  result += (token.nesting === -1 ? '</' : '<') + token.tag;

  // Encode attributes, e.g. `<img src="foo"`
  result += this.renderAttrs(token);

  // Add a slash for self-closing tags, e.g. `<img src="foo" /`
  if (token.nesting === 0 && options.xhtmlOut) {
    result += ' /';
  }

  // Check if we need to add a newline after this tag
  if (token.block) {
    needLf = true;
    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];
        if (nextToken.type === 'inline' || nextToken.hidden) {
          // Block-level tag containing an inline tag.
          //
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
          //
          needLf = false;
        }
      }
    }
  }
  result += needLf ? '>\n' : '>';
  return result;
};

/**
 * Renderer.renderInline(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to render
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * The same as [[Renderer.render]], but for single token of `inline` type.
 **/
Renderer.prototype.renderInline = function (tokens, options, env) {
  var type,
    result = '',
    rules = this.rules;
  for (var i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;
    if (typeof rules[type] !== 'undefined') {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }
  return result;
};

/** internal
 * Renderer.renderInlineAsText(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to render
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Special kludge for image `alt` attributes to conform CommonMark spec.
 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
 * instead of simple escaping.
 **/
Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
  var result = '';
  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === 'text') {
      result += tokens[i].content;
    } else if (tokens[i].type === 'image') {
      result += this.renderInlineAsText(tokens[i].children, options, env);
    } else if (tokens[i].type === 'softbreak') {
      result += '\n';
    }
  }
  return result;
};

/**
 * Renderer.render(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to render
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Takes token stream and generates HTML. Probably, you will never need to call
 * this method directly.
 **/
Renderer.prototype.render = function (tokens, options, env) {
  var i,
    len,
    type,
    result = '',
    rules = this.rules;
  for (i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;
    if (type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== 'undefined') {
      result += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }
  return result;
};
module.exports = Renderer;

/***/ }),

/***/ 7869:
/***/ ((module) => {

"use strict";
/**
 * class Ruler
 *
 * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and
 * [[MarkdownIt#inline]] to manage sequences of functions (rules):
 *
 * - keep rules in defined order
 * - assign the name to each rule
 * - enable/disable rules
 * - add/replace rules
 * - allow assign rules to additional named chains (in the same)
 * - cacheing lists of active rules
 *
 * You will not need use this class directly until write plugins. For simple
 * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and
 * [[MarkdownIt.use]].
 **/


/**
 * new Ruler()
 **/
function Ruler() {
  // List of added rules. Each element is:
  //
  // {
  //   name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ]
  // }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - diginal anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}

////////////////////////////////////////////////////////////////////////////////
// Helper methods, should not be used directly

// Find rule index by name
//
Ruler.prototype.__find__ = function (name) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};

// Build rules lookup cache
//
Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = [''];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) {
      return;
    }
    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });
  self.__cache__ = {};
  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) {
        return;
      }
      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }
      self.__cache__[chain].push(rule.fn);
    });
  });
};

/**
 * Ruler.at(name, fn [, options])
 * - name (String): rule name to replace.
 * - fn (Function): new rule function.
 * - options (Object): new rule options (not mandatory).
 *
 * Replace rule by name with new function & options. Throws error if name not
 * found.
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * Replace existing typographer replacement rule with new one:
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.at('replacements', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.at = function (name, fn, options) {
  var index = this.__find__(name);
  var opt = options || {};
  if (index === -1) {
    throw new Error('Parser rule not found: ' + name);
  }
  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};

/**
 * Ruler.before(beforeName, ruleName, fn [, options])
 * - beforeName (String): new rule will be added before this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain before one with given name. See also
 * [[Ruler.after]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var index = this.__find__(beforeName);
  var opt = options || {};
  if (index === -1) {
    throw new Error('Parser rule not found: ' + beforeName);
  }
  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};

/**
 * Ruler.after(afterName, ruleName, fn [, options])
 * - afterName (String): new rule will be added after this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain after one with given name. See also
 * [[Ruler.before]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var index = this.__find__(afterName);
  var opt = options || {};
  if (index === -1) {
    throw new Error('Parser rule not found: ' + afterName);
  }
  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};

/**
 * Ruler.push(ruleName, fn [, options])
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Push new rule to the end of chain. See also
 * [[Ruler.before]], [[Ruler.after]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.push('my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};
  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};

/**
 * Ruler.enable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to enable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.enable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }
  var result = [];

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);
  this.__cache__ = null;
  return result;
};

/**
 * Ruler.enableOnly(list [, ignoreInvalid])
 * - list (String|Array): list of rule names to enable (whitelist).
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names, and disable everything else. If any rule name
 * not found - throw Error. Errors can be disabled by second param.
 *
 * See also [[Ruler.disable]], [[Ruler.enable]].
 **/
Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }
  this.__rules__.forEach(function (rule) {
    rule.enabled = false;
  });
  this.enable(list, ignoreInvalid);
};

/**
 * Ruler.disable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Disable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.disable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }
  var result = [];

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);
  this.__cache__ = null;
  return result;
};

/**
 * Ruler.getRules(chainName) -> Array
 *
 * Return array of active functions (rules) for given chain name. It analyzes
 * rules configuration, compiles caches if not exists and returns result.
 *
 * Default chain name is `''` (empty string). It can't be skipped. That's
 * done intentionally, to keep signature monomorphic for high speed.
 **/
Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }

  // Chain can be empty, if rules disabled. But we still have to return Array.
  return this.__cache__[chainName] || [];
};
module.exports = Ruler;

/***/ }),

/***/ 8264:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Block quotes



var isSpace = (__webpack_require__(7504).isSpace);
module.exports = function blockquote(state, startLine, endLine, silent) {
  var adjustTab,
    ch,
    i,
    initial,
    l,
    lastLineEmpty,
    lines,
    nextLine,
    offset,
    oldBMarks,
    oldBSCount,
    oldIndent,
    oldParentType,
    oldSCount,
    oldTShift,
    spaceAfterMarker,
    terminate,
    terminatorRules,
    token,
    isOutdented,
    oldLineMax = state.lineMax,
    pos = state.bMarks[startLine] + state.tShift[startLine],
    max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // check the block quote marker
  if (state.src.charCodeAt(pos++) !== 0x3E /* > */) {
    return false;
  }

  // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode
  if (silent) {
    return true;
  }

  // set offset past spaces and ">"
  initial = offset = state.sCount[startLine] + 1;

  // skip one optional space after '>'
  if (state.src.charCodeAt(pos) === 0x20 /* space */) {
    // ' >   test '
    //     ^ -- position start of line here:
    pos++;
    initial++;
    offset++;
    adjustTab = false;
    spaceAfterMarker = true;
  } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
    spaceAfterMarker = true;
    if ((state.bsCount[startLine] + offset) % 4 === 3) {
      // '  >\t  test '
      //       ^ -- position start of line here (tab has width===1)
      pos++;
      initial++;
      offset++;
      adjustTab = false;
    } else {
      // ' >\t  test '
      //    ^ -- position start of line here + shift bsCount slightly
      //         to make extra space appear
      adjustTab = true;
    }
  } else {
    spaceAfterMarker = false;
  }
  oldBMarks = [state.bMarks[startLine]];
  state.bMarks[startLine] = pos;
  while (pos < max) {
    ch = state.src.charCodeAt(pos);
    if (isSpace(ch)) {
      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset++;
      }
    } else {
      break;
    }
    pos++;
  }
  oldBSCount = [state.bsCount[startLine]];
  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
  lastLineEmpty = pos >= max;
  oldSCount = [state.sCount[startLine]];
  state.sCount[startLine] = offset - initial;
  oldTShift = [state.tShift[startLine]];
  state.tShift[startLine] = pos - state.bMarks[startLine];
  terminatorRules = state.md.block.ruler.getRules('blockquote');
  oldParentType = state.parentType;
  state.parentType = 'blockquote';

  // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag:
  //     ```
  //     > test
  //      - - -
  //     ```
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    // check if it's outdented, i.e. it's inside list item and indented
    // less than said list item:
    //
    // ```
    // 1. anything
    //    > current blockquote
    // 2. checking this line
    // ```
    isOutdented = state.sCount[nextLine] < state.blkIndent;
    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];
    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }
    if (state.src.charCodeAt(pos++) === 0x3E /* > */ && !isOutdented) {
      // This line is inside the blockquote.

      // set offset past spaces and ">"
      initial = offset = state.sCount[nextLine] + 1;

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20 /* space */) {
        // ' >   test '
        //     ^ -- position start of line here:
        pos++;
        initial++;
        offset++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
        spaceAfterMarker = true;
        if ((state.bsCount[nextLine] + offset) % 4 === 3) {
          // '  >\t  test '
          //       ^ -- position start of line here (tab has width===1)
          pos++;
          initial++;
          offset++;
          adjustTab = false;
        } else {
          // ' >\t  test '
          //    ^ -- position start of line here + shift bsCount slightly
          //         to make extra space appear
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 0x09) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      lastLineEmpty = pos >= max;
      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;
      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }

    // Case 2: line is not inside the blockquote, and the last line was empty.
    if (lastLineEmpty) {
      break;
    }

    // Case 3: another tag found.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      // Quirk to enforce "hard termination mode" for paragraphs;
      // normally if you call `tokenize(state, startLine, nextLine)`,
      // paragraphs will look below nextLine for paragraph continuation,
      // but if blockquote is terminated by another tag, they shouldn't
      state.lineMax = nextLine;
      if (state.blkIndent !== 0) {
        // state.blkIndent was non-zero, we now set it to zero,
        // so we need to re-calculate all offsets to appear as
        // if indent wasn't changed
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }
      break;
    }
    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);

    // A negative indentation means that this is a paragraph continuation
    //
    state.sCount[nextLine] = -1;
  }
  oldIndent = state.blkIndent;
  state.blkIndent = 0;
  token = state.push('blockquote_open', 'blockquote', 1);
  token.markup = '>';
  token.map = lines = [startLine, 0];
  state.md.block.tokenize(state, startLine, nextLine);
  token = state.push('blockquote_close', 'blockquote', -1);
  token.markup = '>';
  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;

  // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;
  return true;
};

/***/ }),

/***/ 7636:
/***/ ((module) => {

"use strict";
// Code block (4 spaces padded)



module.exports = function code(state, startLine, endLine /*, silent*/) {
  var nextLine, last, token;
  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }
  last = nextLine = startLine + 1;
  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }
  state.line = last;
  token = state.push('code_block', 'code', 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + '\n';
  token.map = [startLine, state.line];
  return true;
};

/***/ }),

/***/ 785:
/***/ ((module) => {

"use strict";
// fences (``` lang, ~~~ lang)



module.exports = function fence(state, startLine, endLine, silent) {
  var marker,
    len,
    params,
    nextLine,
    mem,
    token,
    markup,
    haveEndMarker = false,
    pos = state.bMarks[startLine] + state.tShift[startLine],
    max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (pos + 3 > max) {
    return false;
  }
  marker = state.src.charCodeAt(pos);
  if (marker !== 0x7E /* ~ */ && marker !== 0x60 /* ` */) {
    return false;
  }

  // scan marker length
  mem = pos;
  pos = state.skipChars(pos, marker);
  len = pos - mem;
  if (len < 3) {
    return false;
  }
  markup = state.src.slice(mem, pos);
  params = state.src.slice(pos, max);
  if (marker === 0x60 /* ` */) {
    if (params.indexOf(String.fromCharCode(marker)) >= 0) {
      return false;
    }
  }

  // Since start is found, we can report success here in validation mode
  if (silent) {
    return true;
  }

  // search end of block
  nextLine = startLine;
  for (;;) {
    nextLine++;
    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }
    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];
    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }
    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }
    pos = state.skipChars(pos, marker);

    // closing code fence must be at least as long as the opening one
    if (pos - mem < len) {
      continue;
    }

    // make sure tail has spaces only
    pos = state.skipSpaces(pos);
    if (pos < max) {
      continue;
    }
    haveEndMarker = true;
    // found!
    break;
  }

  // If a fence has heading spaces, they should be removed from its inner block
  len = state.sCount[startLine];
  state.line = nextLine + (haveEndMarker ? 1 : 0);
  token = state.push('fence', 'code', 0);
  token.info = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state.line];
  return true;
};

/***/ }),

/***/ 5492:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// heading (#, ##, ...)



var isSpace = (__webpack_require__(7504).isSpace);
module.exports = function heading(state, startLine, endLine, silent) {
  var ch,
    level,
    tmp,
    token,
    pos = state.bMarks[startLine] + state.tShift[startLine],
    max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  ch = state.src.charCodeAt(pos);
  if (ch !== 0x23 /* # */ || pos >= max) {
    return false;
  }

  // count heading level
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 0x23 /* # */ && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }
  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }
  if (silent) {
    return true;
  }

  // Let's cut tails like '    ###  ' from the end of string

  max = state.skipSpacesBack(max, pos);
  tmp = state.skipCharsBack(max, 0x23, pos); // #
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }
  state.line = startLine + 1;
  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = '########'.slice(0, level);
  token.map = [startLine, state.line];
  token = state.push('inline', '', 0);
  token.content = state.src.slice(pos, max).trim();
  token.map = [startLine, state.line];
  token.children = [];
  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = '########'.slice(0, level);
  return true;
};

/***/ }),

/***/ 622:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Horizontal rule



var isSpace = (__webpack_require__(7504).isSpace);
module.exports = function hr(state, startLine, endLine, silent) {
  var marker,
    cnt,
    ch,
    token,
    pos = state.bMarks[startLine] + state.tShift[startLine],
    max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  marker = state.src.charCodeAt(pos++);

  // Check hr marker
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x5F /* _ */) {
    return false;
  }

  // markers can be mixed with spaces, but there should be at least 3 of them

  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }
  if (cnt < 3) {
    return false;
  }
  if (silent) {
    return true;
  }
  state.line = startLine + 1;
  token = state.push('hr', 'hr', 0);
  token.map = [startLine, state.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
  return true;
};

/***/ }),

/***/ 7607:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// HTML block



var block_names = __webpack_require__(9204);
var HTML_OPEN_CLOSE_TAG_RE = (__webpack_require__(7110)/* .HTML_OPEN_CLOSE_TAG_RE */ .q);

// An array of opening and corresponding closing sequences for html tags,
// last argument defines whether it can terminate a paragraph or not
//
var HTML_SEQUENCES = [[/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true], [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'), /^$/, false]];
module.exports = function html_block(state, startLine, endLine, silent) {
  var i,
    nextLine,
    token,
    lineText,
    pos = state.bMarks[startLine] + state.tShift[startLine],
    max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (!state.md.options.html) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
    return false;
  }
  lineText = state.src.slice(pos, max);
  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }
  if (i === HTML_SEQUENCES.length) {
    return false;
  }
  if (silent) {
    // true if this sequence can be a terminator, false otherwise
    return HTML_SEQUENCES[i][2];
  }
  nextLine = startLine + 1;

  // If we are here - we detected HTML block.
  // Let's roll down till block end.
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);
      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }
  state.line = nextLine;
  token = state.push('html_block', '', 0);
  token.map = [startLine, nextLine];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
  return true;
};

/***/ }),

/***/ 6726:
/***/ ((module) => {

"use strict";
// lheading (---, ===)



module.exports = function lheading(state, startLine, endLine /*, silent*/) {
  var content,
    terminate,
    i,
    l,
    token,
    pos,
    max,
    level,
    marker,
    nextLine = startLine + 1,
    oldParentType,
    terminatorRules = state.md.block.ruler.getRules('paragraph');

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  oldParentType = state.parentType;
  state.parentType = 'paragraph'; // use paragraph to match terminatorRules

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    //
    // Check for underline in setext header
    //
    if (state.sCount[nextLine] >= state.blkIndent) {
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      if (pos < max) {
        marker = state.src.charCodeAt(pos);
        if (marker === 0x2D /* - */ || marker === 0x3D /* = */) {
          pos = state.skipChars(pos, marker);
          pos = state.skipSpaces(pos);
          if (pos >= max) {
            level = marker === 0x3D /* = */ ? 1 : 2;
            break;
          }
        }
      }
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  if (!level) {
    // Didn't find valid underline
    return false;
  }
  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine + 1;
  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = String.fromCharCode(marker);
  token.map = [startLine, state.line];
  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line - 1];
  token.children = [];
  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = String.fromCharCode(marker);
  state.parentType = oldParentType;
  return true;
};

/***/ }),

/***/ 6483:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Lists



var isSpace = (__webpack_require__(7504).isSpace);

// Search `[-+*][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipBulletListMarker(state, startLine) {
  var marker, pos, max, ch;
  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];
  marker = state.src.charCodeAt(pos++);
  // Check bullet
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x2B /* + */) {
    return -1;
  }
  if (pos < max) {
    ch = state.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      // " -test " - is not a list item
      return -1;
    }
  }
  return pos;
}

// Search `\d+[.)][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipOrderedListMarker(state, startLine) {
  var ch,
    start = state.bMarks[startLine] + state.tShift[startLine],
    pos = start,
    max = state.eMarks[startLine];

  // List marker should have at least 2 chars (digit + dot)
  if (pos + 1 >= max) {
    return -1;
  }
  ch = state.src.charCodeAt(pos++);
  if (ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */) {
    return -1;
  }
  for (;;) {
    // EOL -> fail
    if (pos >= max) {
      return -1;
    }
    ch = state.src.charCodeAt(pos++);
    if (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) {
      // List marker should have no more than 9 digits
      // (prevents integer overflow in browsers)
      if (pos - start >= 10) {
        return -1;
      }
      continue;
    }

    // found valid marker
    if (ch === 0x29 /* ) */ || ch === 0x2e /* . */) {
      break;
    }
    return -1;
  }
  if (pos < max) {
    ch = state.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      // " 1.test " - is not a list item
      return -1;
    }
  }
  return pos;
}
function markTightParagraphs(state, idx) {
  var i,
    l,
    level = state.level + 2;
  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}
module.exports = function list(state, startLine, endLine, silent) {
  var ch,
    contentStart,
    i,
    indent,
    indentAfterMarker,
    initial,
    isOrdered,
    itemLines,
    l,
    listLines,
    listTokIdx,
    markerCharCode,
    markerValue,
    max,
    nextLine,
    offset,
    oldListIndent,
    oldParentType,
    oldSCount,
    oldTShift,
    oldTight,
    pos,
    posAfterMarker,
    prevEmptyEnd,
    start,
    terminate,
    terminatorRules,
    token,
    isTerminatingParagraph = false,
    tight = true;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // Special case:
  //  - item 1
  //   - item 2
  //    - item 3
  //     - item 4
  //      - this one is a paragraph continuation
  if (state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {
    return false;
  }

  // limit conditions when list can interrupt
  // a paragraph (validation mode only)
  if (silent && state.parentType === 'paragraph') {
    // Next list item should still terminate previous list item;
    //
    // This code can fail if plugins use blkIndent as well as lists,
    // but I hope the spec gets fixed long before that happens.
    //
    if (state.sCount[startLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }

  // Detect list type and position after marker
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.slice(start, posAfterMarker - 1));

    // If we're starting a new ordered list right after
    // a paragraph, it should start with 1.
    if (isTerminatingParagraph && markerValue !== 1) return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }

  // If we're starting a new unordered list right after
  // a paragraph, first line should not be empty.
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
  }

  // We should terminate list on style change. Remember first one to compare.
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

  // For validation mode we can terminate immediately
  if (silent) {
    return true;
  }

  // Start list
  listTokIdx = state.tokens.length;
  if (isOrdered) {
    token = state.push('ordered_list_open', 'ol', 1);
    if (markerValue !== 1) {
      token.attrs = [['start', markerValue]];
    }
  } else {
    token = state.push('bullet_list_open', 'ul', 1);
  }
  token.map = listLines = [startLine, 0];
  token.markup = String.fromCharCode(markerCharCode);

  //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.md.block.ruler.getRules('list');
  oldParentType = state.parentType;
  state.parentType = 'list';
  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];
    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);
    while (pos < max) {
      ch = state.src.charCodeAt(pos);
      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch === 0x20) {
        offset++;
      } else {
        break;
      }
      pos++;
    }
    contentStart = pos;
    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }

    // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }

    // "  -  test"
    //  ^^^^^ - calculating total length of this thing
    indent = initial + indentAfterMarker;

    // Run subparser & write tokens
    token = state.push('list_item_open', 'li', 1);
    token.markup = String.fromCharCode(markerCharCode);
    token.map = itemLines = [startLine, 0];
    if (isOrdered) {
      token.info = state.src.slice(start, posAfterMarker - 1);
    }

    // change current state, then restore it after parser subcall
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldSCount = state.sCount[startLine];

    //  - example list
    // ^ listIndent position will be here
    //   ^ blkIndent position will be here
    //
    oldListIndent = state.listIndent;
    state.listIndent = state.blkIndent;
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.sCount[startLine] = offset;
    if (contentStart >= max && state.isEmpty(startLine + 1)) {
      // workaround for this case
      // (list item is empty, list terminates before "foo"):
      // ~~~~~~~~
      //   -
      //
      //     foo
      // ~~~~~~~~
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, startLine, endLine, true);
    }

    // If any of list item is tight, mark list as tight
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish
    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
    state.blkIndent = state.listIndent;
    state.listIndent = oldListIndent;
    state.tShift[startLine] = oldTShift;
    state.sCount[startLine] = oldSCount;
    state.tight = oldTight;
    token = state.push('list_item_close', 'li', -1);
    token.markup = String.fromCharCode(markerCharCode);
    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];
    if (nextLine >= endLine) {
      break;
    }

    //
    // Try to check if list is terminated or continued.
    //
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    // if it's indented more than 3 spaces, it should be a code block
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      break;
    }

    // fail if terminating block found
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }

    // fail if list has another type
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
      start = state.bMarks[nextLine] + state.tShift[nextLine];
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }
    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }

  // Finalize list
  if (isOrdered) {
    token = state.push('ordered_list_close', 'ol', -1);
  } else {
    token = state.push('bullet_list_close', 'ul', -1);
  }
  token.markup = String.fromCharCode(markerCharCode);
  listLines[1] = nextLine;
  state.line = nextLine;
  state.parentType = oldParentType;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }
  return true;
};

/***/ }),

/***/ 3794:
/***/ ((module) => {

"use strict";
// Paragraph



module.exports = function paragraph(state, startLine /*, endLine*/) {
  var content,
    terminate,
    i,
    l,
    token,
    oldParentType,
    nextLine = startLine + 1,
    terminatorRules = state.md.block.ruler.getRules('paragraph'),
    endLine = state.lineMax;
  oldParentType = state.parentType;
  state.parentType = 'paragraph';

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine;
  token = state.push('paragraph_open', 'p', 1);
  token.map = [startLine, state.line];
  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line];
  token.children = [];
  token = state.push('paragraph_close', 'p', -1);
  state.parentType = oldParentType;
  return true;
};

/***/ }),

/***/ 9194:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var normalizeReference = (__webpack_require__(7504).normalizeReference);
var isSpace = (__webpack_require__(7504).isSpace);
module.exports = function reference(state, startLine, _endLine, silent) {
  var ch,
    destEndPos,
    destEndLineNo,
    endLine,
    href,
    i,
    l,
    label,
    labelEnd,
    oldParentType,
    res,
    start,
    str,
    terminate,
    terminatorRules,
    title,
    lines = 0,
    pos = state.bMarks[startLine] + state.tShift[startLine],
    max = state.eMarks[startLine],
    nextLine = startLine + 1;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 0x5B /* [ */) {
    return false;
  }

  // Simple check to quickly interrupt scan on [link](url) at the start of line.
  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
  while (++pos < max) {
    if (state.src.charCodeAt(pos) === 0x5D /* ] */ && state.src.charCodeAt(pos - 1) !== 0x5C /* \ */) {
      if (pos + 1 === max) {
        return false;
      }
      if (state.src.charCodeAt(pos + 1) !== 0x3A /* : */) {
        return false;
      }
      break;
    }
  }
  endLine = state.lineMax;

  // jump line-by-line until empty one or EOF
  terminatorRules = state.md.block.ruler.getRules('reference');
  oldParentType = state.parentType;
  state.parentType = 'reference';
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  max = str.length;
  for (pos = 1; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x5B /* [ */) {
      return false;
    } else if (ch === 0x5D /* ] */) {
      labelEnd = pos;
      break;
    } else if (ch === 0x0A /* \n */) {
      lines++;
    } else if (ch === 0x5C /* \ */) {
      pos++;
      if (pos < max && str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }
  }
  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A /* : */) {
    return false;
  }

  // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here
  for (pos = labelEnd + 2; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this
  res = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!res.ok) {
    return false;
  }
  href = state.md.normalizeLink(res.str);
  if (!state.md.validateLink(href)) {
    return false;
  }
  pos = res.pos;
  lines += res.lines;

  // save cursor state, we could require to rollback later
  destEndPos = pos;
  destEndLineNo = lines;

  // [label]:   destination   'title'
  //                       ^^^ skipping those spaces
  start = pos;
  for (; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //                          ^^^^^^^ parse this
  res = state.md.helpers.parseLinkTitle(str, pos, max);
  if (pos < max && start !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = '';
    pos = destEndPos;
    lines = destEndLineNo;
  }

  // skip trailing spaces until the rest of the line
  while (pos < max) {
    ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }
  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    if (title) {
      // garbage at the end of the line after title,
      // but it could still be a valid reference if we roll back
      title = '';
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }
  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    // garbage at the end of the line
    return false;
  }
  label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    // CommonMark 0.20 disallows empty labels
    return false;
  }

  // Reference can not terminate anything. This check is for safety only.
  /*istanbul ignore if*/
  if (silent) {
    return true;
  }
  if (typeof state.env.references === 'undefined') {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === 'undefined') {
    state.env.references[label] = {
      title: title,
      href: href
    };
  }
  state.parentType = oldParentType;
  state.line = startLine + lines + 1;
  return true;
};

/***/ }),

/***/ 9031:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Parser state class



var Token = __webpack_require__(8253);
var isSpace = (__webpack_require__(7504).isSpace);
function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;
  this.src = src;

  // link to parser instance
  this.md = md;
  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;
  this.bMarks = []; // line begin offsets for fast jumps
  this.eMarks = []; // line end offsets for fast jumps
  this.tShift = []; // offsets of the first non-space characters (tabs not expanded)
  this.sCount = []; // indents for each line (tabs expanded)

  // An amount of virtual spaces (tabs expanded) between beginning
  // of each line (bMarks) and real beginning of that line.
  //
  // It exists only as a hack because blockquotes override bMarks
  // losing information in the process.
  //
  // It's used only when expanding tabs, you can think about it as
  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
  // means first tab should be expanded to 4-21%4 === 3 spaces.
  //
  this.bsCount = [];

  // block parser variables
  this.blkIndent = 0; // required block content indent (for example, if we are
  // inside a list, it would be positioned after list marker)
  this.line = 0; // line index in src
  this.lineMax = 0; // lines count
  this.tight = false; // loose/tight mode for lists
  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)
  this.listIndent = -1; // indent of the current list block (-1 if there isn't any)

  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
  // used in lists to determine if they interrupt a paragraph
  this.parentType = 'root';
  this.level = 0;

  // renderer
  this.result = '';

  // Create caches
  // Generate markers.
  s = this.src;
  indent_found = false;
  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);
    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;
        if (ch === 0x09) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }
    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);
      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);
  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

// Push new token to "stream".
//
StateBlock.prototype.push = function (type, tag, nesting) {
  var token = new Token(type, tag, nesting);
  token.block = true;
  if (nesting < 0) this.level--; // closing tag
  token.level = this.level;
  if (nesting > 0) this.level++; // opening tag

  this.tokens.push(token);
  return token;
};
StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};
StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};

// Skip spaces from given position.
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch;
  for (var max = this.src.length; pos < max; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};

// Skip spaces from given position in reverse.
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};

// Skip char codes from given position
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) {
      break;
    }
  }
  return pos;
};

// Skip char codes reverse from given position - 1
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};

// cut lines range from source.
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i,
    lineIndent,
    ch,
    first,
    last,
    queue,
    lineStart,
    line = begin;
  if (begin >= end) {
    return '';
  }
  queue = new Array(end - begin);
  for (i = 0; line < end; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];
    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }
    while (first < last && lineIndent < indent) {
      ch = this.src.charCodeAt(first);
      if (isSpace(ch)) {
        if (ch === 0x09) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        // patched tShift masked characters to look like spaces (blockquotes, list markers)
        lineIndent++;
      } else {
        break;
      }
      first++;
    }
    if (lineIndent > indent) {
      // partially expanding tabs in code blocks, e.g '\t\tfoobar'
      // with indent=2 becomes '  \tfoobar'
      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }
  return queue.join('');
};

// re-export Token class to use in block rules
StateBlock.prototype.Token = Token;
module.exports = StateBlock;

/***/ }),

/***/ 6961:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// GFM table, https://github.github.com/gfm/#tables-extension-



var isSpace = (__webpack_require__(7504).isSpace);
function getLine(state, line) {
  var pos = state.bMarks[line] + state.tShift[line],
    max = state.eMarks[line];
  return state.src.substr(pos, max - pos);
}
function escapedSplit(str) {
  var result = [],
    pos = 0,
    max = str.length,
    ch,
    isEscaped = false,
    lastPos = 0,
    current = '';
  ch = str.charCodeAt(pos);
  while (pos < max) {
    if (ch === 0x7c /* | */) {
      if (!isEscaped) {
        // pipe separating cells, '|'
        result.push(current + str.substring(lastPos, pos));
        current = '';
        lastPos = pos + 1;
      } else {
        // escaped pipe, '\|'
        current += str.substring(lastPos, pos - 1);
        lastPos = pos;
      }
    }
    isEscaped = ch === 0x5c /* \ */;
    pos++;
    ch = str.charCodeAt(pos);
  }
  result.push(current + str.substring(lastPos));
  return result;
}
module.exports = function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, l, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;

  // should have at least two lines
  if (startLine + 2 > endLine) {
    return false;
  }
  nextLine = startLine + 1;
  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }

  // first character of the second line should be '|', '-', ':',
  // and no other characters are allowed but spaces;
  // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp

  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  firstCh = state.src.charCodeAt(pos++);
  if (firstCh !== 0x7C /* | */ && firstCh !== 0x2D /* - */ && firstCh !== 0x3A /* : */) {
    return false;
  }
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  secondCh = state.src.charCodeAt(pos++);
  if (secondCh !== 0x7C /* | */ && secondCh !== 0x2D /* - */ && secondCh !== 0x3A /* : */ && !isSpace(secondCh)) {
    return false;
  }

  // if first character is '-', then second character must not be a space
  // (due to parsing ambiguity with list)
  if (firstCh === 0x2D /* - */ && isSpace(secondCh)) {
    return false;
  }
  while (pos < state.eMarks[nextLine]) {
    ch = state.src.charCodeAt(pos);
    if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */ && !isSpace(ch)) {
      return false;
    }
    pos++;
  }
  lineText = getLine(state, startLine + 1);
  columns = lineText.split('|');
  aligns = [];
  for (i = 0; i < columns.length; i++) {
    t = columns[i].trim();
    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }
    if (!/^:?-+:?$/.test(t)) {
      return false;
    }
    if (t.charCodeAt(t.length - 1) === 0x3A /* : */) {
      aligns.push(t.charCodeAt(0) === 0x3A /* : */ ? 'center' : 'right');
    } else if (t.charCodeAt(0) === 0x3A /* : */) {
      aligns.push('left');
    } else {
      aligns.push('');
    }
  }
  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf('|') === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText);
  if (columns.length && columns[0] === '') columns.shift();
  if (columns.length && columns[columns.length - 1] === '') columns.pop();

  // header row will define an amount of columns in the entire table,
  // and align row should be exactly the same (the rest of the rows can differ)
  columnCount = columns.length;
  if (columnCount === 0 || columnCount !== aligns.length) {
    return false;
  }
  if (silent) {
    return true;
  }
  oldParentType = state.parentType;
  state.parentType = 'table';

  // use 'blockquote' lists for termination because it's
  // the most similar to tables
  terminatorRules = state.md.block.ruler.getRules('blockquote');
  token = state.push('table_open', 'table', 1);
  token.map = tableLines = [startLine, 0];
  token = state.push('thead_open', 'thead', 1);
  token.map = [startLine, startLine + 1];
  token = state.push('tr_open', 'tr', 1);
  token.map = [startLine, startLine + 1];
  for (i = 0; i < columns.length; i++) {
    token = state.push('th_open', 'th', 1);
    if (aligns[i]) {
      token.attrs = [['style', 'text-align:' + aligns[i]]];
    }
    token = state.push('inline', '', 0);
    token.content = columns[i].trim();
    token.children = [];
    token = state.push('th_close', 'th', -1);
  }
  token = state.push('tr_close', 'tr', -1);
  token = state.push('thead_close', 'thead', -1);
  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    lineText = getLine(state, nextLine).trim();
    if (!lineText) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === '') columns.shift();
    if (columns.length && columns[columns.length - 1] === '') columns.pop();
    if (nextLine === startLine + 2) {
      token = state.push('tbody_open', 'tbody', 1);
      token.map = tbodyLines = [startLine + 2, 0];
    }
    token = state.push('tr_open', 'tr', 1);
    token.map = [nextLine, nextLine + 1];
    for (i = 0; i < columnCount; i++) {
      token = state.push('td_open', 'td', 1);
      if (aligns[i]) {
        token.attrs = [['style', 'text-align:' + aligns[i]]];
      }
      token = state.push('inline', '', 0);
      token.content = columns[i] ? columns[i].trim() : '';
      token.children = [];
      token = state.push('td_close', 'td', -1);
    }
    token = state.push('tr_close', 'tr', -1);
  }
  if (tbodyLines) {
    token = state.push('tbody_close', 'tbody', -1);
    tbodyLines[1] = nextLine;
  }
  token = state.push('table_close', 'table', -1);
  tableLines[1] = nextLine;
  state.parentType = oldParentType;
  state.line = nextLine;
  return true;
};

/***/ }),

/***/ 5199:
/***/ ((module) => {

"use strict";


module.exports = function block(state) {
  var token;
  if (state.inlineMode) {
    token = new state.Token('inline', '', 0);
    token.content = state.src;
    token.map = [0, 1];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
};

/***/ }),

/***/ 3286:
/***/ ((module) => {

"use strict";


module.exports = function inline(state) {
  var tokens = state.tokens,
    tok,
    i,
    l;

  // Parse inlines
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === 'inline') {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
};

/***/ }),

/***/ 3490:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Replace link-like texts with link nodes.
//
// Currently restricted by `md.validateLink()` to http/https/ftp
//


var arrayReplaceAt = (__webpack_require__(7504).arrayReplaceAt);
function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}
module.exports = function linkify(state) {
  var i,
    j,
    l,
    tokens,
    token,
    currentToken,
    nodes,
    ln,
    text,
    pos,
    lastPos,
    level,
    htmlLinkLevel,
    url,
    fullUrl,
    urlText,
    blockTokens = state.tokens,
    links;
  if (!state.md.options.linkify) {
    return;
  }
  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline' || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }
    tokens = blockTokens[j].children;
    htmlLinkLevel = 0;

    // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match
    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i];

      // Skip content of markdown links
      if (currentToken.type === 'link_close') {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
          i--;
        }
        continue;
      }

      // Skip content of html tag links
      if (currentToken.type === 'html_inline') {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }
      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {
        text = currentToken.content;
        links = state.md.linkify.match(text);

        // Now split string to nodes
        nodes = [];
        level = currentToken.level;
        lastPos = 0;
        for (ln = 0; ln < links.length; ln++) {
          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }
          urlText = links[ln].text;

          // Linkifier might send raw hostnames like "example.com", where url
          // starts with domain name. So we prepend http:// in those cases,
          // and remove it afterwards.
          //
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }
          pos = links[ln].index;
          if (pos > lastPos) {
            token = new state.Token('text', '', 0);
            token.content = text.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }
          token = new state.Token('link_open', 'a', 1);
          token.attrs = [['href', fullUrl]];
          token.level = level++;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);
          token = new state.Token('text', '', 0);
          token.content = urlText;
          token.level = level;
          nodes.push(token);
          token = new state.Token('link_close', 'a', -1);
          token.level = --level;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);
          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text.length) {
          token = new state.Token('text', '', 0);
          token.content = text.slice(lastPos);
          token.level = level;
          nodes.push(token);
        }

        // replace current node
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
};

/***/ }),

/***/ 4140:
/***/ ((module) => {

"use strict";
// Normalize input string



// https://spec.commonmark.org/0.29/#line-ending
var NEWLINES_RE = /\r\n?|\n/g;
var NULL_RE = /\0/g;
module.exports = function normalize(state) {
  var str;

  // Normalize newlines
  str = state.src.replace(NEWLINES_RE, '\n');

  // Replace NULL characters
  str = str.replace(NULL_RE, '\uFFFD');
  state.src = str;
};

/***/ }),

/***/ 5131:
/***/ ((module) => {

"use strict";
// Simple typographic replacements
//
// (c) (C) → ©
// (tm) (TM) → ™
// (r) (R) → ®
// +- → ±
// (p) (P) -> §
// ... → … (also ?.... → ?.., !.... → !..)
// ???????? → ???, !!!!! → !!!, `,,` → `,`
// -- → &ndash;, --- → &mdash;
//


// TODO:
// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾
// - miltiplication 2 x 4 -> 2 × 4
var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

// Workaround for phantomjs - need regex without /g flag,
// or root check will fail every second time
var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;
var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  c: '©',
  r: '®',
  p: '§',
  tm: '™'
};
function replaceFn(match, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}
function replace_scoped(inlineTokens) {
  var i,
    token,
    inside_autolink = 0;
  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];
    if (token.type === 'text' && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }
    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }
    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}
function replace_rare(inlineTokens) {
  var i,
    token,
    inside_autolink = 0;
  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];
    if (token.type === 'text' && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, '±')
        // .., ..., ....... -> …
        // but ?..... & !..... -> ?.. & !..
        .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..').replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
        // em-dash
        .replace(/(^|[^-])---(?=[^-]|$)/mg, '$1\u2014')
        // en-dash
        .replace(/(^|\s)--(?=\s|$)/mg, '$1\u2013').replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, '$1\u2013');
      }
    }
    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }
    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}
module.exports = function replace(state) {
  var blkIdx;
  if (!state.md.options.typographer) {
    return;
  }
  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== 'inline') {
      continue;
    }
    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }
    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
};

/***/ }),

/***/ 7185:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Convert straight quotation marks to typographic ones
//


var isWhiteSpace = (__webpack_require__(7504).isWhiteSpace);
var isPunctChar = (__webpack_require__(7504).isPunctChar);
var isMdAsciiPunct = (__webpack_require__(7504).isMdAsciiPunct);
var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = '\u2019'; /* ’ */

function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}
function process_inlines(tokens, state) {
  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
  stack = [];
  for (i = 0; i < tokens.length; i++) {
    token = tokens[i];
    thisLevel = tokens[i].level;
    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;
    if (token.type !== 'text') {
      continue;
    }
    text = token.content;
    pos = 0;
    max = text.length;

    /*eslint no-labels:0,block-scoped-var:0*/
    OUTER: while (pos < max) {
      QUOTE_RE.lastIndex = pos;
      t = QUOTE_RE.exec(text);
      if (!t) {
        break;
      }
      canOpen = canClose = true;
      pos = t.index + 1;
      isSingle = t[0] === "'";

      // Find previous character,
      // default to space if it's the beginning of the line
      //
      lastChar = 0x20;
      if (t.index - 1 >= 0) {
        lastChar = text.charCodeAt(t.index - 1);
      } else {
        for (j = i - 1; j >= 0; j--) {
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20
          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'

          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
          break;
        }
      }

      // Find next character,
      // default to space if it's the end of the line
      //
      nextChar = 0x20;
      if (pos < max) {
        nextChar = text.charCodeAt(pos);
      } else {
        for (j = i + 1; j < tokens.length; j++) {
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20
          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'

          nextChar = tokens[j].content.charCodeAt(0);
          break;
        }
      }
      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);
      if (isNextWhiteSpace) {
        canOpen = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          canOpen = false;
        }
      }
      if (isLastWhiteSpace) {
        canClose = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          canClose = false;
        }
      }
      if (nextChar === 0x22 /* " */ && t[0] === '"') {
        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
          // special case: 1"" - count first quote as an inch
          canClose = canOpen = false;
        }
      }
      if (canOpen && canClose) {
        // Replace quotes in the middle of punctuation sequence, but not
        // in the middle of the words, i.e.:
        //
        // 1. foo " bar " baz - not replaced
        // 2. foo-"-bar-"-baz - replaced
        // 3. foo"bar"baz     - not replaced
        //
        canOpen = isLastPunctChar;
        canClose = isNextPunctChar;
      }
      if (!canOpen && !canClose) {
        // middle of word
        if (isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
        continue;
      }
      if (canClose) {
        // this could be a closing quote, rewind the stack to get a match
        for (j = stack.length - 1; j >= 0; j--) {
          item = stack[j];
          if (stack[j].level < thisLevel) {
            break;
          }
          if (item.single === isSingle && stack[j].level === thisLevel) {
            item = stack[j];
            if (isSingle) {
              openQuote = state.md.options.quotes[2];
              closeQuote = state.md.options.quotes[3];
            } else {
              openQuote = state.md.options.quotes[0];
              closeQuote = state.md.options.quotes[1];
            }

            // replace token.content *before* tokens[item.token].content,
            // because, if they are pointing at the same token, replaceAt
            // could mess up indices when quote length != 1
            token.content = replaceAt(token.content, t.index, closeQuote);
            tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);
            pos += closeQuote.length - 1;
            if (item.token === i) {
              pos += openQuote.length - 1;
            }
            text = token.content;
            max = text.length;
            stack.length = j;
            continue OUTER;
          }
        }
      }
      if (canOpen) {
        stack.push({
          token: i,
          pos: t.index,
          single: isSingle,
          level: thisLevel
        });
      } else if (canClose && isSingle) {
        token.content = replaceAt(token.content, t.index, APOSTROPHE);
      }
    }
  }
}
module.exports = function smartquotes(state) {
  /*eslint max-depth:0*/
  var blkIdx;
  if (!state.md.options.typographer) {
    return;
  }
  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== 'inline' || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }
    process_inlines(state.tokens[blkIdx].children, state);
  }
};

/***/ }),

/***/ 6546:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Core state object
//


var Token = __webpack_require__(8253);
function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md; // link to parser instance
}

// re-export Token class to use in core rules
StateCore.prototype.Token = Token;
module.exports = StateCore;

/***/ }),

/***/ 6891:
/***/ ((module) => {

"use strict";
// Process autolinks '<protocol:...>'



/*eslint max-len:0*/
var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
module.exports = function autolink(state, silent) {
  var url,
    fullUrl,
    token,
    ch,
    start,
    max,
    pos = state.pos;
  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
    return false;
  }
  start = state.pos;
  max = state.posMax;
  for (;;) {
    if (++pos >= max) return false;
    ch = state.src.charCodeAt(pos);
    if (ch === 0x3C /* < */) return false;
    if (ch === 0x3E /* > */) break;
  }
  url = state.src.slice(start + 1, pos);
  if (AUTOLINK_RE.test(url)) {
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';
      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);
      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }
    state.pos += url.length + 2;
    return true;
  }
  if (EMAIL_RE.test(url)) {
    fullUrl = state.md.normalizeLink('mailto:' + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';
      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);
      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }
    state.pos += url.length + 2;
    return true;
  }
  return false;
};

/***/ }),

/***/ 8326:
/***/ ((module) => {

"use strict";
// Parse backticks



module.exports = function backtick(state, silent) {
  var start,
    max,
    marker,
    token,
    matchStart,
    matchEnd,
    openerLength,
    closerLength,
    pos = state.pos,
    ch = state.src.charCodeAt(pos);
  if (ch !== 0x60 /* ` */) {
    return false;
  }
  start = pos;
  pos++;
  max = state.posMax;

  // scan marker length
  while (pos < max && state.src.charCodeAt(pos) === 0x60 /* ` */) {
    pos++;
  }
  marker = state.src.slice(start, pos);
  openerLength = marker.length;
  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
    if (!silent) state.pending += marker;
    state.pos += openerLength;
    return true;
  }
  matchStart = matchEnd = pos;

  // Nothing found in the cache, scan until the end of the line (or until marker is found)
  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    // scan marker length
    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60 /* ` */) {
      matchEnd++;
    }
    closerLength = matchEnd - matchStart;
    if (closerLength === openerLength) {
      // Found matching closer length.
      if (!silent) {
        token = state.push('code_inline', 'code', 0);
        token.markup = marker;
        token.content = state.src.slice(pos, matchStart).replace(/\n/g, ' ').replace(/^ (.+) $/, '$1');
      }
      state.pos = matchEnd;
      return true;
    }

    // Some different length found, put it in cache as upper limit of where closer can be found
    state.backticks[closerLength] = matchStart;
  }

  // Scanned through the end, didn't find anything
  state.backticksScanned = true;
  if (!silent) state.pending += marker;
  state.pos += openerLength;
  return true;
};

/***/ }),

/***/ 4312:
/***/ ((module) => {

"use strict";
// For each opening emphasis-like marker find a matching closing one
//


function processDelimiters(state, delimiters) {
  var closerIdx,
    openerIdx,
    closer,
    opener,
    minOpenerIdx,
    newMinOpenerIdx,
    isOddMatch,
    lastJump,
    openersBottom = {},
    max = delimiters.length;
  if (!max) return;

  // headerIdx is the first delimiter of the current (where closer is) delimiter run
  var headerIdx = 0;
  var lastTokenIdx = -2; // needs any value lower than -1
  var jumps = [];
  for (closerIdx = 0; closerIdx < max; closerIdx++) {
    closer = delimiters[closerIdx];
    jumps.push(0);

    // markers belong to same delimiter run if:
    //  - they have adjacent tokens
    //  - AND markers are the same
    //
    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
      headerIdx = closerIdx;
    }
    lastTokenIdx = closer.token;

    // Length is only used for emphasis-specific "rule of 3",
    // if it's not defined (in strikethrough or 3rd party plugins),
    // we can default it to 0 to disable those checks.
    //
    closer.length = closer.length || 0;
    if (!closer.close) continue;

    // Previously calculated lower bounds (previous fails)
    // for each marker, each delimiter length modulo 3,
    // and for whether this closer can be an opener;
    // https://github.com/commonmark/cmark/commit/34250e12ccebdc6372b8b49c44fab57c72443460
    if (!openersBottom.hasOwnProperty(closer.marker)) {
      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
    }
    minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
    openerIdx = headerIdx - jumps[headerIdx] - 1;
    newMinOpenerIdx = openerIdx;
    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
      opener = delimiters[openerIdx];
      if (opener.marker !== closer.marker) continue;
      if (opener.open && opener.end < 0) {
        isOddMatch = false;

        // from spec:
        //
        // If one of the delimiters can both open and close emphasis, then the
        // sum of the lengths of the delimiter runs containing the opening and
        // closing delimiters must not be a multiple of 3 unless both lengths
        // are multiples of 3.
        //
        if (opener.close || closer.open) {
          if ((opener.length + closer.length) % 3 === 0) {
            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
              isOddMatch = true;
            }
          }
        }
        if (!isOddMatch) {
          // If previous delimiter cannot be an opener, we can safely skip
          // the entire sequence in future checks. This is required to make
          // sure algorithm has linear complexity (see *_*_*_*_*_... case).
          //
          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
          jumps[closerIdx] = closerIdx - openerIdx + lastJump;
          jumps[openerIdx] = lastJump;
          closer.open = false;
          opener.end = closerIdx;
          opener.close = false;
          newMinOpenerIdx = -1;
          // treat next token as start of run,
          // it optimizes skips in **<...>**a**<...>** pathological case
          lastTokenIdx = -2;
          break;
        }
      }
    }
    if (newMinOpenerIdx !== -1) {
      // If match for this delimiter run failed, we want to set lower bound for
      // future lookups. This is required to make sure algorithm has linear
      // complexity.
      //
      // See details here:
      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442
      //
      openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
    }
  }
}
module.exports = function link_pairs(state) {
  var curr,
    tokens_meta = state.tokens_meta,
    max = state.tokens_meta.length;
  processDelimiters(state, state.delimiters);
  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      processDelimiters(state, tokens_meta[curr].delimiters);
    }
  }
};

/***/ }),

/***/ 8023:
/***/ ((module) => {

"use strict";
// Process *this* and _that_
//


// Insert each marker as a separate text token, and add it to delimiter list
//
module.exports.w = function emphasis(state, silent) {
  var i,
    scanned,
    token,
    start = state.pos,
    marker = state.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) {
    return false;
  }
  scanned = state.scanDelims(state.pos, marker === 0x2A);
  for (i = 0; i < scanned.length; i++) {
    token = state.push('text', '', 0);
    token.content = String.fromCharCode(marker);
    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: marker,
      // Total length of these series of delimiters.
      //
      length: scanned.length,
      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
};
function postProcess(state, delimiters) {
  var i,
    startDelim,
    endDelim,
    token,
    ch,
    isStrong,
    max = delimiters.length;
  for (i = max - 1; i >= 0; i--) {
    startDelim = delimiters[i];
    if (startDelim.marker !== 0x5F /* _ */ && startDelim.marker !== 0x2A /* * */) {
      continue;
    }

    // Process only opening markers
    if (startDelim.end === -1) {
      continue;
    }
    endDelim = delimiters[startDelim.end];

    // If the previous delimiter has the same marker and is adjacent to this one,
    // merge those into one strong delimiter.
    //
    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
    //
    isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 &&
    // check that first two markers match and adjacent
    delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 &&
    // check that last two markers are adjacent (we can safely assume they match)
    delimiters[startDelim.end + 1].token === endDelim.token + 1;
    ch = String.fromCharCode(startDelim.marker);
    token = state.tokens[startDelim.token];
    token.type = isStrong ? 'strong_open' : 'em_open';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = 1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';
    token = state.tokens[endDelim.token];
    token.type = isStrong ? 'strong_close' : 'em_close';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = -1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';
    if (isStrong) {
      state.tokens[delimiters[i - 1].token].content = '';
      state.tokens[delimiters[startDelim.end + 1].token].content = '';
      i--;
    }
  }
}

// Walk through delimiter list and replace text tokens with tags
//
module.exports.g = function emphasis(state) {
  var curr,
    tokens_meta = state.tokens_meta,
    max = state.tokens_meta.length;
  postProcess(state, state.delimiters);
  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state, tokens_meta[curr].delimiters);
    }
  }
};

/***/ }),

/***/ 8685:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Process html entity - &#123;, &#xAF;, &quot;, ...



var entities = __webpack_require__(1087);
var has = (__webpack_require__(7504).has);
var isValidEntityCode = (__webpack_require__(7504).isValidEntityCode);
var fromCodePoint = (__webpack_require__(7504).fromCodePoint);
var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
module.exports = function entity(state, silent) {
  var ch,
    code,
    match,
    pos = state.pos,
    max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x26 /* & */) {
    return false;
  }
  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);
    if (ch === 0x23 /* # */) {
      match = state.src.slice(pos).match(DIGITAL_RE);
      if (match) {
        if (!silent) {
          code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
          state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
        }
        state.pos += match[0].length;
        return true;
      }
    } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        if (has(entities, match[1])) {
          if (!silent) {
            state.pending += entities[match[1]];
          }
          state.pos += match[0].length;
          return true;
        }
      }
    }
  }
  if (!silent) {
    state.pending += '&';
  }
  state.pos++;
  return true;
};

/***/ }),

/***/ 340:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Process escaped chars and hardbreaks



var isSpace = (__webpack_require__(7504).isSpace);
var ESCAPED = [];
for (var i = 0; i < 256; i++) {
  ESCAPED.push(0);
}
'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});
module.exports = function escape(state, silent) {
  var ch,
    pos = state.pos,
    max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x5C /* \ */) {
    return false;
  }
  pos++;
  if (pos < max) {
    ch = state.src.charCodeAt(pos);
    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) {
        state.pending += state.src[pos];
      }
      state.pos += 2;
      return true;
    }
    if (ch === 0x0A) {
      if (!silent) {
        state.push('hardbreak', 'br', 0);
      }
      pos++;
      // skip leading whitespaces from next line
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
      state.pos = pos;
      return true;
    }
  }
  if (!silent) {
    state.pending += '\\';
  }
  state.pos++;
  return true;
};

/***/ }),

/***/ 5061:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Process html tags



var HTML_TAG_RE = (__webpack_require__(7110)/* .HTML_TAG_RE */ .n);
function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return lc >= 0x61 /* a */ && lc <= 0x7a /* z */;
}

module.exports = function html_inline(state, silent) {
  var ch,
    match,
    max,
    token,
    pos = state.pos;
  if (!state.md.options.html) {
    return false;
  }

  // Check start
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x3C /* < */ || pos + 2 >= max) {
    return false;
  }

  // Quick fail on second char
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 0x21 /* ! */ && ch !== 0x3F /* ? */ && ch !== 0x2F /* / */ && !isLetter(ch)) {
    return false;
  }
  match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) {
    return false;
  }
  if (!silent) {
    token = state.push('html_inline', '', 0);
    token.content = state.src.slice(pos, pos + match[0].length);
  }
  state.pos += match[0].length;
  return true;
};

/***/ }),

/***/ 898:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Process ![image](<src> "title")



var normalizeReference = (__webpack_require__(7504).normalizeReference);
var isSpace = (__webpack_require__(7504).isSpace);
module.exports = function image(state, silent) {
  var attrs,
    code,
    content,
    label,
    labelEnd,
    labelStart,
    pos,
    ref,
    res,
    title,
    token,
    tokens,
    start,
    href = '',
    oldPos = state.pos,
    max = state.posMax;
  if (state.src.charCodeAt(state.pos) !== 0x21 /* ! */) {
    return false;
  }
  if (state.src.charCodeAt(state.pos + 1) !== 0x5B /* [ */) {
    return false;
  }
  labelStart = state.pos + 2;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
    //
    // Inline link
    //

    // [link](  <href>  "title"  )
    //        ^^ skipping these spaces
    pos++;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (!isSpace(code) && code !== 0x0A) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }

    // [link](  <href>  "title"  )
    //          ^^^^^^ parsing link destination
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = '';
      }
    }

    // [link](  <href>  "title"  )
    //                ^^ skipping these spaces
    start = pos;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (!isSpace(code) && code !== 0x0A) {
        break;
      }
    }

    // [link](  <href>  "title"  )
    //                  ^^^^^^^ parsing link title
    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;

      // [link](  <href>  "title"  )
      //                         ^^ skipping these spaces
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
    } else {
      title = '';
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
      state.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }
    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);
    state.md.inline.parse(content, state.md, state.env, tokens = []);
    token = state.push('image', 'img', 0);
    token.attrs = attrs = [['src', href], ['alt', '']];
    token.children = tokens;
    token.content = content;
    if (title) {
      attrs.push(['title', title]);
    }
  }
  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),

/***/ 1786:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Process [link](<to> "stuff")



var normalizeReference = (__webpack_require__(7504).normalizeReference);
var isSpace = (__webpack_require__(7504).isSpace);
module.exports = function link(state, silent) {
  var attrs,
    code,
    label,
    labelEnd,
    labelStart,
    pos,
    res,
    ref,
    token,
    href = '',
    title = '',
    oldPos = state.pos,
    max = state.posMax,
    start = state.pos,
    parseReference = true;
  if (state.src.charCodeAt(state.pos) !== 0x5B /* [ */) {
    return false;
  }
  labelStart = state.pos + 1;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
    //
    // Inline link
    //

    // might have found a valid shortcut link, disable reference parsing
    parseReference = false;

    // [link](  <href>  "title"  )
    //        ^^ skipping these spaces
    pos++;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (!isSpace(code) && code !== 0x0A) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }

    // [link](  <href>  "title"  )
    //          ^^^^^^ parsing link destination
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = '';
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      }
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
      // parsing a valid shortcut link failed, fallback to reference
      parseReference = true;
    }
    pos++;
  }
  if (parseReference) {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }
    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;
    token = state.push('link_open', 'a', 1);
    token.attrs = attrs = [['href', href]];
    if (title) {
      attrs.push(['title', title]);
    }
    state.md.inline.tokenize(state);
    token = state.push('link_close', 'a', -1);
  }
  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),

/***/ 8254:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Proceess '\n'



var isSpace = (__webpack_require__(7504).isSpace);
module.exports = function newline(state, silent) {
  var pmax,
    max,
    ws,
    pos = state.pos;
  if (state.src.charCodeAt(pos) !== 0x0A /* \n */) {
    return false;
  }
  pmax = state.pending.length - 1;
  max = state.posMax;

  // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        // Find whitespaces tail of pending chars.
        ws = pmax - 1;
        while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 0x20) ws--;
        state.pending = state.pending.slice(0, ws);
        state.push('hardbreak', 'br', 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push('softbreak', 'br', 0);
      }
    } else {
      state.push('softbreak', 'br', 0);
    }
  }
  pos++;

  // skip heading spaces for next line
  while (pos < max && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }
  state.pos = pos;
  return true;
};

/***/ }),

/***/ 9017:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Inline parser state



var Token = __webpack_require__(8253);
var isWhiteSpace = (__webpack_require__(7504).isWhiteSpace);
var isPunctChar = (__webpack_require__(7504).isPunctChar);
var isMdAsciiPunct = (__webpack_require__(7504).isMdAsciiPunct);
function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;
  this.tokens_meta = Array(outTokens.length);
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;

  // Stores { start: end } pairs. Useful for backtrack
  // optimization of pairs parse (emphasis, strikes).
  this.cache = {};

  // List of emphasis-like delimiters for current tag
  this.delimiters = [];

  // Stack of delimiter lists for upper level tags
  this._prev_delimiters = [];

  // backtick length => last seen position
  this.backticks = {};
  this.backticksScanned = false;
}

// Flush pending text
//
StateInline.prototype.pushPending = function () {
  var token = new Token('text', '', 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = '';
  return token;
};

// Push new token to "stream".
// If pending text exists - flush it as text token
//
StateInline.prototype.push = function (type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }
  var token = new Token(type, tag, nesting);
  var token_meta = null;
  if (nesting < 0) {
    // closing tag
    this.level--;
    this.delimiters = this._prev_delimiters.pop();
  }
  token.level = this.level;
  if (nesting > 0) {
    // opening tag
    this.level++;
    this._prev_delimiters.push(this.delimiters);
    this.delimiters = [];
    token_meta = {
      delimiters: this.delimiters
    };
  }
  this.pendingLevel = this.level;
  this.tokens.push(token);
  this.tokens_meta.push(token_meta);
  return token;
};

// Scan a sequence of emphasis-like markers, and determine whether
// it can start an emphasis sequence or end an emphasis sequence.
//
//  - start - position to scan from (it should point at a valid marker);
//  - canSplitWord - determine if these markers can be found inside a word
//
StateInline.prototype.scanDelims = function (start, canSplitWord) {
  var pos = start,
    lastChar,
    nextChar,
    count,
    can_open,
    can_close,
    isLastWhiteSpace,
    isLastPunctChar,
    isNextWhiteSpace,
    isNextPunctChar,
    left_flanking = true,
    right_flanking = true,
    max = this.posMax,
    marker = this.src.charCodeAt(start);

  // treat beginning of the line as a whitespace
  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;
  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }
  count = pos - start;

  // treat end of the line as a whitespace
  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;
  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);
  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }
  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }
  if (!canSplitWord) {
    can_open = left_flanking && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking || isNextPunctChar);
  } else {
    can_open = left_flanking;
    can_close = right_flanking;
  }
  return {
    can_open: can_open,
    can_close: can_close,
    length: count
  };
};

// re-export Token class to use in block rules
StateInline.prototype.Token = Token;
module.exports = StateInline;

/***/ }),

/***/ 8032:
/***/ ((module) => {

"use strict";
// ~~strike through~~
//


// Insert each marker as a separate text token, and add it to delimiter list
//
module.exports.w = function strikethrough(state, silent) {
  var i,
    scanned,
    token,
    len,
    ch,
    start = state.pos,
    marker = state.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker !== 0x7E /* ~ */) {
    return false;
  }
  scanned = state.scanDelims(state.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker);
  if (len < 2) {
    return false;
  }
  if (len % 2) {
    token = state.push('text', '', 0);
    token.content = ch;
    len--;
  }
  for (i = 0; i < len; i += 2) {
    token = state.push('text', '', 0);
    token.content = ch + ch;
    state.delimiters.push({
      marker: marker,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: state.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
};
function postProcess(state, delimiters) {
  var i,
    j,
    startDelim,
    endDelim,
    token,
    loneMarkers = [],
    max = delimiters.length;
  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];
    if (startDelim.marker !== 0x7E /* ~ */) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    endDelim = delimiters[startDelim.end];
    token = state.tokens[startDelim.token];
    token.type = 's_open';
    token.tag = 's';
    token.nesting = 1;
    token.markup = '~~';
    token.content = '';
    token = state.tokens[endDelim.token];
    token.type = 's_close';
    token.tag = 's';
    token.nesting = -1;
    token.markup = '~~';
    token.content = '';
    if (state.tokens[endDelim.token - 1].type === 'text' && state.tokens[endDelim.token - 1].content === '~') {
      loneMarkers.push(endDelim.token - 1);
    }
  }

  // If a marker sequence has an odd number of characters, it's splitted
  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
  // start of the sequence.
  //
  // So, we have to move all those markers after subsequent s_close tags.
  //
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;
    while (j < state.tokens.length && state.tokens[j].type === 's_close') {
      j++;
    }
    j--;
    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
}

// Walk through delimiter list and replace text tokens with tags
//
module.exports.g = function strikethrough(state) {
  var curr,
    tokens_meta = state.tokens_meta,
    max = state.tokens_meta.length;
  postProcess(state, state.delimiters);
  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state, tokens_meta[curr].delimiters);
    }
  }
};

/***/ }),

/***/ 6242:
/***/ ((module) => {

"use strict";
// Skip text characters for text token, place those to pending buffer
// and increment current pos



// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions

// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~

// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A /* \n */:
    case 0x21 /* ! */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2D /* - */:
    case 0x3A /* : */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}
module.exports = function text(state, silent) {
  var pos = state.pos;
  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }
  if (pos === state.pos) {
    return false;
  }
  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }
  state.pos = pos;
  return true;
};

// Alternative implementation, for memory.
//
// It costs 10% of performance, but allows extend terminators list, if place it
// to `ParcerInline` property. Probably, will switch to it sometime, such
// flexibility required.

/*
var TERMINATOR_RE = /[\n!#$%&*+\-:<=>@[\\\]^_`{}~]/;

module.exports = function text(state, silent) {
  var pos = state.pos,
      idx = state.src.slice(pos).search(TERMINATOR_RE);

  // first char is terminator -> empty text
  if (idx === 0) { return false; }

  // no terminator -> text till end of string
  if (idx < 0) {
    if (!silent) { state.pending += state.src.slice(pos); }
    state.pos = state.src.length;
    return true;
  }

  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }

  state.pos += idx;

  return true;
};*/

/***/ }),

/***/ 4013:
/***/ ((module) => {

"use strict";
// Clean up tokens after emphasis and strikethrough postprocessing:
// merge adjacent text nodes into one and re-calculate all token levels
//
// This is necessary because initially emphasis delimiter markers (*, _, ~)
// are treated as their own separate text tokens. Then emphasis rule either
// leaves them as text (needed to merge with adjacent text) or turns them
// into opening/closing tags (which messes up levels inside).
//


module.exports = function text_collapse(state) {
  var curr,
    last,
    level = 0,
    tokens = state.tokens,
    max = state.tokens.length;
  for (curr = last = 0; curr < max; curr++) {
    // re-calculate levels after emphasis/strikethrough turns some text nodes
    // into opening/closing tags
    if (tokens[curr].nesting < 0) level--; // closing tag
    tokens[curr].level = level;
    if (tokens[curr].nesting > 0) level++; // opening tag

    if (tokens[curr].type === 'text' && curr + 1 < max && tokens[curr + 1].type === 'text') {
      // collapse two adjacent text nodes
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }
      last++;
    }
  }
  if (curr !== last) {
    tokens.length = last;
  }
};

/***/ }),

/***/ 8253:
/***/ ((module) => {

"use strict";
// Token class



/**
 * class Token
 **/

/**
 * new Token(type, tag, nesting)
 *
 * Create new token and fill passed properties.
 **/
function Token(type, tag, nesting) {
  /**
   * Token#type -> String
   *
   * Type of the token (string, e.g. "paragraph_open")
   **/
  this.type = type;

  /**
   * Token#tag -> String
   *
   * html tag name, e.g. "p"
   **/
  this.tag = tag;

  /**
   * Token#attrs -> Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs = null;

  /**
   * Token#map -> Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map = null;

  /**
   * Token#nesting -> Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting = nesting;

  /**
   * Token#level -> Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level = 0;

  /**
   * Token#children -> Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -> String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content = '';

  /**
   * Token#markup -> String
   *
   * '*' or '_' for emphasis, fence string for fence, etc.
   **/
  this.markup = '';

  /**
   * Token#info -> String
   *
   * Additional information:
   *
   * - Info string for "fence" tokens
   * - The value "auto" for autolink "link_open" and "link_close" tokens
   * - The string value of the item marker for ordered-list "list_item_open" tokens
   **/
  this.info = '';

  /**
   * Token#meta -> Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta = null;

  /**
   * Token#block -> Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block = false;

  /**
   * Token#hidden -> Boolean
   *
   * If it's true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden = false;
}

/**
 * Token.attrIndex(name) -> Number
 *
 * Search attribute index by name.
 **/
Token.prototype.attrIndex = function attrIndex(name) {
  var attrs, i, len;
  if (!this.attrs) {
    return -1;
  }
  attrs = this.attrs;
  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) {
      return i;
    }
  }
  return -1;
};

/**
 * Token.attrPush(attrData)
 *
 * Add `[ name, value ]` attribute to list. Init attrs if necessary
 **/
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};

/**
 * Token.attrSet(name, value)
 *
 * Set `name` attribute to `value`. Override old value if exists.
 **/
Token.prototype.attrSet = function attrSet(name, value) {
  var idx = this.attrIndex(name),
    attrData = [name, value];
  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};

/**
 * Token.attrGet(name)
 *
 * Get the value of attribute `name`, or null if it does not exist.
 **/
Token.prototype.attrGet = function attrGet(name) {
  var idx = this.attrIndex(name),
    value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};

/**
 * Token.attrJoin(name, value)
 *
 * Join value to existing attribute via space. Or create new attribute if not
 * exists. Useful to operate with token classes.
 **/
Token.prototype.attrJoin = function attrJoin(name, value) {
  var idx = this.attrIndex(name);
  if (idx < 0) {
    this.attrPush([name, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
  }
};
module.exports = Token;

/***/ }),

/***/ 5325:
/***/ ((module) => {

"use strict";


/* eslint-disable no-bitwise */
var decodeCache = {};
function getDecodeCache(exclude) {
  var i,
    ch,
    cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = decodeCache[exclude] = [];
  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }
  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
  }
  return cache;
}

// Decode percent-encoded string.
//
function decode(string, exclude) {
  var cache;
  if (typeof exclude !== 'string') {
    exclude = decode.defaultChars;
  }
  cache = getDecodeCache(exclude);
  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {
    var i,
      l,
      b1,
      b2,
      b3,
      b4,
      chr,
      result = '';
    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);
      if (b1 < 0x80) {
        result += cache[b1];
        continue;
      }
      if ((b1 & 0xE0) === 0xC0 && i + 3 < l) {
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        if ((b2 & 0xC0) === 0x80) {
          chr = b1 << 6 & 0x7C0 | b2 & 0x3F;
          if (chr < 0x80) {
            result += '\ufffd\ufffd';
          } else {
            result += String.fromCharCode(chr);
          }
          i += 3;
          continue;
        }
      }
      if ((b1 & 0xF0) === 0xE0 && i + 6 < l) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
          chr = b1 << 12 & 0xF000 | b2 << 6 & 0xFC0 | b3 & 0x3F;
          if (chr < 0x800 || chr >= 0xD800 && chr <= 0xDFFF) {
            result += '\ufffd\ufffd\ufffd';
          } else {
            result += String.fromCharCode(chr);
          }
          i += 6;
          continue;
        }
      }
      if ((b1 & 0xF8) === 0xF0 && i + 9 < l) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);
        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
          chr = b1 << 18 & 0x1C0000 | b2 << 12 & 0x3F000 | b3 << 6 & 0xFC0 | b4 & 0x3F;
          if (chr < 0x10000 || chr > 0x10FFFF) {
            result += '\ufffd\ufffd\ufffd\ufffd';
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
          }
          i += 9;
          continue;
        }
      }
      result += '\ufffd';
    }
    return result;
  });
}
decode.defaultChars = ';/?:@&=+$,#';
decode.componentChars = '';
module.exports = decode;

/***/ }),

/***/ 9108:
/***/ ((module) => {

"use strict";


var encodeCache = {};

// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i,
    ch,
    cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = encodeCache[exclude] = [];
  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }
  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }
  return cache;
}

// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i,
    l,
    code,
    nextCode,
    cache,
    result = '';
  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped = exclude;
    exclude = encode.defaultChars;
  }
  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }
  cache = getEncodeCache(exclude);
  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);
    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }
    if (code < 128) {
      result += cache[code];
      continue;
    }
    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }
    result += encodeURIComponent(string[i]);
  }
  return result;
}
encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";
module.exports = encode;

/***/ }),

/***/ 3923:
/***/ ((module) => {

"use strict";


module.exports = function format(url) {
  var result = '';
  result += url.protocol || '';
  result += url.slashes ? '//' : '';
  result += url.auth ? url.auth + '@' : '';
  if (url.hostname && url.hostname.indexOf(':') !== -1) {
    // ipv6 address
    result += '[' + url.hostname + ']';
  } else {
    result += url.hostname || '';
  }
  result += url.port ? ':' + url.port : '';
  result += url.pathname || '';
  result += url.search || '';
  result += url.hash || '';
  return result;
};

/***/ }),

/***/ 4149:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports.encode = __webpack_require__(9108);
module.exports.decode = __webpack_require__(5325);
module.exports.format = __webpack_require__(3923);
module.exports.parse = __webpack_require__(4652);

/***/ }),

/***/ 4652:
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



//
// Changes from joyent/node:
//
// 1. No leading slash in paths,
//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
//
// 2. Backslashes are not replaced with slashes,
//    so `http:\\example.org\` is treated like a relative path
//
// 3. Trailing colon is treated like a part of the path,
//    i.e. in `http://example.org:foo` pathname is `:foo`
//
// 4. Nothing is URL-encoded in the resulting object,
//    (in joyent/node some chars in auth and paths are encoded)
//
// 5. `url.parse()` does not have `parseQueryString` argument
//
// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
//    which can be constructed using other parts of the url.
//
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
  portPattern = /:[0-9]*$/,
  // Special case for a simple path URL
  simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
  // RFC 2396: characters reserved for delimiting URLs.
  // We actually just auto-escape these.
  delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
  // RFC 2396: characters not allowed for various reasons.
  unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
  autoEscape = ['\''].concat(unwise),
  // Characters that are never ever allowed in a hostname.
  // Note that any invalid chars are also handled, but these
  // are the ones that are *expected* to be seen, so we fast-path
  // them.
  nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
  hostEndingChars = ['/', '?', '#'],
  hostnameMaxLen = 255,
  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
  // protocols that can allow "unsafe" and "unwise" chars.
  /* eslint-disable no-script-url */
  // protocols that never have a hostname.
  hostlessProtocol = {
    'javascript': true,
    'javascript:': true
  },
  // protocols that always contain a // bit.
  slashedProtocol = {
    'http': true,
    'https': true,
    'ftp': true,
    'gopher': true,
    'file': true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
  };
/* eslint-enable no-script-url */

function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) {
    return url;
  }
  var u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}
Url.prototype.parse = function (url, slashesDenoteHost) {
  var i,
    l,
    lowerProto,
    hec,
    slashes,
    rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();
  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    if (rest[hostEnd - 1] === ':') {
      hostEnd--;
    }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost(host);

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    }

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '';
  }
  return this;
};
Url.prototype.parseHost = function (host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};
module.exports = urlParse;

/***/ }),

/***/ 1911:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   encode: () => (/* binding */ encode),
/* harmony export */   toASCII: () => (/* binding */ toASCII),
/* harmony export */   toUnicode: () => (/* binding */ toUnicode),
/* harmony export */   ucs2decode: () => (/* binding */ ucs2decode),
/* harmony export */   ucs2encode: () => (/* binding */ ucs2encode)
/* harmony export */ });


/** Highest positive signed 32-bit float value */
const maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128; // 0x80
const delimiter = '-'; // '\x2D'

/** Regular expressions */
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7F]/; // Note: U+007F DEL is excluded too.
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
const errors = {
  'overflow': 'Overflow: input needs wider integers to process',
  'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
  'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
const baseMinusTMin = base - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error(type) {
  throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, callback) {
  const result = [];
  let length = array.length;
  while (length--) {
    result[length] = callback(array[length]);
  }
  return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {String} A new string of characters returned by the callback
 * function.
 */
function mapDomain(domain, callback) {
  const parts = domain.split('@');
  let result = '';
  if (parts.length > 1) {
    // In email addresses, only the domain name should be punycoded. Leave
    // the local part (i.e. everything up to `@`) intact.
    result = parts[0] + '@';
    domain = parts[1];
  }
  // Avoid `split(regex)` for IE8 compatibility. See #17.
  domain = domain.replace(regexSeparators, '\x2E');
  const labels = domain.split('.');
  const encoded = map(labels, callback).join('.');
  return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // It's a high surrogate, and there is a next character.
      const extra = string.charCodeAt(counter++);
      if ((extra & 0xFC00) == 0xDC00) {
        // Low surrogate.
        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // It's an unmatched surrogate; only append this code unit, in case the
        // next code unit is the high surrogate of a surrogate pair.
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
const ucs2encode = codePoints => String.fromCodePoint(...codePoints);

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
const basicToDigit = function (codePoint) {
  if (codePoint >= 0x30 && codePoint < 0x3A) {
    return 26 + (codePoint - 0x30);
  }
  if (codePoint >= 0x41 && codePoint < 0x5B) {
    return codePoint - 0x41;
  }
  if (codePoint >= 0x61 && codePoint < 0x7B) {
    return codePoint - 0x61;
  }
  return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
const digitToBasic = function (digit, flag) {
  //  0..25 map to ASCII a..z or A..Z
  // 26..35 map to ASCII 0..9
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
const adapt = function (delta, numPoints, firstTime) {
  let k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for /* no initialization */
  (; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
const decode = function (input) {
  // Don't use UCS-2.
  const output = [];
  const inputLength = input.length;
  let i = 0;
  let n = initialN;
  let bias = initialBias;

  // Handle the basic code points: let `basic` be the number of input code
  // points before the last delimiter, or `0` if there is none, then copy
  // the first basic code points to the output.

  let basic = input.lastIndexOf(delimiter);
  if (basic < 0) {
    basic = 0;
  }
  for (let j = 0; j < basic; ++j) {
    // if it's not a basic code point
    if (input.charCodeAt(j) >= 0x80) {
      error('not-basic');
    }
    output.push(input.charCodeAt(j));
  }

  // Main decoding loop: start just after the last delimiter if any basic code
  // points were copied; start at the beginning otherwise.

  for /* no final expression */
  (let index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
    // `index` is the index of the next character to be consumed.
    // Decode a generalized variable-length integer into `delta`,
    // which gets added to `i`. The overflow checking is easier
    // if we increase `i` as we go, then subtract off its starting
    // value at the end to obtain `delta`.
    const oldi = i;
    for /* no condition */
    (let w = 1, k = base;; k += base) {
      if (index >= inputLength) {
        error('invalid-input');
      }
      const digit = basicToDigit(input.charCodeAt(index++));
      if (digit >= base) {
        error('invalid-input');
      }
      if (digit > floor((maxInt - i) / w)) {
        error('overflow');
      }
      i += digit * w;
      const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
      if (digit < t) {
        break;
      }
      const baseMinusT = base - t;
      if (w > floor(maxInt / baseMinusT)) {
        error('overflow');
      }
      w *= baseMinusT;
    }
    const out = output.length + 1;
    bias = adapt(i - oldi, out, oldi == 0);

    // `i` was supposed to wrap around from `out` to `0`,
    // incrementing `n` each time, so we'll fix that now:
    if (floor(i / out) > maxInt - n) {
      error('overflow');
    }
    n += floor(i / out);
    i %= out;

    // Insert `n` at position `i` of the output.
    output.splice(i++, 0, n);
  }
  return String.fromCodePoint(...output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
const encode = function (input) {
  const output = [];

  // Convert the input in UCS-2 to an array of Unicode code points.
  input = ucs2decode(input);

  // Cache the length.
  const inputLength = input.length;

  // Initialize the state.
  let n = initialN;
  let delta = 0;
  let bias = initialBias;

  // Handle the basic code points.
  for (const currentValue of input) {
    if (currentValue < 0x80) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  const basicLength = output.length;
  let handledCPCount = basicLength;

  // `handledCPCount` is the number of code points that have been handled;
  // `basicLength` is the number of basic code points.

  // Finish the basic string with a delimiter unless it's empty.
  if (basicLength) {
    output.push(delimiter);
  }

  // Main encoding loop:
  while (handledCPCount < inputLength) {
    // All non-basic code points < n have been handled already. Find the next
    // larger one:
    let m = maxInt;
    for (const currentValue of input) {
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }

    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
    // but guard against overflow.
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error('overflow');
    }
    delta += (m - n) * handledCPCountPlusOne;
    n = m;
    for (const currentValue of input) {
      if (currentValue < n && ++delta > maxInt) {
        error('overflow');
      }
      if (currentValue === n) {
        // Represent delta as a generalized variable-length integer.
        let q = delta;
        for /* no condition */
        (let k = base;; k += base) {
          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (q < t) {
            break;
          }
          const qMinusT = q - t;
          const baseMinusT = base - t;
          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
          q = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n;
  }
  return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
const toUnicode = function (input) {
  return mapDomain(input, function (string) {
    return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
  });
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
const toASCII = function (input) {
  return mapDomain(input, function (string) {
    return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
  });
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
const punycode = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  'version': '2.1.0',
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  'ucs2': {
    'decode': ucs2decode,
    'encode': ucs2encode
  },
  'decode': decode,
  'encode': encode,
  'toASCII': toASCII,
  'toUnicode': toUnicode
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (punycode);

/***/ }),

/***/ 3098:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ Notification)
/* harmony export */ });
/* unused harmony export NotificationKind */
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9193);
/* harmony import */ var _observable_of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5917);
/* harmony import */ var _observable_throwError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(205);



var NotificationKind = /*#__PURE__*/(/* unused pure expression or super */ null && ((() => {
  (function (NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
  })(NotificationKind || (NotificationKind = {}));
  return NotificationKind;
})()));
class Notification {
  constructor(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === 'N';
  }
  observe(observer) {
    switch (this.kind) {
      case 'N':
        return observer.next && observer.next(this.value);
      case 'E':
        return observer.error && observer.error(this.error);
      case 'C':
        return observer.complete && observer.complete();
    }
  }
  do(next, error, complete) {
    const kind = this.kind;
    switch (kind) {
      case 'N':
        return next && next(this.value);
      case 'E':
        return error && error(this.error);
      case 'C':
        return complete && complete();
    }
  }
  accept(nextOrObserver, error, complete) {
    if (nextOrObserver && typeof nextOrObserver.next === 'function') {
      return this.observe(nextOrObserver);
    } else {
      return this.do(nextOrObserver, error, complete);
    }
  }
  toObservable() {
    const kind = this.kind;
    switch (kind) {
      case 'N':
        return (0,_observable_of__WEBPACK_IMPORTED_MODULE_0__.of)(this.value);
      case 'E':
        return (0,_observable_throwError__WEBPACK_IMPORTED_MODULE_1__/* .throwError */ ._)(this.error);
      case 'C':
        return (0,_observable_empty__WEBPACK_IMPORTED_MODULE_2__/* .empty */ .c)();
    }
    throw new Error('unexpected notification kind value');
  }
  static createNext(value) {
    if (typeof value !== 'undefined') {
      return new Notification('N', value);
    }
    return Notification.undefinedValueNotification;
  }
  static createError(err) {
    return new Notification('E', undefined, err);
  }
  static createComplete() {
    return Notification.completeNotification;
  }
}
Notification.completeNotification = new Notification('C');
Notification.undefinedValueNotification = new Notification('N', undefined);
//# sourceMappingURL=Notification.js.map

/***/ }),

/***/ 2298:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  t: () => (/* binding */ ReplaySubject)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subject.js
var Subject = __webpack_require__(9765);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js + 1 modules
var AsyncAction = __webpack_require__(6465);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/QueueAction.js

class QueueAction extends AsyncAction/* AsyncAction */.o {
  constructor(scheduler, work) {
    super(scheduler, work);
    this.scheduler = scheduler;
    this.work = work;
  }
  schedule(state, delay = 0) {
    if (delay > 0) {
      return super.schedule(state, delay);
    }
    this.delay = delay;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  }
  execute(state, delay) {
    return delay > 0 || this.closed ? super.execute(state, delay) : this._execute(state, delay);
  }
  requestAsyncId(scheduler, id, delay = 0) {
    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
      return super.requestAsyncId(scheduler, id, delay);
    }
    return scheduler.flush(this);
  }
}
//# sourceMappingURL=QueueAction.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js + 1 modules
var AsyncScheduler = __webpack_require__(6102);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/QueueScheduler.js

class QueueScheduler extends AsyncScheduler/* AsyncScheduler */.v {}
//# sourceMappingURL=QueueScheduler.js.map
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/queue.js


const queueScheduler = new QueueScheduler(QueueAction);
const queue = queueScheduler;
//# sourceMappingURL=queue.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscription.js + 1 modules
var Subscription = __webpack_require__(5319);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscriber.js
var Subscriber = __webpack_require__(7393);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Notification.js
var Notification = __webpack_require__(3098);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/observeOn.js


function observeOn(scheduler, delay = 0) {
  return function observeOnOperatorFunction(source) {
    return source.lift(new ObserveOnOperator(scheduler, delay));
  };
}
class ObserveOnOperator {
  constructor(scheduler, delay = 0) {
    this.scheduler = scheduler;
    this.delay = delay;
  }
  call(subscriber, source) {
    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
  }
}
class ObserveOnSubscriber extends Subscriber/* Subscriber */.L {
  constructor(destination, scheduler, delay = 0) {
    super(destination);
    this.scheduler = scheduler;
    this.delay = delay;
  }
  static dispatch(arg) {
    const {
      notification,
      destination
    } = arg;
    notification.observe(destination);
    this.unsubscribe();
  }
  scheduleMessage(notification) {
    const destination = this.destination;
    destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
  }
  _next(value) {
    this.scheduleMessage(Notification/* Notification */.P.createNext(value));
  }
  _error(err) {
    this.scheduleMessage(Notification/* Notification */.P.createError(err));
    this.unsubscribe();
  }
  _complete() {
    this.scheduleMessage(Notification/* Notification */.P.createComplete());
    this.unsubscribe();
  }
}
class ObserveOnMessage {
  constructor(notification, destination) {
    this.notification = notification;
    this.destination = destination;
  }
}
//# sourceMappingURL=observeOn.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = __webpack_require__(7971);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/SubjectSubscription.js
var SubjectSubscription = __webpack_require__(8858);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/ReplaySubject.js






class ReplaySubject extends Subject/* Subject */.xQ {
  constructor(bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY, scheduler) {
    super();
    this.scheduler = scheduler;
    this._events = [];
    this._infiniteTimeWindow = false;
    this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
    this._windowTime = windowTime < 1 ? 1 : windowTime;
    if (windowTime === Number.POSITIVE_INFINITY) {
      this._infiniteTimeWindow = true;
      this.next = this.nextInfiniteTimeWindow;
    } else {
      this.next = this.nextTimeWindow;
    }
  }
  nextInfiniteTimeWindow(value) {
    if (!this.isStopped) {
      const _events = this._events;
      _events.push(value);
      if (_events.length > this._bufferSize) {
        _events.shift();
      }
    }
    super.next(value);
  }
  nextTimeWindow(value) {
    if (!this.isStopped) {
      this._events.push(new ReplayEvent(this._getNow(), value));
      this._trimBufferThenGetEvents();
    }
    super.next(value);
  }
  _subscribe(subscriber) {
    const _infiniteTimeWindow = this._infiniteTimeWindow;
    const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
    const scheduler = this.scheduler;
    const len = _events.length;
    let subscription;
    if (this.closed) {
      throw new ObjectUnsubscribedError/* ObjectUnsubscribedError */.N();
    } else if (this.isStopped || this.hasError) {
      subscription = Subscription/* Subscription */.w.EMPTY;
    } else {
      this.observers.push(subscriber);
      subscription = new SubjectSubscription/* SubjectSubscription */.W(this, subscriber);
    }
    if (scheduler) {
      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
    }
    if (_infiniteTimeWindow) {
      for (let i = 0; i < len && !subscriber.closed; i++) {
        subscriber.next(_events[i]);
      }
    } else {
      for (let i = 0; i < len && !subscriber.closed; i++) {
        subscriber.next(_events[i].value);
      }
    }
    if (this.hasError) {
      subscriber.error(this.thrownError);
    } else if (this.isStopped) {
      subscriber.complete();
    }
    return subscription;
  }
  _getNow() {
    return (this.scheduler || queue).now();
  }
  _trimBufferThenGetEvents() {
    const now = this._getNow();
    const _bufferSize = this._bufferSize;
    const _windowTime = this._windowTime;
    const _events = this._events;
    const eventsCount = _events.length;
    let spliceCount = 0;
    while (spliceCount < eventsCount) {
      if (now - _events[spliceCount].time < _windowTime) {
        break;
      }
      spliceCount++;
    }
    if (eventsCount > _bufferSize) {
      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
    }
    if (spliceCount > 0) {
      _events.splice(0, spliceCount);
    }
    return _events;
  }
}
class ReplayEvent {
  constructor(time, value) {
    this.time = time;
    this.value = value;
  }
}
//# sourceMappingURL=ReplaySubject.js.map

/***/ }),

/***/ 2759:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ fromEvent)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8891);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9796);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9105);
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8002);




const toString = (() => Object.prototype.toString)();
function fromEvent(target, eventName, options, resultSelector) {
  if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__/* .isFunction */ .m)(options)) {
    resultSelector = options;
    options = undefined;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe((0,_operators_map__WEBPACK_IMPORTED_MODULE_1__/* .map */ .U)(args => (0,_util_isArray__WEBPACK_IMPORTED_MODULE_2__/* .isArray */ .k)(args) ? resultSelector(...args) : resultSelector(args)));
  }
  return new _Observable__WEBPACK_IMPORTED_MODULE_3__/* .Observable */ .y(subscriber => {
    function handler(e) {
      if (arguments.length > 1) {
        subscriber.next(Array.prototype.slice.call(arguments));
      } else {
        subscriber.next(e);
      }
    }
    setupSubscription(target, eventName, handler, subscriber, options);
  });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
  let unsubscribe;
  if (isEventTarget(sourceObj)) {
    const source = sourceObj;
    sourceObj.addEventListener(eventName, handler, options);
    unsubscribe = () => source.removeEventListener(eventName, handler, options);
  } else if (isJQueryStyleEventEmitter(sourceObj)) {
    const source = sourceObj;
    sourceObj.on(eventName, handler);
    unsubscribe = () => source.off(eventName, handler);
  } else if (isNodeStyleEventEmitter(sourceObj)) {
    const source = sourceObj;
    sourceObj.addListener(eventName, handler);
    unsubscribe = () => source.removeListener(eventName, handler);
  } else if (sourceObj && sourceObj.length) {
    for (let i = 0, len = sourceObj.length; i < len; i++) {
      setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
    }
  } else {
    throw new TypeError('Invalid event target');
  }
  subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isEventTarget(sourceObj) {
  return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
//# sourceMappingURL=fromEvent.js.map

/***/ }),

/***/ 205:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _: () => (/* binding */ throwError)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8891);

function throwError(error, scheduler) {
  if (!scheduler) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__/* .Observable */ .y(subscriber => subscriber.error(error));
  } else {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__/* .Observable */ .y(subscriber => scheduler.schedule(dispatch, 0, {
      error,
      subscriber
    }));
  }
}
function dispatch({
  error,
  subscriber
}) {
  subscriber.error(error);
}
//# sourceMappingURL=throwError.js.map

/***/ }),

/***/ 8634:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  H: () => (/* binding */ timer)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Observable.js + 2 modules
var Observable = __webpack_require__(8891);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/async.js
var scheduler_async = __webpack_require__(3637);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isArray.js
var isArray = __webpack_require__(9796);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/util/isNumeric.js

function isNumeric(val) {
  return !(0,isArray/* isArray */.k)(val) && val - parseFloat(val) + 1 >= 0;
}
//# sourceMappingURL=isNumeric.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isScheduler.js
var isScheduler = __webpack_require__(4869);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/observable/timer.js




function timer(dueTime = 0, periodOrScheduler, scheduler) {
  let period = -1;
  if (isNumeric(periodOrScheduler)) {
    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
  } else if ((0,isScheduler/* isScheduler */.K)(periodOrScheduler)) {
    scheduler = periodOrScheduler;
  }
  if (!(0,isScheduler/* isScheduler */.K)(scheduler)) {
    scheduler = scheduler_async/* async */.P;
  }
  return new Observable/* Observable */.y(subscriber => {
    const due = isNumeric(dueTime) ? dueTime : +dueTime - scheduler.now();
    return scheduler.schedule(dispatch, due, {
      index: 0,
      period,
      subscriber
    });
  });
}
function dispatch(state) {
  const {
    index,
    period,
    subscriber
  } = state;
  subscriber.next(index);
  if (subscriber.closed) {
    return;
  } else if (period === -1) {
    return subscriber.complete();
  }
  state.index = index + 1;
  this.schedule(state, period);
}
//# sourceMappingURL=timer.js.map

/***/ }),

/***/ 4395:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   b: () => (/* binding */ debounceTime)
/* harmony export */ });
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7393);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3637);


function debounceTime(dueTime, scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__/* .async */ .P) {
  return source => source.lift(new DebounceTimeOperator(dueTime, scheduler));
}
class DebounceTimeOperator {
  constructor(dueTime, scheduler) {
    this.dueTime = dueTime;
    this.scheduler = scheduler;
  }
  call(subscriber, source) {
    return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
  }
}
class DebounceTimeSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_1__/* .Subscriber */ .L {
  constructor(destination, dueTime, scheduler) {
    super(destination);
    this.dueTime = dueTime;
    this.scheduler = scheduler;
    this.debouncedSubscription = null;
    this.lastValue = null;
    this.hasValue = false;
  }
  _next(value) {
    this.clearDebounce();
    this.lastValue = value;
    this.hasValue = true;
    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
  }
  _complete() {
    this.debouncedNext();
    this.destination.complete();
  }
  debouncedNext() {
    this.clearDebounce();
    if (this.hasValue) {
      const {
        lastValue
      } = this;
      this.lastValue = null;
      this.hasValue = false;
      this.destination.next(lastValue);
    }
  }
  clearDebounce() {
    const debouncedSubscription = this.debouncedSubscription;
    if (debouncedSubscription !== null) {
      this.remove(debouncedSubscription);
      debouncedSubscription.unsubscribe();
      this.debouncedSubscription = null;
    }
  }
}
function dispatchNext(subscriber) {
  subscriber.debouncedNext();
}
//# sourceMappingURL=debounceTime.js.map

/***/ }),

/***/ 1289:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  g: () => (/* binding */ delay)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/async.js
var scheduler_async = __webpack_require__(3637);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/util/isDate.js
function isDate(value) {
  return value instanceof Date && !isNaN(+value);
}
//# sourceMappingURL=isDate.js.map
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscriber.js
var Subscriber = __webpack_require__(7393);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Notification.js
var Notification = __webpack_require__(3098);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/delay.js




function delay(delay, scheduler = scheduler_async/* async */.P) {
  const absoluteDelay = isDate(delay);
  const delayFor = absoluteDelay ? +delay - scheduler.now() : Math.abs(delay);
  return source => source.lift(new DelayOperator(delayFor, scheduler));
}
class DelayOperator {
  constructor(delay, scheduler) {
    this.delay = delay;
    this.scheduler = scheduler;
  }
  call(subscriber, source) {
    return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
  }
}
class DelaySubscriber extends Subscriber/* Subscriber */.L {
  constructor(destination, delay, scheduler) {
    super(destination);
    this.delay = delay;
    this.scheduler = scheduler;
    this.queue = [];
    this.active = false;
    this.errored = false;
  }
  static dispatch(state) {
    const source = state.source;
    const queue = source.queue;
    const scheduler = state.scheduler;
    const destination = state.destination;
    while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {
      queue.shift().notification.observe(destination);
    }
    if (queue.length > 0) {
      const delay = Math.max(0, queue[0].time - scheduler.now());
      this.schedule(state, delay);
    } else {
      this.unsubscribe();
      source.active = false;
    }
  }
  _schedule(scheduler) {
    this.active = true;
    const destination = this.destination;
    destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
      source: this,
      destination: this.destination,
      scheduler: scheduler
    }));
  }
  scheduleNotification(notification) {
    if (this.errored === true) {
      return;
    }
    const scheduler = this.scheduler;
    const message = new DelayMessage(scheduler.now() + this.delay, notification);
    this.queue.push(message);
    if (this.active === false) {
      this._schedule(scheduler);
    }
  }
  _next(value) {
    this.scheduleNotification(Notification/* Notification */.P.createNext(value));
  }
  _error(err) {
    this.errored = true;
    this.queue = [];
    this.destination.error(err);
    this.unsubscribe();
  }
  _complete() {
    this.scheduleNotification(Notification/* Notification */.P.createComplete());
    this.unsubscribe();
  }
}
class DelayMessage {
  constructor(time, notification) {
    this.time = time;
    this.notification = notification;
  }
}
//# sourceMappingURL=delay.js.map

/***/ }),

/***/ 7519:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   x: () => (/* binding */ distinctUntilChanged)
/* harmony export */ });
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7393);

function distinctUntilChanged(compare, keySelector) {
  return source => source.lift(new DistinctUntilChangedOperator(compare, keySelector));
}
class DistinctUntilChangedOperator {
  constructor(compare, keySelector) {
    this.compare = compare;
    this.keySelector = keySelector;
  }
  call(subscriber, source) {
    return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
  }
}
class DistinctUntilChangedSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__/* .Subscriber */ .L {
  constructor(destination, compare, keySelector) {
    super(destination);
    this.keySelector = keySelector;
    this.hasKey = false;
    if (typeof compare === 'function') {
      this.compare = compare;
    }
  }
  compare(x, y) {
    return x === y;
  }
  _next(value) {
    let key;
    try {
      const {
        keySelector
      } = this;
      key = keySelector ? keySelector(value) : value;
    } catch (err) {
      return this.destination.error(err);
    }
    let result = false;
    if (this.hasKey) {
      try {
        const {
          compare
        } = this;
        result = compare(this.key, key);
      } catch (err) {
        return this.destination.error(err);
      }
    } else {
      this.hasKey = true;
    }
    if (!result) {
      this.key = key;
      this.destination.next(value);
    }
  }
}
//# sourceMappingURL=distinctUntilChanged.js.map

/***/ }),

/***/ 6804:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   l: () => (/* binding */ endWith)
/* harmony export */ });
/* harmony import */ var _observable_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8071);
/* harmony import */ var _observable_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5917);


function endWith(...array) {
  return source => (0,_observable_concat__WEBPACK_IMPORTED_MODULE_0__/* .concat */ .z)(source, (0,_observable_of__WEBPACK_IMPORTED_MODULE_1__.of)(...array));
}
//# sourceMappingURL=endWith.js.map

/***/ }),

/***/ 5829:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   l: () => (/* binding */ ignoreElements)
/* harmony export */ });
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7393);

function ignoreElements() {
  return function ignoreElementsOperatorFunction(source) {
    return source.lift(new IgnoreElementsOperator());
  };
}
class IgnoreElementsOperator {
  call(subscriber, source) {
    return source.subscribe(new IgnoreElementsSubscriber(subscriber));
  }
}
class IgnoreElementsSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__/* .Subscriber */ .L {
  _next(unused) {}
}
//# sourceMappingURL=ignoreElements.js.map

/***/ }),

/***/ 6736:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   h: () => (/* binding */ mapTo)
/* harmony export */ });
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7393);

function mapTo(value) {
  return source => source.lift(new MapToOperator(value));
}
class MapToOperator {
  constructor(value) {
    this.value = value;
  }
  call(subscriber, source) {
    return source.subscribe(new MapToSubscriber(subscriber, this.value));
  }
}
class MapToSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__/* .Subscriber */ .L {
  constructor(destination, value) {
    super(destination);
    this.value = value;
  }
  _next(x) {
    this.destination.next(this.value);
  }
}
//# sourceMappingURL=mapTo.js.map

/***/ }),

/***/ 9328:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ pairwise)
/* harmony export */ });
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7393);

function pairwise() {
  return source => source.lift(new PairwiseOperator());
}
class PairwiseOperator {
  call(subscriber, source) {
    return source.subscribe(new PairwiseSubscriber(subscriber));
  }
}
class PairwiseSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__/* .Subscriber */ .L {
  constructor(destination) {
    super(destination);
    this.hasPrev = false;
  }
  _next(value) {
    let pair;
    if (this.hasPrev) {
      pair = [this.prev, value];
    } else {
      this.hasPrev = true;
    }
    this.prev = value;
    if (pair) {
      this.destination.next(pair);
    }
  }
}
//# sourceMappingURL=pairwise.js.map

/***/ }),

/***/ 2361:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ repeatWhen)
/* harmony export */ });
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9765);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5345);


function repeatWhen(notifier) {
  return source => source.lift(new RepeatWhenOperator(notifier));
}
class RepeatWhenOperator {
  constructor(notifier) {
    this.notifier = notifier;
  }
  call(subscriber, source) {
    return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
  }
}
class RepeatWhenSubscriber extends _innerSubscribe__WEBPACK_IMPORTED_MODULE_0__/* .SimpleOuterSubscriber */ .Ds {
  constructor(destination, notifier, source) {
    super(destination);
    this.notifier = notifier;
    this.source = source;
    this.sourceIsBeingSubscribedTo = true;
  }
  notifyNext() {
    this.sourceIsBeingSubscribedTo = true;
    this.source.subscribe(this);
  }
  notifyComplete() {
    if (this.sourceIsBeingSubscribedTo === false) {
      return super.complete();
    }
  }
  complete() {
    this.sourceIsBeingSubscribedTo = false;
    if (!this.isStopped) {
      if (!this.retries) {
        this.subscribeToRetries();
      }
      if (!this.retriesSubscription || this.retriesSubscription.closed) {
        return super.complete();
      }
      this._unsubscribeAndRecycle();
      this.notifications.next(undefined);
    }
  }
  _unsubscribe() {
    const {
      notifications,
      retriesSubscription
    } = this;
    if (notifications) {
      notifications.unsubscribe();
      this.notifications = undefined;
    }
    if (retriesSubscription) {
      retriesSubscription.unsubscribe();
      this.retriesSubscription = undefined;
    }
    this.retries = undefined;
  }
  _unsubscribeAndRecycle() {
    const {
      _unsubscribe
    } = this;
    this._unsubscribe = null;
    super._unsubscribeAndRecycle();
    this._unsubscribe = _unsubscribe;
    return this;
  }
  subscribeToRetries() {
    this.notifications = new _Subject__WEBPACK_IMPORTED_MODULE_1__/* .Subject */ .xQ();
    let retries;
    try {
      const {
        notifier
      } = this;
      retries = notifier(this.notifications);
    } catch (e) {
      return super.complete();
    }
    this.retries = retries;
    this.retriesSubscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_0__/* .innerSubscribe */ .ft)(retries, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_0__/* .SimpleInnerSubscriber */ .IY(this));
  }
}
//# sourceMappingURL=repeatWhen.js.map

/***/ }),

/***/ 7349:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   d: () => (/* binding */ shareReplay)
/* harmony export */ });
/* harmony import */ var _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2298);

function shareReplay(configOrBufferSize, windowTime, scheduler) {
  let config;
  if (configOrBufferSize && typeof configOrBufferSize === 'object') {
    config = configOrBufferSize;
  } else {
    config = {
      bufferSize: configOrBufferSize,
      windowTime,
      refCount: false,
      scheduler
    };
  }
  return source => source.lift(shareReplayOperator(config));
}
function shareReplayOperator({
  bufferSize = Number.POSITIVE_INFINITY,
  windowTime = Number.POSITIVE_INFINITY,
  refCount: useRefCount,
  scheduler
}) {
  let subject;
  let refCount = 0;
  let subscription;
  let hasError = false;
  let isComplete = false;
  return function shareReplayOperation(source) {
    refCount++;
    let innerSub;
    if (!subject || hasError) {
      hasError = false;
      subject = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__/* .ReplaySubject */ .t(bufferSize, windowTime, scheduler);
      innerSub = subject.subscribe(this);
      subscription = source.subscribe({
        next(value) {
          subject.next(value);
        },
        error(err) {
          hasError = true;
          subject.error(err);
        },
        complete() {
          isComplete = true;
          subscription = undefined;
          subject.complete();
        }
      });
      if (isComplete) {
        subscription = undefined;
      }
    } else {
      innerSub = subject.subscribe(this);
    }
    this.add(() => {
      refCount--;
      innerSub.unsubscribe();
      innerSub = undefined;
      if (subscription && !isComplete && useRefCount && refCount === 0) {
        subscription.unsubscribe();
        subscription = undefined;
        subject = undefined;
      }
    });
  };
}
//# sourceMappingURL=shareReplay.js.map

/***/ }),

/***/ 9499:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ switchMapTo)
/* harmony export */ });
/* harmony import */ var _switchMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3190);

function switchMapTo(innerObservable, resultSelector) {
  return resultSelector ? (0,_switchMap__WEBPACK_IMPORTED_MODULE_0__/* .switchMap */ .w)(() => innerObservable, resultSelector) : (0,_switchMap__WEBPACK_IMPORTED_MODULE_0__/* .switchMap */ .w)(() => innerObservable);
}
//# sourceMappingURL=switchMapTo.js.map

/***/ }),

/***/ 6782:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ takeUntil)
/* harmony export */ });
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5345);

function takeUntil(notifier) {
  return source => source.lift(new TakeUntilOperator(notifier));
}
class TakeUntilOperator {
  constructor(notifier) {
    this.notifier = notifier;
  }
  call(subscriber, source) {
    const takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
    const notifierSubscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_0__/* .innerSubscribe */ .ft)(this.notifier, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_0__/* .SimpleInnerSubscriber */ .IY(takeUntilSubscriber));
    if (notifierSubscription && !takeUntilSubscriber.seenValue) {
      takeUntilSubscriber.add(notifierSubscription);
      return source.subscribe(takeUntilSubscriber);
    }
    return takeUntilSubscriber;
  }
}
class TakeUntilSubscriber extends _innerSubscribe__WEBPACK_IMPORTED_MODULE_0__/* .SimpleOuterSubscriber */ .Ds {
  constructor(destination) {
    super(destination);
    this.seenValue = false;
  }
  notifyNext() {
    this.seenValue = true;
    this.complete();
  }
  notifyComplete() {}
}
//# sourceMappingURL=takeUntil.js.map

/***/ }),

/***/ 409:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   o: () => (/* binding */ takeWhile)
/* harmony export */ });
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7393);

function takeWhile(predicate, inclusive = false) {
  return source => source.lift(new TakeWhileOperator(predicate, inclusive));
}
class TakeWhileOperator {
  constructor(predicate, inclusive) {
    this.predicate = predicate;
    this.inclusive = inclusive;
  }
  call(subscriber, source) {
    return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
  }
}
class TakeWhileSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__/* .Subscriber */ .L {
  constructor(destination, predicate, inclusive) {
    super(destination);
    this.predicate = predicate;
    this.inclusive = inclusive;
    this.index = 0;
  }
  _next(value) {
    const destination = this.destination;
    let result;
    try {
      result = this.predicate(value, this.index++);
    } catch (err) {
      destination.error(err);
      return;
    }
    this.nextOrComplete(value, result);
  }
  nextOrComplete(value, predicateResult) {
    const destination = this.destination;
    if (Boolean(predicateResult)) {
      destination.next(value);
    } else {
      if (this.inclusive) {
        destination.next(value);
      }
      destination.complete();
    }
  }
}
//# sourceMappingURL=takeWhile.js.map

/***/ }),

/***/ 9426:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  p: () => (/* binding */ throttleTime)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscriber.js
var Subscriber = __webpack_require__(7393);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/async.js
var scheduler_async = __webpack_require__(3637);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/throttle.js

const defaultThrottleConfig = {
  leading: true,
  trailing: false
};
function throttle(durationSelector, config = defaultThrottleConfig) {
  return source => source.lift(new ThrottleOperator(durationSelector, !!config.leading, !!config.trailing));
}
class ThrottleOperator {
  constructor(durationSelector, leading, trailing) {
    this.durationSelector = durationSelector;
    this.leading = leading;
    this.trailing = trailing;
  }
  call(subscriber, source) {
    return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
  }
}
class ThrottleSubscriber extends (/* unused pure expression or super */ null && (SimpleOuterSubscriber)) {
  constructor(destination, durationSelector, _leading, _trailing) {
    super(destination);
    this.destination = destination;
    this.durationSelector = durationSelector;
    this._leading = _leading;
    this._trailing = _trailing;
    this._hasValue = false;
  }
  _next(value) {
    this._hasValue = true;
    this._sendValue = value;
    if (!this._throttled) {
      if (this._leading) {
        this.send();
      } else {
        this.throttle(value);
      }
    }
  }
  send() {
    const {
      _hasValue,
      _sendValue
    } = this;
    if (_hasValue) {
      this.destination.next(_sendValue);
      this.throttle(_sendValue);
    }
    this._hasValue = false;
    this._sendValue = undefined;
  }
  throttle(value) {
    const duration = this.tryDurationSelector(value);
    if (!!duration) {
      this.add(this._throttled = innerSubscribe(duration, new SimpleInnerSubscriber(this)));
    }
  }
  tryDurationSelector(value) {
    try {
      return this.durationSelector(value);
    } catch (err) {
      this.destination.error(err);
      return null;
    }
  }
  throttlingDone() {
    const {
      _throttled,
      _trailing
    } = this;
    if (_throttled) {
      _throttled.unsubscribe();
    }
    this._throttled = undefined;
    if (_trailing) {
      this.send();
    }
  }
  notifyNext() {
    this.throttlingDone();
  }
  notifyComplete() {
    this.throttlingDone();
  }
}
//# sourceMappingURL=throttle.js.map
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/throttleTime.js



function throttleTime(duration, scheduler = scheduler_async/* async */.P, config = defaultThrottleConfig) {
  return source => source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));
}
class ThrottleTimeOperator {
  constructor(duration, scheduler, leading, trailing) {
    this.duration = duration;
    this.scheduler = scheduler;
    this.leading = leading;
    this.trailing = trailing;
  }
  call(subscriber, source) {
    return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
  }
}
class ThrottleTimeSubscriber extends Subscriber/* Subscriber */.L {
  constructor(destination, duration, scheduler, leading, trailing) {
    super(destination);
    this.duration = duration;
    this.scheduler = scheduler;
    this.leading = leading;
    this.trailing = trailing;
    this._hasTrailingValue = false;
    this._trailingValue = null;
  }
  _next(value) {
    if (this.throttled) {
      if (this.trailing) {
        this._trailingValue = value;
        this._hasTrailingValue = true;
      }
    } else {
      this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, {
        subscriber: this
      }));
      if (this.leading) {
        this.destination.next(value);
      } else if (this.trailing) {
        this._trailingValue = value;
        this._hasTrailingValue = true;
      }
    }
  }
  _complete() {
    if (this._hasTrailingValue) {
      this.destination.next(this._trailingValue);
      this.destination.complete();
    } else {
      this.destination.complete();
    }
  }
  clearThrottle() {
    const throttled = this.throttled;
    if (throttled) {
      if (this.trailing && this._hasTrailingValue) {
        this.destination.next(this._trailingValue);
        this._trailingValue = null;
        this._hasTrailingValue = false;
      }
      throttled.unsubscribe();
      this.remove(throttled);
      this.throttled = null;
    }
  }
}
function dispatchNext(arg) {
  const {
    subscriber
  } = arg;
  subscriber.clearThrottle();
}
//# sourceMappingURL=throttleTime.js.map

/***/ }),

/***/ 7057:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   M: () => (/* binding */ withLatestFrom)
/* harmony export */ });
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5197);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(509);


function withLatestFrom(...args) {
  return source => {
    let project;
    if (typeof args[args.length - 1] === 'function') {
      project = args.pop();
    }
    const observables = args;
    return source.lift(new WithLatestFromOperator(observables, project));
  };
}
class WithLatestFromOperator {
  constructor(observables, project) {
    this.observables = observables;
    this.project = project;
  }
  call(subscriber, source) {
    return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
  }
}
class WithLatestFromSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__/* .OuterSubscriber */ .L {
  constructor(destination, observables, project) {
    super(destination);
    this.observables = observables;
    this.project = project;
    this.toRespond = [];
    const len = observables.length;
    this.values = new Array(len);
    for (let i = 0; i < len; i++) {
      this.toRespond.push(i);
    }
    for (let i = 0; i < len; i++) {
      let observable = observables[i];
      this.add((0,_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__/* .subscribeToResult */ .D)(this, observable, undefined, i));
    }
  }
  notifyNext(_outerValue, innerValue, outerIndex) {
    this.values[outerIndex] = innerValue;
    const toRespond = this.toRespond;
    if (toRespond.length > 0) {
      const found = toRespond.indexOf(outerIndex);
      if (found !== -1) {
        toRespond.splice(found, 1);
      }
    }
  }
  notifyComplete() {}
  _next(value) {
    if (this.toRespond.length === 0) {
      const args = [value, ...this.values];
      if (this.project) {
        this._tryProject(args);
      } else {
        this.destination.next(args);
      }
    }
  }
  _tryProject(args) {
    let result;
    try {
      result = this.project.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  }
}
//# sourceMappingURL=withLatestFrom.js.map

/***/ }),

/***/ 6465:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  o: () => (/* binding */ AsyncAction)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscription.js + 1 modules
var Subscription = __webpack_require__(5319);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/Action.js

class Action extends Subscription/* Subscription */.w {
  constructor(scheduler, work) {
    super();
  }
  schedule(state, delay = 0) {
    return this;
  }
}
//# sourceMappingURL=Action.js.map
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js

class AsyncAction extends Action {
  constructor(scheduler, work) {
    super(scheduler, work);
    this.scheduler = scheduler;
    this.work = work;
    this.pending = false;
  }
  schedule(state, delay = 0) {
    if (this.closed) {
      return this;
    }
    this.state = state;
    const id = this.id;
    const scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay);
    }
    this.pending = true;
    this.delay = delay;
    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
    return this;
  }
  requestAsyncId(scheduler, id, delay = 0) {
    return setInterval(scheduler.flush.bind(scheduler, this), delay);
  }
  recycleAsyncId(scheduler, id, delay = 0) {
    if (delay !== null && this.delay === delay && this.pending === false) {
      return id;
    }
    clearInterval(id);
    return undefined;
  }
  execute(state, delay) {
    if (this.closed) {
      return new Error('executing a cancelled action');
    }
    this.pending = false;
    const error = this._execute(state, delay);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  }
  _execute(state, delay) {
    let errored = false;
    let errorValue = undefined;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = !!e && e || new Error(e);
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  }
  _unsubscribe() {
    const id = this.id;
    const scheduler = this.scheduler;
    const actions = scheduler.actions;
    const index = actions.indexOf(this);
    this.work = null;
    this.state = null;
    this.pending = false;
    this.scheduler = null;
    if (index !== -1) {
      actions.splice(index, 1);
    }
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, null);
    }
    this.delay = null;
  }
}
//# sourceMappingURL=AsyncAction.js.map

/***/ }),

/***/ 6102:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  v: () => (/* binding */ AsyncScheduler)
});

;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/Scheduler.js
let Scheduler = /*#__PURE__*/(() => {
  class Scheduler {
    constructor(SchedulerAction, now = Scheduler.now) {
      this.SchedulerAction = SchedulerAction;
      this.now = now;
    }
    schedule(work, delay = 0, state) {
      return new this.SchedulerAction(this, work).schedule(state, delay);
    }
  }
  Scheduler.now = () => Date.now();
  //# sourceMappingURL=Scheduler.js.map
  return Scheduler;
})();
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js

class AsyncScheduler extends Scheduler {
  constructor(SchedulerAction, now = Scheduler.now) {
    super(SchedulerAction, () => {
      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
        return AsyncScheduler.delegate.now();
      } else {
        return now();
      }
    });
    this.actions = [];
    this.active = false;
    this.scheduled = undefined;
  }
  schedule(work, delay = 0, state) {
    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
      return AsyncScheduler.delegate.schedule(work, delay, state);
    } else {
      return super.schedule(work, delay, state);
    }
  }
  flush(action) {
    const {
      actions
    } = this;
    if (this.active) {
      actions.push(action);
      return;
    }
    let error;
    this.active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this.active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  }
}
//# sourceMappingURL=AsyncScheduler.js.map

/***/ }),

/***/ 3637:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ async)
/* harmony export */ });
/* unused harmony export asyncScheduler */
/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6465);
/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6102);


const asyncScheduler = new _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__/* .AsyncScheduler */ .v(_AsyncAction__WEBPACK_IMPORTED_MODULE_1__/* .AsyncAction */ .o);
const async = asyncScheduler;
//# sourceMappingURL=async.js.map

/***/ }),

/***/ 2775:
/***/ (function(module) {

!function (e, r) {
   true ? module.exports = r() : 0;
}(this, function () {
  return function (e) {
    function r(n) {
      if (t[n]) return t[n].exports;
      var o = t[n] = {
        exports: {},
        id: n,
        loaded: !1
      };
      return e[n].call(o.exports, o, o.exports, r), o.loaded = !0, o.exports;
    }
    var t = {};
    return r.m = e, r.c = t, r.p = "", r(0);
  }([function (e, r, t) {
    "use strict";

    function n(e) {
      return e && e.__esModule ? e : {
        default: e
      };
    }
    Object.defineProperty(r, "__esModule", {
      value: !0
    });
    var o = t(3);
    Object.defineProperty(r, "conformToMask", {
      enumerable: !0,
      get: function () {
        return n(o).default;
      }
    });
    var i = t(2);
    Object.defineProperty(r, "adjustCaretPosition", {
      enumerable: !0,
      get: function () {
        return n(i).default;
      }
    });
    var a = t(5);
    Object.defineProperty(r, "createTextMaskInputElement", {
      enumerable: !0,
      get: function () {
        return n(a).default;
      }
    });
  }, function (e, r) {
    "use strict";

    Object.defineProperty(r, "__esModule", {
      value: !0
    }), r.placeholderChar = "_", r.strFunction = "function";
  }, function (e, r) {
    "use strict";

    function t(e) {
      var r = e.previousConformedValue,
        t = void 0 === r ? o : r,
        i = e.previousPlaceholder,
        a = void 0 === i ? o : i,
        u = e.currentCaretPosition,
        l = void 0 === u ? 0 : u,
        s = e.conformedValue,
        f = e.rawValue,
        d = e.placeholderChar,
        c = e.placeholder,
        p = e.indexesOfPipedChars,
        v = void 0 === p ? n : p,
        h = e.caretTrapIndexes,
        m = void 0 === h ? n : h;
      if (0 === l || !f.length) return 0;
      var y = f.length,
        g = t.length,
        b = c.length,
        C = s.length,
        P = y - g,
        k = P > 0,
        x = 0 === g,
        O = P > 1 && !k && !x;
      if (O) return l;
      var T = k && (t === s || s === c),
        w = 0,
        M = void 0,
        S = void 0;
      if (T) w = l - P;else {
        var j = s.toLowerCase(),
          _ = f.toLowerCase(),
          V = _.substr(0, l).split(o),
          A = V.filter(function (e) {
            return j.indexOf(e) !== -1;
          });
        S = A[A.length - 1];
        var N = a.substr(0, A.length).split(o).filter(function (e) {
            return e !== d;
          }).length,
          E = c.substr(0, A.length).split(o).filter(function (e) {
            return e !== d;
          }).length,
          F = E !== N,
          R = void 0 !== a[A.length - 1] && void 0 !== c[A.length - 2] && a[A.length - 1] !== d && a[A.length - 1] !== c[A.length - 1] && a[A.length - 1] === c[A.length - 2];
        !k && (F || R) && N > 0 && c.indexOf(S) > -1 && void 0 !== f[l] && (M = !0, S = f[l]);
        for (var I = v.map(function (e) {
            return j[e];
          }), J = I.filter(function (e) {
            return e === S;
          }).length, W = A.filter(function (e) {
            return e === S;
          }).length, q = c.substr(0, c.indexOf(d)).split(o).filter(function (e, r) {
            return e === S && f[r] !== e;
          }).length, L = q + W + J + (M ? 1 : 0), z = 0, B = 0; B < C; B++) {
          var D = j[B];
          if (w = B + 1, D === S && z++, z >= L) break;
        }
      }
      if (k) {
        for (var G = w, H = w; H <= b; H++) if (c[H] === d && (G = H), c[H] === d || m.indexOf(H) !== -1 || H === b) return G;
      } else if (M) {
        for (var K = w - 1; K >= 0; K--) if (s[K] === S || m.indexOf(K) !== -1 || 0 === K) return K;
      } else for (var Q = w; Q >= 0; Q--) if (c[Q - 1] === d || m.indexOf(Q) !== -1 || 0 === Q) return Q;
    }
    Object.defineProperty(r, "__esModule", {
      value: !0
    }), r.default = t;
    var n = [],
      o = "";
  }, function (e, r, t) {
    "use strict";

    function n() {
      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
        r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : u,
        t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      if (!(0, i.isArray)(r)) {
        if (("undefined" == typeof r ? "undefined" : o(r)) !== a.strFunction) throw new Error("Text-mask:conformToMask; The mask property must be an array.");
        r = r(e, t), r = (0, i.processCaretTraps)(r).maskWithoutCaretTraps;
      }
      var n = t.guide,
        s = void 0 === n || n,
        f = t.previousConformedValue,
        d = void 0 === f ? l : f,
        c = t.placeholderChar,
        p = void 0 === c ? a.placeholderChar : c,
        v = t.placeholder,
        h = void 0 === v ? (0, i.convertMaskToPlaceholder)(r, p) : v,
        m = t.currentCaretPosition,
        y = t.keepCharPositions,
        g = s === !1 && void 0 !== d,
        b = e.length,
        C = d.length,
        P = h.length,
        k = r.length,
        x = b - C,
        O = x > 0,
        T = m + (O ? -x : 0),
        w = T + Math.abs(x);
      if (y === !0 && !O) {
        for (var M = l, S = T; S < w; S++) h[S] === p && (M += p);
        e = e.slice(0, T) + M + e.slice(T, b);
      }
      for (var j = e.split(l).map(function (e, r) {
          return {
            char: e,
            isNew: r >= T && r < w
          };
        }), _ = b - 1; _ >= 0; _--) {
        var V = j[_].char;
        if (V !== p) {
          var A = _ >= T && C === k;
          V === h[A ? _ - x : _] && j.splice(_, 1);
        }
      }
      var N = l,
        E = !1;
      e: for (var F = 0; F < P; F++) {
        var R = h[F];
        if (R === p) {
          if (j.length > 0) for (; j.length > 0;) {
            var I = j.shift(),
              J = I.char,
              W = I.isNew;
            if (J === p && g !== !0) {
              N += p;
              continue e;
            }
            if (r[F].test(J)) {
              if (y === !0 && W !== !1 && d !== l && s !== !1 && O) {
                for (var q = j.length, L = null, z = 0; z < q; z++) {
                  var B = j[z];
                  if (B.char !== p && B.isNew === !1) break;
                  if (B.char === p) {
                    L = z;
                    break;
                  }
                }
                null !== L ? (N += J, j.splice(L, 1)) : F--;
              } else N += J;
              continue e;
            }
            E = !0;
          }
          g === !1 && (N += h.substr(F, P));
          break;
        }
        N += R;
      }
      if (g && O === !1) {
        for (var D = null, G = 0; G < N.length; G++) h[G] === p && (D = G);
        N = null !== D ? N.substr(0, D + 1) : l;
      }
      return {
        conformedValue: N,
        meta: {
          someCharsRejected: E
        }
      };
    }
    Object.defineProperty(r, "__esModule", {
      value: !0
    });
    var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
      return typeof e;
    } : function (e) {
      return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    };
    r.default = n;
    var i = t(4),
      a = t(1),
      u = [],
      l = "";
  }, function (e, r, t) {
    "use strict";

    function n() {
      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : f,
        r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : s.placeholderChar;
      if (!o(e)) throw new Error("Text-mask:convertMaskToPlaceholder; The mask property must be an array.");
      if (e.indexOf(r) !== -1) throw new Error("Placeholder character must not be used as part of the mask. Please specify a character that is not present in your mask as your placeholder character.\n\n" + ("The placeholder character that was received is: " + JSON.stringify(r) + "\n\n") + ("The mask that was received is: " + JSON.stringify(e)));
      return e.map(function (e) {
        return e instanceof RegExp ? r : e;
      }).join("");
    }
    function o(e) {
      return Array.isArray && Array.isArray(e) || e instanceof Array;
    }
    function i(e) {
      return "string" == typeof e || e instanceof String;
    }
    function a(e) {
      return "number" == typeof e && void 0 === e.length && !isNaN(e);
    }
    function u(e) {
      return "undefined" == typeof e || null === e;
    }
    function l(e) {
      for (var r = [], t = void 0; t = e.indexOf(d), t !== -1;) r.push(t), e.splice(t, 1);
      return {
        maskWithoutCaretTraps: e,
        indexes: r
      };
    }
    Object.defineProperty(r, "__esModule", {
      value: !0
    }), r.convertMaskToPlaceholder = n, r.isArray = o, r.isString = i, r.isNumber = a, r.isNil = u, r.processCaretTraps = l;
    var s = t(1),
      f = [],
      d = "[]";
  }, function (e, r, t) {
    "use strict";

    function n(e) {
      return e && e.__esModule ? e : {
        default: e
      };
    }
    function o(e) {
      var r = {
        previousConformedValue: void 0,
        previousPlaceholder: void 0
      };
      return {
        state: r,
        update: function (t) {
          var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e,
            o = n.inputElement,
            s = n.mask,
            d = n.guide,
            m = n.pipe,
            g = n.placeholderChar,
            b = void 0 === g ? v.placeholderChar : g,
            C = n.keepCharPositions,
            P = void 0 !== C && C,
            k = n.showMask,
            x = void 0 !== k && k;
          if ("undefined" == typeof t && (t = o.value), t !== r.previousConformedValue) {
            ("undefined" == typeof s ? "undefined" : l(s)) === y && void 0 !== s.pipe && void 0 !== s.mask && (m = s.pipe, s = s.mask);
            var O = void 0,
              T = void 0;
            if (s instanceof Array && (O = (0, p.convertMaskToPlaceholder)(s, b)), s !== !1) {
              var w = a(t),
                M = o.selectionEnd,
                S = r.previousConformedValue,
                j = r.previousPlaceholder,
                _ = void 0;
              if (("undefined" == typeof s ? "undefined" : l(s)) === v.strFunction) {
                if (T = s(w, {
                  currentCaretPosition: M,
                  previousConformedValue: S,
                  placeholderChar: b
                }), T === !1) return;
                var V = (0, p.processCaretTraps)(T),
                  A = V.maskWithoutCaretTraps,
                  N = V.indexes;
                T = A, _ = N, O = (0, p.convertMaskToPlaceholder)(T, b);
              } else T = s;
              var E = {
                  previousConformedValue: S,
                  guide: d,
                  placeholderChar: b,
                  pipe: m,
                  placeholder: O,
                  currentCaretPosition: M,
                  keepCharPositions: P
                },
                F = (0, c.default)(w, T, E),
                R = F.conformedValue,
                I = ("undefined" == typeof m ? "undefined" : l(m)) === v.strFunction,
                J = {};
              I && (J = m(R, u({
                rawValue: w
              }, E)), J === !1 ? J = {
                value: S,
                rejected: !0
              } : (0, p.isString)(J) && (J = {
                value: J
              }));
              var W = I ? J.value : R,
                q = (0, f.default)({
                  previousConformedValue: S,
                  previousPlaceholder: j,
                  conformedValue: W,
                  placeholder: O,
                  rawValue: w,
                  currentCaretPosition: M,
                  placeholderChar: b,
                  indexesOfPipedChars: J.indexesOfPipedChars,
                  caretTrapIndexes: _
                }),
                L = W === O && 0 === q,
                z = x ? O : h,
                B = L ? z : W;
              r.previousConformedValue = B, r.previousPlaceholder = O, o.value !== B && (o.value = B, i(o, q));
            }
          }
        }
      };
    }
    function i(e, r) {
      document.activeElement === e && (g ? b(function () {
        return e.setSelectionRange(r, r, m);
      }, 0) : e.setSelectionRange(r, r, m));
    }
    function a(e) {
      if ((0, p.isString)(e)) return e;
      if ((0, p.isNumber)(e)) return String(e);
      if (void 0 === e || null === e) return h;
      throw new Error("The 'value' provided to Text Mask needs to be a string or a number. The value received was:\n\n " + JSON.stringify(e));
    }
    Object.defineProperty(r, "__esModule", {
      value: !0
    });
    var u = Object.assign || function (e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = arguments[r];
          for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
        }
        return e;
      },
      l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e;
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
      };
    r.default = o;
    var s = t(2),
      f = n(s),
      d = t(3),
      c = n(d),
      p = t(4),
      v = t(1),
      h = "",
      m = "none",
      y = "object",
      g = "undefined" != typeof navigator && /Android/i.test(navigator.userAgent),
      b = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : setTimeout;
  }]);
});

/***/ }),

/***/ 9756:
/***/ ((module) => {

module.exports = /[\0-\x1F\x7F-\x9F]/;

/***/ }),

/***/ 7713:
/***/ ((module) => {

module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

/***/ }),

/***/ 4897:
/***/ ((module) => {

module.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

/***/ }),

/***/ 1905:
/***/ ((module) => {

module.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;

/***/ }),

/***/ 8363:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.Any = __webpack_require__(3644);
exports.Cc = __webpack_require__(9756);
exports.Cf = __webpack_require__(7713);
exports.P = __webpack_require__(4897);
exports.Z = __webpack_require__(1905);

/***/ }),

/***/ 3644:
/***/ ((module) => {

module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

/***/ }),

/***/ 7582:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fM: () => (/* binding */ __param),
/* harmony export */   gn: () => (/* binding */ __decorate),
/* harmony export */   mG: () => (/* binding */ __awaiter)
/* harmony export */ });
/* unused harmony exports __extends, __assign, __rest, __esDecorate, __runInitializers, __propKey, __setFunctionName, __metadata, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __spreadArray, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet, __classPrivateFieldIn, __addDisposableResource, __disposeResources */
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose;
    if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  function next() {
    while (env.stack.length) {
      var rec = env.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
      }
      catch (e) {
          fail(e);
      }
    }
    if (env.hasError) throw env.error;
  }
  return next();
}

/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ({
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
});


/***/ }),

/***/ 5485:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"\'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\\"","QUOT":"\\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}');

/***/ })

}]);